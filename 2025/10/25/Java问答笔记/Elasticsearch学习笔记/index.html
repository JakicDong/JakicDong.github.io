
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0" theme-name="Stellar" theme-version="1.30.0">
  
  <meta name="generator" content="Hexo 7.0.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>Elasticsearch学习笔记 - Jakic's Blog</title>

  
    <meta name="description" content="ES 倒排索引、分词器、DSL 查询与常见问题整理。">
<meta property="og:type" content="article">
<meta property="og:title" content="Elasticsearch学习笔记">
<meta property="og:url" content="https://jakicdong.github.io/2025/10/25/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Jakic&#39;s Blog">
<meta property="og:description" content="ES 倒排索引、分词器、DSL 查询与常见问题整理。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025162250.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025162336.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020041315205452.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4afd4cac6e1e5380a76766b70d4afac6.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/12e803ea51dd43d770c72d0824e40506.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/26db7023c16a51030095cea7d281dc1b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/76970448e0c9aecbd26ffc32a00cf891.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/bd0031bb7b0a29df0f780b4914a2909f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/bc1cc3c43df1df5495c29f0782375fc1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/321ea298beffdd05570e1d1afe9f48d2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/7d4ffab6287f760f075ac3f2bdb46d93.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210717190921978.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/9af0da6c7613419d82453fff24d91265.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/6399c96d479e9c46ad3bbccb18eff6bb.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210717191702274.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210717191823352.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210717201031390.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210717201549655.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a9bd1e6d1fdc4640b4ffe1e971d8574d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/bc8f74b1432446d7a56752723a15b05c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202105111544302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ4Nzk1NjA3,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7ac34c18990747bab66a2705d0f8a3a7.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210511154742415.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210511154128479.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210511155335503.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021051115551187.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/295bba3073c98023dbd924e7d79ffc95.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4edb26a728c282ca239357fc8fc45901.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/86334771817746242352ddec06a29787.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/34f03524c57d500a3934d1bfec04a576.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ee2d5a8a97832f58b601c33263519500.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210511155706553.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210511160030892.png">
<meta property="article:published_time" content="2025-10-24T16:00:00.000Z">
<meta property="article:modified_time" content="2026-02-13T08:19:29.142Z">
<meta property="article:author" content="JakicDong">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="MyBatis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025162250.png">
  
  
  
  <meta name="keywords" content="基础,MyBatis">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.30.0">


  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/logo.png">
  

  

  
<!-- hexo injector head_end start --><script src="./func.js"></script><!-- hexo injector head_end end --></head>
<link rel="stylesheet" href="/css/check-in.css"><body><div class="sitebg"><div class="siteblur"></div></div>

<div class="l_body content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://avatars.githubusercontent.com/u/130200522?v=4" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Jakic's Blog</div><div class="sub normal cap">学习生活记录</div><div class="sub hover cap" style="opacity:0"> 踏上取经路,比抵达灵山更重要</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客首页" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="打卡墙" href="/check-in" style="color:#1976D2"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="github" target="_blank" rel="noopener" href="https://github.com/JakicDong/" style="color:#1BCDFC"><svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle"> <path fill="#cccccc" d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path> </svg></a><a class="nav-item" title="力扣" target="_blank" rel="noopener" href="https://leetcode.cn/u/dong7/" style="color:#3DC550"><svg width="59" height="22" viewBox="0 0 59 22" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-full w-auto max-w-none"> <path fill-rule="evenodd" clip-rule="evenodd" d="M27.8226 17.4752C28.3202 16.1443 28.7218 14.5458 28.9859 12.6607C29.1277 11.6491 29.2845 10.1658 29.4568 8.20813H35.2561C35.2637 8.20813 35.2713 8.20828 35.2789 8.20857C35.6071 8.22119 35.8628 8.49743 35.8502 8.82558L35.4996 17.9427C35.4873 18.262 35.2249 18.5144 34.9054 18.5144H33.2974C32.8595 18.5144 32.5046 18.8694 32.5046 19.3072C32.5046 19.7451 32.8595 20.1 33.2974 20.1H35.4776C36.3533 20.1 37.0631 19.3901 37.0631 18.5144L37.4595 8.20813C37.4595 7.33244 36.7497 6.62254 35.874 6.62254H29.5913C29.671 5.65054 29.7537 4.58575 29.8394 3.42794C29.8718 2.99129 29.544 2.61109 29.1074 2.57874C28.6707 2.54639 28.2905 2.87414 28.2582 3.3108C28.1689 4.51669 28.0829 5.62069 28.0004 6.62254H25.3695C24.9316 6.62254 24.5767 6.97749 24.5767 7.41534C24.5767 7.85318 24.9316 8.20813 25.3695 8.20813H27.8651C27.7 10.07 27.5501 11.4816 27.4157 12.4407C27.1674 14.2124 26.7941 15.6986 26.3374 16.9199C26.0981 17.5599 25.8527 18.0822 25.6163 18.4944C25.5366 18.6333 25.4649 18.7474 25.4029 18.8378C25.3703 18.8853 25.3512 18.9109 25.3475 18.9155C25.0722 19.256 25.1252 19.7552 25.4657 20.0305C25.8062 20.3057 26.3054 20.2528 26.5806 19.9123C26.6737 19.7971 26.8159 19.5898 26.9917 19.2833C27.271 18.7963 27.5531 18.1959 27.8226 17.4752ZM48.5586 17.3184V7.72969H55.6831C56.3474 7.72969 56.883 8.26047 56.883 8.9117V16.4576C56.883 17.1088 56.3474 17.6396 55.6831 17.6396H53.3916C52.7274 17.6396 52.1918 17.1088 52.1918 16.4576V10.1081C52.1918 9.67022 51.8369 9.31528 51.399 9.31528C50.9612 9.31528 50.6062 9.67022 50.6062 10.1081V16.4576C50.6062 17.9877 51.8548 19.2252 53.3916 19.2252H55.6831C57.2199 19.2252 58.4686 17.9877 58.4686 16.4576V8.9117C58.4686 7.38157 57.2199 6.14411 55.6831 6.14411H48.5586V3.76573C48.5586 3.32788 48.2037 2.97294 47.7658 2.97294C47.328 2.97294 46.9731 3.32788 46.9731 3.76573V6.14411H44.1983C43.7604 6.14411 43.4055 6.49905 43.4055 6.9369C43.4055 7.37475 43.7604 7.72969 44.1983 7.72969H46.9731V12.465L44.3002 13.5341C43.8937 13.6968 43.696 14.1581 43.8586 14.5647C44.0212 14.9712 44.4826 15.1689 44.8891 15.0063L46.9731 14.1727V17.3184C46.9731 18.3666 46.0906 19.2252 44.9911 19.2252C44.5532 19.2252 44.1983 19.5801 44.1983 20.018C44.1983 20.4558 44.5532 20.8108 44.9911 20.8108C46.9567 20.8108 48.5586 19.2522 48.5586 17.3184Z" fill="white"></path> <path d="M13.3797 16.4636C13.874 15.9701 14.674 15.9714 15.1667 16.4665C15.6593 16.9616 15.6581 17.7631 15.1638 18.2566L12.9691 20.4481C10.9443 22.4699 7.64261 22.4992 5.58369 20.5162C5.57179 20.5048 4.655 19.6058 1.63058 16.6402C-0.381491 14.6673 -0.581941 11.5104 1.31147 9.4831L4.84172 5.7031C6.7209 3.69085 10.1849 3.47093 12.3335 5.20847L15.5398 7.80152C16.0828 8.24065 16.1676 9.03757 15.7292 9.58151C15.2909 10.1254 14.4953 10.2104 13.9523 9.77127L10.746 7.17824C9.62238 6.26954 7.65677 6.39434 6.68718 7.43259L3.15688 11.2126C2.23512 12.1996 2.33607 13.7895 3.39833 14.8311C5.61922 17.0088 7.33084 18.6871 7.33282 18.689C8.40324 19.72 10.134 19.7046 11.185 18.6551L13.3797 16.4636Z" fill="#FFA116"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M8.04824 14.2706C7.35039 14.2706 6.78467 13.7039 6.78467 13.0048C6.78467 12.3057 7.35039 11.739 8.04824 11.739H17.3671C18.0649 11.739 18.6306 12.3057 18.6306 13.0048C18.6306 13.7039 18.0649 14.2706 17.3671 14.2706H8.04824Z" fill="#B3B3B3"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M9.79343 0.401024C10.2702 -0.109469 11.0698 -0.136141 11.5794 0.34145C12.089 0.819042 12.1156 1.62004 11.6389 2.13054L3.15692 11.2126C2.23513 12.1995 2.33608 13.7894 3.39827 14.831L7.31536 18.6721C7.81405 19.1611 7.82258 19.9625 7.33442 20.4621C6.84626 20.9616 6.04626 20.9702 5.54757 20.4812L1.63046 16.6401C-0.381492 14.6671 -0.581942 11.5102 1.31155 9.48305L9.79343 0.401024Z" fill="white"></path> </svg></a><a class="nav-item" title="知识星球" target="_blank" rel="noopener" href="https://wx.zsxq.com/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="联系我" href="https://jakicdong.github.io/2025/06/01/contact_author/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="sidebar-check-in">
    <div id="sidebar-check-in-calendar"></div>
</div>
<div class="widgets">
<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">专栏：学习博客</span></div><div class="widget-body"><a class="item" href="/2026/02/24/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%97%AE%E9%97%AE%E9%A2%98/"><span class="title">程序员如何优雅地问问题</span></a><a class="item" href="/2026/01/31/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/Redis-KV-MySQL%E5%AD%98%E5%82%A8%E5%AF%B9%E6%AF%94/"><span class="title">Redis、KV、MySQL 存储对比</span></a><a class="item" href="/2026/01/28/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%9C%AC%E5%9C%B0GoLand%E4%B8%8E%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E6%9C%BA%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"><span class="title">本地GoLand与远程开发机代码同步与调试</span></a><a class="item" href="/2026/01/26/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/Clawdbot%E4%BD%BF%E7%94%A8/"><span class="title">Clawdbot使用</span></a><a class="item" href="/2025/12/01/Go%E5%9F%BA%E7%A1%80/Go%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">Go基础笔记</span></a><a class="item" href="/2025/11/13/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/LLM%E5%A6%82%E4%BD%95%E6%80%9D%E7%BB%B4%E5%8F%8A%E7%93%B6%E9%A2%88%E4%BD%95%E5%9C%A8/"><span class="title">LLM如何进行思维?LLM的瓶颈何在?</span></a><a class="item active" href="/2025/10/25/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Elasticsearch学习笔记</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item" href="/2025/10/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%83%AD%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">🔥热点知识点学习笔记</span></a><a class="item" href="/2025/10/23/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">场景设计学习笔记</span></a><a class="item" href="/2025/10/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%AC%AC%E4%BA%8C%E7%89%88)/"><span class="title">Spring学习笔记(第二版)</span></a><a class="item" href="/2025/10/18/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/MYDB%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">MYDB项目笔记</span></a><a class="item" href="/2025/10/17/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RAG%E7%9F%A5%E8%AF%86%E5%BA%93%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">RAG知识库项目笔记</span></a><a class="item" href="/2025/10/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">SQL刷题笔记</span></a><a class="item" href="/2025/10/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">设计模式学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">操作系统学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">微服务学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">分布式学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">MyBatis学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">RocketMQ学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Linux学习笔记</span></a><a class="item" href="/2025/09/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%AE%80%E5%8E%86%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="title">简历对应知识点</span></a><a class="item" href="/2025/09/09/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Elasticsearch(ES)%E4%B8%8B%E8%BD%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><span class="title">Elasticsearch(ES)下载使用指南</span></a><a class="item" href="/2025/08/30/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/git%E7%A7%98%E9%92%A5%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86/"><span class="title">Redis学习笔记</span></a><a class="item" href="/2025/08/08/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java并发编程学习笔记</span></a><a class="item" href="/2025/08/06/3DGS/SSH%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"><span class="title">SSH远程调用开发环境</span></a><a class="item" href="/2025/08/05/3DGS/Ubuntu20%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%ACCUDA/"><span class="title">Ubuntu20使用多个版本CUDA</span></a><a class="item" href="/2025/08/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Thymeleaf%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"><span class="title">Thymeleaf模版引擎</span></a><a class="item" href="/2025/08/01/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架学习笔记</span></a><a class="item" href="/2025/07/30/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Natapp/"><span class="title">Natapp内网穿透使用</span></a><a class="item" href="/2025/07/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"><span class="title">微信扫码登录</span></a><a class="item" href="/2025/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%81%B5%E8%8C%B6%E5%B1%B1%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">灵茶山算法基础笔记</span></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Redis学习笔记</span></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JavaSE学习笔记</span></a><a class="item" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/"><span class="title">程序员养生指南</span></a><a class="item" href="/2025/07/14/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">计算机网络学习笔记</span></a><a class="item" href="/2025/07/12/3DGS/%E4%BD%BF%E7%94%A8Postshot%E8%AE%AD%E7%BB%833DGS%E6%B5%81%E7%A8%8B/"><span class="title">使用Postshot训练3DGS模型流程</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/%E8%B7%A8%E5%9F%9F%E6%94%AF%E6%8C%81%E7%AC%94%E8%AE%B0/"><span class="title">跨域支持笔记</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/MybatisPlus%E7%AC%94%E8%AE%B0/"><span class="title">MybatisPlus笔记</span></a><a class="item" href="/2025/06/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/TecHub%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">TecHub项目笔记</span></a><a class="item" href="/2025/06/24/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"><span class="title">技术派项目环境问题</span></a><a class="item" href="/2025/06/24/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"><span class="title">Unity游戏开发笔记</span></a><a class="item" href="/2025/06/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82B%E6%A0%91/"><span class="title">一次性搞懂B树</span></a><a class="item" href="/2025/06/12/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Spring学习笔记</span></a><a class="item" href="/2025/06/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/nvm%E6%9B%B4%E6%94%B9node%E7%89%88%E6%9C%AC/"><span class="title">nvm更改node版本</span></a><a class="item" href="/2025/06/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/node%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"><span class="title">node使用记录</span></a><a class="item" href="/2025/06/11/3DGS/3DGS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">3DGS学习笔记</span></a><a class="item" href="/2025/06/11/3DGS/3DGS-Ubuntu%E7%8E%AF%E5%A2%83/"><span class="title">3DGS-Ubuntu环境.md</span></a><a class="item" href="/2025/06/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Mysql学习笔记</span></a><a class="item" href="/2025/06/10/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架笔记</span></a><a class="item" href="/2025/06/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记</span></a><a class="item" href="/2025/06/07/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%AF%87/"><span class="title">Java并发篇</span></a><a class="item" href="/2025/06/06/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E9%94%AE%E8%AE%B0%E5%BD%95/"><span class="title">常用组合键记录</span></a><a class="item" href="/2025/06/06/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/java30%E5%A4%A9%E7%AC%94%E8%AE%B0/"><span class="title">java30天学习笔记</span></a><a class="item" href="/2025/06/05/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/hello-world/"><span class="title">Hello World</span></a><a class="item" href="/2025/06/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">技术派项目笔记</span></a><a class="item" href="/2025/06/02/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"><span class="title">个人博客搭建指南</span></a><a class="item" href="/2025/06/01/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RabbitMQ%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/"><span class="title">RabbitMQ项目使用</span></a><a class="item" href="/2025/06/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">数据结构与算法学习笔记</span></a><a class="item" href="/2025/06/01/contact_author/"><span class="title">contact_author</span></a></div></widget>

<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/06/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">技术派项目笔记</span></a><a class="item title" href="/2025/10/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%83%AD%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">🔥热点知识点学习笔记</span></a><a class="item title" href="/2026/02/24/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%97%AE%E9%97%AE%E9%A2%98/"><span class="title">程序员如何优雅地问问题</span></a><a class="item title" href="/2025/06/06/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E9%94%AE%E8%AE%B0%E5%BD%95/"><span class="title">常用组合键记录</span></a><a class="item title" href="/2025/06/02/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"><span class="title">个人博客搭建指南</span></a><a class="item title" href="/2025/08/01/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架学习笔记</span></a><a class="item title" href="/2025/10/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记</span></a><a class="item title" href="/2025/06/12/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Spring学习笔记</span></a><a class="item title" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/"><span class="title">程序员养生指南</span></a><a class="item title" href="/2025/10/23/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">场景设计学习笔记</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2026/02/24/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%97%AE%E9%97%AE%E9%A2%98/">学习博客</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-10-24T16:00:00.000Z">2025-10-25</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2026-02-13T08:19:29.142Z">2026-02-13</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Elasticsearch学习笔记</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content slide-up"><h2 id="常见问题汇总"><a href="#常见问题汇总" class="headerlink" title="常见问题汇总"></a>常见问题汇总</h2><p>一、ES基础概念与原理</p>
<p> 基础概念</p>
<ul>
<li>什么是Elasticsearch？请介绍一下Elasticsearch</li>
<li>Elasticsearch 的基本概念有哪些？</li>
<li>Elasticsearch 中的集群、节点、索引、文档、类型是什么？</li>
<li>说一下text 和 keyword类型的区别</li>
<li>DocValues的作用是什么？</li>
<li>什么是停顿词过滤？</li>
<li>query 和 filter 的区别是什么？</li>
<li>Elasticsearch有哪些数据类型？你在项目中用了哪些？</li>
<li>Elasticsearch支持事务吗？</li>
</ul>
<p> 核心原理</p>
<ul>
<li>什么是倒排索引？</li>
<li>你了解倒排索引的实现原理吗？</li>
<li>在 Elasticsearch 中，是怎么根据一个词找到对应的倒排索引的？</li>
<li>如何在保留不变性的前提下实现倒排索引的更新？</li>
<li>lucence 内部结构是什么？</li>
<li>是否了解字典树？</li>
<li>讲一下elasticsearch和mysql 的区别</li>
<li>Elasticsearch为什么适合搜索？</li>
<li>elasticsearch的原理和结构是怎样的？</li>
<li>ES为什么这么快？</li>
</ul>
<p> 存储机制</p>
<ul>
<li>String类型在ES中是怎么存储的？</li>
<li>Elasticsearch列式存储与行式存储的区别是什么？链式存储的优势有哪些？</li>
<li>你了解Elasticsearch的Segment吗？</li>
<li>说一下Elasticsearch的Refresh机制</li>
<li>你知道Elasticsearch的Flush操作吗？</li>
<li>什么是Merge操作？</li>
<li>ES如何保证数据不丢失？<br> 二、ES架构与集群管理</li>
</ul>
<p> 集群架构</p>
<ul>
<li>Elasticsearch的架构是怎样的？</li>
<li>说说你们公司 es 的集群架构，索引数据大小，分片有多少？</li>
<li>分片机制是如何实现分布式集群的？</li>
<li>分片和副本有什么区别？</li>
<li>你了解分段机制吗？</li>
<li>ES是怎么样去运行的？跑了几个节点？</li>
</ul>
<p> Master选举与脑裂</p>
<ul>
<li>Elasticsearch 的分布式原理是什么？</li>
<li>Elasticsearch是如何实现Master选举的？</li>
<li>Elasticsearch 重要的节点（比如公共 20 个），其中的 10 个选了一个master，另外 10 个选了另一个 master，怎么办？</li>
<li>Elasticsearch是如何避免脑裂现象的？</li>
<li>Elasticsearch 集群脑裂问题如何解决？</li>
</ul>
<p> 节点协调与负载</p>
<ul>
<li>节点和分片是如何协调的？</li>
<li>客户端在和集群连接时，如何选择特定的节点执行请求的？</li>
<li>你遇到过数据倾斜问题吗？如何处理？</li>
<li>什么是长尾问题？</li>
</ul>
<p> 三、数据写入与更新</p>
<p> 写入流程</p>
<ul>
<li>详细描述一下 Elasticsearch 索引文档的过程</li>
<li>es 写数据的过程是怎样的？</li>
<li>写数据的底层原理是什么？</li>
<li>文档索引步骤顺序是什么？</li>
<li>新增的文档怎么快速和旧文档一起被检索？</li>
</ul>
<p> 更新删除</p>
<ul>
<li>详细描述一下 Elasticsearch 更新和删除文档的过程</li>
<li>ES更新一个文档，它的操作步骤是什么样子的？</li>
</ul>
<p> 高并发写入</p>
<ul>
<li>写压力大时怎么处理？</li>
<li>海量数据如何写入es？</li>
<li>在并发情况下，Elasticsearch 如何保证读写一致？</li>
<li>ES在高并发下如何保证读写一致性？</li>
</ul>
<p> 四、搜索与查询</p>
<p> 搜索流程</p>
<ul>
<li>详细描述一下 Elasticsearch 搜索的过程</li>
<li>Query阶段是如何工作的？</li>
<li>Fetch阶段是如何工作的？</li>
</ul>
<p> 分词与查询</p>
<ul>
<li>分词器的分词流程是怎样的？</li>
<li>ES你是用过什么样的接口去搜索的？比如搜索一个关键字，你是怎么去搜索的？</li>
<li>title的类型是什么类型(设置ES索引的时候)？</li>
</ul>
<p> 深度分页</p>
<ul>
<li>ES的深度分页与滚动搜索scroll是什么？</li>
</ul>
<p> 五、性能优化与调优</p>
<p> 索引优化</p>
<ul>
<li>建立索引阶段性能提升方法有哪些？</li>
<li>索引阶段性能提升方法有哪些？</li>
<li>elasticsearch 索引数据多了怎么办，如何调优？</li>
<li>说一下你了解的调优手段</li>
</ul>
<p> 聚合优化</p>
<ul>
<li>Elasticsearch 对于大数据量(上亿量级) 的聚合如何实现？</li>
</ul>
<p> 系统调优</p>
<ul>
<li>Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？</li>
<li>对于 GC 方面，在使用 Elasticsearch 时要注意什么？</li>
</ul>
<p> 六、部署与运维</p>
<p> 部署相关</p>
<ul>
<li>elasticsearch如何部署？</li>
<li>ES应用你是怎么部署的？</li>
<li>如何监控 Elasticsearch 集群状态？</li>
</ul>
<p> 七、数据同步与一致性</p>
<p> 数据同步</p>
<ul>
<li>数据库修改信息如何同步ElasticSearch？</li>
<li>项目中你的数据是怎么灌入ES的？</li>
<li>怎样进行数据同步？</li>
<li>如何考虑es和MySQL一致性？</li>
<li>如果用消息队列异步写入的话，消息丢失怎么办？</li>
</ul>
<p> 八、应用场景与实战</p>
<p> 使用场景</p>
<ul>
<li>ElasticSearch的主要功能及应用场景是什么？</li>
<li>实习中的ElasticSearch为什么要用？为啥不直接查Mysql？</li>
</ul>
<p> 特殊场景</p>
<ul>
<li>针对文字，ES可以用倒排索引，你知道ES针对地图如何构建索引吗？</li>
</ul>
<h2 id="ElasticSearch基础："><a href="#ElasticSearch基础：" class="headerlink" title="ElasticSearch基础："></a>ElasticSearch基础：</h2><h3 id="一、Elasticsearch-的基本概念："><a href="#一、Elasticsearch-的基本概念：" class="headerlink" title="一、Elasticsearch 的基本概念："></a>一、Elasticsearch 的基本概念：</h3><p><strong>1、什么是Elasticsearch：</strong></p>
<p>​ Elasticsearch 是基于 Lucene 的 Restful 的分布式实时全文搜索引擎，每个字段都被索引并可被搜索，可以快速存储、搜索、分析海量的数据。</p>
<blockquote>
<p>全文检索是指对每一个词建立一个索引，指明该词在文章中出现的次数和位置。当查询时，根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。</p>
</blockquote>
<p><strong>2、Elasticsearch 的基本概念：</strong></p>
<p>（1）index 索引：索引类似于mysql 中的数据库，Elasticesearch 中的索引是存在数据的地方，包含了一堆有相似结构的文档数据。</p>
<p>（2）type 类型：类型是用来定义数据结构，可以认为是 mysql 中的一张表，type 是 index 中的一个逻辑数据分类</p>
<p>（3）document 文档：类似于 MySQL 中的一行，不同之处在于 ES 中的每个文档可以有不同的字段，但是对于通用字段应该具有相同的数据类型，文档是es中的最小数据单元，可以认为一个文档就是一条记录。</p>
<p>（4）Field 字段：Field是Elasticsearch的最小单位，一个document里面有多个field</p>
<p>（5）shard 分片：单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。</p>
<p>（6）replica 副本：任何服务器随时可能故障或宕机，此时 shard 可能会丢失，通过创建 replica 副本，可以在 shard 故障时提供备用服务，保证数据不丢失，另外 replica 还可以提升搜索操作的吞吐量。</p>
<blockquote>
<p>shard 分片数量在建立索引时设置，设置后不能修改，默认5个；replica 副本数量默认1个，可随时修改数量；</p>
</blockquote>
<p><strong>3、什么是倒排索引：</strong></p>
<p>​ 在搜索引擎中，每个文档都有对应的文档 ID，文档内容可以表示为一系列关键词的集合，例如，某个文档经过分词，提取了 20 个关键词，而通过倒排索引，可以记录每个关键词在文档中出现的次数和出现位置。也就是说，倒排索引是 关键词到文档 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了该关键词。</p>
<blockquote>
<p>要注意倒排索引的两个细节：</p>
<ul>
<li>倒排索引中的所有词项对应一个或多个文档</li>
<li>倒排索引中的词项 根据字典顺序升序排列</li>
</ul>
</blockquote>
<p><strong>4、doc_values 的作用：</strong></p>
<p>​ 倒排索引虽然可以提高搜索性能，但也存在缺陷，比如我们需要对数据做排序或聚合等操作时，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=lucene&spm=1001.2101.3001.7020">lucene</a> 会提取所有出现在文档集合的排序字段，然后构建一个排好序的文档集合，而这个步骤是基于内存的，如果排序数据量巨大的话，容易造成内存溢出和性能缓慢。</p>
<p>​ doc_values 就是 es 在构建倒排索引的同时，会对开启 doc_values 的字段构建一个有序的 “document文档 &#x3D;&#x3D;&gt; field value” 的列式存储映射，可以看作是以文档维度，实现了根据指定字段进行排序和聚合的功能，降低对内存的依赖。另外 doc_values 保存在操作系统的磁盘中，当 doc_values 大于节点的可用内存，ES可以从操作系统页缓存中加载或弹出，从而避免发生内存溢出的异常，但如果 docValues 远小于节点的可用内存，操作系统就自然将所有 doc_values 存于内存中（堆外内存），有助于快速访问。</p>
<p><strong>5、text 和 keyword类型的区别：</strong></p>
<p>​ 两个类型的区别主要是分词：keyword 类型是不会分词的，直接根据字符串内容建立倒排索引，所以keyword类型的字段只能通过精确值搜索到；Text 类型在存入 Elasticsearch 的时候，会先分词，然后根据分词后的内容建立倒排索引</p>
<p><strong>6、query 和 filter 的区别？</strong></p>
<p>（1）query：查询操作不仅仅会进行查询，还会计算分值，用于确定相关度；</p>
<p>（2）filter：查询操作仅判断是否满足查询条件，不会计算任何分值，也不会关心返回的排序问题，同时，filter 查询的结果可以被缓存，提高性能。</p>
<h3 id="二、ES的写入流程："><a href="#二、ES的写入流程：" class="headerlink" title="二、ES的写入流程："></a>二、ES的写入流程：</h3><p><strong>1、ES写数据的整体流程：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025162250.png" alt="20251025162250"></p>
<blockquote>
<ul>
<li>（1）客户端选择 ES 的某个 node 发送请求过去，这个 node 就是协调节点 coordinating node</li>
<li>（2）coordinating node 对 document 进行路由，将请求转发给对应的 node（有 primary shard）</li>
<li>（3）实际的 node 上的 primary shard 处理请求，然后将数据同步到 replica node</li>
<li>（4）coordinating node 等到 primary node 和所有 replica node 都执行成功之后，最后返回响应结果给客户端。</li>
</ul>
</blockquote>
<p><strong>2、ES主分片写数据的详细流程：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025162336.png" alt="20251025162336"></p>
<p>（1）主分片先将数据写入ES的 memory buffer，然后定时（默认1s）将 memory buffer 中的数据写入一个新的 segment 文件中，并进入操作系统缓存 Filesystem cache（同时清空 memory buffer），这个过程就叫做 refresh；每个 segment 文件实际上是一些倒排索引的集合， 只有经历了 refresh 操作之后，这些数据才能变成可检索的。</p>
<blockquote>
<p>ES 的近实时性：数据存在 memory buffer 时是搜索不到的，只有数据被 refresh 到 Filesystem cache 之后才能被搜索到，而 refresh 是每秒一次， 所以称 es 是近实时的；可以手动调用 es 的 api 触发一次 refresh 操作，让数据马上可以被搜索到；</p>
</blockquote>
<p>（2）由于 memory Buffer 和 Filesystem Cache 都是基于内存，假设服务器宕机，那么数据就会丢失，所以 ES 通过 translog 日志文件来保证数据的可靠性，在数据写入 memory buffer 的同时，将数据也写入 translog 日志文件中，当机器宕机重启时，es 会自动读取 translog 日志文件中的数据，恢复到 memory buffer 和 Filesystem cache 中去。</p>
<blockquote>
<p>ES 数据丢失的问题：translog 也是先写入 Filesystem cache，然后默认每隔 5 秒刷一次到磁盘中，所以默认情况下，可能有 5 秒的数据会仅仅停留在 memory buffer 或者 translog 文件的 Filesystem cache中，而不在磁盘上，如果此时机器宕机，会丢失 5 秒钟的数据。也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。</p>
</blockquote>
<p>（3）flush 操作：不断重复上面的步骤，translog 会变得越来越大，不过 translog 文件默认每30分钟或者 阈值超过 512M 时，就会触发 commit 操作，即 flush操作，将 memory buffer 中所有的数据写入新的 segment 文件中， 并将内存中所有的 segment 文件全部落盘，最后清空 translog 事务日志。</p>
<blockquote>
<ul>
<li>① 将 memory buffer 中的数据 refresh 到 Filesystem Cache 中去，清空 buffer；</li>
<li>② 创建一个新的 commit point（提交点），同时强行将 Filesystem Cache 中目前所有的数据都 fsync 到磁盘文件中；</li>
<li>③ 删除旧的 translog 日志文件并创建一个新的 translog 日志文件，此时 commit 操作完成</li>
</ul>
</blockquote>
<p>更多 ES 的数据写入流程的说明欢迎阅读这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/118076845">ElasticSearch搜索引擎：数据的写入流程</a></p>
<h3 id="三、ES的更新和删除流程："><a href="#三、ES的更新和删除流程：" class="headerlink" title="三、ES的更新和删除流程："></a>三、ES的更新和删除流程：</h3><p>​ 删除和更新都是写操作，但是由于 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；所以 ES 利用 .del 文件 标记文档是否被删除，磁盘上的每个段都有一个相应的.del 文件</p>
<p>（1）如果是删除操作，文档其实并没有真的被删除，而是在 .del 文件中被标记为 deleted 状态。该文档依然能匹配查询，但是会在结果中被过滤掉。</p>
<p>（2）如果是更新操作，就是将旧的 doc 标识为 deleted 状态，然后创建一个新的 doc。</p>
<blockquote>
<p>​ memory buffer 每 refresh 一次，就会产生一个 segment 文件 ，所以默认情况下是 1s 生成一个 segment 文件，这样下来 segment 文件会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 segment 文件合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉，不写入到新的 segment 中，然后将新的 segment 文件写入磁盘，这里会写一个 commit point ，标识所有新的 segment 文件，然后打开 segment 文件供搜索使用，同时删除旧的 segment 文件</p>
<p>有关segment段合并过程，欢迎阅读这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/117953198">Elasticsearch搜索引擎：ES的segment段合并原理</a></p>
</blockquote>
<h3 id="四、ES的搜索流程："><a href="#四、ES的搜索流程：" class="headerlink" title="四、ES的搜索流程："></a>四、ES的搜索流程：</h3><p>搜索被执行成一个两阶段过程，即 Query Then Fetch：</p>
<p><strong>1、Query阶段：</strong></p>
<p>​ 客户端发送请求到 coordinate node，协调节点将搜索请求广播到所有的 primary shard 或 replica，每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。接着每个分片返回各自优先队列中 所有 docId 和 打分值 给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</p>
<p><strong>2、Fetch阶段：</strong></p>
<p>​ 协调节点根据 Query阶段产生的结果，去各个节点上查询 docId 实际的 document 内容，最后由协调节点返回结果给客户端。</p>
<blockquote>
<ul>
<li>coordinate node 对 doc id 进行哈希路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>
<li>接收请求的 node 返回 document 给 coordinate node 。</li>
<li>coordinate node 返回 document 给客户端。</li>
</ul>
</blockquote>
<p>​ Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。</p>
<h3 id="五、ES在高并发下如何保证读写一致性？"><a href="#五、ES在高并发下如何保证读写一致性？" class="headerlink" title="五、ES在高并发下如何保证读写一致性？"></a>五、ES在高并发下如何保证读写一致性？</h3><p>（1）对于更新操作：可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖</p>
<blockquote>
<p>每个文档都有一个_version 版本号，这个版本号在文档被改变时加一。Elasticsearch使用这个 _version 保证所有修改都被正确排序，当一个旧版本出现在新版本之后，它会被简单的忽略。</p>
<p>利用_version的这一优点确保数据不会因为修改冲突而丢失，比如指定文档的version来做更改，如果那个版本号不是现在的，我们的请求就失败了。</p>
</blockquote>
<p>（2）对于写操作，一致性级别支持 quorum&#x2F;one&#x2F;all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，副本将会在一个不同的节点上重建。</p>
<blockquote>
<ul>
<li>one：写操作只要有一个primary shard是active活跃可用的，就可以执行</li>
<li>all：写操作必须所有的primary shard和replica shard都是活跃可用的，才可以执行</li>
<li>quorum：默认值，要求ES中大部分的shard是活跃可用的，才可以执行写操作</li>
</ul>
</blockquote>
<p>（3）对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication 为 async 时，也可以通过设置搜索请求参数 _preference 为 primary 来查询主分片，确保文档是最新版本。</p>
<h3 id="六、ES集群如何选举Master节点："><a href="#六、ES集群如何选举Master节点：" class="headerlink" title="六、ES集群如何选举Master节点："></a>六、ES集群如何选举Master节点：</h3><p><strong>1、Elasticsearch 的分布式原理：</strong></p>
<p>​ Elasticsearch 会对存储的数据进行切分，划分到不同的分片上，同时每一个分片会生成多个副本，从而保证<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>环境的高可用。ES集群中的节点是对等的，节点间会选出集群的 Master，由 Master 会负责维护集群状态信息，并同步给其他节点。</p>
<blockquote>
<p>Elasticsearch 的性能会不会很低：不会，ES只有建立 index 和 type 时需要经过 Master，而数据的写入有一个简单的 Routing 规则，可以路由到集群中的任意节点，所以数据写入压力是分散在整个集群的。</p>
</blockquote>
<p><strong>2、ES集群 如何 选举 Master：</strong></p>
<p>​ Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和 Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；</p>
<blockquote>
<ul>
<li>（1）确认候选主节点的最少投票通过数量（elasticsearch.yml 设置的值 discovery.zen.minimum_master_nodes）</li>
<li>（2）选举时，集群中每个节点对所有 master候选节点（node.master: true）根据 nodeId 进行字典排序，然后选出第一个节点（第0位），暂且认为它是master节点。</li>
<li>（3）如果对某个节点的投票数达到阈值，并且该节点自己也选举自己，那这个节点就是master；否则重新选举一直到满足上述条件。</li>
</ul>
</blockquote>
<p>补充：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能。</p>
<p><strong>3、Elasticsearch是如何避免脑裂现象：</strong></p>
<p>（1）当集群中 master 候选节点数量不小于3个时（node.master: true），可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes），设置超过所有候选节点一半以上来解决脑裂问题，即设置为 (N&#x2F;2)+1；</p>
<p>（2）当集群 master 候选节点 只有两个时，这种情况是不合理的，最好把另外一个node.master改成false。如果我们不改节点设置，还是套上面的(N&#x2F;2)+1公式，此时discovery.zen.minimum_master_nodes应该设置为2。这就出现一个问题，两个master备选节点，只要有一个挂，就选不出master了</p>
<h3 id="七、建立索引阶段性能提升方法："><a href="#七、建立索引阶段性能提升方法：" class="headerlink" title="七、建立索引阶段性能提升方法："></a>七、建立索引阶段性能提升方法：</h3><blockquote>
<ul>
<li>（1）如果是大批量导入，可以设置 index.number_of_replicas: 0 关闭副本，等数据导入完成之后再开启副本</li>
<li>（2）使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。</li>
<li>（3）如果搜索结果不需要近实时性，可以把每个索引的 index.refresh_interval 改到30s</li>
<li>（4）增加 index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的值，比如 1 GB</li>
<li>（5）使用 SSD 存储介质</li>
<li>（6）段和合并：Elasticsearch 默认值是 20 MB&#x2F;s。但如果用的是 SSD，可以考虑提高到 100–200 MB&#x2F;s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。</li>
</ul>
</blockquote>
<blockquote>
<p>说明：本文会以pdf格式持续更新，更多最新尼恩3高pdf笔记，请从下面的链接获取：<a target="_blank" rel="noopener" href="https://www.yuque.com/crazymakercircle/gkkw8s/khigna">语雀</a> 或者 <a target="_blank" rel="noopener" href="https://gitee.com/crazymaker/SimpleCrayIM/blob/master/%E7%96%AF%E7%8B%82%E5%88%9B%E5%AE%A2%E5%9C%88%E6%80%BB%E7%9B%AE%E5%BD%95.md">码云</a></p>
</blockquote>
<h2 id="聊聊：什么是ElasticSearch？"><a href="#聊聊：什么是ElasticSearch？" class="headerlink" title="聊聊：什么是ElasticSearch？"></a>聊聊：什么是ElasticSearch？</h2><p>Elasticsearch是一个基于Lucene的全文搜索引擎，也可称分布式搜索引擎，用于Java开发的，且开源，具有Http Web和无框架Json文档的分布式。</p>
<p>2、ElasticSearch中的集群、节点、索引、文档、类型是什么？</p>
<p><strong>集群</strong>：是一个或多个服务器的集合，共同保存数据并提供所有节点的联合索引和搜索功能。集群有唯一标志，为”ElasticSearch”。</p>
<p><strong>节点</strong>：节点是属于集群一部分的单体服务器，储存有数据并参与集群索引和搜索功能。如果节点设置为按名称加入集群，则该节点只能是集群的一部分。</p>
<p><strong>索引</strong>：类似关系型数据库中的数据库，有一个定义多重类型的映射。索引是逻辑名称空间，可映射到一个或多个主分片，并且可以有不限个数的副本分片。</p>
<p><strong>文档</strong>：文档类似关系型数据库中的数据行，不同的是处在索引中的文档可以有不同的结构或字段，但是通用字段应该具有相同的数据类型。</p>
<h2 id="聊聊：列出-10-家使用-Elasticsearch-作为其应用程序的搜索引擎和数据库的公司？"><a href="#聊聊：列出-10-家使用-Elasticsearch-作为其应用程序的搜索引擎和数据库的公司？" class="headerlink" title="聊聊：列出 10 家使用 Elasticsearch 作为其应用程序的搜索引擎和数据库的公司？"></a>聊聊：列出 10 家使用 Elasticsearch 作为其应用程序的搜索引擎和数据库的公司？</h2><p>参与过Elastic中文社区活动或者经常关注社区动态的人都知道，使用的公司太多了，列举如下（排名不分先后）：</p>
<p>阿里、腾讯、字节跳动、百度、京东、美团、小米、滴滴、携程、贝壳找房、360、IBM、顺丰快递等等，几乎能想到的互联网公司都在使用Elasticsearch。</p>
<h2 id="聊聊：ElasticSearch中的分片是什么？"><a href="#聊聊：ElasticSearch中的分片是什么？" class="headerlink" title="聊聊：ElasticSearch中的分片是什么？"></a>聊聊：ElasticSearch中的分片是什么？</h2><p>​ 谈到分片需要谈到索引，索引是类似关系型数据库中的数据库，有一个定义多重类型的映射。索引是逻辑名称空间，可映射到一个或多个主分片，并且可以有不限个数的副本分片。因此分片是索引被分割成分布在多个节点上的元素。</p>
<h2 id="聊聊：ElasticSearch特点"><a href="#聊聊：ElasticSearch特点" class="headerlink" title="聊聊：ElasticSearch特点"></a>聊聊：ElasticSearch特点</h2><p><strong>1、Elasticsearch 是一个分布式的 RESTful 风格的搜索和数据分析引擎</strong></p>
<p>（1）查询：搜索方式随心而变。</p>
<p>（2）分析：可探索数据的趋势和模式。</p>
<p>（3）速度：速度快。</p>
<p>（4）可扩展性：个人和企业服务器上都可用。</p>
<p>（5）弹性：Elasticsearch 运行在一个分布式的环境中。</p>
<p>（6）灵活性：具备多个案例场景，支持所有数据类型</p>
<p>（7）HADOOP &amp; SPARK ： Elasticsearch + Hadoop</p>
<p><strong>2、Elasticsearch是一个高度可伸缩的开源全文搜索和分析引擎。它允许您快速和接近实时地存储、搜索和分析大量数据。</strong></p>
<p>这里有一些使用Elasticsearch的用例：</p>
<p>（1）网上商店。</p>
<p>（2）分析、调研日志或事务数据。</p>
<p>（3）实时调度用户关注信息的推送。</p>
<p>（4）结合Kibana (Elasticsearch&#x2F; loghide &#x2F;Kibana堆栈的一部分)来构建自定义仪表板，以可视化自定义数据。此外，还可以使用Elasticsearch聚合功能对数据执行复杂的业务智能查询。</p>
<h2 id="聊聊：谈谈分词与倒排索引的原理"><a href="#聊聊：谈谈分词与倒排索引的原理" class="headerlink" title="聊聊：谈谈分词与倒排索引的原理"></a>聊聊：谈谈分词与倒排索引的原理</h2><p>分词：分词用于检索，英文的分词是按单词之间空格区分，中文要考虑效率和准确分词率，防止出现歧义。</p>
<p>倒排：根据文档内容找文档，从关键字去找文档。</p>
<p>倒排索引是搜索引擎的核心。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。区别于传统的正向索引，倒排索引会再存储数据时将关键词和数据进行关联，保存到倒排表中，然后查询时，将查询内容进行分词后在倒排表中进行查询，最后匹配数<br>据即可。Elasticsearch 使用一种称为倒排索引的结构，ES中的倒排索引其实就是 <strong>lucene 的倒排索引</strong>，它适用于快速的全文搜索。正向索引（forward index），就是搜索引擎会将待搜索的文件都对应一个文件 ID，搜索时将这个ID 和搜索关键字进行对应，形成 K-V 对，然后对关键字进行统计计数。但是互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足<strong>实时返回排名结果</strong>的要求。所以，搜索引擎会将正向索引重新构建为反向索引（inverted index，倒排索引），即<strong>把文件ID对应到关键词的映射，转换为关键词到文件ID的映射</strong>，每个关键词都对应着一系列的文件，并保存到倒排表中，查询时会将内容进行分词后在倒排表中进行查询，最后匹配数据即可。这些文件中都出现这个关键词。</p>
<h2 id="聊聊：elasticsearch-的倒排索引是什么"><a href="#聊聊：elasticsearch-的倒排索引是什么" class="headerlink" title="聊聊：elasticsearch 的倒排索引是什么"></a>聊聊：elasticsearch 的倒排索引是什么</h2><p>我们传统的检索方式是通过遍历整篇文章，逐个比对找到对应的关键词位置，</p>
<p>而倒排索引是通过分词策略，形成词和文章的关系映射表，这种<em>词典+映射表的方式就是倒排索引</em>，有点类似于我们以前使用的新华字典。倒排索引可极大的提高查询效率。</p>
<h2 id="聊聊：elasticsearch-索引数据多了怎么办，如何调优，部署"><a href="#聊聊：elasticsearch-索引数据多了怎么办，如何调优，部署" class="headerlink" title="聊聊：elasticsearch 索引数据多了怎么办，如何调优，部署"></a>聊聊：elasticsearch 索引数据多了怎么办，如何调优，部署</h2><p>1.在设计的时候可以基于模板+时间滚动方式创建索引，每天递增数据，避免单个索引很大的情况出现。</p>
<p>2.在存储的时候，冷热数据分开存储,比如最近3天的数据作为热数据，其他的作为冷数据，冷数据的话，由于不会再写入新数据了，可以考虑定期force_merge（强制合并）和shrink（压缩）的方式进行处理，节约空间和检索效率</p>
<p>3.由于es支持动态扩展，所有可以多加几台机器来缓解集群压力。</p>
<h2 id="聊聊：什么是近实时搜索？"><a href="#聊聊：什么是近实时搜索？" class="headerlink" title="聊聊：什么是近实时搜索？"></a>聊聊：什么是近实时搜索？</h2><p>在 Elasticsearch 和磁盘之间是<strong>文件系统缓存</strong>。在内存索引缓冲区中的文档会被写入到一个新的段中。 但是这里新段会被先写入到文件系统缓存，这一步代价会比较低，稍后再被刷写到磁盘—这一步代价比较高。<strong>不过只要文件已经在缓存中，就可以像其它文件一样被打开和读取了</strong>。在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 refresh 。 <strong>默认情况下每个分片会每秒自动刷新一次，即刷新文件系统缓存</strong>。这就是为什么我们说 Elasticsearch 是 近实时搜索：文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。这些行为可能会对新用户造成困惑：他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用 refresh API 执行一次手动刷新：&#x2F;users&#x2F;_refresh。</p>
<h2 id="聊聊：如何理解-Elasticsearch-的近实时的性质，并改善它的不足？"><a href="#聊聊：如何理解-Elasticsearch-的近实时的性质，并改善它的不足？" class="headerlink" title="聊聊：如何理解 Elasticsearch 的近实时的性质，并改善它的不足？"></a>聊聊：如何理解 Elasticsearch 的近实时的性质，并改善它的不足？</h2><p>并不是所有的情况都需要每秒刷新。可能你正在使用 Elasticsearch 索引大量的日志文件，你可能想<strong>优化索引速度</strong>而不是近实时搜索， 可以通过设置 refresh_interval ， 降低每个索引的刷新频率。refresh_interval 可以在既存索引上进行动态更新。 在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 关闭自动刷新</span><br><span class="line">PUT /users/_settings</span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;refresh_interval&quot;</span><span class="punctuation">:</span> <span class="number">-1</span> <span class="punctuation">&#125;</span> </span><br><span class="line"># 每一秒刷新</span><br><span class="line">PUT /users/_settings</span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;refresh_interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1s&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="聊聊：Elasticsearch-中索引在设计阶段如何调优？"><a href="#聊聊：Elasticsearch-中索引在设计阶段如何调优？" class="headerlink" title="聊聊：Elasticsearch 中索引在设计阶段如何调优？"></a>聊聊：Elasticsearch 中索引在设计阶段如何调优？</h2><p>1）根据业务增量需求，采取基于日期模板创建索引，通过roll over API滚动索引；</p>
<p>2）使用别名进行索引管理；</p>
<p>3）每天凌晨定时对索引做force_merge操作，以释放空间；</p>
<p>4）采取冷热分离机制，热数据存储到SSD，提高检索效率；冷数据定期进行shrink操作，以缩减存储；</p>
<p>5）采取curator进行索引的生命周期管理；</p>
<p>5）仅针对需要分词的字段，合理的设置分词器；</p>
<p>6）Mapping阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。</p>
<h2 id="聊聊：解释一下-Elasticsearch-Node？"><a href="#聊聊：解释一下-Elasticsearch-Node？" class="headerlink" title="聊聊：解释一下 Elasticsearch Node？"></a>聊聊：解释一下 Elasticsearch Node？</h2><p>节点是Elasticsearch的实例。实际业务中，会说：ES集群包含3个节点、7个节点。</p>
<p>这里节点实际就是：一个独立的Elasticsearch进程，一般将一个节点部署到一台独立的服务器或者虚拟机、容器中。</p>
<p>不同节点根据角色不同，可以划分为：</p>
<p><strong>主节点</strong></p>
<p>帮助配置和管理在整个集群中添加和删除节点。</p>
<p><strong>数据节点</strong></p>
<p>存储数据并执行诸如CRUD（创建&#x2F;读取&#x2F;更新&#x2F;删除）操作，对数据进行搜索和聚合的操作。</p>
<p>1、 客户端节点（或者说：协调节点） 将集群请求转发到主节点，将与数据相关的请求转发到数据节点</p>
<p>2、 摄取节点</p>
<p>用于在索引之前对文档进行预处理。</p>
<h2 id="聊聊：Elasticsearch-中分析器由哪几部分组成？"><a href="#聊聊：Elasticsearch-中分析器由哪几部分组成？" class="headerlink" title="聊聊：Elasticsearch 中分析器由哪几部分组成？"></a>聊聊：Elasticsearch 中分析器由哪几部分组成？</h2><p>分析器由三部分构成：</p>
<p>1、字符过滤器（Character Filters）</p>
<p>2、分词器（Tokenizers）</p>
<p>3、分词过滤器（Token Filters）</p>
<p>一个分析器不一定这三个部分都有，但是一般会包含分词器。ES自带的分析器有如下几种：</p>
<p>Standard Analyzer、Simple Analyzer、Whitespace Analyzer、Stop Analyzer、Keyword Analyzer、Pattern Analyzer、Language Analyzers 和 Fingerprint Analyzer。</p>
<p>Elasticsearch内置了若干分析器类型，其中常用的是标准分析器，叫做”standard”。其中Standard Analyzer是ES默认的分析器，如果没有指定任何分析器的话，ES将默认使用这种分析器。</p>
<p>分析器（Analyzer）通常由一个Tokenizer（怎么分词），以及若干个TokenFilter（过滤分词）、Character Filter（过滤字符）组成。</p>
<h2 id="聊聊：Elasticsearch中的-Ingest-节点如何工作？"><a href="#聊聊：Elasticsearch中的-Ingest-节点如何工作？" class="headerlink" title="聊聊：Elasticsearch中的 Ingest 节点如何工作？"></a>聊聊：Elasticsearch中的 Ingest 节点如何工作？</h2><p>ingest节点可以看作是数据前置处理转换的节点，支持pipeline管道设置，可以使用ingest对数据进行过滤、转换等操作，类似于logstash中filter的作用，功能相当强大。</p>
<h2 id="聊聊：Elasticsearch-中的分析器是什么？"><a href="#聊聊：Elasticsearch-中的分析器是什么？" class="headerlink" title="聊聊：Elasticsearch 中的分析器是什么？"></a>聊聊：Elasticsearch 中的分析器是什么？</h2><p>分析（analysis）机制用于进行全文文本（Full Text）的分词，以建立供搜索用的反向索引。</p>
<p>1、在ElasticSearch中索引数据时，数据由为索引定义的Analyzer在内部进行转换。分析器由一个Tokenizer和零个或多个TokenFilter组成。</p>
<p>编译器可以在一个或多个CharFilter之前。分析模块允许您在逻辑名称下注册分析器，然后可以在映射定义或某些API中引用它们。</p>
<p>2、Elasticsearch附带了许多可以随时使用的预建分析器。或者可以组合内置的字符过滤器，编译器和过滤器器来创建自定义分析器。</p>
<h2 id="聊聊：Elasticsearch-支持哪些配置管理工具？"><a href="#聊聊：Elasticsearch-支持哪些配置管理工具？" class="headerlink" title="聊聊：Elasticsearch 支持哪些配置管理工具？"></a>聊聊：Elasticsearch 支持哪些配置管理工具？</h2><p>Ansible、Chef、Puppet和Salt Stack是DevOps团队使用的Elasticsearch支持的配置工具。</p>
<h2 id="聊聊：ElasticSearch-的节点类型有什么区别？"><a href="#聊聊：ElasticSearch-的节点类型有什么区别？" class="headerlink" title="聊聊：ElasticSearch 的节点类型有什么区别？"></a>聊聊：ElasticSearch 的节点类型有什么区别？</h2><p>节点是指ElasticSearch的实例。当启动Elasticsearch的实例，就会启动至少一个节点。</p>
<p>相同集群名的多个节点的连接就组成了一个集群，在默认情况下，集群中的每个节点都可以处理http请求和集群节点间的数据传输，集群中所有的节点都知道集群中其他所有的节点，可以将客户端请求转发到适当的节点。</p>
<p>节点有以下类型：</p>
<p>主(master)节点：在一个节点上当node.master设置为True（默认）的时候，它有资格被选作为主节点，控制整个集群。</p>
<p>数据(data)节点：在一个节点上node.data设置为True（默认）的时候。该节点保存数据和执行数据相关的操作，如增删改查，搜索，和聚合。</p>
<p>客户端节点：当一个节点的node.master和node.data都设置为false的时候，它既不能保持数据也不能成为主节点，该节点可以作为客户端节点，可以响应用户的情况，并把相关操作发送到其他节点。</p>
<p>部落节点：当一个节点配置tribe.*的时候，它是一个特殊的客户端，它可以连接多个集群，在所有连接的集群上执行搜索和其他操作。</p>
<blockquote>
<p>说明：本文会以pdf格式持续更新，更多最新尼恩3高pdf笔记，请从下面的链接获取：<a target="_blank" rel="noopener" href="https://www.yuque.com/crazymakercircle/gkkw8s/khigna">语雀</a> 或者 <a target="_blank" rel="noopener" href="https://gitee.com/crazymaker/SimpleCrayIM/blob/master/%E7%96%AF%E7%8B%82%E5%88%9B%E5%AE%A2%E5%9C%88%E6%80%BB%E7%9B%AE%E5%BD%95.md">码云</a></p>
</blockquote>
<h2 id="聊聊：Elasticsearch了解多少，聊聊你们公司ES的集群架构，索引数据大小，分片有多少，以及一些调优手段-。"><a href="#聊聊：Elasticsearch了解多少，聊聊你们公司ES的集群架构，索引数据大小，分片有多少，以及一些调优手段-。" class="headerlink" title="聊聊：Elasticsearch了解多少，聊聊你们公司ES的集群架构，索引数据大小，分片有多少，以及一些调优手段 。"></a>聊聊：Elasticsearch了解多少，聊聊你们公司ES的集群架构，索引数据大小，分片有多少，以及一些调优手段 。</h2><p><strong>面试官：</strong></p>
<p>想了解应聘者之前公司接触的ES使用场景、规模，有没有做过比较大规模的索引设计、规划、调优。</p>
<p><strong>解答策略：</strong></p>
<p>如实结合自己的实践场景回答即可。</p>
<p>比如：ES集群架构13个节点，索引根据通道不同共20+索引，根据日期，每日递增20+</p>
<p>索引：10分片，每日递增1亿+数据，每个通道每天索引大小控制：150GB之内。</p>
<h3 id="索引层面调优手段："><a href="#索引层面调优手段：" class="headerlink" title="索引层面调优手段："></a>索引层面调优手段：</h3><h4 id="1、设计阶段调优"><a href="#1、设计阶段调优" class="headerlink" title="1、设计阶段调优"></a>1、设计阶段调优</h4><p>1）根据业务增量需求，采取基于日期模板创建索引，通过roll over API滚动索引；<br>2）使用别名进行索引管理；<br>3）每天凌晨定时对索引做force_merge操作，以释放空间；<br>4）采取冷热分离机制，热数据存储到SSD，提高检索效率；冷数据定期进行shrink操作，以缩减存储；<br>5）采取curator进行索引的生命周期管理；<br>6）仅针对需要分词的字段，合理的设置分词器；<br>7）Mapping阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。</p>
<h4 id="2、写入调优"><a href="#2、写入调优" class="headerlink" title="2、写入调优"></a>2、写入调优</h4><p>1）写入前副本数设置为0；<br>2）写入前关闭refresh_interval设置为-1，禁用刷新机制；<br>3）写入过程中：采取bulk批量写入；<br>4）写入后恢复副本数和刷新间隔；<br>5）尽量使用自动生成的id。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/2020041315205452.png" alt="img"></p>
<p>6）当写入数据时，确保bulk请求时轮询访问所有节点。不要发送所有请求到一个节点，导致这一个节点要在内存存储所有请求的数据去处理</p>
<h4 id="3、查询调优"><a href="#3、查询调优" class="headerlink" title="3、查询调优"></a>3、查询调优</h4><p><strong>1、</strong>filesystem cache越大越好 为了使得搜索速度更快， es严重依赖filesystem cache</p>
<p>一般来说，需要至少一半的 可用内存作为filesystem cache，这样es可以在物理内存中 保有 索引的热点区域（hot regions of the index）</p>
<p><strong>2、</strong>用更好的硬件 搜索一般是I&#x2F;O bound的，此时，你需要</p>
<p>​</p>
<ol>
<li>为filesystem cache分配更多的内存</li>
<li>使用SSD硬盘</li>
<li>使用local storage（不要使用NFS、SMB 等remote filesystem）</li>
<li>亚马逊的 弹性块存储（Elastic Block Storage）也是极好的，当然，和local storage比起来，它还是要慢点 如果你的搜索是 CPU-bound，买好的CPU吧</li>
</ol>
<p><strong>3、</strong>文档模型（document modeling） 文档需要使用合适的类型，从而使得 search-time operations 消耗更少的资源。咋作呢？</p>
<p><strong>答：避免 join操作</strong>。具体是指 a.nested 会使得查询慢 好几倍 b.parent-child关系 更是使得查询慢几百倍 如果 无需join 能解决问题，则查询速度会快很多</p>
<p><strong>4、</strong>预索引 数据 根据“搜索数据最常用的方式”来最优化索引数据的方式</p>
<p>举个例子：所有文档都有price字段，大部分query 在 fixed ranges 上运行 range aggregation。你可以把给定范围的数据 预先索引下。然后，使用 terms aggregation</p>
<p><strong>5、</strong>Mappings（能用 keyword 最好了） 数字类型的数据，并不意味着一定非得使用numeric类型的字段。</p>
<p>一般来说，存储标识符的 字段（书号ISBN、或来自数据库的 标识一条记录的 数字），使用keyword更好（integer，long 不好哦）</p>
<p><strong>6、</strong>避免运行脚本 一般来说，脚本应该避免。如果他们是绝对需要的，你应该使用painless和expressions引擎。</p>
<p><strong>7、</strong>搜索rounded 日期 日期字段上使用now，一般来说不会被缓存。但，rounded date则可以利用上query cache rounded到分钟等</p>
<p><strong>8、</strong>强制merge只读的index 只读的index可以从“merge成 一个单独的 大segment”中收益</p>
<p><strong>9、</strong>预热 全局序数（global ordinals）。全局序数用于在keyword字段上运行terms aggregations。es不知道哪些fields将用于&#x2F;不用于 term aggregation</p>
<p>因此全局序数在需要时才加载进内存，但可以在mapping type上，定义 eager_global_ordinals&#x3D;&#x3D;true。这样，refresh时就会加载 全局序数</p>
<p><strong>10、</strong>预热 filesystem cache 机器重启时，filesystem cache就被清空。</p>
<p>OS将index的热点区域（hot regions of the index）加载进filesystem cache是需要花费一段时间的。设置 index.store.preload 可以告知OS 这些文件需要提早加载进入内存</p>
<p><strong>11、</strong>使用索引排序来加速连接 索引排序对于以较慢的索引为代价来加快连接速度非常有用。在索引分类文档中阅读更多关于它的信息。</p>
<p><strong>12、</strong>使用preference来优化高速缓存利用率 有多个缓存可以帮助提高搜索性能，例如文件系统缓存，请求缓存或查询缓存。</p>
<p>然而，所有这些缓存都维护在节点级别，这意味着如果连续运行两次相同的请求，则有一个或多个副本，并使用循环（默认路由算法），那么这两个请求将转到不同的分片副本，阻止节点级别的缓存帮助。</p>
<p>由于搜索应用程序的用户一个接一个地运行类似的请求是常见的，例如为了分析索引的较窄的子集，使用标识当前用户或会话的优选值可以帮助优化高速缓存的使用。</p>
<p><strong>13、</strong>副本可能有助于吞吐量，但不会一直存在 除了提高弹性外，副本可以帮助提高吞吐量。例如，如果您有单个分片索引和三个节点，则需要将副本数设置为2，以便共有3个分片副本，以便使用所有节点。</p>
<p>现在假设你有一个2-shards索引和两个节点。</p>
<p>在一种情况下，副本的数量是0，这意味着每个节点拥有一个分片。在第二种情况下，副本的数量是1，这意味着每个节点都有两个碎片。</p>
<p>哪个设置在搜索性能方面表现最好？通常情况下，每个节点的碎片数少的设置将会更好。</p>
<p>原因在于它将可用文件系统缓存的份额提高到了每个碎片，而文件系统缓存可能是Elasticsearch的1号性能因子。</p>
<p>同时，要注意，没有副本的设置在发生单个节点故障的情况下会出现故障，因此在吞吐量和可用性之间进行权衡。</p>
<p>那么复制品的数量是多少？如果您有一个具有num_nodes节点的群集，那么num_primaries总共是主分片，如果您希望能够一次处理max_failures节点故障，那么正确的副本数是max（max_failures，ceil（num_nodes &#x2F; num_primaries） - 1）。</p>
<p><strong>14、</strong>打开自适应副本选择 当存在多个数据副本时，elasticsearch可以使用一组称为自适应副本选择的标准，根据包含分片的每个副本的节点的响应时间，服务时间和队列大小来选择数据的最佳副本。这可以提高查询吞吐量并减少搜索量大的应用程序的延迟。</p>
<h4 id="4、其他调优"><a href="#4、其他调优" class="headerlink" title="4、其他调优"></a>4、其他调优</h4><p>部署调优，业务调优等。</p>
<p>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。</p>
<h2 id="聊聊：客户端在和ES集群连接时，如何选择特定的节点执行请求的？"><a href="#聊聊：客户端在和ES集群连接时，如何选择特定的节点执行请求的？" class="headerlink" title="聊聊：客户端在和ES集群连接时，如何选择特定的节点执行请求的？"></a>聊聊：客户端在和ES集群连接时，如何选择特定的节点执行请求的？</h2><p>客户端是通过transport 模块远程连接一个 elasticsearch 集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮询 的方式与这些地址进行通信。</p>
<h2 id="聊聊：-Elasticsearch-中，是怎么根据一个词找到对应的倒排索引的？"><a href="#聊聊：-Elasticsearch-中，是怎么根据一个词找到对应的倒排索引的？" class="headerlink" title="聊聊： Elasticsearch 中，是怎么根据一个词找到对应的倒排索引的？"></a>聊聊： Elasticsearch 中，是怎么根据一个词找到对应的倒排索引的？</h2><p>首先我们应该了解一下什么是倒排索引，倒排索引就是通过分词策略把分词和文章形成一个关系映射表，这种词典和映射表的方式就是我们的倒排索引，所以当我们去检索一个词语的时候，会根据文档id去整个索引库中去查询到匹配的索引，然后返回给客户端。</p>
<h2 id="聊聊：Elasticsearch的倒排索引与Mysql正排索引的区别？"><a href="#聊聊：Elasticsearch的倒排索引与Mysql正排索引的区别？" class="headerlink" title="聊聊：Elasticsearch的倒排索引与Mysql正排索引的区别？"></a>聊聊：Elasticsearch的倒排索引与Mysql正排索引的区别？</h2><blockquote>
<p>一切设计都是为了提高搜索的性能</p>
</blockquote>
<p>倒排索引（Inverted Index）也叫反向索引，有反向索引必有正向索引。通俗地来讲，正向索引是通过key找value，反向索引则是通过value找key。</p>
<p>先来回忆一下我们是怎么插入一条索引记录的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/user/_doc/1&quot;</span> -H <span class="symbol">&#x27;Content</span>-Type: application/json<span class="string">&#x27; -d&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span> : <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其实就是直接PUT一个JSON的对象，这个对象有多个字段，在插入这些数据到索引的同时，Elasticsearch还为这些字段建立索引——倒排索引，因为Elasticsearch最核心功能是搜索。</p>
<p>那么，倒排索引是个什么样子呢？</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/4afd4cac6e1e5380a76766b70d4afac6.png" alt="img"></p>
<p>首先，来搞清楚几个概念，为此，举个例子：</p>
<p>假设有个user索引，它有四个字段：分别是name，gender，age，address。</p>
<p>画出来的话，大概是下面这个样子，跟关系型数据库一样</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/12e803ea51dd43d770c72d0824e40506.png" alt="img"></p>
<p><strong>Term（单词）</strong>：一段文本经过分析器分析以后就会输出一串单词，这一个一个的就叫做Term（直译为：单词）</p>
<p><strong>Term Dictionary（单词字典）</strong>：顾名思义，它里面维护的是Term，可以理解为Term的集合</p>
<p><strong>Term Index（单词索引）</strong>：为了更快的找到某个单词，我们为单词建立索引</p>
<p><strong>Posting List（倒排列表）</strong>：倒排列表记录了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。（PS：实际的倒排列表中并不只是存了文档ID这么简单，还有一些其它的信息，比如：词频（Term出现的次数）、偏移量（offset）等，可以想象成是Python中的元组，或者Java中的对象）</p>
<p>（PS：如果类比现代汉语词典的话，那么Term就相当于词语，Term Dictionary相当于汉语词典本身，Term Index相当于词典的目录索引）</p>
<p>我们知道，每个文档都有一个ID，如果插入的时候没有指定的话，Elasticsearch会自动生成一个，因此ID字段就不多说了</p>
<p>上面的例子，Elasticsearch建立的索引大致如下：</p>
<p><strong>name字段：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/26db7023c16a51030095cea7d281dc1b.png" alt="img"></p>
<p><strong>age字段：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/76970448e0c9aecbd26ffc32a00cf891.png" alt="img"><br><strong>gender字段：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/bd0031bb7b0a29df0f780b4914a2909f.png" alt="img"></p>
<p><strong>address字段：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/bc1cc3c43df1df5495c29f0782375fc1.png" alt="img"></p>
<p>Elasticsearch分别为每个字段都建立了一个倒排索引。</p>
<p>比如，在上面“张三”、“北京市”、22 这些都是Term，而[1，3]就是Posting List。Posting list就是一个数组，存储了所有符合某个Term的文档ID。</p>
<p>只要知道文档ID，就能快速找到文档。可是，要怎样通过我们给定的关键词快速找到这个Term呢？</p>
<p>当然是建索引了，为Terms建立索引，最好的就是B-Tree索引（PS：MySQL就是B树索引最好的例子）。</p>
<p>首先，让我们来回忆一下MyISAM存储引擎中的索引是什么样的：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/321ea298beffdd05570e1d1afe9f48d2.png" alt="img"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/7d4ffab6287f760f075ac3f2bdb46d93.png" alt="img"></p>
<p>我们查找Term的过程跟在MyISAM中记录ID的过程大致是一样的</p>
<p>MyISAM中，索引和数据是分开，通过索引可以找到记录的地址，进而可以找到这条记录</p>
<p>倒排索引是区别于正排索引的概念：</p>
<ul>
<li><strong>正排索引</strong>：是以文档对象的唯一 ID 作为索引，以文档内容作为记录。</li>
<li><strong>倒排索引</strong>：Inverted index，指的是将文档内容中的单词作为索引，将包含该词的文档 ID 作为记录。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20210717190921978.png" alt="在这里插入图片描述"></p>
<p>在倒排索引中，通过Term索引可以找到Term在Term Dictionary中的位置，进而找到Posting List，有了倒排列表就可以根据ID找到文档了</p>
<p>（PS：可以这样理解，类比MyISAM的话，Term Index相当于索引文件，Term Dictionary相当于数据文件）</p>
<p>（PS：其实，前面我们分了三步，我们可以把Term Index和Term Dictionary看成一步，就是找Term。因此，可以这样理解倒排索引：通过单词找到对应的倒排列表，根据倒排列表中的倒排项进而可以找到文档记录）</p>
<p>为了更进一步理解，下面从网上摘了两张图来具现化这一过程：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/9af0da6c7613419d82453fff24d91265.png" alt="img"> <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/6399c96d479e9c46ad3bbccb18eff6bb.png" alt="img"></p>
<h3 id="倒排索引的生成过程"><a href="#倒排索引的生成过程" class="headerlink" title="倒排索引的生成过程"></a>倒排索引的生成过程</h3><p>下面通过一个例子来说明下倒排索引的生成过程。</p>
<p>假设目前有以下两个文档内容：</p>
<blockquote>
<p>苏州街维亚大厦<br>桔子酒店苏州街店</p>
</blockquote>
<p>其处理步骤如下：</p>
<p>1、正排索引给每个文档进行编号，作为其唯一的标识。</p>
<table>
<thead>
<tr>
<th>文档 id</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>苏州街维亚大厦</td>
</tr>
<tr>
<td>2</td>
<td>桔子酒店苏州街店</td>
</tr>
</tbody></table>
<p>2、生成倒排索引：</p>
<ul>
<li>首先要对字段的内容进行分词，分词就是将一段连续的文本按照语义拆分为多个单词，这里两个文档包含的关键词有：苏州街、维亚大厦…</li>
<li>然后按照单词来作为索引，对应的文档 id 建立一个链表，就能构成上述的倒排索引结构。</li>
</ul>
<table>
<thead>
<tr>
<th>Word</th>
<th>文档 id</th>
</tr>
</thead>
<tbody><tr>
<td>苏州街</td>
<td>1,2</td>
</tr>
<tr>
<td>维亚大厦</td>
<td>1</td>
</tr>
<tr>
<td>维亚</td>
<td>1</td>
</tr>
<tr>
<td>桔子</td>
<td>2</td>
</tr>
<tr>
<td>酒店</td>
<td>2</td>
</tr>
<tr>
<td>大赛</td>
<td>1</td>
</tr>
</tbody></table>
<p>有了倒排索引，能快速、灵活地实现各类搜索需求。整个搜索过程中我们不需要做任何文本的模糊匹配。</p>
<blockquote>
<p>例如，如果需要在上述两个文档中查询 苏州街桔子 ，可以通过分词后 苏州街 查到 1、2，通过 桔子 查到 2，然后再进行取交取并等操作得到最终结果。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20210717191702274.png" alt="在这里插入图片描述"></p>
<h3 id="倒排索引的结构"><a href="#倒排索引的结构" class="headerlink" title="倒排索引的结构"></a>倒排索引的结构</h3><p>根据倒排索引的概念，我们可以用一个 Map来简单描述这个结构。这个 <strong>Map 的 Key 的即是分词后的单词</strong>，这里的单词称为 Term，这一系列的 Term 组成了倒排索引的第一个部分 —— Term Dictionary (索引表，可简称为 Dictionary)。</p>
<p>倒排索引的另一部分为 Postings List（记录表），也对应上述 <strong>Map 结构的 Value 部分</strong>集合。</p>
<p>记录表由所有的 Term 对应的数据（Postings） 组成，它不仅仅为文档 id 信息，可能包含以下信息：</p>
<ul>
<li><strong>文档 id（DocId, Document Id），</strong>包含单词的所有文档唯一 id<strong>，用于去正排索引中查询原始数据。</strong></li>
<li><strong>词频（TF，Term Frequency），</strong>记录 Term 在每篇文档中出现的次数<strong>，用于后续相关性算分。</strong></li>
<li><strong>位置（Position），</strong>记录 Term 在每篇文档中的分词位置（多个）<strong>，用于做词语搜索（Phrase Query）。</strong></li>
<li><strong>偏移（Offset），</strong>记录 Term 在每篇文档的开始和结束位置<strong>，用于高亮显示等。</strong></li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20210717191823352.png" alt="在这里插入图片描述"></p>
<h3 id="Lucene-倒排索引实现"><a href="#Lucene-倒排索引实现" class="headerlink" title="Lucene 倒排索引实现"></a>Lucene 倒排索引实现</h3><p>全文搜索引擎在海量数据的情况下是需要存储大量的文本，所以面临以下问题：</p>
<ul>
<li>Dictionary 是比较大的（比如我们搜索中的一个字段可能有上千万个 Term）</li>
<li>Postings 可能会占据大量的存储空间（一个Term多的有几百万个doc）</li>
</ul>
<p>因此上面说的基于 Map 的实现方式几乎是不可行的。</p>
<p>在海量数据背景下，倒排索引的实现直接关系到存储成本以及搜索性能。</p>
<p>为此，Lucene 引入了多种巧妙的数据结构和算法。其倒排索引实现拥有以下特性：</p>
<ul>
<li>以较低的存储成本存储在磁盘 （索引大小大约为被索引文本的20-30％）</li>
<li>快速读写</li>
</ul>
<p>下面将根据倒排索引的结构，按 Posting List 和 Terms Dictionary 两部分来分析 Lucene 中的实现。</p>
<h3 id="Posting-List-实现"><a href="#Posting-List-实现" class="headerlink" title="Posting List 实现"></a>Posting List 实现</h3><p>PostingList 包含文档 id、词频、位置等多个信息，这些数据之间本身是相对独立的，因此 Lucene 将 Postings List 被拆成三个文件存储：</p>
<ul>
<li><strong>doc后缀文件</strong>：记录 Postings 的 docId 信息和 Term 的词频</li>
<li><strong>pay后缀文件</strong>：记录 Payload 信息和偏移量信息</li>
<li><strong>pos后缀文件</strong>：记录位置信息</li>
</ul>
<p>基本所有的查询都会用 .doc 文件获取文档 id，且一般的查询仅需要用到 .doc 文件就足够了，只有对于近似查询等位置相关的查询则需要用位置相关数据。</p>
<p>三个文件整体实现差不太多，这里以.doc 文件为例分析其实现。</p>
<p>.doc 文件存储的是每个 Term 对应的文档 Id 和词频。每个 Term 都包含一对 TermFreqs 和 SkipData 结构。</p>
<p>其中 TermFreqs 存放 docId 和词频信息，SkipData 为跳表信息，用于实现 TermFreqs 内部的快速跳转。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20210717201031390.png" alt="在这里插入图片描述"></p>
<h3 id="Term-Dictionary-实现"><a href="#Term-Dictionary-实现" class="headerlink" title="Term Dictionary 实现"></a>Term Dictionary 实现</h3><p>Terms Dictionary（索引表）存储所有的 Term 数据，同时它也是 Term 与 Postings 的关系纽带，存储了每个 Term 和其对应的 Postings 文件位置指针。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20210717201549655.png" alt="在这里插入图片描述"></p>
<h2 id="聊聊：Elasticsearch索引数据多了怎么办，如何调优，部署？"><a href="#聊聊：Elasticsearch索引数据多了怎么办，如何调优，部署？" class="headerlink" title="聊聊：Elasticsearch索引数据多了怎么办，如何调优，部署？"></a>聊聊：Elasticsearch索引数据多了怎么办，如何调优，部署？</h2><p><strong>答：</strong></p>
<p>面试官：想了解大数据量的运维能力。</p>
<p>解答：索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，这样才能有效的避免突如其来的数据激增导致集群处理能力不足引发的线上客户检索或者其他业务受到影响。</p>
<p>如何调优，正如问题1所说，这里细化一下：</p>
<p><strong>3.1 动态索引层面</strong></p>
<p>基于模板+时间+rollover api滚动创建索引，举例：设计阶段定义：blog索引的模板格式为：blog_index_时间戳的形式，每天递增数据。</p>
<p>这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线2的32次幂-1，索引存储达到了TB+甚至更大。<br>一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。</p>
<p><strong>3.2 存储层面</strong></p>
<p>冷热数据分离存储，热数据（比如最近3天或者一周的数据），其余为冷数据。对于冷数据不会再写入新数据，可以考虑定期 force_merge 加 shrink 压缩操作，节省存储空间和检索效率。</p>
<p><strong>3.3 部署层面</strong></p>
<p>一旦之前没有规划，这里就属于应急策略。结合ES自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注意：如果之前主节点等规划合理，不需要重启集群也能完成动态新增的。</p>
<blockquote>
<p>说明：本文会以pdf格式持续更新，更多最新尼恩3高pdf笔记，请从下面的链接获取：<a target="_blank" rel="noopener" href="https://www.yuque.com/crazymakercircle/gkkw8s/khigna">语雀</a> 或者 <a target="_blank" rel="noopener" href="https://gitee.com/crazymaker/SimpleCrayIM/blob/master/%E7%96%AF%E7%8B%82%E5%88%9B%E5%AE%A2%E5%9C%88%E6%80%BB%E7%9B%AE%E5%BD%95.md">码云</a></p>
</blockquote>
<h2 id="聊聊：Elasticsearch是如何实现master选举的？"><a href="#聊聊：Elasticsearch是如何实现master选举的？" class="headerlink" title="聊聊：Elasticsearch是如何实现master选举的？"></a>聊聊：Elasticsearch是如何实现master选举的？</h2><p><strong>答：</strong></p>
<p>面试官：想了解ES集群的底层原理，不再只关注业务层面了。</p>
<p>解答：</p>
<p>前置前提：</p>
<p>1、只有候选主节点（master：true）的节点才能成为主节点。</p>
<p>2、最小主节点数（min_master_nodes）的目的是防止脑裂。</p>
<p>这个我看了各种网上分析的版本和源码分析的书籍，云里雾里。</p>
<p>核对了一下代码，核心入口为findMaster，选择主节点成功返回对应Master，否则返回null。</p>
<p>选举流程大致描述如下：</p>
<p>第一步：确认候选主节点数达标，elasticsearch.yml设置的值</p>
<p>discovery.zen.minimum_master_nodes；</p>
<p>第二步：比较：先判定是否具备master资格，具备候选主节点资格的优先返回；若两节点都为候选主节点，则id小的值会主节点。注意这里的id为string类型。</p>
<h2 id="聊聊：Elasticsearch-的-master-选举流程？"><a href="#聊聊：Elasticsearch-的-master-选举流程？" class="headerlink" title="聊聊：Elasticsearch 的 master 选举流程？"></a>聊聊：Elasticsearch 的 master 选举流程？</h2><ul>
<li>Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 <strong>Ping</strong>（节点之间通过这个 RPC 来发现彼此）和 <strong>Unicast</strong>（单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分</li>
<li>对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排序，每次选举每个节点都把自己所知道节点<strong>排一次序，然后选出第一个（第 0 位）节点，暂且认为它是 master 节点</strong>。</li>
<li>如果对某个节点的投票数达到一定的值<strong>（可以成为 master 节点数 n&#x2F;2+1）并且该节点自己也选举自己</strong>，那这个节点就是 master。否则重新选举一直到满足上述条件。</li>
<li>master 节点的职责主要包括集群、节点和索引的管理，<strong>不负责文档级别的管理</strong>；<strong>data 节点可以关闭 http功能</strong>。</li>
</ul>
<h2 id="聊聊：详细描述一下Elasticsearch索引文档的过程。"><a href="#聊聊：详细描述一下Elasticsearch索引文档的过程。" class="headerlink" title="聊聊：详细描述一下Elasticsearch索引文档的过程。"></a>聊聊：详细描述一下Elasticsearch索引文档的过程。</h2><p>面试官：想了解ES的底层原理，不再只关注业务层面了。</p>
<p><strong>解答：</strong></p>
<p>首先客户端向集群发出索引文档的请求，它会选择<strong>任何一个节点</strong>，</p>
<p>这个节点当接收到请求后会根据<strong>路由算法</strong>找到应该放的那个主分片的位置，从而索引数据， <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/a9bd1e6d1fdc4640b4ffe1e971d8574d.png" alt="请添加图片描述"></p>
<p>之后为了保证数据的完整性，它会将它的副本数据进行同步，同步完成后客户端就可以进行访问了。</p>
<p>细节方面：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/bc8f74b1432446d7a56752723a15b05c.png" alt="请添加图片描述"></p>
<p>用户的索引请求发过来之后，首先协调结点默认使用文档ID参与哈希计算（也支持通过routing），</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shard</span> = hash(document_id) % (num_of_primary_shards)</span><br></pre></td></tr></table></figure>

<p>即</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分片位置索引 = 将文档ID或路由ID进行哈希计算后的值 <span class="comment">% 所有分片总数</span></span><br></pre></td></tr></table></figure>

<p>随后会在内存（memory）中建立一个索引（Index），这个Index会在内存中形成一个分段对象（Segment），</p>
<p>为了防止数据出现问题，会同时在索引数据之后写入到日志（Translog）当中，</p>
<p>在此过程中，每隔1秒钟，会向Segment会将数据刷新到系统文件缓存区（OS Cache），以方便接收用户的查询，</p>
<p>因为如果让用户查询直接访问内存或磁盘，会使速度变慢。</p>
<p>当过了30分钟或者Translog中的数据超过了512M，Os Cache中的Segment会将数据刷写（flush）到磁盘当中，刷写后内存中的缓冲将被清除。</p>
<p>此时一旦刷写的数据比较多了的话（磁盘中有多个Segment），磁盘就会将这些分段进行合并。</p>
<h2 id="聊聊：详细描述一下Elasticsearch索引文档的过程。-1"><a href="#聊聊：详细描述一下Elasticsearch索引文档的过程。-1" class="headerlink" title="聊聊：详细描述一下Elasticsearch索引文档的过程。"></a>聊聊：详细描述一下Elasticsearch索引文档的过程。</h2><p><strong>答：</strong></p>
<p>协调节点默认使用文档ID参与计算（也支持通过routing），以便为路由提供合适的分片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = hash(document_id) % (num_of_primary_shards)</span><br></pre></td></tr></table></figure>

<p>1、当分片所在的节点接收到来自协调节点的请求后，会将请求写入到Memory Buffer，然后定时（默认是每隔1秒）写入到 Filesystem Cache，这个从MomeryBuffer到Filesystem Cache的过程就叫做refresh；</p>
<p>2、当然在某些情况下，存在Momery Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当 Filesystem cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush；</p>
<p>3、在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。</p>
<p>4、flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/202105111544302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ4Nzk1NjA3,size_16,color_FFFFFF,t_70" alt="img"><br>补充：关于Lucene 的 Segement：</p>
<p>1、Lucene索引是由多个段组成，段本身是一个功能齐全的倒排索引。</p>
<p>2、段是不可变的，允许Lucene将新的文档增量地添加到索引中，而不用从头重建索引。</p>
<p>3、对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗CPU的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。</p>
<p>4、为了解决这个问题，Elasticsearch会合并小段到一个较大的段，提交新的合并段到磁盘，并删除那些旧的小段。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="聊聊：详细描述一下Elasticsearch搜索的过程？"><a href="#聊聊：详细描述一下Elasticsearch搜索的过程？" class="headerlink" title="聊聊：详细描述一下Elasticsearch搜索的过程？"></a>聊聊：详细描述一下Elasticsearch搜索的过程？</h2><p>面试官：想了解ES搜索的底层原理，不再只关注业务层面了。</p>
<p><strong>解答：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/7ac34c18990747bab66a2705d0f8a3a7.png" alt="请添加图片描述"></p>
<ul>
<li>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch（查询后取回）；</li>
<li>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本<br>地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在搜索的时候是会查询<br><strong>Filesystem Cache</strong> 的，但是有部分数据<strong>还在 Memory Buffer，所以搜索是近实时的</strong>。</li>
<li>每个分片返回各自优先队列中 所有文档的 <strong>ID 和排序值</strong> 给 <strong>协调节点，它合并这些值到自己的优先队</strong><br><strong>列中来产生一个全局排序后的结果列表</strong>。</li>
<li>接下来就是取回阶段，协调节点辨别出哪些文档需要被取回，<strong>并向相关的分片提交多个 GET 请求</strong>。每<br>个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，<br>协调节点返回结果给客户端。</li>
<li>Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少<br>的时候可能不够准确，DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document<br>frequency，这个评分更准确，但是性能会变差。</li>
</ul>
<h2 id="聊聊：详细描述一下Elasticsearch搜索的过程。"><a href="#聊聊：详细描述一下Elasticsearch搜索的过程。" class="headerlink" title="聊聊：详细描述一下Elasticsearch搜索的过程。"></a>聊聊：详细描述一下Elasticsearch搜索的过程。</h2><p><strong>答：</strong></p>
<p>1、搜索被执行成一个两阶段过程，我们称之为Query Then Fetch；</p>
<p>2、在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为from + size的优先队列。</p>
<p>PS：在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在MemoryBuffer，所以搜索是近实时的。</p>
<p>3、每个分片返回各自优先队列中 所有文档的ID和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p>
<p>4、接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个GET请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</p>
<p>5、补充：Query Then Fetch的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch增加了一个预查询的处理，询问Term 和 Document frequency，这个评分更准确，但是性能会变差。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20210511154742415.png" alt="img"></p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="聊聊：详细描述一下Elasticsearch更新和删除文档的过程。"><a href="#聊聊：详细描述一下Elasticsearch更新和删除文档的过程。" class="headerlink" title="聊聊：详细描述一下Elasticsearch更新和删除文档的过程。"></a>聊聊：详细描述一下Elasticsearch更新和删除文档的过程。</h2><p><strong>答：</strong></p>
<p>1、删除和更新也都是写操作，但是Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；</p>
<p>2、磁盘上的每个段都有一个相应的del文件。当删除请求发送后，文档并没有真的被删除，而是在del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在del文件中被标记为删除的文档将不会被写入新段。</p>
<p>3、在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h2 id="聊聊：Elasticsearch在部署时，对Linux的设置有哪些优化方法？"><a href="#聊聊：Elasticsearch在部署时，对Linux的设置有哪些优化方法？" class="headerlink" title="聊聊：Elasticsearch在部署时，对Linux的设置有哪些优化方法？"></a>聊聊：Elasticsearch在部署时，对Linux的设置有哪些优化方法？</h2><p>面试官：想了解对ES集群的运维能力。</p>
<p><strong>解答：</strong></p>
<p>1、关闭缓存swap</p>
<p>2、堆内存设置为：Min（节点内存&#x2F;2, 32GB）</p>
<p>3、设置最大文件句柄数</p>
<p>4、线程池+队列大小根据业务需要做调整</p>
<p>5、磁盘存储raid方式——存储有条件使用RAID10，增加单节点性能以及避免单节点存储故障</p>
<h2 id="聊聊：lucence内部结构是什么？"><a href="#聊聊：lucence内部结构是什么？" class="headerlink" title="聊聊：lucence内部结构是什么？"></a>聊聊：lucence内部结构是什么？</h2><p>面试官：想了解你的知识面的广度和深度。</p>
<p><strong>解答：</strong><br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20210511154128479.png" alt="img"><br>Lucene是有索引和搜索的两个过程，包含索引创建，索引，搜索三个要点。可以基于这个脉络展开一些。</p>
<p>最近面试一些公司，被问到的关于Elasticsearch和搜索引擎相关的问题，以及自己总结的回答。</p>
<h2 id="聊聊：Elasticsearch是如何实现Master选举的？"><a href="#聊聊：Elasticsearch是如何实现Master选举的？" class="headerlink" title="聊聊：Elasticsearch是如何实现Master选举的？"></a>聊聊：Elasticsearch是如何实现Master选举的？</h2><p>1、Elasticsearch的选主是ZenDiscovery 模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；</p>
<p>2、对所有可以成为master的节点（node.master：true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。</p>
<p>3、如果对某个节点的投票数达到一定的值（可以成为master节点数n&#x2F;2+1）并且该节点自己也选举自己，那这个节点就是 master。否则重新选举一直到满足上述条件。</p>
<p>4、补充：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http 功能*。</p>
<h2 id="聊聊：Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办？"><a href="#聊聊：Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办？" class="headerlink" title="聊聊：Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办？"></a>聊聊：Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办？</h2><p>1、当集群master候选数量不小于3个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；</p>
<p>2、当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题</p>
<h2 id="聊聊：客户端在和集群连接时，如何选择特定的节点执行请求的？"><a href="#聊聊：客户端在和集群连接时，如何选择特定的节点执行请求的？" class="headerlink" title="聊聊：客户端在和集群连接时，如何选择特定的节点执行请求的？"></a>聊聊：客户端在和集群连接时，如何选择特定的节点执行请求的？</h2><p><strong>答：</strong></p>
<p>1、TransportClient利用transport模块远程连接一个elasticsearch集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的transport地址，并以 轮询 的方式与这些地址进行通信。</p>
<blockquote>
<p>说明：本文会以pdf格式持续更新，更多最新尼恩3高pdf笔记，请从下面的链接获取：<a target="_blank" rel="noopener" href="https://www.yuque.com/crazymakercircle/gkkw8s/khigna">语雀</a> 或者 <a target="_blank" rel="noopener" href="https://gitee.com/crazymaker/SimpleCrayIM/blob/master/%E7%96%AF%E7%8B%82%E5%88%9B%E5%AE%A2%E5%9C%88%E6%80%BB%E7%9B%AE%E5%BD%95.md">码云</a></p>
</blockquote>
<h2 id="聊聊：Elasticsearch在部署时，对Linux的设置有哪些优化方法？-1"><a href="#聊聊：Elasticsearch在部署时，对Linux的设置有哪些优化方法？-1" class="headerlink" title="聊聊：Elasticsearch在部署时，对Linux的设置有哪些优化方法？"></a>聊聊：Elasticsearch在部署时，对Linux的设置有哪些优化方法？</h2><p><strong>答：</strong></p>
<p>1、64GB内存的机器是非常理想的， 但是32GB和16GB机器也是很常见的。少于8GB会适得其反。</p>
<p>2、如果你要在更快的CPUs和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91&spm=1001.2101.3001.7020">并发</a>远胜过稍微快一点点的时钟频率。</p>
<p>3、如果你负担得起SSD，它将远远超出任何旋转介质。 基于SSD的节点，查询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。</p>
<p>4、即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。</p>
<p>5、请确保运行你应用程序的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020">JVM</a>和服务器的JVM是完全一样的。 在Elasticsearch的几个地方，使用Java的本地序列化。</p>
<p>6、通过设置 gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。</p>
<p>7、Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。</p>
<p>8、不要随意修改垃圾回收器（CMS）和各个线程池的大小。</p>
<p>9、把你的内存的（少于）一半给Lucene（但不要超过32GB！），通过ES_HEAP_SIZE 环境变量设置。</p>
<p>10、内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个100微秒的操作可能变成10毫秒。 再想想那么多10微秒的操作时延累加起来。 不难看出swapping对于性能是多么可怕。</p>
<p>11、Lucene使用了大量的文件。同时，Elasticsearch在节点和HTTP客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如64,000。</p>
<p>补充：索引阶段性能提升方法</p>
<p>1、使用批量请求并调整其大小：每次批量数据5–15 MB大是个不错的起始点。</p>
<p>2、存储：使用 SSD</p>
<p>3、段和合并：Elasticsearch 默认值是20MB&#x2F;s，对机械磁盘应该是个不错的设置。如果你用的是SSD，可以考虑提高到 100–200 MB&#x2F;s。</p>
<p>如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加index.translog.flush_threshold_size设置，从默认的512MB到更大一些的值，比如1GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。</p>
<p>4、如果你的搜索结果不需要近实时的准确度，考虑把每个索引的index.refresh_interval 改到30s。</p>
<p>5、如果你在做大批量导入，考虑通过设置 index.number_of_replicas: 0 关闭副本。</p>
<h2 id="聊聊：对于GC方面，在使用Elasticsearch时要注意什么？"><a href="#聊聊：对于GC方面，在使用Elasticsearch时要注意什么？" class="headerlink" title="聊聊：对于GC方面，在使用Elasticsearch时要注意什么？"></a>聊聊：对于GC方面，在使用Elasticsearch时要注意什么？</h2><p><strong>答：</strong></p>
<p>1、官方资料：<a target="_blank" rel="noopener" href="https://elasticsearch.cn/article/32">https://elasticsearch.cn/article/32</a></p>
<p>2、倒排词典的索引需要常驻内存，无法GC，需要监控data node 上segmentmemory增长趋势。</p>
<p>3、各类缓存，field cache, filter cache, indexing cache, bulk queue 等等，要设置合理的大小，并且要应该根据最坏的情况来看heap是否够用，也就是各类缓存全部占满的时候，还有heap空间可以分配给其他任务吗？避免采用clear cache等“自欺欺人”的方式来释放内存。</p>
<p>4、避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用scan &amp; scroll api来实现。</p>
<p>5、cluster stats驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过tribe node连接。</p>
<p>6、想知道heap够不够，必须结合实际应用场景，并对集群的heap使用情况做持续的监控。</p>
<h2 id="聊聊：Elasticsearch对于大数据量（上亿量级）的聚合如何实现？"><a href="#聊聊：Elasticsearch对于大数据量（上亿量级）的聚合如何实现？" class="headerlink" title="聊聊：Elasticsearch对于大数据量（上亿量级）的聚合如何实现？"></a>聊聊：Elasticsearch对于大数据量（上亿量级）的聚合如何实现？</h2><p><strong>答：</strong></p>
<p>Elasticsearch提供的首个近似聚合是cardinality度量。它提供一个字段的基数，即该字段的distinct或者unique值的数目。</p>
<p>它是基于HLL算法的。HLL会先对我们的输入作哈希运算，然后根据哈希运算的结果中的bits做概率估算从而得到基数。</p>
<p>其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；</p>
<p>小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p>
<h2 id="聊聊：在并发情况下，Elasticsearch如果保证读写一致？"><a href="#聊聊：在并发情况下，Elasticsearch如果保证读写一致？" class="headerlink" title="聊聊：在并发情况下，Elasticsearch如果保证读写一致？"></a>聊聊：在并发情况下，Elasticsearch如果保证读写一致？</h2><p><strong>答：</strong></p>
<p>1、可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p>
<p>2、另外对于写操作，一致性级别支持quorum&#x2F;one&#x2F;all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p>
<p>3、对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication 为async时，也可以通过设置搜索请求参数_preference 为 primary来查询主分片，确保文档是最新版本。</p>
<h2 id="聊聊：并发情况下，Elasticsearch-如果保证读写一致？"><a href="#聊聊：并发情况下，Elasticsearch-如果保证读写一致？" class="headerlink" title="聊聊：并发情况下，Elasticsearch 如果保证读写一致？"></a>聊聊：并发情况下，Elasticsearch 如果保证读写一致？</h2><ul>
<li><p>可以通过<strong>版本号使用乐观锁并发控制</strong>，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p>
</li>
<li><p>对于写操作：一致性级别支持 quorum&#x2F;one&#x2F;all，默认为 quorum。</p>
<ul>
<li>quorum：即<strong>只有当大多数（一半以上）分片可用时才允许写操作</strong>。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</li>
<li>one：即只要主分片数据保存成功，那么客户端就可以进行查询操作了。</li>
<li>all：是最高的一致性级别，要求所有分片的数据要全部保存成功，才可以继续进行。</li>
</ul>
</li>
<li><p>对于读操作：可以设置 replication 为 sync(默认为同步)，这使得操作在主分片和副本分片都完成后才会返回；设置 replication 为 async（异步）时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。</p>
</li>
</ul>
<h2 id="聊聊：Elasticsearch-中的节点（比如共-20-个），其中的-10-个选了一个master，另外-10-个选了另一个-master，怎么办？"><a href="#聊聊：Elasticsearch-中的节点（比如共-20-个），其中的-10-个选了一个master，另外-10-个选了另一个-master，怎么办？" class="headerlink" title="聊聊：Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了一个master，另外 10 个选了另一个 master，怎么办？"></a>聊聊：Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了一个master，另外 10 个选了另一个 master，怎么办？</h2><p>1、当集群master候选数量不小于3个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；</p>
<p>2、当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。</p>
<h2 id="聊聊：Elasticsearch-集群脑裂问题？有哪些解决方法？"><a href="#聊聊：Elasticsearch-集群脑裂问题？有哪些解决方法？" class="headerlink" title="聊聊：Elasticsearch 集群脑裂问题？有哪些解决方法？"></a>聊聊：Elasticsearch 集群脑裂问题？有哪些解决方法？</h2><p>“脑裂”问题可能的成因：（有两个master）</p>
<ul>
<li>网络问题：集群间的网络延迟导致一些节点访问不到 master，<strong>认为 master 挂掉了从而选举出新的master</strong>，并对 master 上的分片和副本标红，分配新的主分片</li>
<li>节点负载：主节点的角色既为 master 又为 data，<strong>访问量较大时可能会导致 ES 停止响应造成大面积延迟</strong>，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。</li>
<li>内存回收：data 节点上的 ES 进程占用的内存较大，<strong>引发 JVM 的大规模内存回收，造成 ES 进程失去响应</strong>。</li>
</ul>
<p>脑裂问题解决方案</p>
<ul>
<li>减少误判：discovery.zen.ping_timeout 节点状态的响应时间（<strong>超过这个时间就会重新选举master</strong>），默认为 3s，可以适当调大，如果 master在<strong>该响应时间的范围内没有做出响应应答</strong>，判断该节点已经挂掉了。调大参数（如 6s，discovery.zen.ping_timeout:6），可适当减少误判。</li>
<li>选举触发：discovery.zen.minimum_master_nodes:1</li>
</ul>
<p>该参数是用于控制选举行为发生的<strong>最小集群主节点数量</strong>。当备选主节点的个数大于等于该参数的值，<br>且备选主节点中<strong>有该参数个节点认为主节点挂了</strong>，进行选举。官方建议为（n&#x2F;2）+1，n 为主节点个数<br>（即有资格成为主节点的节点个数）</p>
<ul>
<li>角色分离：即 master 节点与 data 节点分离，限制角色<br>主节点配置为：node.master: true node.data: false<br>从节点配置为：node.master: false node.data: true</li>
</ul>
<h2 id="聊聊：如何监控Elasticsearch集群状态？"><a href="#聊聊：如何监控Elasticsearch集群状态？" class="headerlink" title="聊聊：如何监控Elasticsearch集群状态？"></a>聊聊：如何监控Elasticsearch集群状态？</h2><p><strong>答：</strong></p>
<p>Marvel让你可以很简单的通过Kibana监控Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。</p>
<h2 id="聊聊：介绍下你们电商搜索的整体技术架构。"><a href="#聊聊：介绍下你们电商搜索的整体技术架构。" class="headerlink" title="聊聊：介绍下你们电商搜索的整体技术架构。"></a>聊聊：介绍下你们电商搜索的整体技术架构。</h2><p><strong>答：</strong><br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20210511155335503.png" alt="img"></p>
<h2 id="聊聊：字典树的大致思想和性质？"><a href="#聊聊：字典树的大致思想和性质？" class="headerlink" title="聊聊：字典树的大致思想和性质？"></a>聊聊：字典树的大致思想和性质？</h2><p>很多数据结构均能完成字典功能，总结如下。</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>排序列表Array&#x2F;List</td>
<td>使用二分法查找，不平衡</td>
</tr>
<tr>
<td>HashMap&#x2F;TreeMap</td>
<td>性能高，内存消耗大，几乎是原始数据的三倍</td>
</tr>
<tr>
<td>Skip List</td>
<td>跳跃表，可快速查找词语，在lucene、redis、Hbase等均有实现。相对于TreeMap等结构，特别适合高并发场景</td>
</tr>
<tr>
<td>Trie</td>
<td>适合英文词典，如果系统中存在大量字符串且这些字符串基本没有公共前缀，则相应的trie树将非常消耗内存</td>
</tr>
<tr>
<td>Double Array Trie</td>
<td>适合做中文词典，内存占用小，很多分词工具均采用此种算法</td>
</tr>
<tr>
<td>Ternary Search Tree</td>
<td>三叉树，每一个node有3个节点，兼具省空间和查询快的优点</td>
</tr>
<tr>
<td>Finite State Transducers (FST)</td>
<td>一种有限状态转移机，Lucene 4有开源实现，并大量使用</td>
</tr>
</tbody></table>
<p>Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>它有3个基本性质：</p>
<p>1、根节点不包含字符，除根节点外每一个节点都只包含一个字符。</p>
<p>2、从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
<p>3、每个节点的所有子节点包含的字符都不相同。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/2021051115551187.png" alt="img"></p>
<p>1、可以看到，trie树每一层的节点数是26^i 级别的。所以为了节省空间，我们还可以用动态链表，或者用数组来模拟动态。而空间的花费，不会超过单词数×单词长度。</p>
<p>2、实现：对每个结点开一个字母集大小的数组，每个结点挂一个链表，使用左儿子右兄弟表示法记录这棵树；</p>
<p>3、对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查询速度上可以保留哈希的复杂度O(1)</p>
<h2 id="聊聊：是否了解字典树？"><a href="#聊聊：是否了解字典树？" class="headerlink" title="聊聊：是否了解字典树？"></a>聊聊：是否了解字典树？</h2><blockquote>
<p>常用字典数据结构</p>
</blockquote>
<ul>
<li><p>排序列表Array&#x2F;List：使用二分法查找，不平衡</p>
</li>
<li><p>HashMap&#x2F;TreeMap：性能高，内存消耗大，几乎是原始数据的三倍</p>
</li>
<li><p>Skip List 跳跃表：可快速查找词语，在lucene、redis、Hbase等均有实现。相对于TreeMap等结构，特别</p>
<p>适合高并发场景(Skip List介绍)</p>
</li>
<li><p>Trie：适合英文词典，如果系统中存在大量字符串且这些字符串基本没有公共前级，则相应的trie树将非常消耗内存(数据结构之trie树)</p>
</li>
<li><p>Double Array Trie：适合做中文词典，内存占用小。很多分词工具均采用此种算法(深入双数组Trie)</p>
</li>
<li><p>Ternary Search Tree 三叉树：每一个node有3个节点，兼具省空间和查询快的优点(Ternary Search Tree)</p>
</li>
<li><p>Finite State Transducers(FST) ：一种有限状态转移机，Lucene4有开源实现，并大量使用</p>
</li>
</ul>
<p>字典树又称单词查找树，<strong>Trie 树</strong>，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</p>
<p>它的优点是：<strong>利用字符串的公共前缀</strong>来减少查询时间，最大限度地减少无谓的字符串比较，<strong>查询效率比哈希树高</strong>（空间换时间）。</p>
<p>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>它有 3 个基本性质：</p>
<ul>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ul>
<p>对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查询速度上可以保留哈希的复杂度 **O(1)**。</p>
<h2 id="聊聊：-FST原理"><a href="#聊聊：-FST原理" class="headerlink" title="聊聊： FST原理"></a>聊聊： FST原理</h2><p>Finite State Transducers(FST) ：一种有限状态转移机，Lucene4有开源实现，并大量使用.</p>
<p>lucene从4开始大量使用的数据结构是FST（Finite State Transducer）。</p>
<p>FST有两个优点：</p>
<p>1）空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；</p>
<p>2）查询速度快。O(len(str))的查询时间复杂度。</p>
<p>下面简单描述下FST的构造过程。</p>
<p>我们对“cat”、 “deep”、 “do”、 “dog” 、“dogs”这5个单词进行插入构建FST（注：必须已排序）。</p>
<p>1）插入“cat”</p>
<p>插入cat，每个字母形成一条边，其中t边指向终点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/295bba3073c98023dbd924e7d79ffc95.png" alt="img"></p>
<p>2）插入“deep”</p>
<p>与前一个单词“cat”进行最大前缀匹配，发现没有匹配则直接插入，P边指向终点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/4edb26a728c282ca239357fc8fc45901.png" alt="img"></p>
<p>3）插入“do”</p>
<p>与前一个单词“deep”进行最大前缀匹配，发现是d，则在d边后增加新边o，o边指向终点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/86334771817746242352ddec06a29787.png" alt="img"></p>
<p>4）插入“dog”</p>
<p>与前一个单词“do”进行最大前缀匹配，发现是do，则在o边后增加新边g，g边指向终点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/34f03524c57d500a3934d1bfec04a576.png" alt="img"></p>
<p>5）插入“dogs”</p>
<p>与前一个单词“dog”进行最大前缀匹配，发现是dog，则在g后增加新边s，s边指向终点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/img_convert/ee2d5a8a97832f58b601c33263519500.png" alt="img"></p>
<p>最终我们得到了如上一个有向无环图。利用该结构可以很方便的进行查询，如给定一个term “dog”，我们可以通过上述结构很方便的查询存不存在，甚至我们在构建过程中可以将单词与某一数字、单词进行关联，从而实现key-value的映射。</p>
<h2 id="聊聊：拼写纠错是如何实现的？"><a href="#聊聊：拼写纠错是如何实现的？" class="headerlink" title="聊聊：拼写纠错是如何实现的？"></a>聊聊：拼写纠错是如何实现的？</h2><p><strong>答：</strong></p>
<p>1、拼写纠错是基于编辑距离来实现；编辑距离是一种标准的方法，它用来表示经过插入、删除和替换操作从一个字符串转换到另外一个字符串的最小操作步数；</p>
<p>2、编辑距离的计算过程：比如要计算 batyu 和 beauty 的编辑距离，先创建一个7×8 的表（batyu长度为5，coffee长度为6，各加2），接着，在如下位置填入黑色数字。其他格的计算过程是取以下三个值的最小值：</p>
<p>如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字+1。</p>
<p>（对于3,3 来说为 0）</p>
<p>左方数字+1（对于3,3格来说为2）</p>
<p>上方数字+1（对于3,3格来说为2）</p>
<p>最终取右下角的值即为编辑距离的值3。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20210511155706553.png" alt="img"></p>
<p>对于拼写纠错，我们考虑构造一个度量空间（Metric Space），该空间内任何关系满足以下三条基本条件：</p>
<p>d(x,y) &#x3D; 0 – 假如 x 与 y 的距离为 0，则 x&#x3D;y</p>
<p>d(x,y) &#x3D; d(y,x) – x 到 y 的距离等同于 y 到 x 的距离</p>
<p>d(x,y) + d(y,z) &gt;&#x3D; d(x,z) – 三角不等式</p>
<p>1、根据三角不等式，则满足与query距离在n范围内的另一个字符转B，其与A的距离最大为d+n，最小为d-n。</p>
<p>2、BK树的构造就过程如下：</p>
<p>每个节点有任意个子节点，每条边有个值表示编辑距离。所有子节点到父节点的边上标注n表示编辑距离恰好为n。<br>比如，我们有棵树父节点是”book”和两个子节点”cake”和”books”，”book”到”books”的边标号1，”book”到”cake”的边上标号4。</p>
<p>从字典里构造好树后，无论何时你想插入新单词时，计算该单词与根节点的编辑距离，并且查找数值为d(neweord, root)的边。递归得与各子节点进行比较，直到没有子节点，你就可以创建新的子节点并将新单词保存在那。</p>
<p>比如，插入”boo”到刚才上述例子的树中，我们先检查根节点，查找 d(“book”, “boo”) &#x3D;1的边，然后检查标号为1的边的子节点，得到单词”books”。我们再计算距离 d(“books”, “boo”)&#x3D;2，则将新单词插在”books”之后，边标号为2。</p>
<p>3、查询相似词如下：计算单词与根节点的编辑距离d，然后递归查找每个子节点标号为d-n到d+n（包含）的边。假如被检查的节点与搜索单词的距离d小于n，则返回该节点并继续查询。</p>
<p>比如输入cape且最大容忍距离为1，则先计算和根的编辑距离 d(“book”, “cape”)&#x3D;4，然后接着找和根节点之间编辑距离为3到5 的，这个就找到了cake这个节点，计算d(“cake”,“cape”)&#x3D;1，满足条件所以返回cake，然后再找和cake节点编辑距离是0到2 的，分别找到cape和cart节点，这样就得到cape这个满足条件的结果。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20210511160030892.png" alt="img"></p>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/database-timestamp-02?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk">https://www.infoq.cn/article/database-timestamp-02?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sha0830/p/8000242.html">https://www.cnblogs.com/sha0830/p/8000242.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/andy_wcl/article/details/81631609">https://blog.csdn.net/andy_wcl/article/details/81631609</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/329497">https://cloud.tencent.com/developer/news/329497</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39144436/article/details/124509108">https://blog.csdn.net/qq_39144436/article/details/124509108</a></p>

<div class="article-footer slide-up fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap slide-up" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/10/26/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.26%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.10.26学习日记</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/10/25/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.25%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.10.25学习日记</a></div></section></div>







<footer class="page-footer slide-up footnote"><hr><div class="text"><p>本站由 <a href="/">JakicDong</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0">Stellar 1.30.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper slide-up toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB"><span class="toc-text">常见问题汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ElasticSearch%E5%9F%BA%E7%A1%80%EF%BC%9A"><span class="toc-text">ElasticSearch基础：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Elasticsearch-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">一、Elasticsearch 的基本概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ES%E7%9A%84%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">二、ES的写入流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81ES%E7%9A%84%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">三、ES的更新和删除流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ES%E7%9A%84%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">四、ES的搜索流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81ES%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-text">五、ES在高并发下如何保证读写一致性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81ES%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E9%80%89%E4%B8%BEMaster%E8%8A%82%E7%82%B9%EF%BC%9A"><span class="toc-text">六、ES集群如何选举Master节点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E9%98%B6%E6%AE%B5%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">七、建立索引阶段性能提升方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFElasticSearch%EF%BC%9F"><span class="toc-text">聊聊：什么是ElasticSearch？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E5%88%97%E5%87%BA-10-%E5%AE%B6%E4%BD%BF%E7%94%A8-Elasticsearch-%E4%BD%9C%E4%B8%BA%E5%85%B6%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%85%AC%E5%8F%B8%EF%BC%9F"><span class="toc-text">聊聊：列出 10 家使用 Elasticsearch 作为其应用程序的搜索引擎和数据库的公司？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticSearch%E4%B8%AD%E7%9A%84%E5%88%86%E7%89%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">聊聊：ElasticSearch中的分片是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticSearch%E7%89%B9%E7%82%B9"><span class="toc-text">聊聊：ElasticSearch特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E8%B0%88%E8%B0%88%E5%88%86%E8%AF%8D%E4%B8%8E%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">聊聊：谈谈分词与倒排索引的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9Aelasticsearch-%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">聊聊：elasticsearch 的倒排索引是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9Aelasticsearch-%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E5%A4%9A%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98%EF%BC%8C%E9%83%A8%E7%BD%B2"><span class="toc-text">聊聊：elasticsearch 索引数据多了怎么办，如何调优，部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%91%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A2%EF%BC%9F"><span class="toc-text">聊聊：什么是近实时搜索？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Elasticsearch-%E7%9A%84%E8%BF%91%E5%AE%9E%E6%97%B6%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%8C%E5%B9%B6%E6%94%B9%E5%96%84%E5%AE%83%E7%9A%84%E4%B8%8D%E8%B6%B3%EF%BC%9F"><span class="toc-text">聊聊：如何理解 Elasticsearch 的近实时的性质，并改善它的不足？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch-%E4%B8%AD%E7%B4%A2%E5%BC%95%E5%9C%A8%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch 中索引在设计阶段如何调优？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-Elasticsearch-Node%EF%BC%9F"><span class="toc-text">聊聊：解释一下 Elasticsearch Node？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch-%E4%B8%AD%E5%88%86%E6%9E%90%E5%99%A8%E7%94%B1%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch 中分析器由哪几部分组成？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch%E4%B8%AD%E7%9A%84-Ingest-%E8%8A%82%E7%82%B9%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch中的 Ingest 节点如何工作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch-%E4%B8%AD%E7%9A%84%E5%88%86%E6%9E%90%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch 中的分析器是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch 支持哪些配置管理工具？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticSearch-%E7%9A%84%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">聊聊：ElasticSearch 的节点类型有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%8C%E8%81%8A%E8%81%8A%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8ES%E7%9A%84%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%EF%BC%8C%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%88%86%E7%89%87%E6%9C%89%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5-%E3%80%82"><span class="toc-text">聊聊：Elasticsearch了解多少，聊聊你们公司ES的集群架构，索引数据大小，分片有多少，以及一些调优手段 。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%B1%82%E9%9D%A2%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5%EF%BC%9A"><span class="toc-text">索引层面调优手段：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E8%B0%83%E4%BC%98"><span class="toc-text">1、设计阶段调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%86%99%E5%85%A5%E8%B0%83%E4%BC%98"><span class="toc-text">2、写入调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9F%A5%E8%AF%A2%E8%B0%83%E4%BC%98"><span class="toc-text">3、查询调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%85%B6%E4%BB%96%E8%B0%83%E4%BC%98"><span class="toc-text">4、其他调优</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%92%8CES%E9%9B%86%E7%BE%A4%E8%BF%9E%E6%8E%A5%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%89%B9%E5%AE%9A%E7%9A%84%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82%E7%9A%84%EF%BC%9F"><span class="toc-text">聊聊：客户端在和ES集群连接时，如何选择特定的节点执行请求的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A-Elasticsearch-%E4%B8%AD%EF%BC%8C%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E8%AF%8D%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%EF%BC%9F"><span class="toc-text">聊聊： Elasticsearch 中，是怎么根据一个词找到对应的倒排索引的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E4%B8%8EMysql%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch的倒排索引与Mysql正排索引的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B"><span class="toc-text">倒排索引的生成过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">倒排索引的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lucene-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">Lucene 倒排索引实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Posting-List-%E5%AE%9E%E7%8E%B0"><span class="toc-text">Posting List 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Term-Dictionary-%E5%AE%9E%E7%8E%B0"><span class="toc-text">Term Dictionary 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E5%A4%9A%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98%EF%BC%8C%E9%83%A8%E7%BD%B2%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch索引数据多了怎么办，如何调优，部署？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0master%E9%80%89%E4%B8%BE%E7%9A%84%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch是如何实现master选举的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch-%E7%9A%84-master-%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch 的 master 选举流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BElasticsearch%E7%B4%A2%E5%BC%95%E6%96%87%E6%A1%A3%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-text">聊聊：详细描述一下Elasticsearch索引文档的过程。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BElasticsearch%E7%B4%A2%E5%BC%95%E6%96%87%E6%A1%A3%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82-1"><span class="toc-text">聊聊：详细描述一下Elasticsearch索引文档的过程。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BElasticsearch%E6%90%9C%E7%B4%A2%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">聊聊：详细描述一下Elasticsearch搜索的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BElasticsearch%E6%90%9C%E7%B4%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-text">聊聊：详细描述一下Elasticsearch搜索的过程。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BElasticsearch%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%87%E6%A1%A3%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-text">聊聊：详细描述一下Elasticsearch更新和删除文档的过程。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-2"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch%E5%9C%A8%E9%83%A8%E7%BD%B2%E6%97%B6%EF%BC%8C%E5%AF%B9Linux%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch在部署时，对Linux的设置有哪些优化方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9Alucence%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">聊聊：lucence内部结构是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Master%E9%80%89%E4%B8%BE%E7%9A%84%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch是如何实现Master选举的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E6%AF%94%E5%A6%82%E5%85%B120%E4%B8%AA%EF%BC%89%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%8410%E4%B8%AA%E9%80%89%E4%BA%86%E4%B8%80%E4%B8%AAmaster%EF%BC%8C%E5%8F%A6%E5%A4%9610%E4%B8%AA%E9%80%89%E4%BA%86%E5%8F%A6%E4%B8%80%E4%B8%AAmaster%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%92%8C%E9%9B%86%E7%BE%A4%E8%BF%9E%E6%8E%A5%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%89%B9%E5%AE%9A%E7%9A%84%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82%E7%9A%84%EF%BC%9F"><span class="toc-text">聊聊：客户端在和集群连接时，如何选择特定的节点执行请求的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch%E5%9C%A8%E9%83%A8%E7%BD%B2%E6%97%B6%EF%BC%8C%E5%AF%B9Linux%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9F-1"><span class="toc-text">聊聊：Elasticsearch在部署时，对Linux的设置有哪些优化方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E5%AF%B9%E4%BA%8EGC%E6%96%B9%E9%9D%A2%EF%BC%8C%E5%9C%A8%E4%BD%BF%E7%94%A8Elasticsearch%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">聊聊：对于GC方面，在使用Elasticsearch时要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch%E5%AF%B9%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%EF%BC%88%E4%B8%8A%E4%BA%BF%E9%87%8F%E7%BA%A7%EF%BC%89%E7%9A%84%E8%81%9A%E5%90%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch对于大数据量（上亿量级）的聚合如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E5%9C%A8%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8CElasticsearch%E5%A6%82%E6%9E%9C%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%EF%BC%9F"><span class="toc-text">聊聊：在并发情况下，Elasticsearch如果保证读写一致？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8CElasticsearch-%E5%A6%82%E6%9E%9C%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%EF%BC%9F"><span class="toc-text">聊聊：并发情况下，Elasticsearch 如果保证读写一致？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch-%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E6%AF%94%E5%A6%82%E5%85%B1-20-%E4%B8%AA%EF%BC%89%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84-10-%E4%B8%AA%E9%80%89%E4%BA%86%E4%B8%80%E4%B8%AAmaster%EF%BC%8C%E5%8F%A6%E5%A4%96-10-%E4%B8%AA%E9%80%89%E4%BA%86%E5%8F%A6%E4%B8%80%E4%B8%AA-master%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了一个master，另外 10 个选了另一个 master，怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9AElasticsearch-%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">聊聊：Elasticsearch 集群脑裂问题？有哪些解决方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7Elasticsearch%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">聊聊：如何监控Elasticsearch集群状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E4%BB%8B%E7%BB%8D%E4%B8%8B%E4%BD%A0%E4%BB%AC%E7%94%B5%E5%95%86%E6%90%9C%E7%B4%A2%E7%9A%84%E6%95%B4%E4%BD%93%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%82"><span class="toc-text">聊聊：介绍下你们电商搜索的整体技术架构。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%A4%A7%E8%87%B4%E6%80%9D%E6%83%B3%E5%92%8C%E6%80%A7%E8%B4%A8%EF%BC%9F"><span class="toc-text">聊聊：字典树的大致思想和性质？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E6%98%AF%E5%90%A6%E4%BA%86%E8%A7%A3%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%9F"><span class="toc-text">聊聊：是否了解字典树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A-FST%E5%8E%9F%E7%90%86"><span class="toc-text">聊聊： FST原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%EF%BC%9A%E6%8B%BC%E5%86%99%E7%BA%A0%E9%94%99%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">聊聊：拼写纠错是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%EF%BC%9A"><span class="toc-text">参考文献：</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function (response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function (data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function (error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.30.0" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script defer src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const slideUp = {
      distance: `16px`,
      duration: `800`,
      interval: `100`,
      scale: `1`,
      opacity: 0,
      easing: "ease-out"
    };
    ScrollReveal().reveal('.l_left .slide-up', slideUp);
    ScrollReveal().reveal('.l_main .slide-up', slideUp);
    ScrollReveal().reveal('.l_right .slide-up', slideUp);
  });
</script>

  <script type="text/javascript">
    // 从服务器端配置中解析配置对象
    var cozeConfig = {"enable":true,"api_host":"http://localhost:8888","sdk_url":"http://localhost:8888/static/chat-sdk.js","config":{"type":"app","appInfo":{"appId":"7594744377281347584","workflowId":"7597782620230909952"}},"auth":{"type":"token","token":"pat_824d6b760a23f2f27174d1656d9f5bee888d270024a6494f9f164516fa641f75"},"componentProps":{"title":"AI 助手","lang":"zh-CN","layout":"PC"}};
    
    // 等待 SDK 完全初始化的函数（使用轮询机制）
    function waitForSDK(maxAttempts, interval) {
      maxAttempts = maxAttempts || 50;
      interval = interval || 100;
      
      return new Promise(function(resolve, reject) {
        var attempts = 0;

        var checkSDK = function() {
          attempts++;

          // 检查 SDK 是否加载完成
          // 尝试多种可能的访问方式
          var WebChatClient = null;
          
          if (window.CozeWebSDK) {
            // 方式1: 直接访问 (普通全局对象)
            if (window.CozeWebSDK.WebChatClient) {
              WebChatClient = window.CozeWebSDK.WebChatClient;
            }
            // 方式2: ES Module 的 default 导出
            else if (window.CozeWebSDK.default && window.CozeWebSDK.default.WebChatClient) {
              WebChatClient = window.CozeWebSDK.default.WebChatClient;
            }
            // 方式3: ES Module 的直接导出
            else if (window.CozeWebSDK.default) {
              // 如果 default 就是 WebChatClient
              WebChatClient = window.CozeWebSDK.default;
            }
            // 方式4: 检查是否有其他导出方式
            else if (typeof window.CozeWebSDK === 'object') {
              // 尝试访问所有可能的属性
              var sdk = window.CozeWebSDK;
              if (sdk.WebChatClient) {
                WebChatClient = sdk.WebChatClient;
              } else if (sdk.default && sdk.default.WebChatClient) {
                WebChatClient = sdk.default.WebChatClient;
              } else if (sdk.default && typeof sdk.default === 'function') {
                WebChatClient = sdk.default;
              }
            }
          }
          
          if (WebChatClient) {
            console.log('[Coze SDK] SDK 初始化成功，找到 WebChatClient');
            resolve(WebChatClient);
            return;
          }

          // 检查是否超时
          if (attempts >= maxAttempts) {
            console.error('[Coze SDK] SDK 加载超时');
            console.error('[Coze SDK] window.CozeWebSDK:', window.CozeWebSDK);
            console.error('[Coze SDK] window.CozeWebSDK 类型:', typeof window.CozeWebSDK);
            console.error('[Coze SDK] 可用的 CozeWebSDK 属性:', Object.keys(window.CozeWebSDK || {}));
            
            // 尝试输出更多调试信息
            if (window.CozeWebSDK) {
              console.error('[Coze SDK] window.CozeWebSDK.default:', window.CozeWebSDK.default);
              console.error('[Coze SDK] window.CozeWebSDK 的所有属性（包括不可枚举）:');
              for (var key in window.CozeWebSDK) {
                console.error('  -', key, ':', typeof window.CozeWebSDK[key]);
              }
            }
            
            reject(new Error('SDK 加载超时'));
            return;
          }

          // 继续等待
          setTimeout(checkSDK, interval);
        };

        // 开始检查
        checkSDK();
      });
    }
    
    // 等待 DOM 加载完成后再初始化 SDK
    function initCozeSDK() {
      console.log('[Coze SDK] 开始加载 Coze SDK...');
      
      // 检查 DOM 是否已加载
      if (!document.head) {
        console.error('[Coze SDK] document.head 不存在，等待 DOM 加载...');
        return;
      }
      
      // 设置 Coze API 地址（如果需要修改默认地址）
      if (cozeConfig.api_host) {
        window.__COZE_API_HOST__ = cozeConfig.api_host;
        console.log('[Coze SDK] API 地址设置为:', cozeConfig.api_host);
      }
      
      // 动态加载 Coze SDK
      var webSdkScript = document.createElement('script');
      var sdkUrl = cozeConfig.sdk_url || 'http://localhost:8888/static/chat-sdk.js';
      webSdkScript.src = sdkUrl;
      webSdkScript.async = true; // 异步加载
      console.log('[Coze SDK] 正在加载 SDK 脚本:', sdkUrl);
      
      // SDK 加载成功后的回调
      webSdkScript.onload = function () {
        console.log('[Coze SDK] SDK 脚本加载完成');

        // 等待 SDK 完全初始化（使用轮询机制）
        waitForSDK()
          .then(function(WebChatClient) {
            try {
              // 构建配置对象
              var authToken = (cozeConfig.auth && cozeConfig.auth.token) || "pat_824d6b760a23f2f27174d1656d9f5bee888d270024a6494f9f164516fa641f75";
              
              // 构建 auth 配置，确保 onRefreshToken 函数存在
              var authConfig = cozeConfig.auth || {
                type: "token",
                token: authToken
              };
              
              // 确保 onRefreshToken 函数能正确返回 token
              if (!authConfig.onRefreshToken) {
                authConfig.onRefreshToken = function () {
                  return authToken;
                };
              }
              
              // 构建 appInfo 配置，workflowId 是可选的
              var appInfo = {
                appId: (cozeConfig.config && cozeConfig.config.appInfo && cozeConfig.config.appInfo.appId) || "7594744377281347584"
              };
              
              // 只有当 workflowId 存在时才添加
              if (cozeConfig.config && cozeConfig.config.appInfo && cozeConfig.config.appInfo.workflowId) {
                appInfo.workflowId = cozeConfig.config.appInfo.workflowId;
              }
              
              var sdkConfig = {
                config: {
                  type: (cozeConfig.config && cozeConfig.config.type) || "app",
                  appInfo: appInfo
                },
                auth: authConfig
              };
              
              // 添加 UI 配置（如果存在）
              if (cozeConfig.componentProps) {
                sdkConfig.componentProps = cozeConfig.componentProps;
              }
              
              console.log('[Coze SDK] 开始创建 WebChatClient，配置:', JSON.stringify(sdkConfig, null, 2));
              
              // 创建 WebChatClient 实例
              var chatClient = new WebChatClient(sdkConfig);
              
              // 保存 client 实例到全局，方便后续控制
              window.cozeChatClient = chatClient;
              console.log('[Coze SDK] WebChatClient 创建成功，client 实例已保存到 window.cozeChatClient');
              
              // 尝试自动显示聊天窗口（如果 SDK 支持）
              if (typeof chatClient.showChatBot === 'function') {
                console.log('[Coze SDK] 尝试自动显示聊天窗口');
                try {
                  chatClient.showChatBot();
                  console.log('[Coze SDK] 聊天窗口显示命令已执行');
                } catch (e) {
                  console.warn('[Coze SDK] 自动显示聊天窗口失败，可能需要手动调用:', e);
                }
              } else {
                console.log('[Coze SDK] showChatBot 方法不存在，聊天窗口可能需要手动触发');
              }
            } catch (error) {
              console.error('[Coze SDK] 创建 WebChatClient 失败:', error);
              console.error('[Coze SDK] 错误堆栈:', error.stack);
            }
          })
          .catch(function(error) {
            console.error('[Coze SDK] SDK 初始化失败:', error);
            console.error('[Coze SDK] 请检查：');
            console.error('1. SDK 文件是否正确加载');
            console.error('2. 浏览器控制台是否有其他错误');
            console.error('3. 网络请求是否成功');
          });
      };
      
      // SDK 加载失败的回调
      webSdkScript.onerror = function() {
        console.error('[Coze SDK] SDK 脚本加载失败');
        console.error('[Coze SDK] 请检查以下事项:');
        console.error('  1. Coze 服务是否运行在 ' + (cozeConfig.api_host || 'http://localhost:8888'));
        console.error('  2. SDK 文件路径是否正确: ' + sdkUrl);
        console.error('  3. 是否存在跨域问题（CORS）');
        console.error('  4. 浏览器控制台是否有其他错误信息');
      };
      
      // 将脚本添加到 head
      try {
        document.head.appendChild(webSdkScript);
        console.log('[Coze SDK] SDK 脚本标签已添加到页面');
      } catch (e) {
        console.error('[Coze SDK] 添加脚本标签失败:', e);
      }
    }
    
    // 如果 DOM 已经加载完成，立即执行；否则等待 DOMContentLoaded 事件
    if (document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', initCozeSDK);
    } else {
      // DOM 已经加载完成，立即执行
      initCozeSDK();
    }
  </script>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>
<script>
(function() {
  if (typeof window === 'undefined') return;
  var dedupMode = 'day';
  var skip = false;
  var storageKey;
  if (dedupMode === 'session') {
    storageKey = 'visit_notify_sent';
    skip = sessionStorage.getItem(storageKey);
  } else if (dedupMode === 'day') {
    var now = new Date();
    var dateStr = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0');
    storageKey = 'visit_notify_' + dateStr;
    try { skip = localStorage.getItem(storageKey); } catch (e) {}
  }
  if (skip) return;
  var page = location.href;
  var time = new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' });
  var referrer = document.referrer || '(直接访问)';
  function done() {
    if (dedupMode === 'session') try { sessionStorage.setItem(storageKey, '1'); } catch (e) {}
    if (dedupMode === 'day') try { localStorage.setItem(storageKey, '1'); } catch (e) {}
  }
  function sendNotify(ip, location) {
    var ipStr = ip || '(获取失败)';
    var locStr = location || '(获取失败)';
    
    fetch('https://formsubmit.co/fdcb2ed2c38b8b8b5f4f6cf674c147b1', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        _subject: '【博客访问】有人打开了你的网站',
        page: page,
        time: time,
        referrer: referrer,
        '访客IP': ipStr,
        '访客位置': locStr,
        _template: 'box',
        _captcha: 'false'
      }).toString(),
      mode: 'no-cors'
    }).then(done).catch(function() {});
    
  }
  function tryGeo() {
    var last = { ip: null, loc: null };
    var urls = [
      { url: 'https://ipapi.co/json/', parse: function(d) { return { ip: d && d.ip, loc: (d && d.country_name) ? [d.city, d.region, d.country_name].filter(Boolean).join(', ') : null }; } },
      { url: 'https://get.geojs.io/v1/ip/geo.json', parse: function(d) { return { ip: d && d.ip, loc: (d && d.country) ? [d.city, d.region, d.country].filter(Boolean).join(', ') : null }; } },
      { url: 'https://ipinfo.io/json', parse: function(d) { return { ip: d && d.ip, loc: (d && d.country) ? [d.city, d.region, d.country].filter(Boolean).join(', ') : null }; } },
      { url: 'https://api.ipify.org?format=json', parse: function(d) { return { ip: d && d.ip, loc: null }; } },
      { url: 'https://httpbin.org/ip', parse: function(d) { return { ip: (d && d.origin) ? (typeof d.origin === 'string' ? d.origin : d.origin[0]) : null, loc: null }; } }
    ];
    function hasCity(loc) { return loc && loc.indexOf(',') >= 0; }
    function tryNext(i) {
      if (i >= urls.length) { sendNotify(last.ip, last.loc); return; }
      fetch(urls[i].url, { mode: 'cors' }).then(function(r) { if (!r.ok) throw new Error(); return r.json(); }).then(function(d) {
        var r = urls[i].parse(d);
        if (r.ip) last.ip = r.ip;
        if (r.loc) last.loc = r.loc;
        if (last.ip && hasCity(last.loc)) { sendNotify(last.ip, last.loc); return; }
        if (i === urls.length - 1) sendNotify(last.ip, last.loc);
        else tryNext(i + 1);
      }).catch(function() { tryNext(i + 1); });
    }
    tryNext(0);
  }
  tryGeo();
})();
</script>



<!-- inject -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script><script src="/js/check-in.js"></script></div></body></html>
