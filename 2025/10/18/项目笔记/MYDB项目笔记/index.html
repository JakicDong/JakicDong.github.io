
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0" theme-name="Stellar" theme-version="1.30.0">
  
  <meta name="generator" content="Hexo 7.0.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>MYDB项目笔记 - Jakic's Blog</title>

  
    <meta name="description" content="MYDB的学习过程及知识点记录">
<meta property="og:type" content="article">
<meta property="og:title" content="MYDB项目笔记">
<meta property="og:url" content="https://jakicdong.github.io/2025/10/18/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/MYDB%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Jakic&#39;s Blog">
<meta property="og:description" content="MYDB的学习过程及知识点记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018151518.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018154211.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018154622.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018155117.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018155327.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018162437.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018163454.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018163545.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018164703.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018164739.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018164808.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020184912.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020185849.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020191613.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020192123.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020192948.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020193013.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020194823.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020200630.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020200806.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020200824.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020200953.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020204934.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020204904.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020211720.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020212404.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020213617.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215311.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215616.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215631.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215950.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020225334.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020225406.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215934.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215919.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251021163347.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251021163414.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251021164132.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251021164705.png">
<meta property="article:published_time" content="2025-10-17T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-21T08:49:44.732Z">
<meta property="article:author" content="JakicDong">
<meta property="article:tag" content="项目">
<meta property="article:tag" content="技术派">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018151518.png">
  
  
  
  <meta name="keywords" content="项目,技术派">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.30.0">


  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/logo.png">
  

  

  
<!-- hexo injector head_end start --><script src="./func.js"></script><!-- hexo injector head_end end --></head>
<link rel="stylesheet" href="/css/check-in.css"><body><div class="sitebg"><div class="siteblur"></div></div>

<div class="l_body content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://avatars.githubusercontent.com/u/130200522?v=4" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Jakic's Blog</div><div class="sub normal cap">学习生活记录</div><div class="sub hover cap" style="opacity:0"> 踏上取经路,比抵达灵山更重要</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客首页" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="打卡墙" href="/check-in" style="color:#1976D2"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="github" target="_blank" rel="noopener" href="https://github.com/JakicDong/" style="color:#1BCDFC"><svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle"> <path fill="#cccccc" d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path> </svg></a><a class="nav-item" title="力扣" target="_blank" rel="noopener" href="https://leetcode.cn/u/dong7/" style="color:#3DC550"><svg width="59" height="22" viewBox="0 0 59 22" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-full w-auto max-w-none"> <path fill-rule="evenodd" clip-rule="evenodd" d="M27.8226 17.4752C28.3202 16.1443 28.7218 14.5458 28.9859 12.6607C29.1277 11.6491 29.2845 10.1658 29.4568 8.20813H35.2561C35.2637 8.20813 35.2713 8.20828 35.2789 8.20857C35.6071 8.22119 35.8628 8.49743 35.8502 8.82558L35.4996 17.9427C35.4873 18.262 35.2249 18.5144 34.9054 18.5144H33.2974C32.8595 18.5144 32.5046 18.8694 32.5046 19.3072C32.5046 19.7451 32.8595 20.1 33.2974 20.1H35.4776C36.3533 20.1 37.0631 19.3901 37.0631 18.5144L37.4595 8.20813C37.4595 7.33244 36.7497 6.62254 35.874 6.62254H29.5913C29.671 5.65054 29.7537 4.58575 29.8394 3.42794C29.8718 2.99129 29.544 2.61109 29.1074 2.57874C28.6707 2.54639 28.2905 2.87414 28.2582 3.3108C28.1689 4.51669 28.0829 5.62069 28.0004 6.62254H25.3695C24.9316 6.62254 24.5767 6.97749 24.5767 7.41534C24.5767 7.85318 24.9316 8.20813 25.3695 8.20813H27.8651C27.7 10.07 27.5501 11.4816 27.4157 12.4407C27.1674 14.2124 26.7941 15.6986 26.3374 16.9199C26.0981 17.5599 25.8527 18.0822 25.6163 18.4944C25.5366 18.6333 25.4649 18.7474 25.4029 18.8378C25.3703 18.8853 25.3512 18.9109 25.3475 18.9155C25.0722 19.256 25.1252 19.7552 25.4657 20.0305C25.8062 20.3057 26.3054 20.2528 26.5806 19.9123C26.6737 19.7971 26.8159 19.5898 26.9917 19.2833C27.271 18.7963 27.5531 18.1959 27.8226 17.4752ZM48.5586 17.3184V7.72969H55.6831C56.3474 7.72969 56.883 8.26047 56.883 8.9117V16.4576C56.883 17.1088 56.3474 17.6396 55.6831 17.6396H53.3916C52.7274 17.6396 52.1918 17.1088 52.1918 16.4576V10.1081C52.1918 9.67022 51.8369 9.31528 51.399 9.31528C50.9612 9.31528 50.6062 9.67022 50.6062 10.1081V16.4576C50.6062 17.9877 51.8548 19.2252 53.3916 19.2252H55.6831C57.2199 19.2252 58.4686 17.9877 58.4686 16.4576V8.9117C58.4686 7.38157 57.2199 6.14411 55.6831 6.14411H48.5586V3.76573C48.5586 3.32788 48.2037 2.97294 47.7658 2.97294C47.328 2.97294 46.9731 3.32788 46.9731 3.76573V6.14411H44.1983C43.7604 6.14411 43.4055 6.49905 43.4055 6.9369C43.4055 7.37475 43.7604 7.72969 44.1983 7.72969H46.9731V12.465L44.3002 13.5341C43.8937 13.6968 43.696 14.1581 43.8586 14.5647C44.0212 14.9712 44.4826 15.1689 44.8891 15.0063L46.9731 14.1727V17.3184C46.9731 18.3666 46.0906 19.2252 44.9911 19.2252C44.5532 19.2252 44.1983 19.5801 44.1983 20.018C44.1983 20.4558 44.5532 20.8108 44.9911 20.8108C46.9567 20.8108 48.5586 19.2522 48.5586 17.3184Z" fill="white"></path> <path d="M13.3797 16.4636C13.874 15.9701 14.674 15.9714 15.1667 16.4665C15.6593 16.9616 15.6581 17.7631 15.1638 18.2566L12.9691 20.4481C10.9443 22.4699 7.64261 22.4992 5.58369 20.5162C5.57179 20.5048 4.655 19.6058 1.63058 16.6402C-0.381491 14.6673 -0.581941 11.5104 1.31147 9.4831L4.84172 5.7031C6.7209 3.69085 10.1849 3.47093 12.3335 5.20847L15.5398 7.80152C16.0828 8.24065 16.1676 9.03757 15.7292 9.58151C15.2909 10.1254 14.4953 10.2104 13.9523 9.77127L10.746 7.17824C9.62238 6.26954 7.65677 6.39434 6.68718 7.43259L3.15688 11.2126C2.23512 12.1996 2.33607 13.7895 3.39833 14.8311C5.61922 17.0088 7.33084 18.6871 7.33282 18.689C8.40324 19.72 10.134 19.7046 11.185 18.6551L13.3797 16.4636Z" fill="#FFA116"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M8.04824 14.2706C7.35039 14.2706 6.78467 13.7039 6.78467 13.0048C6.78467 12.3057 7.35039 11.739 8.04824 11.739H17.3671C18.0649 11.739 18.6306 12.3057 18.6306 13.0048C18.6306 13.7039 18.0649 14.2706 17.3671 14.2706H8.04824Z" fill="#B3B3B3"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M9.79343 0.401024C10.2702 -0.109469 11.0698 -0.136141 11.5794 0.34145C12.089 0.819042 12.1156 1.62004 11.6389 2.13054L3.15692 11.2126C2.23513 12.1995 2.33608 13.7894 3.39827 14.831L7.31536 18.6721C7.81405 19.1611 7.82258 19.9625 7.33442 20.4621C6.84626 20.9616 6.04626 20.9702 5.54757 20.4812L1.63046 16.6401C-0.381492 14.6671 -0.581942 11.5102 1.31155 9.48305L9.79343 0.401024Z" fill="white"></path> </svg></a><a class="nav-item" title="知识星球" target="_blank" rel="noopener" href="https://wx.zsxq.com/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="语雀" target="_blank" rel="noopener" href="https://www.yuque.com/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="sidebar-check-in">
    <div id="sidebar-check-in-calendar"></div>
</div>
<div class="widgets">
<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">专栏：学习博客</span></div><div class="widget-body"><a class="item" href="/2025/10/25/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Elasticsearch学习笔记-开倒排索引通天地,布分词器炼文字丹</span></a><a class="item" href="/2025/10/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%83%AD%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">🔥热点知识点学习笔记-炼金丹熔高频考点,布天网擒技术热点</span></a><a class="item" href="/2025/10/23/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">场景设计学习笔记-闯架构天宫演诸法,降需求心魔定禅心</span></a><a class="item" href="/2025/10/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%AC%AC%E4%BA%8C%E7%89%88)/"><span class="title">Spring学习笔记(第二版)-炼金丹炉铸Bean山 布注解阵控轮回盘</span></a><a class="item active" href="/2025/10/18/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/MYDB%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">MYDB项目笔记</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item" href="/2025/10/17/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RAG%E7%9F%A5%E8%AF%86%E5%BA%93%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">RAG知识库项目笔记</span></a><a class="item" href="/2025/10/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">SQL刷题笔记-执SQL咒扫乾坤表,祭联合影擒数据妖</span></a><a class="item" href="/2025/10/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记-窥内存洞天观玄机,调GC轮回掌生死</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">设计模式学习笔记-布天罡阵降需求妖,演变化术破代码劫</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">微服务学习笔记-化整为零散作星,聚沙成塔架云台</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">操作系统学习笔记-掌轮回内核定纲常,渡进程内存化阴阳</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">分布式学习笔记-架天网布分布式,炼金丹渡一致劫</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">RocketMQ学习笔记-架消息桥通三界路 施持久咒定乾坤轮</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">MyBatis学习笔记-架映射桥通人神境 写SQL咒调数据兵</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Linux学习笔记-踏终端登灵霄殿,执符咒驭众生器</span></a><a class="item" href="/2025/09/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%AE%80%E5%8E%86%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="title">简历对应知识点</span></a><a class="item" href="/2025/09/09/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Elasticsearch(ES)%E4%B8%8B%E8%BD%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><span class="title">Elasticsearch(ES)下载使用指南</span></a><a class="item" href="/2025/08/30/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/git%E7%A7%98%E9%92%A5%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86/"><span class="title">Redis学习笔记</span></a><a class="item" href="/2025/08/08/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java并发编程学习笔记-布天罗网锁线程妖,设八卦阵伏竞态魔</span></a><a class="item" href="/2025/08/06/3DGS/SSH%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"><span class="title">SSH远程调用开发环境</span></a><a class="item" href="/2025/08/05/3DGS/Ubuntu20%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%ACCUDA/"><span class="title">Ubuntu20使用多个版本CUDA</span></a><a class="item" href="/2025/08/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Thymeleaf%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"><span class="title">Thymeleaf模版引擎</span></a><a class="item" href="/2025/08/01/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架学习笔记-开乾坤袋纳百川 布玲珑局定山河</span></a><a class="item" href="/2025/07/30/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Natapp/"><span class="title">Natapp内网穿透使用</span></a><a class="item" href="/2025/07/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"><span class="title">微信扫码登录</span></a><a class="item" href="/2025/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%81%B5%E8%8C%B6%E5%B1%B1%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">灵茶山算法基础笔记</span></a><a class="item" href="/2025/07/25/Go%E5%9F%BA%E7%A1%80/Go%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">Go基础笔记</span></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄</span></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JavaSE学习笔记-筑基篇开修行路,炼气层破语法障</span></a><a class="item" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/"><span class="title">程序员养生指南-调阴阳戒久坐劫 通经脉战代码妖</span></a><a class="item" href="/2025/07/14/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">计算机网络学习笔记-布协议栈通三界,架路由桥渡万维</span></a><a class="item" href="/2025/07/12/3DGS/%E4%BD%BF%E7%94%A8Postshot%E8%AE%AD%E7%BB%833DGS%E6%B5%81%E7%A8%8B/"><span class="title">使用Postshot训练3DGS模型流程</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/%E8%B7%A8%E5%9F%9F%E6%94%AF%E6%8C%81%E7%AC%94%E8%AE%B0/"><span class="title">跨域支持笔记</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/MybatisPlus%E7%AC%94%E8%AE%B0/"><span class="title">MybatisPlus笔记</span></a><a class="item" href="/2025/06/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/TecHub%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">TecHub项目笔记</span></a><a class="item" href="/2025/06/24/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"><span class="title">技术派项目环境问题</span></a><a class="item" href="/2025/06/24/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"><span class="title">Unity游戏开发笔记</span></a><a class="item" href="/2025/06/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82B%E6%A0%91/"><span class="title">一次性搞懂B树</span></a><a class="item" href="/2025/06/12/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Spring学习笔记-开IOC瓶纳百川水 织AOP网覆三界尘</span></a><a class="item" href="/2025/06/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/nvm%E6%9B%B4%E6%94%B9node%E7%89%88%E6%9C%AC/"><span class="title">nvm更改node版本</span></a><a class="item" href="/2025/06/11/3DGS/3DGS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">3DGS学习笔记-撒神经点布星云阵 炼辐射场塑造化身</span></a><a class="item" href="/2025/06/11/3DGS/3DGS-Ubuntu%E7%8E%AF%E5%A2%83/"><span class="title">3DGS-Ubuntu环境.md</span></a><a class="item" href="/2025/06/10/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架笔记</span></a><a class="item" href="/2025/06/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Mysql学习笔记-布B+树阵锁苍龙 写SQL真言召天兵</span></a><a class="item" href="/2025/06/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记</span></a><a class="item" href="/2025/06/07/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%AF%87/"><span class="title">Java并发篇</span></a><a class="item" href="/2025/06/06/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E9%94%AE%E8%AE%B0%E5%BD%95/"><span class="title">常用组合键记录-结印诀腾挪三界,弹指间呼风唤雨</span></a><a class="item" href="/2025/06/06/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/java30%E5%A4%A9%E7%AC%94%E8%AE%B0/"><span class="title">java30天学习笔记</span></a><a class="item" href="/2025/06/05/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/hello-world/"><span class="title">Hello World</span></a><a class="item" href="/2025/06/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">技术派项目笔记</span></a><a class="item" href="/2025/06/02/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"><span class="title">个人博客搭建指南-架祥云自建菩提境,点慧灯独照博客天</span></a><a class="item" href="/2025/06/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">数据结构算法学习笔记-布天罡阵伏算法妖 炼金石破数据结构</span></a><a class="item" href="/2025/06/01/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RabbitMQ%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/"><span class="title">RabbitMQ项目使用</span></a></div></widget>

<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/10/27/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.27%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.27学习日记</span></a><a class="item title" href="/2025/06/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">技术派项目笔记</span></a><a class="item title" href="/2025/06/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Mysql学习笔记-布B+树阵锁苍龙 写SQL真言召天兵</span></a><a class="item title" href="/2025/10/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%83%AD%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">🔥热点知识点学习笔记-炼金丹熔高频考点,布天网擒技术热点</span></a><a class="item title" href="/2025/08/08/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java并发编程学习笔记-布天罗网锁线程妖,设八卦阵伏竞态魔</span></a><a class="item title" href="/2025/10/26/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.26%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.26学习日记</span></a><a class="item title" href="/2025/10/25/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.25%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.25学习日记</span></a><a class="item title" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄</span></a><a class="item title" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">分布式学习笔记-架天网布分布式,炼金丹渡一致劫</span></a><a class="item title" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">RocketMQ学习笔记-架消息桥通三界路 施持久咒定乾坤轮</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/10/25/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习博客</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-10-17T16:00:00.000Z">2025-10-18</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-10-21T08:49:44.732Z">2025-10-21</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>MYDB项目笔记</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content slide-up"><h2 id="MYDB项目结构"><a href="#MYDB项目结构" class="headerlink" title="MYDB项目结构"></a>MYDB项目结构</h2><p><strong>整体结构</strong></p>
<p>MYDB 分为后端和前端，前后端通过 <code>socket</code> 进行交互。<br>前端（客户端）的职责很单一，读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。<br>MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，MYDB 的后端划分为五个模块，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。五个模块如下：</p>
<ol>
<li>Transaction Manager (TM)</li>
<li>Data Manager (DM)</li>
<li>Version Manager (VM)</li>
<li>Index Manager (IM)</li>
<li>Table Manager (TBM)</li>
</ol>
<p>这是五个模块的依赖关系图:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018151518.png" alt="20251018151518"></p>
<p>每个模块的职责如下：</p>
<ol>
<li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li>
<li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li>
<li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li>
<li>IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。</li>
<li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li>
</ol>
<h2 id="TM-Transaction-Manager-事务管理器"><a href="#TM-Transaction-Manager-事务管理器" class="headerlink" title="TM(Transaction Manager) 事务管理器"></a>TM(Transaction Manager) 事务管理器</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>TM模块主要用于<strong>管理事务，包括开始、提交、回滚事务</strong>，以及检查事务的状态。在类中需要定义一些常量来管理事务如<code>LEN_XID_HEADER_LENGTH、XID_FIELD_SIZE、FIELD_TRAN_ACTIVE、FIELD_TRAN_COMMITTED、FIELD_TRAN_ABORTED、SUPER_XID和XID_SUFFIX</code>，分别表示XID文件头长度、每个事务的占用长度、事务的三种状态、超级事务、XID文件后缀。</p>
<p>还需定义一个<code>RandomAccessFile</code> 类型的<code>file</code>和一个<code>FileChannel</code>类型的<code>fc</code>，用于操作<code>XID</code>文件。还有一个<code>xidCounter</code>用于记录事务的数量，以及一个Lock类用于保证线程安全。然后会在构造函数中给file和fc赋值，然后调用<code>checkXIDCounter</code>方法检查<code>XID</code>文件是否合法。  </p>
<p><code>begin</code>方法用于开始一个新的事务，<code>commit</code>方法用于提交事务，<code>abort</code>方法用于回滚事务。这三个方法内部都会调用<code>updateXID</code>方法，将事务ID和事务状态写入到XID文件中。<code>begin</code>还会调用另外一个<code>incrXIDCounter</code>方法，用于将XID +1并更新XID Header。</p>
<p><code>isActive、isCommitted</code>和<code>isAborted</code>方法用于检查事务是否处于活动、已提交或已回滚状态。这三个方法内部都会调用checkXID方法，检查XID文件中的事务状态是否与给定的状态相等；close方法用于关闭文件通道和文件。</p>
<h3 id="XID文件"><a href="#XID文件" class="headerlink" title="XID文件"></a>XID文件</h3><ol>
<li><strong>XID 的定义和规则：</strong><ul>
<li>每个事务都有一个唯一的事务标识符 XID，从 1 开始递增，并且 XID 0 被特殊定义为超级事务（Super Transaction）。</li>
<li>XID 0 用于表示在没有申请事务的情况下进行的操作，其状态永远是 committed。</li>
</ul>
</li>
<li><strong>事务的状态：</strong><ul>
<li>每个事务可以处于三种状态之一：active（正在进行，尚未结束）、committed（已提交）和aborted（已撤销或回滚）。</li>
</ul>
</li>
<li><strong>XID 文件的结构和管理：</strong><ul>
<li>TransactionManager 负责维护一个 XID 格式的文件，用于记录各个事务的状态。</li>
<li>XID 文件中为每个事务分配了一个字节的空间，用来保存其状态。</li>
<li>XID 文件的头部保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。</li>
<li>因此，事务 XID 在文件中的状态存储在 (XID-1)+8 字节的位置处，其中 XID-1 是因为 XID 0（超级事务）的状态不需要记录。</li>
</ul>
</li>
</ol>
<h3 id="TM接口"><a href="#TM接口" class="headerlink" title="TM接口"></a>TM接口</h3><p>在<code>TransactionManager</code>中提供了一些接口供其他模块调用，用来创建事务和查询事务的状态；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>; <span class="comment">//开启事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;  <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;   <span class="comment">//撤销或回滚事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>; <span class="comment">//查询一个事务的状态是否正在运行</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;  <span class="comment">//查询一个事务的状态是否已经提交</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;    <span class="comment">//查询一个事务的状态是否撤销或回滚</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;   <span class="comment">//关闭事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何实现TM的"><a href="#如何实现TM的" class="headerlink" title="如何实现TM的?"></a>如何实现TM的?</h3><h4 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XID文件头长度</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_XID_HEADER_LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 每个事务的占用长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">XID_FIELD_SIZE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务的三种状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ACTIVE</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//正在进行，尚未结束</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_COMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//已提交</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ABORTED</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//已撤销(回滚)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超级事务，永远为commited状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SUPER_XID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XID文件后缀</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">XID_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.xid&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="checkXIDCounter"><a href="#checkXIDCounter" class="headerlink" title="checkXIDCounter"></a>checkXIDCounter</h4><p>在构造函数创建了一个 <code>TransactionManager</code> 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，通过文件头的 8 字节数字<strong>反推文件的理论长度</strong>，与文件的实际长度做对比。如果不同则认为 XID 文件不合法。对于校验没有通过的，会直接通过 panic 方法，强制停机。在一些基础模块中出现错误都会如此处理，无法恢复的错误只能直接停机。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018154211.png" alt="20251018154211"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查XID文件是否合法</span></span><br><span class="line"><span class="comment"> * 读取XID_FILE_HEADER中的xidcounter，根据它计算文件的理论长度，对比实际长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkXIDCounter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化文件长度为0</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">fileLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取文件的长度，RandomAccessFile在构造函数中赋值</span></span><br><span class="line">        fileLen = file.length();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，抛出BadXIDFileException错误</span></span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件长度小于XID头部长度，抛出BadXIDFileException错误</span></span><br><span class="line">    <span class="keyword">if</span> (fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个长度为XID头部长度的ByteBuffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将文件通道的位置设置为0</span></span><br><span class="line">        fc.position(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 从文件通道读取数据到ByteBuffer</span></span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，抛出错误</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将ByteBuffer的内容解析为长整型，作为xidCounter</span></span><br><span class="line">    <span class="built_in">this</span>.xidCounter = Parser.parseLong(buf.array()); </span><br><span class="line">    <span class="comment">// 计算xidCounter+1对应的XID位置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> getXidPosition(<span class="built_in">this</span>.xidCounter + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果计算出的XID位置与文件长度不符，抛出BadXIDFileException错误</span></span><br><span class="line">    <span class="keyword">if</span> (end != fileLen) &#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数组前八位转换成长整数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buf 需要转换的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">parseLong</span><span class="params">(<span class="type">byte</span>[] buf)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(buf, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> buffer.getLong();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferGetLong</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个包含8个字节的字节数组</span></span><br><span class="line">    <span class="comment">//因为long 在Java中占用8个字节，每个字节占用8位，一下数组可以转换成一个long数字</span></span><br><span class="line">    <span class="comment">// 00000000 00000000 00000000 00000000 00000000 00000000 00001010 00000001</span></span><br><span class="line">    <span class="comment">// 1010 00000001 --&gt; 2561</span></span><br><span class="line">    <span class="type">byte</span>[] byteArray = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用ByteBuffer.wrap方法将字节数组包装为一个ByteBuffer对象</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(byteArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用getLong方法从ByteBuffer中读取一个长整型数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> buffer.getLong();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出读取的长整型数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;The long value is: &quot;</span> + longValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getXidPosition"><a href="#getXidPosition" class="headerlink" title="getXidPosition"></a>getXidPosition</h4><p>根据事务xid取得其在xid文件中对应的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据事务xid取得其在xid文件中对应的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getXidPosition</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LEN_XID_HEADER_LENGTH + (xid - <span class="number">1</span>) * XID_FIELD_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="begin"><a href="#begin" class="headerlink" title="begin()"></a>begin()</h4><p><code>**begin()**</code> 方法会开始一个事务，更具体的，首先设置 <code>xidCounter+1</code> 事务的状态为 <code>active</code>，随后 <code>xidCounter</code> 自增，并更新文件头。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始一个事务，并返回XID</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 锁定计数器，防止并发问题</span></span><br><span class="line">    counterLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// xidCounter是当前事务的计数器，每开始一个新的事务，就将其加1</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xidCounter + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 调用updateXID方法，将新的事务ID和事务状态（这里是活动状态）写入到XID文件中</span></span><br><span class="line">        updateXID(xid, FIELD_TRAN_ACTIVE);</span><br><span class="line">        <span class="comment">// 调用incrXIDCounter方法，将事务计数器加1，并更新XID文件的头部信息</span></span><br><span class="line">        incrXIDCounter();</span><br><span class="line">        <span class="comment">// 返回新的事务ID</span></span><br><span class="line">        <span class="keyword">return</span> xid;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        counterLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="updateXid"><a href="#updateXid" class="headerlink" title="updateXid"></a>updateXid</h4><p>更新事务<code>ID</code>状态,<code>commit()</code>和<code>abort()</code>方法就可以直接借助 <code>updateXID()</code> 方法实现。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018154622.png" alt="20251018154622"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新xid事务的状态为status</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取事务xid在xid文件中对应的位置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="comment">// 创建一个长度为XID_FIELD_SIZE的字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE];</span><br><span class="line">    <span class="comment">// 将事务状态设置为status</span></span><br><span class="line">    tmp[<span class="number">0</span>] = status;</span><br><span class="line">    <span class="comment">// 使用字节数组创建一个ByteBuffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(tmp);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将文件通道的位置设置为offset</span></span><br><span class="line">        fc.position(offset);</span><br><span class="line">        <span class="comment">// 将ByteBuffer中的数据写入到文件通道</span></span><br><span class="line">        fc.write(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 强制将文件通道中的所有未写入的数据写入到磁盘</span></span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="incrXIDCounter"><a href="#incrXIDCounter" class="headerlink" title="incrXIDCounter"></a>incrXIDCounter</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018155117.png" alt="20251018155117"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将XID加一，并更新XID Header</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">incrXIDCounter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 事务总数加一</span></span><br><span class="line">    xidCounter++;</span><br><span class="line">    <span class="comment">// 将新的事务总数转换为字节数组，并用ByteBuffer包装</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将文件通道的位置设置为0，即文件的开始位置</span></span><br><span class="line">        fc.position(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将ByteBuffer中的数据写入到文件通道，即更新了XID文件的头部信息</span></span><br><span class="line">        fc.write(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 强制将文件通道中的所有未写入的数据写入到磁盘</span></span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将长整型值写入到字节缓冲区，将其转成为8字节的二进制形式，然后将这个8个字节写入到字节缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] long2Byte(<span class="type">long</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.allocate(Long.SIZE / Byte.SIZE).putLong(value).array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="checkXID"><a href="#checkXID" class="headerlink" title="checkXID"></a>checkXID</h4><p><code>**isActive()、isCommitted() **</code>和 <code>**isAborted()**</code> 都是检查一个 <strong>xid</strong> 的状态</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018155327.png" alt="20251018155327"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个方法，接收一个事务ID（xid）和一个状态（status）作为参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算事务ID在XID文件中的位置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="comment">// 创建一个新的字节缓冲区（ByteBuffer），长度为XID_FIELD_SIZE</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将文件通道的位置设置为offset</span></span><br><span class="line">        fc.position(offset);</span><br><span class="line">        <span class="comment">// 从文件通道读取数据到字节缓冲区</span></span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查字节缓冲区的第一个字节是否等于给定的状态</span></span><br><span class="line">    <span class="comment">// 如果等于，返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> buf.array()[<span class="number">0</span>] == status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Data-Manager-DM-数据管理器"><a href="#Data-Manager-DM-数据管理器" class="headerlink" title="Data Manager (DM) 数据管理器"></a>Data Manager (DM) 数据管理器</h2><h3 id="引用计数缓存框架"><a href="#引用计数缓存框架" class="headerlink" title="引用计数缓存框架"></a>引用计数缓存框架</h3><blockquote>
<p><strong>原文</strong><br> WHY NOT LRU?<br>由于分页管理和数据项（DataItem）管理都涉及缓存，这里设计一个更通用的缓存框架。<br>看到这里，估计你们也开始犯嘀咕了，为啥使用引用计数策略，而不使用 “极为先进的” LRU 策略呢？<br>这里首先从缓存的接口设计说起，如果使用 LRU 缓存，那么只需要设计一个 get(key) 接口即可，释放缓存可以在缓存满了之后自动完成。设想这样一个场景：某个时刻缓存满了，缓存驱逐了一个资源，这时上层模块想要将某个资源强制刷回数据源，这个资源恰好是刚刚被驱逐的资源。那么上层模块就发现，这个数据在缓存里消失了，这时候就陷入了一种尴尬的境地：是否有必要做回源操作？</p>
<ol>
<li>不回源。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li>
<li>回源。如果数据项被驱逐时的数据和现在又是相同的，那就是一次无效回源</li>
<li>放回缓存里，等下次被驱逐时回源。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致缓存抖动问题</li>
</ol>
</blockquote>
<p>当然我们可以记录下资源的最后修改时间，并且让缓存记录下资源被驱逐的时间。但是……</p>
<blockquote>
<p>如无必要，无增实体。 —— 奥卡姆剃刀<br>问题的根源还是，LRU 策略中，资源驱逐不可控，上层模块无法感知。而引用计数策略正好解决了这个问题，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。<br>这就是引用计数法了。增加了一个方法 release(key)，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。<br>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）</p>
</blockquote>
<p>引用计数缓存框架是一种通用的缓存策略，与LRU（最近最少使用）相比，它采用了不同的资源管理方式。在引用计数缓存框架中，<strong>缓存的释放是由上层模块主动调用释放方法来触发的</strong>，而不是被动地由缓存管理器自动驱逐。当某个资源不再被上层模块引用时，通过调用释放方法来释放对该资源的引用。只有当资源的引用计数归零时，缓存才会驱逐该资源。这种方式可以确保缓存中的资源只有在确实不再被使用时才会被释放，<strong>避免了不必要的资源驱逐和回源操作</strong>。</p>
<p><strong>回溯</strong><br>在数据库中，<strong>回源操作</strong>通常指的是从磁盘或者其他持久化存储介质中重新加载数据到内存中。这通常发生在数据库系统需要访问的数据不在内存中时。由于内存访问速度远高于磁盘访问速度，数据库系统会尽量将数据保留在内存中以提高访问速度。当需要访问的数据不在内存中时，数据库系统就需要从磁盘中加载数据，这个过程就称为回源操作。<br>回源操作的性能开销相对较高，因为它涉及到磁盘I&#x2F;O操作，而磁盘I&#x2F;O操作通常比内存访问速度慢得多。因此，数据库系统通常会采取各种策略来尽量减少回源操作的次数，例如通过缓存机制、预读取等方式来提高数据在内存中的命中率，以降低对磁盘的访问需求。</p>
<h4 id="如何实现引用计数缓存"><a href="#如何实现引用计数缓存" class="headerlink" title="如何实现引用计数缓存"></a>如何实现引用计数缓存</h4><h5 id="AbstractCache"><a href="#AbstractCache" class="headerlink" title="AbstractCache&lt;T&gt;"></a><code>AbstractCache&lt;T&gt;</code></h5><p>在<code>**common**</code>包中定义了一个<code>AbstractCache&lt;T&gt;</code>抽象类，以及两个抽象方法，留给实现类去实现具体的操作;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源不在缓存时的获取行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源被驱逐时的写回行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(T obj)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>除了普通的缓存功能之外，还需要维护另外一个计数。除此之外，为了应付多线程的场景，还需要记录哪些资源从数据源获取中。</p>
<ol>
<li><code>private HashMap&lt;Long, T&gt; cache;</code>：这是一个 <strong>HashMap</strong> 对象，用于存储实际缓存的数据。键是资源的唯一标识符（通常是资源的ID或哈希值），值是缓存的资源对象（类型为 <strong>T</strong>）。在这个缓存框架中，<strong>cache</strong> 承担了普通缓存功能，即存储实际的资源数据。</li>
<li><code>private HashMap&lt;Long, Integer&gt; references;</code>：这是另一个 <strong>HashMap</strong> 对象，用于记录每个资源的引用个数。键是资源的唯一标识符，值是一个整数，表示该资源当前的引用计数。引用计数表示有多少个模块或线程正在使用特定的资源。通过跟踪引用计数，可以确定何时可以安全地释放资源。</li>
<li><code>private HashMap&lt;Long, Boolean&gt; getting;</code>：这是第三个 <strong>HashMap</strong> 对象，用于记录哪些资源当前正在从数据源获取中。键是资源的唯一标识符，值是一个布尔值，表示该资源是否正在被获取中。在多线程环境下，当某个线程尝试从数据源获取资源时，需要标记该资源正在被获取，以避免其他线程重复获取相同的资源。这个 <strong>getting</strong> 映射用于处理多线程场景下的并发访问问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="comment">// 实际缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="comment">// 元素的引用个数</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="comment">// 正在获取某资源的线程</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h5><p>从<code>get()</code>中获取资源，以下流程图不规范，理解大概意思即可</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018162437.png" alt="20251018162437"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从缓存中获取资源</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 循环直到获取资源</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">if</span> (getting.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果其他线程正在获取这个资源，那么当前线程将等待一毫秒然后继续循环</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果资源已经在缓存中，直接返回资源，并增加引用计数</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            references.put(key, references.get(key) + <span class="number">1</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果资源不在缓存中，尝试获取资源。如果缓存已满，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (maxResource &gt; <span class="number">0</span> &amp;&amp; count == maxResource) &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">throw</span> Error.CacheFullException;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        getting.put(key, <span class="literal">true</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取资源</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = getForCache(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        count--;</span><br><span class="line">        getting.remove(key);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将获取到的资源添加到缓存中，并设置引用计数为1</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    getting.remove(key);</span><br><span class="line">    cache.put(key, obj);</span><br><span class="line">    references.put(key, <span class="number">1</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="release"><a href="#release" class="headerlink" title="release()"></a><code>release()</code></h5><p>释放一个缓存<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018163454.png" alt="20251018163454"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强行释放一个缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(key) - <span class="number">1</span>; <span class="comment">// 获取资源的引用计数并减一</span></span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="number">0</span>) &#123; <span class="comment">// 如果引用计数为0</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key); <span class="comment">// 从缓存中获取资源</span></span><br><span class="line">            releaseForCache(obj); <span class="comment">// 处理资源的释放</span></span><br><span class="line">            references.remove(key); <span class="comment">// 从引用计数的映射中移除资源</span></span><br><span class="line">            cache.remove(key); <span class="comment">// 从缓存中移除资源</span></span><br><span class="line">            count--; <span class="comment">// 将缓存中的资源计数减一</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果引用计数不为0</span></span><br><span class="line">            references.put(key, ref); <span class="comment">// 更新资源的引用计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="close"><a href="#close" class="headerlink" title="close()"></a><code>close()</code></h5><p>关闭缓存，释放所有缓存信息<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018163545.png" alt="20251018163545"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭缓存，写回所有资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取所有资源key</span></span><br><span class="line">        Set&lt;Long&gt; keys = cache.keySet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> key : keys) &#123;</span><br><span class="line">            <span class="comment">//获取缓存</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            <span class="comment">//释放缓存</span></span><br><span class="line">            releaseForCache(obj);</span><br><span class="line">            <span class="comment">//引用计数移除缓存</span></span><br><span class="line">            references.remove(key);</span><br><span class="line">            <span class="comment">//实际缓存移除缓存</span></span><br><span class="line">            cache.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="共享内存数组"><a href="#共享内存数组" class="headerlink" title="共享内存数组"></a>共享内存数组</h3><h4 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h4><p>这里得提一个 Java 很蛋疼的地方。<br>Java 中，将数组看作一个对象，在内存中，也是以对象的形式存储的。而 c、cpp 和 go 之类的语言，数组是用指针来实现的。这就是为什么有一种说法：<br>只有 Java 有真正的数组<br>但这对这个项目似乎不是一个好消息。譬如 golang，可以执行下面语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 [<span class="number">10</span>]<span class="type">int64</span></span><br><span class="line">array2 := array1[<span class="number">5</span>:]</span><br></pre></td></tr></table></figure>
<p>Copy<br>这种情况下，array2 和 array1 的第五个元素到最后一个元素，是共用同一片内存的，即使这两个数组的长度不同。<br>这在 Java 中是无法实现的（什么是高级语言啊~）。<br>在 Java 中，当你执行类似 subArray 的操作时，只会在底层进行一个复制，无法同一片内存。<br>于是，我写了一个 SubArray 类，来（松散地）规定这个数组的可使用范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] raw;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubArray</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.raw = raw;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>因为这个数组没啥讲的，通过案例进行演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSubArray</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个1~10的数组</span></span><br><span class="line">    <span class="type">byte</span>[] subArray = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; subArray.length; i++) &#123;</span><br><span class="line">        subArray[i] = (<span class="type">byte</span>) (i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建两个SubArray</span></span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">sub1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(subArray,<span class="number">3</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">sub2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(subArray,<span class="number">6</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改共享数组数据</span></span><br><span class="line">    sub1.raw[<span class="number">4</span>] = (<span class="type">byte</span>)<span class="number">44</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印原始数组</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Original Array: &quot;</span>);</span><br><span class="line">    printArray(subArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印共享数组</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubArray1: &quot;</span>);</span><br><span class="line">    printSubArray(sub1);</span><br><span class="line">    System.out.println(<span class="string">&quot;SubArray2: &quot;</span>);</span><br><span class="line">    printSubArray(sub2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">byte</span>[] array)</span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printSubArray</span><span class="params">(SubArray subArray)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> subArray.start; i &lt;= subArray.end; i++) &#123;</span><br><span class="line">        System.out.print(subArray.raw[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------演示结果----------------------------</span><br><span class="line">Original Array: </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">SubArray1: </span><br><span class="line"><span class="number">4</span>	<span class="number">44</span>	<span class="number">6</span>	<span class="number">7</span>	<span class="number">8</span>	</span><br><span class="line">SubArray2: </span><br><span class="line"><span class="number">7</span>	<span class="number">8</span>	<span class="number">9</span>	<span class="number">10</span>	</span><br></pre></td></tr></table></figure>

<h3 id="数据页的缓存和管理"><a href="#数据页的缓存和管理" class="headerlink" title="数据页的缓存和管理"></a>数据页的缓存和管理</h3><p>本节主要内容就是 DM 模块向下对文件系统的抽象部分。DM 将文件系统抽象成页面，每次对文件系统的读写都是以页面为单位的。同样，从文件系统读进来的数据也是以页面为单位进行缓存的。</p>
<p>这里参考大部分数据库的设计，将默认数据页大小定为 8K。如果想要提升向数据库写入大量数据情况下的性能的话，也可以适当增大这个值。</p>
<p>上一节我们已经实现了一个通用的缓存框架，那么这一节我们需要缓存页面，就可以直接借用那个缓存的框架了。但是首先，需要定义出页面的结构。<strong>注意这个页面是存储在内存中的</strong>，与已经持久化到磁盘的抽象页面有区别。</p>
<p>数据库中实现页面缓存的相关设计和实现。</p>
<ol>
<li><strong>页面结构定义</strong>：<ul>
<li>页面（Page）是存储在内存中的数据单元，其结构包括：<ul>
<li>pageNumber：页面的页号，从<strong>1</strong>开始计数。</li>
<li>data：实际包含的字节数据。</li>
<li>dirty：标志着页面是否是脏页面，在缓存驱逐时，脏页面需要被写回磁盘。</li>
<li>lock：用于页面的锁。</li>
<li>PageCache：保存了一个 PageCache 的引用，方便在拿到 Page 的引用时可以快速对页面的缓存进行释放操作。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageImpl</span> <span class="keyword">implements</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> dirty;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> PageCache pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>页面缓存接口定义</strong>：</p>
<ul>
<li>定义了页面缓存的接口，包括新建页面、获取页面、释放页面、关闭缓存、根据最大页号截断缓存、获取当前页面数量以及刷新页面等方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PageCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span>; <span class="comment">// 创建新页面并返回页号</span></span><br><span class="line">    Page <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> pgno)</span> <span class="keyword">throws</span> Exception; <span class="comment">// 根据页号获取页面</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>; <span class="comment">// 关闭缓存并释放资源</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Page page)</span>; <span class="comment">// 释放页面资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">truncateByBgno</span><span class="params">(<span class="type">int</span> maxPgno)</span>; <span class="comment">// 截断超过指定页号的页面</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPageNumber</span><span class="params">()</span>; <span class="comment">// 获取当前最大页号</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(Page pg)</span>; <span class="comment">// 强制将页面写入持久存储</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>页面缓存实现</strong>：</p>
<ul>
<li>页面缓存的具体实现类需要继承抽象缓存框架，并实现具体的 getForCache() 和 releaseForCache() 方法。</li>
<li>getForCache() 方法用于从文件中读取页面数据，并将其包裹成 Page 返回。</li>
<li>releaseForCache() 方法用于在驱逐页面时决定是否将脏页面写回到文件系统。</li>
</ul>
</li>
<li><p><strong>页面写回文件系统</strong>：</p>
<ul>
<li>页面缓存在驱逐页面时，根据页面是否是脏页面决定是否将其写回到文件系统。</li>
<li>写回操作使用文件锁来保证写入的原子性和线程安全性。</li>
</ul>
</li>
<li><p><strong>新建页面</strong>：</p>
<ul>
<li>新建页面时，页面缓存会自增页面数量，并在写入文件系统后返回新建页面的页号。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。</span></span><br><span class="line"><span class="comment">//这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pageNumbers.incrementAndGet();</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, initData, <span class="literal">null</span>);</span><br><span class="line">    flush(pg);  <span class="comment">// 新建的页面需要立刻写回</span></span><br><span class="line">    <span class="keyword">return</span> pgno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>限制条件</strong>：</p>
<ul>
<li>数据库中不允许同一条数据跨页存储，即单条数据的大小不能超过数据库页面的大小。</li>
</ul>
</li>
</ol>
<h4 id="getForCache"><a href="#getForCache" class="headerlink" title="getForCache()"></a><code>getForCache()</code></h4><p>获取数据页的页面缓存，并将其包裹成<code>Page</code><br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018164703.png" alt="20251018164703"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据pageNumber从数据库文件中读取页数据，并包裹成Page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Page <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 将key转换为页码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>) key;</span><br><span class="line">    <span class="comment">// 计算页码对应的偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> PageCacheImpl.pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个大小为PAGE_SIZE的ByteBuffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(PAGE_SIZE);</span><br><span class="line">    <span class="comment">// 锁定文件，确保线程安全</span></span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置文件通道的位置为计算出的偏移量</span></span><br><span class="line">        fc.position(offset);</span><br><span class="line">        <span class="comment">// 从文件通道读取数据到ByteBuffer</span></span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果发生异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都要解锁</span></span><br><span class="line">    fileLock.unlock();</span><br><span class="line">    <span class="comment">// 使用读取到的数据、页码和当前对象创建一个新的PageImpl对象并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, buf.array(), <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PageImpl</span><span class="params">(<span class="type">int</span> pageNumber, <span class="type">byte</span>[] data, PageCache pc)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.pageNumber = pageNumber; <span class="comment">// 设置页面的页号</span></span><br><span class="line">    <span class="built_in">this</span>.data = data; <span class="comment">// 设置页面实际包含的字节数据</span></span><br><span class="line">    <span class="built_in">this</span>.pc = pc; <span class="comment">// 设置页面缓存</span></span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 初始化一个新的可重入锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="releaseForCache"><a href="#releaseForCache" class="headerlink" title="releaseForCache() "></a><code>releaseForCache() </code></h4><p>当一个Page对象（页面）不再需要在缓存中保留时，就会调用这个方法。如果这个页面被标记为”dirty”（即，这个页面的内容已经被修改，但还没有写回到磁盘），那么这个方法就会调用flush方法，将这个页面的内容写回到磁盘。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018164739.png" alt="20251018164739"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pg.isDirty()) &#123;</span><br><span class="line">        flush(pg);</span><br><span class="line">        pg.setDirty(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pg.getPageNumber(); <span class="comment">// 获取Page的页码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> pageOffset(pgno); <span class="comment">// 计算Page在文件中的偏移量</span></span><br><span class="line"></span><br><span class="line">    fileLock.lock(); <span class="comment">// 加锁，确保线程安全</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(pg.getData()); <span class="comment">// 将Page的数据包装成ByteBuffer</span></span><br><span class="line">        fc.position(offset); <span class="comment">// 设置文件通道的位置</span></span><br><span class="line">        fc.write(buf); <span class="comment">// 将数据写入到文件中</span></span><br><span class="line">        fc.force(<span class="literal">false</span>); <span class="comment">// 强制将数据从操作系统的缓存刷新到磁盘</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e); <span class="comment">// 如果发生异常，调用Panic.panic方法处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileLock.unlock(); <span class="comment">// 最后，无论是否发生异常，都要解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="recoverInsert-和recoverUpdate"><a href="#recoverInsert-和recoverUpdate" class="headerlink" title="recoverInsert()和recoverUpdate()"></a><code>recoverInsert()</code>和<code>recoverUpdate()</code></h4><p><code>** recoverInsert() **</code>和 <code>**recoverUpdate()**</code> 用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251018164808.png" alt="20251018164808"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverInsert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>); <span class="comment">// 将pg的dirty标志设置为true，表示pg的数据已经被修改</span></span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length); <span class="comment">// 将raw的数据复制到pg的数据中的offset位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> <span class="variable">rawFSO</span> <span class="operator">=</span> getFSO(pg.getData()); <span class="comment">// 获取pg的当前空闲空间偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (rawFSO &lt; offset + raw.length) &#123; <span class="comment">// 如果当前的空闲空间偏移量小于offset + raw.length</span></span><br><span class="line">        setFSO(pg.getData(), (<span class="type">short</span>) (offset + raw.length)); <span class="comment">// 将pg的空闲空间偏移量设置为offset + raw.length</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将raw插入pg中的offset位置，不更新update</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverUpdate</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>); <span class="comment">// 将pg的dirty标志设置为true，表示pg的数据已经被修改</span></span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length); <span class="comment">// 将raw的数据复制到pg的数据中的offset位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据页的管理"><a href="#数据页的管理" class="headerlink" title="数据页的管理"></a>数据页的管理</h3><h4 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h4><p>数据库文件的第一个，用与做一些特殊用途，比如存储一些元数据，用于启动检查等。在MYDB 中的第一页，只是用来做启动检查。</p>
<ol>
<li>每次数据库启动时，会生成一串随机字节，存储在 <strong>100~107</strong> 字节</li>
<li>在正常数据库关闭时，会将这串字节拷贝到第一页的 <strong>108~115</strong>字节</li>
<li>数据库每次启动时，都会检查第一页两处的字节是否相同；用来判断上次是否正常关闭，是否需要进行数据的恢复流程</li>
</ol>
<h4 id="启动初始化字节"><a href="#启动初始化字节" class="headerlink" title="启动初始化字节"></a>启动初始化字节</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;ValidCheck&quot;为打开状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcOpen(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 随机生成8字节的数据，并拷贝到第一页的 100~107 字节</span></span><br><span class="line">    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="number">0</span>, raw, OF_VC, LEN_VC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关闭时拷贝字节"><a href="#关闭时拷贝字节" class="headerlink" title="关闭时拷贝字节"></a>关闭时拷贝字节</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;ValidCheck&quot;为关闭状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcClose(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置&quot;ValidCheck&quot;为关闭状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 将&quot;ValidCheck&quot;设置为关闭状态</span></span><br><span class="line">    <span class="comment">// 通过复制raw数组中的一部分元素来实现</span></span><br><span class="line">    <span class="comment">// 具体来说，就是将raw数组中从OF_VC开始的LEN_VC个元素复制到raw数组中从OF_VC+LEN_VC开始的位置</span></span><br><span class="line">    <span class="comment">// 即 100~107 拷贝到 108~115</span></span><br><span class="line">    System.arraycopy(raw, OF_VC, raw, OF_VC + LEN_VC, LEN_VC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="校验字节"><a href="#校验字节" class="headerlink" title="校验字节"></a>校验字节</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查&quot;ValidCheck&quot;是否有效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkVc(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查&quot;ValidCheck&quot;是否有效</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 比较 100~107 和 108~115 处字节是否相等</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC + LEN_VC), Arrays.copyOfRange(raw, OF_VC + LEN_VC, OF_VC + <span class="number">2</span> * LEN_VC));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="普通页"><a href="#普通页" class="headerlink" title="普通页"></a>普通页</h4><p>一个普通页面是以 2字节无符号数起始，因为一个页面最大容量为 8k，而二字节的范围是 0到2^16-1，所以2字节作为初始完全足够表达这一页空闲位置的偏移量。<br>对于普通页的管理，基本上都是围绕着 <code>**FSO（Free Space Offset）**</code>进行管理的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置空闲空间偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFSO</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">short</span> ofData)</span> &#123;</span><br><span class="line">    <span class="comment">// 将空闲空间偏移量的值复制到字节数组的指定位置</span></span><br><span class="line">    System.arraycopy(Parser.short2Byte(ofData), <span class="number">0</span>, raw, OF_FREE, OF_DATA); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取pg的空闲空间偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getFSO(pg.getData()); <span class="comment">// 返回pg的数据的空闲空间偏移量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取空闲空间偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="number">0</span>, <span class="number">2</span>)); <span class="comment">// 返回字节数组的前两个字节表示的短整数值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页面的空闲空间大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFreeSpace</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PageCache.PAGE_SIZE - (<span class="type">int</span>) getFSO(pg.getData()); <span class="comment">// 返回页面的空闲空间大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a><code>insert()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中，返回插入位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">insert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>); <span class="comment">// 将pg的dirty标志设置为true，表示pg的数据已经被修改</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> getFSO(pg.getData()); <span class="comment">// 获取pg的空闲空间偏移量</span></span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length); <span class="comment">// 将raw的数据复制到pg的数据中的offset位置</span></span><br><span class="line">    setFSO(pg.getData(), (<span class="type">short</span>) (offset + raw.length)); <span class="comment">// 更新pg的空闲空间偏移量</span></span><br><span class="line">    <span class="keyword">return</span> offset; <span class="comment">// 返回插入位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>MYDB提供了崩溃后的数据恢复功能，DM层在每次对底层数据进行操作时，都会记录一条日志到磁盘上。在数据库崩溃之后，再次重启时，可以根据日志的内容，恢复数据文件，保证其一致性；</p>
<h4 id="日志读写"><a href="#日志读写" class="headerlink" title="日志读写"></a>日志读写</h4><p>日志的二进制文件，按照如下的格式进行排布：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[XChecksum][Log1][Log2][Log3]...[LogN][BadTail]</span><br></pre></td></tr></table></figure>
<p>其中 <code>**XChecksum**</code> 是一个四字节的整数，是对后续所有日志计算的校验和。<code>**Log1 ~ LogN**</code> 是常规的日志数据，<code>**BadTail**</code> 是在数据库崩溃时，没有来得及写完的日志数据，这个 <code>**BadTail**</code> 不一定存在。<br>每条日志的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Size][Checksum][Data]</span><br><span class="line">[0, 0, 0, 3] [3, -112, -4, 93] [97, 97, 97]</span><br><span class="line">[0, 0, 0, 3] [14, 40, -23, -38] [98, 98, 98]</span><br><span class="line">[0, 0, 0, 3] [24, -64, -41, 87] [99, 99, 99]</span><br></pre></td></tr></table></figure>
<p>其中，<code>**Size**</code> 是一个四字节整数，标识了 <code>**Data**</code> 段的字节数。<code>**Checksum**</code> 则是该条日志的校验和。<br><strong>单条文件的校验和</strong><br>对每条日志进行校验和，就可以得到总文件的校验和了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calChecksum</span><span class="params">(<span class="type">int</span> xCheck, <span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> b : log) &#123;</span><br><span class="line">        xCheck = xCheck * SEED + b; <span class="comment">//seed = 13331</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xCheck;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>日志文件的创建及初始化</strong><br>在日志文件创建时<code>create()</code>会初始化 <code>[XChecksum]</code> 的字节大小，默认为0；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class: src/main/java/top/guoziyang/mydb/backend/dm/logger/Logger.java</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(Parser.int2Byte(<span class="number">0</span>)); <span class="comment">// 将0转换成四字节的数字</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fc.position(<span class="number">0</span>);</span><br><span class="line">    fc.write(buf); <span class="comment">//将其写入到文件</span></span><br><span class="line">    fc.force(<span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Panic.panic(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志文件创建完需要打开时，会调用<code>open()</code>方法，并读取日志文件的<code>[XChecksum]</code>以及去除<code>BadTail</code>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        size = file.length(); <span class="comment">//读取文件大小</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">4</span>) &#123; <span class="comment">//若文件大小小于4，证明日志文件创建出现问题</span></span><br><span class="line">        Panic.panic(Error.BadLogFileException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">raw</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>); <span class="comment">//创建一个容量为4的ByteBuffer</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(<span class="number">0</span>);</span><br><span class="line">        fc.read(raw); <span class="comment">//读取四字节大小的内容</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xChecksum</span> <span class="operator">=</span> Parser.parseInt(raw.array()); <span class="comment">//将其转换成int整数</span></span><br><span class="line">    <span class="built_in">this</span>.fileSize = size;</span><br><span class="line">    <span class="built_in">this</span>.xChecksum = xChecksum; <span class="comment">//赋值给当前对象</span></span><br><span class="line"></span><br><span class="line">    checkAndRemoveTail(); <span class="comment">//检查是否需要去除BadTail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="internNext"><a href="#internNext" class="headerlink" title="internNext()"></a><code>internNext()</code></h4><p>画的不规范，大概意思知道即可<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020184912.png" alt="20251020184912"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下一条日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] internNext() &#123;</span><br><span class="line">    <span class="comment">// 检查当前位置是否已经超过了文件的大小，如果超过了，说明没有更多的日志可以读取，返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (position + OF_DATA &gt;= fileSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个大小为 4 的 ByteBuffer，用于读取日志的大小</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">tmp</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将文件通道的位置设置为当前位置</span></span><br><span class="line">        fc.position(position);</span><br><span class="line">        <span class="comment">// 从文件通道中读取 4 个字节的数据到 ByteBuffer 中，即Size日志文件的大小</span></span><br><span class="line">        fc.read(tmp);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果发生 IO 异常，调用 Panic.panic 方法处理异常</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Parser.parseInt 方法将读取到的 4 个字节的数据转换为 int 类型，得到日志的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Parser.parseInt(tmp.array());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前位置加上日志的大小是否超过了文件的大小，如果超过了，说明日志不完整，返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (position + size + OF_DATA &gt; fileSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个大小为 OF_DATA + size 的 ByteBuffer，用于读取完整的日志</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(OF_DATA + size);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将文件通道的位置设置为当前位置</span></span><br><span class="line">        fc.position(position);</span><br><span class="line">        <span class="comment">// 从文件通道中读取 OF_DATA + size 个字节的数据到 ByteBuffer 中</span></span><br><span class="line">        <span class="comment">// 读取整条日志 [Size][Checksum][Data]</span></span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果发生 IO 异常，调用 Panic.panic 方法处理异常</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ByteBuffer 中的数据转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] log = buf.array();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算日志数据的校验和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">checkSum1</span> <span class="operator">=</span> calChecksum(<span class="number">0</span>, Arrays.copyOfRange(log, OF_DATA, log.length));</span><br><span class="line">    <span class="comment">// 从日志中读取校验和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">checkSum2</span> <span class="operator">=</span> Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较计算得到的校验和和日志中的校验和，如果不相等，说明日志已经被破坏，返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (checkSum1 != checkSum2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前位置</span></span><br><span class="line">    position += log.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回读取到的日志</span></span><br><span class="line">    <span class="keyword">return</span> log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="log"><a href="#log" class="headerlink" title="log()"></a><code>log()</code></h4><p>向日志文件写入日志时，也是首先将数据包裹成日志格式，写入文件后，再更新文件的校验和，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020185849.png" alt="20251020185849"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="comment">// 解析成一条完整的log日志</span></span><br><span class="line">    <span class="type">byte</span>[] log = wrapLog(data);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(log);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//写入到指定位置</span></span><br><span class="line">        fc.position(fc.size());</span><br><span class="line">        fc.write(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新总校验值</span></span><br><span class="line">    updateXChecksum(log);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新总校验值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateXChecksum</span><span class="params">(<span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="comment">//计算总校验值</span></span><br><span class="line">    <span class="built_in">this</span>.xChecksum = calChecksum(<span class="built_in">this</span>.xChecksum, log);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(<span class="number">0</span>);</span><br><span class="line">        fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));</span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将数据解析成完整log</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] wrapLog(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">    <span class="comment">// 使用 calChecksum 方法计算数据的校验和，然后将校验和转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] checksum = Parser.int2Byte(calChecksum(<span class="number">0</span>, data));</span><br><span class="line">    <span class="comment">// 将数据的长度转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] size = Parser.int2Byte(data.length);</span><br><span class="line">    <span class="comment">// 使用 Bytes.concat 方法将 size、checksum 和 data 连接成一个新的字节数组，然后返回这个字节数组</span></span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(size, checksum, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h4><p>在MYDB中，有两条规则限制了数据库的操作，以便于恢复日志；</p>
<ol>
<li><strong>正在进行的事务，不会读取其他任何未提交的事务产生的数据</strong></li>
<li><strong>正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据</strong></li>
</ol>
<p>根据上方的两条规则，MYDB日志的恢复也分为两种：</p>
<ol>
<li><strong>通过</strong><code>**redo log**</code><strong>重做所有崩溃时已经完成（</strong><code>**committed 或 aborted**</code><strong>）的事务</strong></li>
<li><strong>通过</strong><code>**undo log**</code><strong>撤销所有崩溃时未完成（</strong><code>**active**</code>**）的事务 **</li>
</ol>
<p><strong>redo：</strong></p>
<ol>
<li>正序扫描事务 T 的所有日志</li>
<li>如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置</li>
<li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx</li>
</ol>
<p><strong>undo：</strong></p>
<ol>
<li>倒序扫描事务 T 的所有日志</li>
<li>如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除</li>
<li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx<blockquote>
<p>注：对于 redo log 和 undo log，可以学习该文章（<a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/log/how_update.html">图解MySQL-日志篇</a>）</p>
</blockquote>
</li>
</ol>
<p><strong>日志格式</strong><br>首先规定两种日志的格式类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recover</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">LOG_TYPE_INSERT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">LOG_TYPE_UPDATE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// updateLog:</span></span><br><span class="line">    <span class="comment">// [LogType] [XID] [UID] [OldRaw] [NewRaw]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// insertLog:</span></span><br><span class="line">    <span class="comment">// [LogType] [XID] [Pgno] [Offset] [Raw]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>重做所有已完成的事务</strong> redo log<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020191613.png" alt="20251020191613"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">redoTranscations</span><span class="params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;</span><br><span class="line">    <span class="comment">// 重置日志文件的读取位置到开始</span></span><br><span class="line">    lg.rewind();</span><br><span class="line">    <span class="comment">// 循环读取日志文件中的所有日志记录</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取下一条日志记录</span></span><br><span class="line">        <span class="type">byte</span>[] log = lg.next();</span><br><span class="line">        <span class="comment">// 如果读取到的日志记录为空，表示已经读取到日志文件的末尾，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (log == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 判断日志记录的类型</span></span><br><span class="line">        <span class="keyword">if</span> (isInsertLog(log)) &#123;</span><br><span class="line">            <span class="comment">// 如果是插入日志，解析日志记录，获取插入日志信息</span></span><br><span class="line">            <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);</span><br><span class="line">            <span class="comment">// 获取事务ID</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> li.xid;</span><br><span class="line">            <span class="comment">// 如果当前事务已经提交，进行重做操作</span></span><br><span class="line">            <span class="keyword">if</span> (!tm.isActive(xid)) &#123;</span><br><span class="line">                doInsertLog(pc, log, REDO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是更新日志，解析日志记录，获取更新日志信息</span></span><br><span class="line">            <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">            <span class="comment">// 获取事务ID</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xi.xid;</span><br><span class="line">            <span class="comment">// 如果当前事务已经提交，进行重做操作</span></span><br><span class="line">            <span class="keyword">if</span> (!tm.isActive(xid)) &#123;</span><br><span class="line">                doUpdateLog(pc, log, REDO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>撤销所有未完成的事务</strong> undolog<br>流程图只是简易表达了意思，详细请查看代码；<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020192123.png" alt="20251020192123"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">undoTranscations</span><span class="params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个用于存储日志的映射，键为事务ID，值为日志列表</span></span><br><span class="line">    Map&lt;Long, List&lt;<span class="type">byte</span>[]&gt;&gt; logCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将日志文件的读取位置重置到开始</span></span><br><span class="line">    lg.rewind();</span><br><span class="line">    <span class="comment">// 循环读取日志文件中的所有日志记录</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取下一条日志记录</span></span><br><span class="line">        <span class="type">byte</span>[] log = lg.next();</span><br><span class="line">        <span class="comment">// 如果读取到的日志记录为空，表示已经读取到日志文件的末尾，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (log == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 判断日志记录的类型</span></span><br><span class="line">        <span class="keyword">if</span> (isInsertLog(log)) &#123;</span><br><span class="line">            <span class="comment">// 如果是插入日志，解析日志记录，获取插入日志信息</span></span><br><span class="line">            <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);</span><br><span class="line">            <span class="comment">// 获取事务ID</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> li.xid;</span><br><span class="line">            <span class="comment">// 如果当前事务仍然活跃，将日志记录添加到对应的日志列表中</span></span><br><span class="line">            <span class="keyword">if</span> (tm.isActive(xid)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!logCache.containsKey(xid)) &#123;</span><br><span class="line">                    logCache.put(xid, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                logCache.get(xid).add(log);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是更新日志，解析日志记录，获取更新日志信息</span></span><br><span class="line">            <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">            <span class="comment">// 获取事务ID</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xi.xid;</span><br><span class="line">            <span class="comment">// 如果当前事务仍然活跃，将日志记录添加到对应的日志列表中</span></span><br><span class="line">            <span class="keyword">if</span> (tm.isActive(xid)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!logCache.containsKey(xid)) &#123;</span><br><span class="line">                    logCache.put(xid, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将事务id对应的log添加到集合中</span></span><br><span class="line">                logCache.get(xid).add(log);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对所有活跃的事务的日志进行倒序撤销</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Long, List&lt;<span class="type">byte</span>[]&gt;&gt; entry : logCache.entrySet()) &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; logs = entry.getValue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> logs.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">byte</span>[] log = logs.get(i);</span><br><span class="line">            <span class="comment">// 判断日志记录的类型</span></span><br><span class="line">            <span class="keyword">if</span> (isInsertLog(log)) &#123;</span><br><span class="line">                <span class="comment">// 如果是插入日志，进行撤销插入操作</span></span><br><span class="line">                doInsertLog(pc, log, UNDO);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是更新日志，进行撤销更新操作</span></span><br><span class="line">                doUpdateLog(pc, log, UNDO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中止当前事务</span></span><br><span class="line">        tm.abort(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="doInsertLog"><a href="#doInsertLog" class="headerlink" title="doInsertLog()"></a><code>doInsertLog()</code></h4><p>以上两种事务的<code>insert</code>操作都是通过此方法完成</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020192948.png" alt="20251020192948"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doInsertLog</span><span class="params">(PageCache pc, <span class="type">byte</span>[] log, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="comment">// 解析日志记录，获取插入日志信息</span></span><br><span class="line">    <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据页码从页面缓存中获取页面，即AbstractCache.get()方法</span></span><br><span class="line">        pg = pc.getPage(li.pgno);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果发生异常，调用Panic.panic方法处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果标志位为UNDO，将数据项设置为无效</span></span><br><span class="line">        <span class="keyword">if</span> (flag == UNDO) &#123;</span><br><span class="line">            DataItem.setDataItemRawInvalid(li.raw);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在指定的页面和偏移量处插入数据</span></span><br><span class="line">        PageX.recoverInsert(pg, li.raw, li.offset);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 无论是否发生异常，都要释放页面,即AbstractCache.release() 方法</span></span><br><span class="line">        pg.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="doUpdateLog"><a href="#doUpdateLog" class="headerlink" title="doUpdateLog()"></a><code>doUpdateLog()</code></h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020193013.png" alt="20251020193013"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doUpdateLog</span><span class="params">(PageCache pc, <span class="type">byte</span>[] log, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pgno; <span class="comment">// 用于存储页面编号</span></span><br><span class="line">    <span class="type">short</span> offset; <span class="comment">// 用于存储偏移量</span></span><br><span class="line">    <span class="type">byte</span>[] raw; <span class="comment">// 用于存储原始数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据标志位判断是进行重做操作还是撤销操作</span></span><br><span class="line">    <span class="keyword">if</span> (flag == REDO) &#123;</span><br><span class="line">        <span class="comment">// 如果是重做操作，解析日志记录，获取更新日志信息，主要获取新数据</span></span><br><span class="line">        <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">        pgno = xi.pgno;</span><br><span class="line">        offset = xi.offset;</span><br><span class="line">        raw = xi.newRaw;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是撤销操作，解析日志记录，获取更新日志信息，主要获取旧数据</span></span><br><span class="line">        <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">        pgno = xi.pgno;</span><br><span class="line">        offset = xi.offset;</span><br><span class="line">        raw = xi.oldRaw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于存储获取到的页面</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试从页面缓存中获取指定页码的页面</span></span><br><span class="line">        pg = pc.getPage(pgno);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果获取页面过程中发生异常，调用Panic.panic方法进行处理</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在指定的页面和偏移量处插入解析出的数据, 数据页缓存讲解了该方法</span></span><br><span class="line">        PageX.recoverUpdate(pg, raw, offset);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 无论是否发生异常，都要释放页面</span></span><br><span class="line">        pg.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="页面索引"><a href="#页面索引" class="headerlink" title="页面索引"></a>页面索引</h3><p><strong>基本介绍</strong><br>这个页面索引的设计用于提高在数据库中进行插入操作时的效率。它缓存了每一页的空闲空间信息，以便在进行插入操作时能够快速找到合适的页面，而无需遍历磁盘或者缓存中的所有页面。<br>具体来说，页面索引将每一页划分为<strong>一定数量</strong>的区间（这里是40个区间），并且在数据库启动时，会遍历所有页面，将每个页面的空闲空间信息分配到这些区间中。当需要进行插入操作时，插入操作首先会将所需的空间大小<strong>向上取整</strong>，然后映射到某一个区间，随后可以直接从该区间中选择任何一页，以满足插入需求。<br><code>**PageIndex**</code> 的实现使用了一个数组，数组的每个元素都是一个列表，用于存储具有相同空闲空间大小的页面信息。<br>从 <code>**PageIndex**</code> 中获取页面的过程非常简单，只需要根据所需的空间大小计算出区间号，然后直接从对应的列表中取出一个页面即可。<br>被选择的页面会从 PageIndex 中移除，这意味着同一个页面不允许并发写入。在上层模块使用完页面后，需要将其重新插入 PageIndex，以便其他插入操作能够继续使用。<br>总的来说，页面索引的设计旨在提高数据库的插入操作效率，通过缓存页面的空闲空间信息，避免了频繁地访问磁盘或者缓存中的页面，从而加速了插入操作的执行。</p>
<blockquote>
<p>注：以上内容来自原文跟GPT</p>
</blockquote>
<h4 id="PageIndex"><a href="#PageIndex" class="headerlink" title="PageIndex"></a>PageIndex</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageIndex</span> &#123;</span><br><span class="line">    <span class="comment">// 将一页划成40个区间，每个区间的大小为204字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PageInfo&gt;[] lists;</span><br><span class="line">    <span class="comment">// 每个区间的大小为204字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERVALS_NO</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> PageCache.PAGE_SIZE / INTERVALS_NO; <span class="comment">//204</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="select-int-spaceSize"><a href="#select-int-spaceSize" class="headerlink" title="select(int spaceSize)"></a><code>select(int spaceSize)</code></h4><p>根据空闲空间的大小计算所处的编号位置，从<code>PageIndex</code>中获取页面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的空间大小选择一个 PageInfo 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spaceSize 需要的空间大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个 PageInfo 对象，其空闲空间大于或等于给定的空间大小。如果没有找到合适的 PageInfo，返回 null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> PageInfo <span class="title function_">select</span><span class="params">(<span class="type">int</span> spaceSize)</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁，确保线程安全</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> spaceSize / THRESHOLD; <span class="comment">// 计算需要的空间大小对应的区间编号</span></span><br><span class="line">        <span class="comment">// 此处+1主要为了向上取整</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1、假需要存储的字节大小为5168，此时计算出来的区间号是25，但是25*204=5100显然是不满足条件的</span></span><br><span class="line"><span class="comment">            2、此时向上取整找到 26，而26*204=5304，是满足插入条件的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (number &lt; INTERVALS_NO) number++; <span class="comment">// 如果计算出的区间编号小于总的区间数，编号加一</span></span><br><span class="line">        <span class="keyword">while</span> (number &lt;= INTERVALS_NO) &#123; <span class="comment">// 从计算出的区间编号开始，向上寻找合适的 PageInfo</span></span><br><span class="line">            <span class="keyword">if</span> (lists[number].size() == <span class="number">0</span>) &#123; <span class="comment">// 如果当前区间没有 PageInfo，继续查找下一个区间</span></span><br><span class="line">                number++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lists[number].remove(<span class="number">0</span>); <span class="comment">// 如果当前区间有 PageInfo，返回第一个 PageInfo，并从列表中移除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果没有找到合适的 PageInfo，返回 null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="add"><a href="#add" class="headerlink" title="add()"></a><code>add()</code></h4><p>因为同一个页面是不允许并发写的，在上层模块使用完这个页面之后，需要重新将其插入到<code>PaegIndex</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的页面编号和空闲空间大小添加一个 PageInfo 对象。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pgno      页面编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> freeSpace 页面的空闲空间大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> pgno, <span class="type">int</span> freeSpace)</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁，确保线程安全</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> freeSpace / THRESHOLD; <span class="comment">// 计算空闲空间大小对应的区间编号</span></span><br><span class="line">        lists[number].add(<span class="keyword">new</span> <span class="title class_">PageInfo</span>(pgno, freeSpace)); <span class="comment">// 在对应的区间列表中添加一个新的 PageInfo 对象</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fillPageIndex"><a href="#fillPageIndex" class="headerlink" title="fillPageIndex()"></a><code>fillPageIndex()</code></h4><p> DataManager 被创建时，需要获取所有页面并填充 PageIndex：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020194823.png" alt="20251020194823"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 填充 PageIndex。</span></span><br><span class="line"><span class="comment"> * 遍历从第二页开始的每一页，将每一页的页面编号和空闲空间大小添加到 PageIndex 中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fillPageIndex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNumber</span> <span class="operator">=</span> pc.getPageNumber(); <span class="comment">// 获取当前的页面数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= pageNumber; i++) &#123; <span class="comment">// 从第二页开始，对每一页进行处理</span></span><br><span class="line">        <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pg = pc.getPage(i); <span class="comment">// 尝试获取页面</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Panic.panic(e); <span class="comment">// 如果出现异常，处理异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg)); <span class="comment">// 将页面编号和页面的空闲空间大小添加到 PageIndex 中</span></span><br><span class="line">        pg.release(); <span class="comment">// 释放页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DataItem"><a href="#DataItem" class="headerlink" title="DataItem"></a>DataItem</h3><p><strong>基本介绍</strong></p>
<p>DataItem 是一个数据抽象层，它提供了一种在上层模块和底层数据存储之间进行交互的接口。其功能和作用主要包括：</p>
<ol>
<li><strong>数据存储和访问</strong>：DataItem 存储了数据的具体内容，以及一些相关的元数据信息，如数据的大小、有效标志等。上层模块可以通过 DataItem 对象获取到其中的数据内容，以进行读取、修改或删除等操作。</li>
<li><strong>数据修改和事务管理</strong>：DataItem 提供了一些方法来支持数据的修改操作，并在修改操作前后执行一系列的流程，如保存原始数据、落日志等。这些流程保证了数据修改的原子性和一致性，同时支持事务管理，确保了数据的安全性。</li>
<li><strong>数据共享和内存管理</strong>：DataItem 的数据内容通过 SubArray 对象返回给上层模块，这使得上层模块可以直接访问数据内容而无需进行拷贝。这种数据共享的方式提高了数据的访问效率，同时减少了内存的开销。</li>
<li><strong>缓存管理</strong>：DataItem 对象由底层的 DataManager 缓存管理，通过调用 release() 方法可以释放缓存中的 DataItem 对象，以便回收内存资源，提高系统的性能和效率。</li>
</ol>
<p>DataItem 提供了一种高层次的数据抽象，隐藏了底层数据存储的细节，为上层模块提供了方便的数据访问和管理接口，同时保证了数据的安全性和一致性。</p>
<p><strong>具体实现</strong></p>
<p>DataItem 中保存的数据，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ValidFlag] [DataSize] [Data]</span><br></pre></td></tr></table></figure>
<p>其中 <code>**ValidFlag**</code> 占用 1 字节，标识了该 <code>**DataItem**</code> 是否有效。删除一个 <code>**DataItem**</code>，只需要简单地将其有效位设置为 0。<code>**DataSize**</code> 占用 2 字节，标识了后面 <code>**Data**</code> 的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataItemImpl</span> <span class="keyword">implements</span> <span class="title class_">DataItem</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SubArray raw; <span class="comment">//原始数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] oldRaw; <span class="comment">//旧的原始数据</span></span><br><span class="line">    <span class="keyword">private</span> DataManagerImpl dm; <span class="comment">//数据管理器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uid; <span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="keyword">private</span> Page pg; <span class="comment">//页面对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="data"><a href="#data" class="headerlink" title="data()"></a><code>data()</code></h4><p>返回数据项中的数据部分，返回的是原始数据的引用，而不是数据的拷贝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SubArray <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 [data] 部分</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(raw.raw, raw.start+OF_DATA, raw.end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="before"><a href="#before" class="headerlink" title="before()"></a><code>before()</code></h4><p>在修改数据项之前调用，用于锁定数据项并保存原始数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    wLock.lock();</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//保存原始数据的副本，以便在需要时进行回滚</span></span><br><span class="line">    System.arraycopy(raw.raw, raw.start, oldRaw, <span class="number">0</span>, oldRaw.length); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unbefore"><a href="#unbefore" class="headerlink" title="unbefore()"></a><code>unbefore()</code></h4><p>在需要撤销修改时调用，用于恢复原始数据并解锁数据项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unBefore</span><span class="params">()</span> &#123;</span><br><span class="line">    System.arraycopy(oldRaw, <span class="number">0</span>, raw.raw, raw.start, oldRaw.length);</span><br><span class="line">    wLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="after"><a href="#after" class="headerlink" title="after()"></a><code>after()</code></h4><p>在修改完成之后调用，用于记录日志并解锁数据项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    dm.logDataItem(xid, <span class="built_in">this</span>);</span><br><span class="line">    wLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个更新日志。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xid 事务ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> di  DataItem对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 更新日志，包含日志类型、事务ID、DataItem的唯一标识符、旧原始数据和新原始数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] updateLog(<span class="type">long</span> xid, DataItem di) &#123;</span><br><span class="line">    <span class="type">byte</span>[] logType = &#123;LOG_TYPE_UPDATE&#125;; <span class="comment">// 创建一个表示日志类型的字节数组，并设置其值为LOG_TYPE_UPDATE</span></span><br><span class="line">    <span class="type">byte</span>[] xidRaw = Parser.long2Byte(xid); <span class="comment">// 将事务ID转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] uidRaw = Parser.long2Byte(di.getUid()); <span class="comment">// 将DataItem对象的唯一标识符转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] oldRaw = di.getOldRaw(); <span class="comment">// 获取DataItem对象的旧原始数据</span></span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> di.getRaw(); <span class="comment">// 获取DataItem对象的新原始数据</span></span><br><span class="line">    <span class="type">byte</span>[] newRaw = Arrays.copyOfRange(raw.raw, raw.start, raw.end); <span class="comment">// 将新原始数据转换为字节数组</span></span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(logType, xidRaw, uidRaw, oldRaw, newRaw); <span class="comment">// 将所有字节数组连接在一起，形成一个完整的更新日志，并返回这个日志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="release-1"><a href="#release-1" class="headerlink" title="release()"></a><code>release()</code></h4><p>在使用完 <code>**DataItem**</code>后，需要调用 <code>release()</code> 释放调 <code>DataItem</code>的缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    dm.releaseDataItem(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DM的实现"><a href="#DM的实现" class="headerlink" title="DM的实现"></a>DM的实现</h3><p><strong>基本介绍</strong></p>
<p>DataManager（DM）是数据库管理系统中的一层，主要负责底层数据的管理和操作。其功能和作用包括：</p>
<ol>
<li><strong>数据缓存和管理</strong>：DataManager 实现了对 DataItem 对象的缓存管理，通过缓存管理，可以提高数据的访问效率，并减少对底层存储的频繁访问，从而提高系统的性能。</li>
<li><strong>数据访问和操作</strong>：DataManager 提供了读取、插入和修改等数据操作方法，上层模块可以通过这些方法对数据库中的数据进行操作和管理。</li>
<li><strong>事务管理</strong>：DataManager 支持事务的管理，通过事务管理，可以保证对数据的修改是原子性的，并且在事务提交或回滚时能够保持数据的一致性和完整性。</li>
<li><strong>日志记录和恢复</strong>：DataManager 在数据修改操作前后会执行一系列的流程，包括日志记录和数据恢复等操作，以确保数据的安全性和可靠性，即使在系统崩溃或异常情况下也能够保证数据的完整性。</li>
<li><strong>页面索引管理</strong>：DataManager 中实现了页面索引管理功能，通过页面索引可以快速定位到合适的空闲空间，从而提高数据插入的效率和性能。</li>
<li><strong>文件初始化和校验</strong>：DataManager 在创建和打开数据库文件时，会进行文件的初始化和校验操作，以确保文件的正确性和完整性，同时在文件关闭时会执行相应的清理操作。</li>
<li><strong>资源管理和释放</strong>：DataManager 在关闭时会执行资源的释放和清理操作，包括缓存和日志的关闭，以及页面的释放和页面索引的清理等。</li>
</ol>
<p>DataManager 在数据库管理系统中扮演着重要的角色，负责底层数据的管理和操作，为上层模块提供了方便的数据访问和操作接口，同时通过事务管理和日志记录等功能保证了数据的安全性和可靠性。</p>
<blockquote>
<p>注：以上内容来自GPT</p>
</blockquote>
<p><strong>具体实现</strong><br><code>DataManager</code> 是 <code>DM</code> 层直接对外提供方法的类，同时，也实现成 <code>DataItem</code> 对象的缓存。<code>DataItem</code> 存储的 <code>**key**</code>，是由页号和页内偏移组成的一个 <strong>8</strong> 字节无符号整数，页号和偏移各占 <strong>4</strong> 字节。</p>
<h4 id="Uid生成以及解析"><a href="#Uid生成以及解析" class="headerlink" title="Uid生成以及解析"></a>Uid生成以及解析</h4><blockquote>
<p>初始化：假设是从第二个页面开始的，并且偏移量为0<br><strong>pgno: 2;</strong><br><strong>offset: 0;</strong></p>
</blockquote>
<ol>
<li>先通过页面编号以及偏移量生成唯一标识 <code>uid</code></li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020200630.png" alt="20251020200630"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Types</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">addressToUid</span><span class="params">(<span class="type">int</span> pgno, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">u0</span> <span class="operator">=</span> (<span class="type">long</span>)pgno;</span><br><span class="line">        <span class="type">long</span> <span class="variable">u1</span> <span class="operator">=</span> (<span class="type">long</span>)offset;</span><br><span class="line">        <span class="keyword">return</span> u0 &lt;&lt; <span class="number">32</span> | u1; <span class="comment">//或运算是全0则0，见1则1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>从 uid 中提取出偏移量（<strong>offset</strong>）</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020200806.png" alt="20251020200806"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 uid 中提取出偏移量（offset），这是通过位操作实现的，偏移量是 uid 的低16位</span></span><br><span class="line"><span class="comment">// &amp; 运算：有0则0，全1才1</span></span><br><span class="line"><span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> (<span class="type">short</span>) (uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>)); </span><br></pre></td></tr></table></figure>

<ol>
<li>将 uid 右移32位，再获取页面编号</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020200824.png" alt="20251020200824"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 uid 右移32位，以便接下来提取出页面编号（pgno）</span></span><br><span class="line">uid &gt;&gt;&gt;= <span class="number">32</span>;</span><br><span class="line"><span class="comment">// 从 uid 中提取出页面编号（pgno），页面编号是 uid 的高32位</span></span><br><span class="line"><span class="comment">// &amp; 运算：有0则0，全1才1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>) (uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h4 id="getForCache-1"><a href="#getForCache-1" class="headerlink" title="getForCache()"></a><code>getForCache()</code></h4><p>也是继承自<code>AbstractCache</code>，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> DataItem <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 从 uid 中提取出偏移量（offset），这是通过位操作实现的，偏移量是 uid 的低16位</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> (<span class="type">short</span>) (uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 将 uid 右移32位，以便接下来提取出页面编号（pgno）</span></span><br><span class="line">    uid &gt;&gt;&gt;= <span class="number">32</span>;</span><br><span class="line">    <span class="comment">// 从 uid 中提取出页面编号（pgno），页面编号是 uid 的高32位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>) (uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 使用页面缓存（pc）的 getPage(int pgno) 方法根据页面编号获取一个 Page 对象</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> pc.getPage(pgno);</span><br><span class="line">    <span class="comment">// 使用 DataItem 接口的静态方法 parseDataItem(Page pg, short offset, DataManagerImpl dm)</span></span><br><span class="line">    <span class="comment">// 根据获取到的 Page 对象、偏移量和当前的 DataManagerImpl 对象（this）解析出一个 DataItem 对象，并返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> DataItem.parseDataItem(pg, offset, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="releaseForCache-1"><a href="#releaseForCache-1" class="headerlink" title="releaseForCache()"></a><code>releaseForCache()</code></h4><p>DataItem 缓存释放，需要将 DataItem 写回数据源，由于对文件的读写是以页为单位进行的，只需要将 DataItem 所在的页 release 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(DataItem di)</span> &#123;</span><br><span class="line">    di.page().release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DataManager初始化"><a href="#DataManager初始化" class="headerlink" title="DataManager初始化"></a>DataManager初始化</h4><p>对于<code>**DataManager**</code>文件的创建有两种流程，一种是从已有文件创建<code>**DataManager**</code><strong>，</strong>另外一种是从空文件创建<code>**DataManager**</code><strong>。</strong>对于两者的不同主要在于第一页的初始化和校验问题：</p>
<ol>
<li>从空文件创建首先需要对第一页进行初始化</li>
<li>而从已有文件创建，则需要对第一页进行校验，来判断是否需要执行恢复流程，并重新对第一页生成随机字节</li>
</ol>
<h5 id="从空文件创建create"><a href="#从空文件创建create" class="headerlink" title="从空文件创建create()"></a>从空文件创建<code>create()</code></h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020200953.png" alt="20251020200953"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法，用于创建DataManager实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataManager <span class="title function_">create</span><span class="params">(String path, <span class="type">long</span> mem, TransactionManager tm)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个PageCache实例，path是文件路径，mem是内存大小</span></span><br><span class="line">    <span class="type">PageCache</span> <span class="variable">pc</span> <span class="operator">=</span> PageCache.create(path, mem);</span><br><span class="line">    <span class="comment">// 创建一个Logger实例，path是文件路径</span></span><br><span class="line">    <span class="type">Logger</span> <span class="variable">lg</span> <span class="operator">=</span> Logger.create(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个DataManagerImpl实例，pc是PageCache实例，lg是Logger实例，tm是TransactionManager实例</span></span><br><span class="line">    <span class="type">DataManagerImpl</span> <span class="variable">dm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataManagerImpl</span>(pc, lg, tm);</span><br><span class="line">    <span class="comment">// 初始化PageOne</span></span><br><span class="line">    dm.initPageOne();</span><br><span class="line">    <span class="comment">// 返回创建的DataManagerImpl实例</span></span><br><span class="line">    <span class="keyword">return</span> dm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="从已有文件创建open"><a href="#从已有文件创建open" class="headerlink" title="从已有文件创建open()"></a>从已有文件创建<code>open()</code></h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020204934.png" alt="20251020204934"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法，用于打开已存在的DataManager实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataManager <span class="title function_">open</span><span class="params">(String path, <span class="type">long</span> mem, TransactionManager tm)</span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个PageCache实例，path是文件路径，mem是内存大小</span></span><br><span class="line">    <span class="type">PageCache</span> <span class="variable">pc</span> <span class="operator">=</span> PageCache.open(path, mem);</span><br><span class="line">    <span class="comment">// 打开一个Logger实例，path是文件路径</span></span><br><span class="line">    <span class="type">Logger</span> <span class="variable">lg</span> <span class="operator">=</span> Logger.open(path);</span><br><span class="line">    <span class="comment">// 创建一个DataManagerImpl实例，pc是PageCache实例，lg是Logger实例，tm是TransactionManager实例</span></span><br><span class="line">    <span class="type">DataManagerImpl</span> <span class="variable">dm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataManagerImpl</span>(pc, lg, tm);</span><br><span class="line">    <span class="comment">// 加载并检查PageOne，如果检查失败，则进行恢复操作</span></span><br><span class="line">    <span class="keyword">if</span> (!dm.loadCheckPageOne()) &#123;</span><br><span class="line">        Recover.recover(tm, lg, pc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充PageIndex，遍历从第二页开始的每一页，将每一页的页面编号和空闲空间大小添加到 PageIndex 中</span></span><br><span class="line">    dm.fillPageIndex();</span><br><span class="line">    <span class="comment">// 设置PageOne为打开状态</span></span><br><span class="line">    PageOne.setVcOpen(dm.pageOne);</span><br><span class="line">    <span class="comment">// 将PageOne立即写入到磁盘中，确保PageOne的数据被持久化</span></span><br><span class="line">    dm.pc.flushPage(dm.pageOne);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回创建的DataManagerImpl实例</span></span><br><span class="line">    <span class="keyword">return</span> dm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DataManager-提供的三个功能"><a href="#DataManager-提供的三个功能" class="headerlink" title="DataManager 提供的三个功能"></a>DataManager 提供的三个功能</h4><p><code>**DM**</code>层主要提供了三个功能供上层使用，分别是读、插入和修改。由于修改是通过读出的 <code>**DataItem**</code> 实现的，也就是说 <code>**DataManager**</code> 只需要 <code>**read()**</code> 和 <code>**insert()**</code> 方法；</p>
<h5 id="read（）"><a href="#read（）" class="headerlink" title="read（）"></a><code>read（）</code></h5><p><code>**read（）**</code>** **是根据 <code>UID</code> 从缓存中获取的 <code>**DataItem**</code>，并校验有效位；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DataItem <span class="title function_">read</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//从缓存页面中读取到DataItemImpl</span></span><br><span class="line">    <span class="type">DataItemImpl</span> <span class="variable">di</span> <span class="operator">=</span> (DataItemImpl) <span class="built_in">super</span>.get(uid);</span><br><span class="line">    <span class="comment">//校验di是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!di.isValid()) &#123;</span><br><span class="line">        <span class="comment">// 无效释放缓存</span></span><br><span class="line">        di.release();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> di;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> DataItem <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 从 uid 中提取出偏移量（offset），这是通过位操作实现的，偏移量是 uid 的低16位</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> (<span class="type">short</span>) (uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 将 uid 右移32位，以便接下来提取出页面编号（pgno）</span></span><br><span class="line">    uid &gt;&gt;&gt;= <span class="number">32</span>;</span><br><span class="line">    <span class="comment">// 从 uid 中提取出页面编号（pgno），页面编号是 uid 的高32位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>) (uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 使用页面缓存（pc）的 getPage(int pgno) 方法根据页面编号获取一个 Page 对象</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> pc.getPage(pgno);</span><br><span class="line">    <span class="comment">// 使用 DataItem 接口的静态方法 parseDataItem(Page pg, short offset, DataManagerImpl dm)</span></span><br><span class="line">    <span class="comment">// 根据获取到的 Page 对象、偏移量和当前的 DataManagerImpl 对象（this）解析出一个 DataItem 对象，并返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> DataItem.parseDataItem(pg, offset, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="insert-1"><a href="#insert-1" class="headerlink" title="insert()"></a><code>insert()</code></h5><p>在 <code>**pageIndex**</code> 中获取一个足以存储插入内容的页面的页号，获取页面后，首先需要写入插入日志，接着才可以通过 <code>**pageX**</code> 插入数据，并返回插入位置的偏移。最后需要将页面信息重新插入 <code>**pageIndex**</code>。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020204904.png" alt="20251020204904"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 将输入的数据包装成DataItem的原始格式</span></span><br><span class="line">    <span class="type">byte</span>[] raw = DataItem.wrapDataItemRaw(data);</span><br><span class="line">    <span class="comment">// 如果数据项的大小超过了页面的最大空闲空间，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (raw.length &gt; PageX.MAX_FREE_SPACE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.DataTooLargeException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个页面信息对象</span></span><br><span class="line">    <span class="type">PageInfo</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 尝试5次找到一个可以容纳新数据项的页面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 从页面索引中选择一个可以容纳新数据项的页面</span></span><br><span class="line">        pi = pIndex.select(raw.length);</span><br><span class="line">        <span class="comment">// 如果找到了合适的页面，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (pi != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到合适的页面，创建一个新的页面，并将其添加到页面索引中</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newPgno</span> <span class="operator">=</span> pc.newPage(PageX.initRaw());</span><br><span class="line">            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还是没有找到合适的页面，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (pi == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.DatabaseBusyException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个页面对象</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 初始化空闲空间大小为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">freeSpace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取页面信息对象中的页面</span></span><br><span class="line">        pg = pc.getPage(pi.pgno);</span><br><span class="line">        <span class="comment">// 生成插入日志</span></span><br><span class="line">        <span class="type">byte</span>[] log = Recover.insertLog(xid, pg, raw);</span><br><span class="line">        <span class="comment">// 将日志写入日志文件</span></span><br><span class="line">        logger.log(log);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在页面中插入新的数据项，并获取其在页面中的偏移量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> PageX.insert(pg, raw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放页面</span></span><br><span class="line">        pg.release();</span><br><span class="line">        <span class="comment">// 返回新插入的数据项的唯一标识符</span></span><br><span class="line">        <span class="keyword">return</span> Types.addressToUid(pi.pgno, offset);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 将页面重新添加到页面索引中</span></span><br><span class="line">        <span class="keyword">if</span> (pg != <span class="literal">null</span>) &#123;</span><br><span class="line">            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pIndex.add(pi.pgno, freeSpace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  返回一个完整的 DataItem 结构数据</span></span><br><span class="line"><span class="comment"> *  dataItem 结构如下：</span></span><br><span class="line"><span class="comment"> *  [ValidFlag] [DataSize] [Data]</span></span><br><span class="line"><span class="comment"> *  ValidFlag 1字节，0为合法，1为非法</span></span><br><span class="line"><span class="comment"> *  DataSize  2字节，标识Data的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] wrapDataItemRaw(<span class="type">byte</span>[] raw) &#123;</span><br><span class="line">    <span class="type">byte</span>[] valid = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span>]; <span class="comment">//证明此时为非法数据</span></span><br><span class="line">    <span class="type">byte</span>[] size = Parser.short2Byte((<span class="type">short</span>)raw.length); <span class="comment">//计算数据字节大小</span></span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(valid, size, raw); <span class="comment">//拼接DataItem 结构数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的空间大小选择一个 PageInfo 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spaceSize 需要的空间大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个 PageInfo 对象，其空闲空间大于或等于给定的空间大小。如果没有找到合适的 PageInfo，返回 null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> PageInfo <span class="title function_">select</span><span class="params">(<span class="type">int</span> spaceSize)</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁，确保线程安全</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> spaceSize / THRESHOLD; <span class="comment">// 计算需要的空间大小对应的区间编号</span></span><br><span class="line">        <span class="comment">// 此处+1主要为了向上取整</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1、假需要存储的字节大小为5168，此时计算出来的区间号是25，但是25*204=5100显然是不满足条件的</span></span><br><span class="line"><span class="comment">            2、此时向上取整找到 26，而26*204=5304，是满足插入条件的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (number &lt; INTERVALS_NO) number++; <span class="comment">// 如果计算出的区间编号小于总的区间数，编号加一</span></span><br><span class="line">        <span class="keyword">while</span> (number &lt;= INTERVALS_NO) &#123; <span class="comment">// 从计算出的区间编号开始，向上寻找合适的 PageInfo</span></span><br><span class="line">            <span class="keyword">if</span> (lists[number].size() == <span class="number">0</span>) &#123; <span class="comment">// 如果当前区间没有 PageInfo，继续查找下一个区间</span></span><br><span class="line">                number++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lists[number].remove(<span class="number">0</span>); <span class="comment">// 如果当前区间有 PageInfo，返回第一个 PageInfo，并从列表中移除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果没有找到合适的 PageInfo，返回 null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个静态方法，用于创建插入日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] insertLog(<span class="type">long</span> xid, Page pg, <span class="type">byte</span>[] raw) &#123;</span><br><span class="line">    <span class="comment">// 创建一个表示日志类型的字节数组，并设置其值为LOG_TYPE_INSERT</span></span><br><span class="line">    <span class="type">byte</span>[] logTypeRaw = &#123;LOG_TYPE_INSERT&#125;;</span><br><span class="line">    <span class="comment">// 将事务ID转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] xidRaw = Parser.long2Byte(xid);</span><br><span class="line">    <span class="comment">// 将页面编号转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] pgnoRaw = Parser.int2Byte(pg.getPageNumber());</span><br><span class="line">    <span class="comment">// 获取页面的第一个空闲空间的偏移量，并将其转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] offsetRaw = Parser.short2Byte(PageX.getFSO(pg));</span><br><span class="line">    <span class="comment">// 将所有字节数组连接在一起，形成一个完整的插入日志，并返回这个日志</span></span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(logTypeRaw, xidRaw, pgnoRaw, offsetRaw, raw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将raw插入pg中，返回插入位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">insert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>); <span class="comment">// 将pg的dirty标志设置为true，表示pg的数据已经被修改</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> getFSO(pg.getData()); <span class="comment">// 获取pg的空闲空间偏移量</span></span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length); <span class="comment">// 将raw的数据复制到pg的数据中的offset位置</span></span><br><span class="line">    setFSO(pg.getData(), (<span class="type">short</span>) (offset + raw.length)); <span class="comment">// 更新pg的空闲空间偏移量</span></span><br><span class="line">    <span class="keyword">return</span> offset; <span class="comment">// 返回插入位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="close-1"><a href="#close-1" class="headerlink" title="close()"></a><code>close()</code></h5><p>DataManager 正常关闭时，需要执行缓存和日志的关闭流程，还需要设置第一页的字节校验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.close();</span><br><span class="line">    logger.close();</span><br><span class="line"></span><br><span class="line">    PageOne.setVcClose(pageOne);</span><br><span class="line">    pageOne.release();</span><br><span class="line">    pc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Version-Manager-VM-版本管理器"><a href="#Version-Manager-VM-版本管理器" class="headerlink" title="Version Manager (VM) 版本管理器"></a>Version Manager (VM) 版本管理器</h2><h3 id="2PL-与-MVCC"><a href="#2PL-与-MVCC" class="headerlink" title="2PL 与 MVCC"></a>2PL 与 MVCC</h3><p><strong>冲突与 2PL</strong><br>首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这两个操作相互冲突：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这两个操作是由不同的事务执行的</span><br><span class="line">这两个操作操作的是同一个数据项</span><br><span class="line">这两个操作至少有一个是更新操作</span><br></pre></td></tr></table></figure>
<p>那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两个不同事务的 U 操作冲突</span><br><span class="line">两个不同事务的 U、R 操作冲突</span><br></pre></td></tr></table></figure>
<p><strong>那么冲突或者不冲突，意义何在？</strong><br>作用在于，交换两个<strong>互不冲突</strong>的操作的顺序，不会对最终的结果造成影响，而交换两个<strong>冲突</strong>操作的顺序，则是会有影响的。</p>
<p>现在我们先抛开冲突不谈，记得在第四章举的例子吗，在并发情况下，两个事务同时操作 x。假设 x 的初值是 0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line">R1(x) // T1 读到 0</span><br><span class="line">R2(x) // T2 读到 0</span><br><span class="line">U1(0+1) // T1 尝试把 x+1</span><br><span class="line">U2(0+1) // T2 尝试把 x+1</span><br><span class="line">T1 commit</span><br><span class="line">T2 commit</span><br></pre></td></tr></table></figure>
<p>最后 x 的结果是 1，这个结果显然与期望的不符。</p>
<p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。MYDB 采用两段锁协议（2PL）来实现。当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。</p>
<p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了事务间的相互阻塞，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</p>
<p><strong>MVCC</strong></p>
<p>在介绍 MVCC 之前，首先明确记录和版本的概念。</p>
<p>DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。</p>
<p>MYDB 通过 MVCC，降低了事务的阻塞概率。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会返回一个较老版本的 X，例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。</p>
<p>还记得我们在<code>恢复策略</code>章节中，为了保证数据的可恢复，VM 层传递到 DM 的操作序列需要满足以下两个规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">规定 1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。</span><br><span class="line">规定 2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</span><br></pre></td></tr></table></figure>
<p>由于 2PL 和 MVCC，我们可以看到，这两个条件都被很轻易地满足了。</p>
<p><strong>前言</strong></p>
<blockquote>
<p>tips:<br>VM是基于两段锁协议实现调度序列的可串行化，并实现了MVCC以消除读写阻塞。同时也实现了两种隔离级别，所以我们还需要明确版本的概念；<br>DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。</p>
</blockquote>
<h3 id="如何实现版本记录？"><a href="#如何实现版本记录？" class="headerlink" title="如何实现版本记录？"></a>如何实现版本记录？</h3><h4 id="Entry格式数据"><a href="#Entry格式数据" class="headerlink" title="Entry格式数据"></a>Entry格式数据</h4><blockquote>
<p><strong>[XMIN]	[XMAX]	[DATA]</strong></p>
</blockquote>
<ol>
<li><strong>XMIN</strong> 是创建该条记录（版本）的事务编号</li>
<li>**XMAX **则是删除该条记录（版本）的事务编号</li>
<li>**DATA **就是这条记录持有的数据</li>
</ol>
<h4 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h4><p>对于一条记录来说，MYDB 使用 <code>Entry</code> 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。	由于一条记录存储在一条 Data Item 中，所以 Entry 中保存一个 DataItem 的引用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="comment">// 定义了XMIN的偏移量为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMIN</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义了XMAX的偏移量为XMIN偏移量后的8个字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMAX</span> <span class="operator">=</span> OF_XMIN+<span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 定义了DATA的偏移量为XMAX偏移量后的8个字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_DATA</span> <span class="operator">=</span> OF_XMAX+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uid字段，可能是用来唯一标识一个Entry的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uid;</span><br><span class="line">    <span class="comment">// DataItem对象，用来存储数据的</span></span><br><span class="line">    <span class="keyword">private</span> DataItem dataItem;</span><br><span class="line">    <span class="comment">// VersionManager对象，用来管理版本的</span></span><br><span class="line">    <span class="keyword">private</span> VersionManager vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法，用来加载一个Entry。它首先从VersionManager中读取数据，然后创建一个新的Entry</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title function_">loadEntry</span><span class="params">(VersionManager vm, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DataItem</span> <span class="variable">di</span> <span class="operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);</span><br><span class="line">        <span class="keyword">return</span> newEntry(vm, di, uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法，用来移除一个Entry。它通过调用dataItem的release方法来实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        dataItem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="日志格式操作"><a href="#日志格式操作" class="headerlink" title="日志格式操作"></a>日志格式操作</h3><h4 id="wrapEntryRaw"><a href="#wrapEntryRaw" class="headerlink" title="wrapEntryRaw()"></a><code>wrapEntryRaw()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成日志格式数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] wrapEntryRaw(<span class="type">long</span> xid, <span class="type">byte</span>[] data) &#123;</span><br><span class="line">    <span class="comment">// 将事务id转为8字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] xmin = Parser.long2Byte(xid);</span><br><span class="line">    <span class="comment">// 创建一个空的8字节数组，等待版本修改或删除是才修改</span></span><br><span class="line">    <span class="type">byte</span>[] xmax = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 拼接成日志格式</span></span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(xmin, xmax, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="data-1"><a href="#data-1" class="headerlink" title="data()"></a><code>data()</code></h4><p>获取记录中持有的数据，也就需要按照上面这个结构来解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以拷贝的形式返回内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] data() &#123;</span><br><span class="line">    <span class="comment">// 加锁，确保数据安全</span></span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取日志数据</span></span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        <span class="comment">// 创建一个去除前16字节的数组，因为前16字节表示 xmin and xmax</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[sa.end - sa.start - OF_DATA];</span><br><span class="line">        <span class="comment">// 拷贝数据到data数组上</span></span><br><span class="line">        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="setXmax"><a href="#setXmax" class="headerlink" title="setXmax()"></a><code>setXmax()</code></h4><p>当需要对数据进行修改时，就需要设置 <code>xmax</code>的值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置删除版本的事务编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXmax</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="comment">// 在修改或删除之前先拷贝好旧数值</span></span><br><span class="line">    dataItem.before();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取需要删除的日志数据</span></span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        <span class="comment">// 将事务编号拷贝到 8~15 处字节</span></span><br><span class="line">        System.arraycopy(Parser.long2Byte(xid), <span class="number">0</span>, sa.raw, sa.start+OF_XMAX, <span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 生成一个修改日志</span></span><br><span class="line">        dataItem.after(xid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h3><h4 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h4><p>在数据库中，“读提交”（Read Committed）是一种事务隔离级别，表示在读取数据时，事务只能读取已经提交的事务产生的数据。这意味着当一个事务正在读取数据时，如果其他事务正在修改相同的数据，它只能读取已经被提交的修改，而无法读取尚未提交的修改。<br>在MYDB中实现读提交，主要为了防止级联回滚与 commit 语义冲突，对每个数据版本（或记录版本），维护了两个关键变量：<strong>XMIN</strong>和<strong>XMAX</strong>。</p>
<ul>
<li><strong>XMIN</strong>表示创建该版本的事务编号。当一个事务创建了一个新的版本时，XMIN会记录该事务的编号。</li>
<li><strong>XMAX</strong>表示删除该版本的事务编号。当一个版本被删除时，或者有新版本出现时，XMAX会记录删除该版本的事务编号。</li>
</ul>
<h5 id="读提交的事务可见性逻辑"><a href="#读提交的事务可见性逻辑" class="headerlink" title="读提交的事务可见性逻辑"></a>读提交的事务可见性逻辑</h5><ol>
<li>如果版本的XMIN等于当前事务的事务编号，并且XMAX为空（表示尚未被删除），则该版本对当前事务可见。</li>
<li>或者，如果版本的XMIN对应的事务已经提交，并且XMAX为空（尚未被删除），或者XMAX不是当前事务的事务编号，并且XMAX对应的事务也已经提交，则该版本对当前事务可见。<blockquote>
<p>在读提交隔离级别下，事务只能看到已经提交的版本，而不能看到尚未提交的版本或被尚未提交的事务删除的版本。这样可以确保读取的数据是稳定和一致的，同时避免了读取到不一致或未提交的数据的可能性。</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(XMIN == Ti and                             // 由Ti创建且</span><br><span class="line">    XMAX == NULL                            // 还未被删除</span><br><span class="line">)</span><br><span class="line">or                                          // 或</span><br><span class="line">(XMIN is commited and                       // 由一个已提交的事务创建且</span><br><span class="line">    (XMAX == NULL or                        // 尚未删除或</span><br><span class="line">    (XMAX != Ti and XMAX is not commited)   // 由一个未提交的事务删除</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<h5 id="readCommited"><a href="#readCommited" class="headerlink" title="readCommited()"></a><code>readCommited()</code></h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020211720.png" alt="20251020211720"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来在读提交的隔离级别下，某个记录是否对事务t可见</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">readCommitted</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取事务的ID</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="comment">// 获取记录的创建版本号</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="comment">// 获取记录的删除版本号</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="comment">// 如果记录的创建版本号等于事务的ID并且记录未被删除，则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (xmin == xid &amp;&amp; xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果记录的创建版本已经提交</span></span><br><span class="line">    <span class="keyword">if</span> (tm.isCommitted(xmin)) &#123;</span><br><span class="line">        <span class="comment">// 如果记录未被删除，则返回true</span></span><br><span class="line">        <span class="keyword">if</span> (xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果记录的删除版本号不等于事务的ID</span></span><br><span class="line">        <span class="keyword">if</span> (xmax != xid) &#123;</span><br><span class="line">            <span class="comment">// 如果记录的删除版本未提交，则返回true</span></span><br><span class="line">            <span class="comment">// 因为没有提交，代表该数据还是上一个版本可见的</span></span><br><span class="line">            <span class="keyword">if</span> (!tm.isCommitted(xmax)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>在数据库中，可<strong>重复读（Repeatable Read）</strong>是一种事务隔离级别，它解决了读提交隔离级别下的不可重复读问题。在可重复读隔离级别下，一个事务执行期间多次读取同一数据项，可以保证读取到的结果是一致的，不会因为其他事务的并发操作而导致数据的不一致性。<br><strong>不可重复</strong>读问题指的是，在读提交隔离级别下，一个事务在执行过程中多次读取同一数据项，但由于其他事务的并发修改操作，导致每次读取到的数据值不同，出现了不一致的情况。可重复读隔离级别通过更严格的规则来解决这个问题。<br>在可重复读隔离级别下，<strong>事务只能读取它开始时已经提交的事务产生的数据版本</strong>。这意味着，在事务开始时已经提交的所有事务所产生的数据对当前事务是可见的，而在事务开始后产生的其他事务所产生的数据对当前事务则是不可见的。这样可以确保事务在执行期间读取到的数据是一致的，不会受到其他事务的影响。</p>
<h5 id="可重复读的事务可见性逻辑"><a href="#可重复读的事务可见性逻辑" class="headerlink" title="可重复读的事务可见性逻辑"></a>可重复读的事务可见性逻辑</h5><ol>
<li>如果版本的<strong>XMIN</strong>等于当前事务的事务编号，并且<strong>XMAX</strong>为空（表示尚未被删除），则该版本对当前事务可见。</li>
<li>或者，如果版本的<strong>XMIN</strong>对应的事务已经提交，并且<strong>XMIN</strong>小于当前事务的事务编号，并且<strong>XMIN</strong>不在当前事务开始前活跃的事务集合<strong>SP(Ti)<strong>中，同时</strong>XMAX</strong>为空（尚未被删除），或者<strong>XMAX</strong>不是当前事务的事务编号，并且<strong>XMAX</strong>对应的事务已经提交，并且<strong>XMAX</strong>大于当前事务的事务编号，或者XMAX在当前事务开始前活跃的事务集合SP(Ti)中，则该版本对当前事务可见。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(XMIN == Ti and                 // 由Ti创建且</span><br><span class="line"> (XMAX == NULL or               // 尚未被删除</span><br><span class="line">))</span><br><span class="line">or                              // 或</span><br><span class="line">(XMIN is commited and           // 由一个已提交的事务创建且</span><br><span class="line"> XMIN &lt; XID and                 // 这个事务小于Ti且</span><br><span class="line"> XMIN is not in SP(Ti) and      // 这个事务在Ti开始前提交且</span><br><span class="line"> (XMAX == NULL or               // 尚未被删除或</span><br><span class="line">  (XMAX != Ti and               // 由其他事务删除但是</span><br><span class="line">   (XMAX is not commited or     // 这个事务尚未提交或</span><br><span class="line">XMAX &gt; Ti or                    // 这个事务在Ti开始之后才开始或</span><br><span class="line">XMAX is in SP(Ti)               // 这个事务在Ti开始前还未提交</span><br><span class="line">))))</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="事务结构"><a href="#事务结构" class="headerlink" title="事务结构"></a>事务结构</h5><p>由于<strong>可重复读</strong>事务的可见性逻辑，需要提供一个结构，用来抽象事务，以保存快照数据；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm对一个事务的抽象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line">    <span class="comment">// 事务的ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> xid;</span><br><span class="line">    <span class="comment">// 事务的隔离级别</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> level;</span><br><span class="line">    <span class="comment">// 事务的快照，用于存储活跃事务的ID</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;</span><br><span class="line">    <span class="comment">// 事务执行过程中的错误</span></span><br><span class="line">    <span class="keyword">public</span> Exception err;</span><br><span class="line">    <span class="comment">// 标志事务是否自动中止</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> autoAborted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Transaction <span class="title function_">newTransaction</span><span class="params">(<span class="type">long</span> xid, <span class="type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">        <span class="comment">// 设置事务ID</span></span><br><span class="line">        t.xid = xid;</span><br><span class="line">        <span class="comment">// 设置事务隔离级别</span></span><br><span class="line">        t.level = level;</span><br><span class="line">        <span class="comment">// 如果隔离级别不为0，创建快照</span></span><br><span class="line">        <span class="keyword">if</span> (level != <span class="number">0</span>) &#123;</span><br><span class="line">            t.snapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 将活跃事务的ID添加到快照中</span></span><br><span class="line">            <span class="keyword">for</span> (Long x : active.keySet()) &#123;</span><br><span class="line">                t.snapshot.put(x, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回新创建的事务</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个事务ID是否在快照中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInSnapshot</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果事务ID等于超级事务ID，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (xid == TransactionManagerImpl.SUPER_XID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，检查事务ID是否在快照中</span></span><br><span class="line">        <span class="keyword">return</span> snapshot.containsKey(xid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="repeatableRead"><a href="#repeatableRead" class="headerlink" title="repeatableRead()"></a><code>repeatableRead()</code></h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020212404.png" alt="20251020212404"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">repeatableRead</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取事务的ID</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="comment">// 获取条目的创建版本号</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="comment">// 获取条目的删除版本号</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="comment">// 如果条目的创建版本号等于事务的ID并且条目未被删除，则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (xmin == xid &amp;&amp; xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果条目的创建版本已经提交，并且创建版本号小于事务的ID，并且创建版本号不在事务的快照中</span></span><br><span class="line">    <span class="keyword">if</span> (tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;</span><br><span class="line">        <span class="comment">// 如果条目未被删除，则返回true</span></span><br><span class="line">        <span class="keyword">if</span> (xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果条目的删除版本号不等于事务的ID</span></span><br><span class="line">        <span class="keyword">if</span> (xmax != xid) &#123;</span><br><span class="line">            <span class="comment">// 如果条目的删除版本未提交，或者删除版本号大于事务的ID，或者删除版本号在事务的快照中，则返回true</span></span><br><span class="line">            <span class="keyword">if</span> (!tm.isCommitted(xmax) || xmax &gt; xid || t.isInSnapshot(xmax)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><h4 id="版本跳跃问题"><a href="#版本跳跃问题" class="headerlink" title="版本跳跃问题"></a>版本跳跃问题</h4><p>版本跳跃问题是指在多版本并发控制（MVCC）中，一个事务要修改某个数据项时，可能会出现跳过中间版本直接修改最新版本的情况，从而产生逻辑上的错误。解决版本跳跃的关键在于检查最新版本的创建者对当前事务是否可见。如果当前事务要修改的数据已经被另一个事务修改并且对当前事务不可见，就要求当前事务回滚。具体来说，对于事务Ti要修改数据X的情况下，要检查如下两种情况：</p>
<ol>
<li>如果另一个事务Tj的事务ID（XID）大于Ti的事务ID，则Tj在时间上晚于Ti开始，因此Ti应该回滚，避免版本跳跃。</li>
<li>如果Tj在Ti的快照集合（SP(Ti)）中，则Tj在Ti开始之前已经提交，但Ti在开始之前并不能看到Tj的修改，因此也应该回滚。</li>
</ol>
<h5 id="版本跳跃的检查"><a href="#版本跳跃的检查" class="headerlink" title="版本跳跃的检查"></a>版本跳跃的检查</h5><p>因为读提交是允许版本跳跃的，可重复读是不允许的，所以只需要检查读提交即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isVersionSkip</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取条目的删除版本号</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="comment">// 如果事务的隔离级别为0，即读未提交，那么不跳过该版本，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (t.level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果事务的隔离级别不为0，那么检查删除版本是否已提交，并且删除版本号大于事务的ID或者删除版本号在事务的快照中</span></span><br><span class="line">        <span class="comment">// 如果满足上述条件，那么跳过该版本，返回true</span></span><br><span class="line">        <span class="keyword">return</span> tm.isCommitted(xmax) &amp;&amp; (xmax &gt; t.xid || t.isInSnapshot(xmax));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="LockTable"><a href="#LockTable" class="headerlink" title="LockTable"></a>LockTable</h5><p>上文提到了在基于<strong>2PL（两段锁协议）</strong>的并发控制中，当一个事务（例如Tj）想要获取某个数据项的锁时，如果该锁已经被其他事务（例如Ti）持有，则Tj会被阻塞，直到Ti释放了该锁。这种等待关系可以被抽象成有向边，比如Tj在等待Ti，可以表示为Tj → Ti。通过记录所有事务之间的等待关系，就可以构建一个有向图，即等待图（Wait-for graph）。在等待图中，如果存在环路，即存在一个事务的等待序列形成了一个闭环，那么就说明存在死锁。因此，检测死锁只需要查看等待图中是否存在环即可。</p>
<h5 id="LockTable基本结构"><a href="#LockTable基本结构" class="headerlink" title="LockTable基本结构"></a>LockTable基本结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 维护了一个依赖等待图，以进行死锁检测</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTable</span> &#123;</span><br><span class="line">    <span class="comment">// 某个XID已经获得的资源的UID列表，键是事务ID，值是该事物持有的资源ID列表。</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;</span><br><span class="line">    <span class="comment">// UID被某个XID持有,键是资源ID，值是持有该资源的事务ID。</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; u2x;</span><br><span class="line">    <span class="comment">// 正在等待UID的XID列表，键是资源ID，值是正在等待该资源的事务ID。</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; </span><br><span class="line">    <span class="comment">// 正在等待资源的XID的锁,键是事务ID，值是该事务的锁对象。</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   </span><br><span class="line">    <span class="comment">// XID正在等待的UID,键是事务ID，值是该事务正在等待的资源ID。</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; waitU;</span><br><span class="line">    <span class="comment">// 一个全局锁，用于同步。</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="add-1"><a href="#add-1" class="headerlink" title="add()"></a><code>add()</code></h5><p>在每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测。如果检测到死锁，就撤销这条边，不允许添加，并撤销该事务。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020213617.png" alt="20251020213617"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要等待则返回null，否则返回锁对象或者会造成死锁则抛出异常</span></span><br><span class="line"><span class="keyword">public</span> Lock <span class="title function_">add</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 锁定全局锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查x2u是否已经拥有这个资源</span></span><br><span class="line">        <span class="keyword">if</span> (isInList(x2u, xid, uid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果已经拥有，直接返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查UID资源是否已经被其他XID事务持有</span></span><br><span class="line">        <span class="keyword">if</span> (!u2x.containsKey(uid)) &#123;</span><br><span class="line">            u2x.put(uid, xid); <span class="comment">// 如果没有被持有，将资源分配给当前事务</span></span><br><span class="line">            putIntoList(x2u, xid, uid); <span class="comment">// 将资源添加到事务的资源列表中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果资源已经被其他事务持有，将当前事务添加到等待列表中</span></span><br><span class="line">        waitU.put(xid, uid);</span><br><span class="line">        putIntoList(wait, uid, xid);</span><br><span class="line">        <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">        <span class="keyword">if</span> (hasDeadLock()) &#123;</span><br><span class="line">            waitU.remove(xid); <span class="comment">// 如果存在死锁，从等待列表中移除当前事务</span></span><br><span class="line">            removeFromList(wait, uid, xid);</span><br><span class="line">            <span class="keyword">throw</span> Error.DeadlockException; <span class="comment">// 抛出死锁异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不存在死锁，为当前事务创建一个新的锁，并锁定它</span></span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        l.lock();</span><br><span class="line">        waitLock.put(xid, l); <span class="comment">// 将新的锁添加到等待锁列表中</span></span><br><span class="line">        <span class="keyword">return</span> l; <span class="comment">// 返回新的锁</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 解锁全局锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="hasDeadLock-and-dfs"><a href="#hasDeadLock-and-dfs" class="headerlink" title="hasDeadLock() and dfs()"></a><code>hasDeadLock() and dfs()</code></h5><p>检查是否包含死锁</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215311.png" alt="20251020215311"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasDeadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    xidStamp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 创建一个新的xidStamp哈希映射</span></span><br><span class="line">    stamp = <span class="number">1</span>; <span class="comment">// 将stamp设置为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> xid : x2u.keySet()) &#123; <span class="comment">// 遍历所有已经获得资源的事务ID</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">s</span> <span class="operator">=</span> xidStamp.get(xid); <span class="comment">// 获取xidStamp中对应事务ID的记录</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span> &amp;&amp; s &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果记录存在，并且值大于0</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过这个事务ID，继续下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        stamp++; <span class="comment">// 将stamp加1</span></span><br><span class="line">        <span class="keyword">if</span> (dfs(xid)) &#123; <span class="comment">// 调用dfs方法进行深度优先搜索</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果dfs方法返回true，表示存在死锁，那么hasDeadLock方法也返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果所有的事务ID都被检查过，并且没有发现死锁，那么hasDeadLock方法返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stp</span> <span class="operator">=</span> xidStamp.get(xid); <span class="comment">// 从xidStamp映射中获取当前事务ID的时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (stp != <span class="literal">null</span> &amp;&amp; stp == stamp) &#123; <span class="comment">// 如果时间戳存在并且等于全局时间戳</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 存在死锁，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stp != <span class="literal">null</span> &amp;&amp; stp &lt; stamp) &#123; <span class="comment">// 如果时间戳存在并且小于全局时间戳</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这个事务ID已经被检查过，并且没有发现死锁，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    xidStamp.put(xid, stamp); <span class="comment">// 将当前事务ID和全局时间戳添加到xidStamp映射中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> waitU.get(xid); <span class="comment">// 从waitU映射中获取当前事务ID正在等待的资源ID</span></span><br><span class="line">    <span class="keyword">if</span> (uid == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果资源ID不存在，表示当前事务ID不在等待任何资源，返回false</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">x</span> <span class="operator">=</span> u2x.get(uid); <span class="comment">// 从u2x映射中获取当前资源ID被哪个事务ID持有</span></span><br><span class="line">    <span class="keyword">assert</span> x != <span class="literal">null</span>; <span class="comment">// 断言这个事务ID存在</span></span><br><span class="line">    <span class="keyword">return</span> dfs(x); <span class="comment">// 递归调用dfs方法检查这个事务ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="死锁演示"><a href="#死锁演示" class="headerlink" title="死锁演示"></a>死锁演示</h4><p><strong>前言</strong><br>采用一下数据实现死锁模拟：</p>
<ol>
<li>lockTable.add(1, 1); &#x2F;&#x2F; 事务1请求资源1</li>
<li>lockTable.add(2, 2); &#x2F;&#x2F; 事务2请求资源2</li>
<li>lockTable.add(3, 3); &#x2F;&#x2F; 事务3请求资源3</li>
<li>lockTable.add(1, 2); &#x2F;&#x2F; 事务1请求资源2</li>
<li>lockTable.add(2, 3); &#x2F;&#x2F; 事务2请求资源3</li>
<li>lockTable.add(3, 1); &#x2F;&#x2F; 事务3请求资源1<blockquote>
<p>在这些数据添加完毕之后，事务1在等待事务2，事务2在等待事务3，事务3又在等待事务1，此时就触发了死锁！</p>
</blockquote>
</li>
</ol>
<p>当数据添加完毕之后，LockTable类中的MAP集合对着一下元素：</p>
<ol>
<li><p><strong>x2u</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xid			uid</span><br><span class="line">1				1</span><br><span class="line">2				2</span><br><span class="line">3				3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>u2x</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uid			xid</span><br><span class="line">1				1</span><br><span class="line">2				2</span><br><span class="line">3				3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>wait</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uid			xid</span><br><span class="line">1				3</span><br><span class="line">2				1</span><br><span class="line">3				2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>waitU</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xid			uid</span><br><span class="line">1				2</span><br><span class="line">2				3</span><br><span class="line">3				1</span><br></pre></td></tr></table></figure>
<p>dfs()演示过程<br>当上方数据插入装载完成之后，会进行死锁校验，此处只是采用简易代码实现，可以自己根据源码进行学习！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">第一遍：xidStamp = <span class="literal">null</span>，stamp=<span class="number">2</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> xid)</span> &#123; <span class="comment">//xid = 1</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stp</span> <span class="operator">=</span> xidStamp.get(xid); <span class="comment">// null</span></span><br><span class="line">    xidStamp.put(xid, stamp); <span class="comment">// 1,2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> waitU.get(xid); <span class="comment">// uid = 2</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">x</span> <span class="operator">=</span> u2x.get(uid); <span class="comment">// x = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(x); <span class="comment">// 将2存入进去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二遍：xidStamp = &#123;<span class="number">1</span>=<span class="number">2</span>&#125;，stamp=<span class="number">2</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> xid)</span> &#123; <span class="comment">// xid = 2</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stp</span> <span class="operator">=</span> xidStamp.get(xid); <span class="comment">// null</span></span><br><span class="line">    xidStamp.put(xid, stamp); <span class="comment">// 2,2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> waitU.get(xid); <span class="comment">// uid = 3</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">x</span> <span class="operator">=</span> u2x.get(uid); <span class="comment">// x = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(x); <span class="comment">// 将3存入进去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第三遍：xidStamp = &#123;<span class="number">1</span>=<span class="number">2</span>,<span class="number">2</span>=<span class="number">2</span>&#125;，stamp=<span class="number">2</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> xid)</span> &#123; <span class="comment">// xid = 3</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stp</span> <span class="operator">=</span> xidStamp.get(xid); <span class="comment">// 3</span></span><br><span class="line">    xidStamp.put(xid, stamp); <span class="comment">// 3,2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> waitU.get(xid); <span class="comment">// uid = 1</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">x</span> <span class="operator">=</span> u2x.get(uid); <span class="comment">// x = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(x); <span class="comment">// 将1存入进去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第四遍：xidStamp = &#123;<span class="number">1</span>=<span class="number">2</span>,<span class="number">2</span>=<span class="number">2</span>,<span class="number">3</span>=<span class="number">2</span>&#125;，stamp=<span class="number">2</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> xid)</span> &#123; <span class="comment">// xid = 1</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stp</span> <span class="operator">=</span> xidStamp.get(xid); <span class="comment">// 此时就获取到了数据，stp = 2;</span></span><br><span class="line">    <span class="keyword">if</span> (stp != <span class="literal">null</span> &amp;&amp; stp == stamp) &#123; <span class="comment">// 此时条件成立，证明存在死锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 存在死锁，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a><code>remove()</code></h5><p>当一个事务commit或者abort时，就会释放掉它自己持有的锁，并将自身从等待图中删除<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215616.png" alt="20251020215616"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取全局锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Long&gt; l = x2u.get(xid); <span class="comment">// 从x2u映射中获取当前事务ID已经获得的资源的UID列表</span></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>); <span class="comment">// 获取并移除列表中的第一个资源ID</span></span><br><span class="line">                selectNewXID(uid); <span class="comment">// 从等待队列中选择一个新的事务ID来占用这个资源</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        waitU.remove(xid); <span class="comment">// 从waitU映射中移除当前事务ID</span></span><br><span class="line">        x2u.remove(xid); <span class="comment">// 从x2u映射中移除当前事务ID</span></span><br><span class="line">        waitLock.remove(xid); <span class="comment">// 从waitLock映射中移除当前事务ID</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 解锁全局锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="selectNewXID"><a href="#selectNewXID" class="headerlink" title="selectNewXID()"></a><code>selectNewXID()</code></h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215631.png" alt="20251020215631"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从等待队列中选择一个xid来占用uid</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">selectNewXID</span><span class="params">(<span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    u2x.remove(uid); <span class="comment">// 从u2x映射中移除当前资源ID</span></span><br><span class="line">    List&lt;Long&gt; l = wait.get(uid); <span class="comment">// 从wait映射中获取当前资源ID的等待队列</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">// 如果等待队列为空，立即返回</span></span><br><span class="line">    <span class="keyword">assert</span> l.size() &gt; <span class="number">0</span>; <span class="comment">// 断言等待队列不为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历等待队列</span></span><br><span class="line">    <span class="keyword">while</span> (l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>); <span class="comment">// 获取并移除队列中的第一个事务ID</span></span><br><span class="line">        <span class="comment">// 检查事务ID是否在waitLock映射中</span></span><br><span class="line">        <span class="keyword">if</span> (!waitLock.containsKey(xid)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 如果不在，跳过这个事务ID，继续下一个</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            u2x.put(uid, xid); <span class="comment">// 将事务ID和资源ID添加到u2x映射中</span></span><br><span class="line">            <span class="type">Lock</span> <span class="variable">lo</span> <span class="operator">=</span> waitLock.remove(xid); <span class="comment">// 从waitLock映射中移除这个事务ID</span></span><br><span class="line">            waitU.remove(xid); <span class="comment">// 从waitU映射中移除这个事务ID</span></span><br><span class="line">            lo.unlock(); <span class="comment">// 解锁这个事务ID的锁</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果等待队列为空，从wait映射中移除当前资源ID</span></span><br><span class="line">    <span class="keyword">if</span> (l.size() == <span class="number">0</span>) wait.remove(uid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VM的实现"><a href="#VM的实现" class="headerlink" title="VM的实现"></a>VM的实现</h3><h4 id="VM的基本定义"><a href="#VM的基本定义" class="headerlink" title="VM的基本定义"></a>VM的基本定义</h4><p>VM 层通过 VersionManager 接口，向上层提供功能，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VersionManager</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，VM 的实现类还被设计为 <code>**Entry**</code>** **的缓存，需要继承<code>** AbstractCache&lt;Entry&gt;**</code>。需要实现的获取到缓存和从缓存释放的方法很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Entry <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 核心还是调用dm.read()方法</span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> Entry.loadEntry(<span class="built_in">this</span>, uid);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.NullEntryException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">    entry.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="begin-1"><a href="#begin-1" class="headerlink" title="begin()"></a><code>begin()</code></h5><p>开启一个事务，并初始化事务的结构<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215950.png" alt="20251020215950"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁，防止并发问题</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> tm.begin(); <span class="comment">// 调用事务管理器的begin方法，开始一个新的事务，并获取事务ID</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> Transaction.newTransaction(xid, level, activeTransaction); <span class="comment">// 创建一个新的事务对象</span></span><br><span class="line">        activeTransaction.put(xid, t); <span class="comment">// 将新的事务对象添加到活动事务的映射中</span></span><br><span class="line">        <span class="keyword">return</span> xid; <span class="comment">// 返回新的事务ID</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Transaction <span class="title function_">newTransaction</span><span class="params">(<span class="type">long</span> xid, <span class="type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">    <span class="comment">// 设置事务ID</span></span><br><span class="line">    t.xid = xid;</span><br><span class="line">    <span class="comment">// 设置事务隔离级别</span></span><br><span class="line">    t.level = level;</span><br><span class="line">    <span class="comment">// 如果隔离级别不为0，创建快照</span></span><br><span class="line">    <span class="keyword">if</span> (level != <span class="number">0</span>) &#123;</span><br><span class="line">        t.snapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将活跃事务的ID添加到快照中</span></span><br><span class="line">        <span class="keyword">for</span> (Long x : active.keySet()) &#123;</span><br><span class="line">            t.snapshot.put(x, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新创建的事务</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="commit"><a href="#commit" class="headerlink" title="commit()"></a><code>commit()</code></h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020225334.png" alt="20251020225334"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁，防止并发问题</span></span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid); <span class="comment">// 从活动事务中获取事务对象</span></span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.err != <span class="literal">null</span>) &#123; <span class="comment">// 如果事务已经出错，那么抛出错误</span></span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException n) &#123; <span class="comment">// 如果事务对象为null，打印事务ID和活动事务的键集，然后抛出异常</span></span><br><span class="line">        System.out.println(xid);</span><br><span class="line">        System.out.println(activeTransaction.keySet());</span><br><span class="line">        Panic.panic(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁，防止并发问题</span></span><br><span class="line">    activeTransaction.remove(xid); <span class="comment">// 从活动事务中移除这个事务</span></span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line"></span><br><span class="line">    lt.remove(xid); <span class="comment">// 从锁表中移除这个事务的锁</span></span><br><span class="line">    tm.commit(xid); <span class="comment">// 调用事务管理器的commit方法，进行事务的提交操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="abort"><a href="#abort" class="headerlink" title="abort()"></a><code>abort()</code></h5><p><code>abort</code> 事务的方法则有两种，手动和自动。手动指的是调用 <code>**abort()**</code> 方法，而自动，则是在事务被检测出出现死锁时，会自动撤销回滚事务；或者出现版本跳跃时，也会自动回滚<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020225406.png" alt="20251020225406"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 公开的abort方法，用于中止一个事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用内部的abort方法，autoAborted参数为false表示这不是一个自动中止的事务</span></span><br><span class="line">    internAbort(xid, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部的abort方法，处理事务的中止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internAbort</span><span class="params">(<span class="type">long</span> xid, <span class="type">boolean</span> autoAborted)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁，防止并发问题</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// 从活动事务中获取事务对象</span></span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    <span class="comment">// 如果这不是一个自动中止的事务，那么从活动事务中移除这个事务</span></span><br><span class="line">    <span class="keyword">if</span> (!autoAborted) &#123;</span><br><span class="line">        activeTransaction.remove(xid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果事务已经被自动中止，那么直接返回，不做任何处理</span></span><br><span class="line">    <span class="keyword">if</span> (t.autoAborted) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从锁表中移除这个事务的锁</span></span><br><span class="line">    lt.remove(xid);</span><br><span class="line">    <span class="comment">// 调用事务管理器的abort方法，进行事务的中止操作</span></span><br><span class="line">    tm.abort(xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="read"><a href="#read" class="headerlink" title="read()"></a><code>read()</code></h5><p><code>read() </code>方法读取一个 <code>entry</code>，需要注意判断可见性<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215934.png" alt="20251020215934"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁，防止并发问题</span></span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid); <span class="comment">// 从活动事务中获取事务对象</span></span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t.err != <span class="literal">null</span>) &#123; <span class="comment">// 如果事务已经出错，那么抛出错误</span></span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entry = <span class="built_in">super</span>.get(uid); <span class="comment">// 尝试获取数据项</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == Error.NullEntryException) &#123; <span class="comment">// 如果数据项不存在，那么返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果出现其他错误，那么抛出错误</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在事务隔离级别中讲解了该方法</span></span><br><span class="line">        <span class="keyword">if</span> (Visibility.isVisible(tm, t, entry)) &#123; <span class="comment">// 如果数据项对当前事务可见，那么返回数据项的数据</span></span><br><span class="line">            <span class="keyword">return</span> entry.data();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果数据项对当前事务不可见，那么返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        entry.release(); <span class="comment">// 释放数据项</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="insert-2"><a href="#insert-2" class="headerlink" title="insert()"></a><code>insert()</code></h5><p>将数据包裹成 <code>Entry</code>，然后交给 DM 插入即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁，防止并发问题</span></span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid); <span class="comment">// 从活动事务中获取事务对象</span></span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t.err != <span class="literal">null</span>) &#123; <span class="comment">// 如果事务已经出错，那么抛出错误</span></span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data); <span class="comment">// 将事务ID和数据包装成一个新的数据项</span></span><br><span class="line">    <span class="keyword">return</span> dm.insert(xid, raw); <span class="comment">// 调用数据管理器的insert方法，插入新的数据项，并返回数据项的唯一标识符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete()"></a><code>delete()</code></h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251020215919.png" alt="20251020215919"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 删除一个数据项的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取锁，防止并发问题</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// 从活动事务中获取事务对象</span></span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果事务已经出错，那么抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试获取数据项</span></span><br><span class="line">        entry = <span class="built_in">super</span>.get(uid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果数据项不存在，那么返回false</span></span><br><span class="line">        <span class="keyword">if</span> (e == Error.NullEntryException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果出现其他错误，那么抛出错误</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果数据项对当前事务不可见，那么返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!Visibility.isVisible(tm, t, entry)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试为数据项添加锁</span></span><br><span class="line">            l = lt.add(xid, uid);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果出现并发更新的错误，那么中止事务，并抛出错误</span></span><br><span class="line">            t.err = Error.ConcurrentUpdateException;</span><br><span class="line">            internAbort(xid, <span class="literal">true</span>);</span><br><span class="line">            t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果成功获取到锁，那么锁定并立即解锁</span></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">            l.lock();</span><br><span class="line">            l.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据项已经被当前事务删除，那么返回false</span></span><br><span class="line">        <span class="keyword">if</span> (entry.getXmax() == xid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据项的版本被跳过，那么中止事务，并抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (Visibility.isVersionSkip(tm, t, entry)) &#123;</span><br><span class="line">            t.err = Error.ConcurrentUpdateException;</span><br><span class="line">            internAbort(xid, <span class="literal">true</span>);</span><br><span class="line">            t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置数据项的xmax为当前事务的ID，表示数据项被当前事务删除</span></span><br><span class="line">        entry.setXmax(xid);</span><br><span class="line">        <span class="comment">// 返回true，表示删除操作成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放数据项</span></span><br><span class="line">        entry.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Index-Manager-IM-索引管理器"><a href="#Index-Manager-IM-索引管理器" class="headerlink" title="Index Manager (IM) 索引管理器"></a>Index Manager (IM) 索引管理器</h2><p><strong>前言</strong></p>
<p>IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的聚簇索引。目前 MYDB 只支持基于索引查找数据，不支持全表扫描。感兴趣的同学可以自行实现。</p>
<p>在依赖关系图中可以看到，IM 直接基于 DM，而没有基于 VM。索引的数据被直接插入数据库文件中，而不需要经过版本管理。</p>
<p>本节不赘述 B+ 树算法，更多描述实现。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[LeafFlag][KeyNumber][SiblingUid]</span><br><span class="line">[Son0][Key0][Son1][Key1]...[SonN][KeyN]</span><br></pre></td></tr></table></figure>

<ul>
<li>**[LeafFlag]**：标记该节点是否为叶子节点</li>
<li>**[KeyNumber]**：该节点中 key 的个数</li>
<li>**[SiblingUid]**：是其兄弟节点存储在 DM 中的 UID，用于实现节点的连接</li>
<li>[**SonN] [KeyN]**：后续穿插的子节点，最后一个 Key 始终为 MAX_VALUE，以方便查找</li>
</ul>
<h3 id="Node具体实现"><a href="#Node具体实现" class="headerlink" title="Node具体实现"></a>Node具体实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">IS_LEAF_OFFSET</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示该节点是否为叶子节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NO_KEYS_OFFSET</span> <span class="operator">=</span> IS_LEAF_OFFSET + <span class="number">1</span>; <span class="comment">// 表示该节点中key的个数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIBLING_OFFSET</span> <span class="operator">=</span> NO_KEYS_OFFSET + <span class="number">2</span>; <span class="comment">// 表示节点的兄弟节点的UID属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_HEADER_SIZE</span> <span class="operator">=</span> SIBLING_OFFSET + <span class="number">8</span>; <span class="comment">// 表示节点头部的大小的常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BALANCE_NUMBER</span> <span class="operator">=</span> <span class="number">32</span>; <span class="comment">// 节点的平衡因子的常量，一个节点最多可以包含32个key</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_SIZE</span> <span class="operator">=</span> NODE_HEADER_SIZE + (<span class="number">2</span> * <span class="number">8</span>) * (BALANCE_NUMBER * <span class="number">2</span> + <span class="number">2</span>); <span class="comment">// 节点的大小</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置是否为叶子节点，1表示是叶子节点，0表示非叶子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRawIsLeaf</span><span class="params">(SubArray raw, <span class="type">boolean</span> isLeaf)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">            raw.raw[raw.start + IS_LEAF_OFFSET] = (<span class="type">byte</span>) <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            raw.raw[raw.start + IS_LEAF_OFFSET] = (<span class="type">byte</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为叶子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getRawIfLeaf</span><span class="params">(SubArray raw)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> raw.raw[raw.start + IS_LEAF_OFFSET] == (<span class="type">byte</span>) <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRawNoKeys</span><span class="params">(SubArray raw, <span class="type">int</span> noKeys)</span> &#123;</span><br><span class="line">        System.arraycopy(Parser.short2Byte((<span class="type">short</span>) noKeys), <span class="number">0</span>, raw.raw, raw.start + NO_KEYS_OFFSET, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRawNoKeys</span><span class="params">(SubArray raw)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) Parser.parseShort(Arrays.copyOfRange(raw.raw, raw.start + NO_KEYS_OFFSET, raw.start + NO_KEYS_OFFSET + <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置兄弟节点的uid，占用八个字节</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> raw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sibling</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRawSibling</span><span class="params">(SubArray raw, <span class="type">long</span> sibling)</span> &#123;</span><br><span class="line">        System.arraycopy(Parser.long2Byte(sibling), <span class="number">0</span>, raw.raw, raw.start + SIBLING_OFFSET, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取兄弟节点的uid</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> raw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getRawSibling</span><span class="params">(SubArray raw)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(raw.raw, raw.start + SIBLING_OFFSET, raw.start + SIBLING_OFFSET + <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置第k个子节点的UID。</span></span><br><span class="line"><span class="comment">     * 注：k 是从0开始的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> raw 节点的原始字节数组。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid 要设置的UID。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> kth 子节点的索引。</span></span><br><span class="line"><span class="comment">     *            raw.start是字节数组的起始位置，NODE_HEADER_SIZE是节点头部的大小，</span></span><br><span class="line"><span class="comment">     *            kth * (8 * 2)是第k个子节点或键的偏移量。所以，raw.start + NODE_HEADER_SIZE + kth * (8 * 2)</span></span><br><span class="line"><span class="comment">     *            就是第k个子节点或键在字节数组中的起始位置。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRawKthSon</span><span class="params">(SubArray raw, <span class="type">long</span> uid, <span class="type">int</span> kth)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> raw.start + NODE_HEADER_SIZE + kth * (<span class="number">8</span> * <span class="number">2</span>);</span><br><span class="line">        System.arraycopy(Parser.long2Byte(uid), <span class="number">0</span>, raw.raw, offset, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取第k个子节点的UID。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getRawKthSon</span><span class="params">(SubArray raw, <span class="type">int</span> kth)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> raw.start + NODE_HEADER_SIZE + kth * (<span class="number">8</span> * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(raw.raw, offset, offset + <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置第k个键的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRawKthKey</span><span class="params">(SubArray raw, <span class="type">long</span> key, <span class="type">int</span> kth)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> raw.start + NODE_HEADER_SIZE + kth * (<span class="number">8</span> * <span class="number">2</span>) + <span class="number">8</span>;</span><br><span class="line">        System.arraycopy(Parser.long2Byte(key), <span class="number">0</span>, raw.raw, offset, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取第k个键的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getRawKthKey</span><span class="params">(SubArray raw, <span class="type">int</span> kth)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> raw.start + NODE_HEADER_SIZE + kth * (<span class="number">8</span> * <span class="number">2</span>) + <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(raw.raw, offset, offset + <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从一个节点的原始字节数组中复制一部分数据到另一个节点的原始字节数组中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyRawFromKth</span><span class="params">(SubArray from, SubArray to, <span class="type">int</span> kth)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算要复制的数据在源节点的原始字节数组中的起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> from.start + NODE_HEADER_SIZE + kth * (<span class="number">8</span> * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 将源节点的原始字节数组中的数据复制到目标节点的原始字节数组中</span></span><br><span class="line">        <span class="comment">// 复制的数据包括从起始位置到源节点的原始字节数组的末尾的所有数据</span></span><br><span class="line">        System.arraycopy(from.raw, offset, to.raw, to.start + NODE_HEADER_SIZE, from.end - offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newRootRaw"><a href="#newRootRaw" class="headerlink" title="newRootRaw()"></a><code>newRootRaw()</code></h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[LeafFlag: 0]</span><br><span class="line">[KeyNumber: 2]</span><br><span class="line">[SiblingUid: 0]</span><br><span class="line">[Son0: left][Key0: key][Son1: right][Key1: MAX<span class="built_in">_</span>VALUE]</span><br><span class="line"></span><br><span class="line">注：一个简单的演示</span><br><span class="line"></span><br><span class="line">        (key)</span><br><span class="line">       /     <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>      /       <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>     /         <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>  [left]     [right]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的根节点的原始字节数组。</span></span><br><span class="line"><span class="comment"> * 这个新的根节点包含两个子节点，它们的键分别是`key`和`Long.MAX_VALUE`，UID分别是`left`和`right`。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newRootRaw(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> key) &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的字节数组，大小为节点的大小</span></span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置节点的基本属性</span></span><br><span class="line">    <span class="comment">// 设置节点为非叶子节点</span></span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 设置节点的键的数量为2</span></span><br><span class="line">    setRawNoKeys(raw, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 设置节点的兄弟节点的UID为0</span></span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置子节点和键值</span></span><br><span class="line">    <span class="comment">// 设置第0个子节点的UID为left</span></span><br><span class="line">    setRawKthSon(raw, left, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置第0个键的值为key</span></span><br><span class="line">    setRawKthKey(raw, key, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置第1个子节点的UID为right</span></span><br><span class="line">    setRawKthSon(raw, right, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 设置第1个键的值为Long.MAX_VALUE</span></span><br><span class="line">    setRawKthKey(raw, Long.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新创建的根节点的原始字节数组</span></span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="newNilRootRaw"><a href="#newNilRootRaw" class="headerlink" title="newNilRootRaw()"></a><code>newNilRootRaw()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的空根节点的原始字节数组，这个新的根节点没有子节点和键。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newNilRootRaw() &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的字节数组，大小为节点的大小</span></span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置节点为叶子节点</span></span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置节点的键的数量为0</span></span><br><span class="line">    setRawNoKeys(raw, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置节点的兄弟节点的UID为0</span></span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新创建的空根节点的原始字节数组</span></span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="searchNext"><a href="#searchNext" class="headerlink" title="searchNext()"></a><code>searchNext()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SearchNextRes</span> &#123;</span><br><span class="line">    <span class="type">long</span> uid;</span><br><span class="line">    <span class="type">long</span> siblingUid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在B+树的节点中搜索下一个节点的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SearchNextRes <span class="title function_">searchNext</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取节点的读锁</span></span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个SearchNextRes对象，用于存储搜索结果</span></span><br><span class="line">        <span class="type">SearchNextRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchNextRes</span>();</span><br><span class="line">        <span class="comment">// 获取节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; noKeys; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取第i个key的值</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, i);</span><br><span class="line">            <span class="comment">// 如果key小于ik，那么找到了下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (key &lt; ik) &#123;</span><br><span class="line">                <span class="comment">// 设置下一个节点的UID</span></span><br><span class="line">                res.uid = getRawKthSon(raw, i);</span><br><span class="line">                <span class="comment">// 设置兄弟节点的UID为0</span></span><br><span class="line">                res.siblingUid = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 返回搜索结果</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到下一个节点，设置uid为0</span></span><br><span class="line">        res.uid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置兄弟节点的UID为当前节点的兄弟节点的UID</span></span><br><span class="line">        res.siblingUid = getRawSibling(raw);</span><br><span class="line">        <span class="comment">// 返回搜索结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放节点的读锁</span></span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LeafSearchRangeRes"><a href="#LeafSearchRangeRes" class="headerlink" title="LeafSearchRangeRes()"></a><code>LeafSearchRangeRes()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LeafSearchRangeRes</span> &#123;</span><br><span class="line">    List&lt;Long&gt; uids;</span><br><span class="line">    <span class="type">long</span> siblingUid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在B+树的叶子节点中搜索一个键值范围的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> LeafSearchRangeRes <span class="title function_">leafSearchRange</span><span class="params">(<span class="type">long</span> leftKey, <span class="type">long</span> rightKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数据项的读锁</span></span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取节点中的键的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="type">int</span> <span class="variable">kth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到第一个大于或等于左键的键</span></span><br><span class="line">        <span class="keyword">while</span> (kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span> (ik &gt;= leftKey) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            kth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个列表，用于存储所有在键值范围内的子节点的UID</span></span><br><span class="line">        List&lt;Long&gt; uids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有的键，将所有小于或等于右键的键对应的子节点的UID添加到列表中</span></span><br><span class="line">        <span class="keyword">while</span> (kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span> (ik &lt;= rightKey) &#123;</span><br><span class="line">                uids.add(getRawKthSon(raw, kth));</span><br><span class="line">                kth++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有的键都被遍历过，获取兄弟节点的UID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">siblingUid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (kth == noKeys) &#123;</span><br><span class="line">            siblingUid = getRawSibling(raw);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个LeafSearchRangeRes对象，用于存储搜索结果</span></span><br><span class="line">        <span class="type">LeafSearchRangeRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafSearchRangeRes</span>();</span><br><span class="line">        res.uids = uids;</span><br><span class="line">        res.siblingUid = siblingUid;</span><br><span class="line">        <span class="comment">// 返回搜索结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放数据项的读锁</span></span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="insertAndSplit"><a href="#insertAndSplit" class="headerlink" title="insertAndSplit()"></a><code>insertAndSplit()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InsertAndSplitRes</span> &#123;</span><br><span class="line">    <span class="type">long</span> siblingUid, newSon, newKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在B+树的节点中插入一个键值对，并在需要时分裂节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> InsertAndSplitRes <span class="title function_">insertAndSplit</span><span class="params">(<span class="type">long</span> uid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建一个标志位，用于标记插入操作是否成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 创建一个异常对象，用于存储在插入或分裂节点时发生的异常</span></span><br><span class="line">    <span class="type">Exception</span> <span class="variable">err</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 创建一个InsertAndSplitRes对象，用于存储插入和分裂节点的结果</span></span><br><span class="line">    <span class="type">InsertAndSplitRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertAndSplitRes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在数据项上设置一个保存点</span></span><br><span class="line">    dataItem.before();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试在节点中插入键值对，并获取插入结果</span></span><br><span class="line">        success = insert(uid, key);</span><br><span class="line">        <span class="comment">// 如果插入失败，设置兄弟节点的UID，并返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            res.siblingUid = getRawSibling(raw);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果需要分裂节点</span></span><br><span class="line">        <span class="keyword">if</span> (needSplit()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 分裂节点，并获取分裂结果</span></span><br><span class="line">                <span class="type">SplitRes</span> <span class="variable">r</span> <span class="operator">=</span> split();</span><br><span class="line">                <span class="comment">// 设置新节点的UID和新键，并返回结果</span></span><br><span class="line">                res.newSon = r.newSon;</span><br><span class="line">                res.newKey = r.newKey;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 如果在分裂节点时发生错误，保存异常并抛出</span></span><br><span class="line">                err = e;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不需要分裂节点，直接返回结果</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有发生错误并且插入成功，提交数据项的修改</span></span><br><span class="line">        <span class="keyword">if</span> (err == <span class="literal">null</span> &amp;&amp; success) &#123;</span><br><span class="line">            dataItem.after(TransactionManagerImpl.SUPER_XID);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果发生错误或插入失败，回滚数据项的修改</span></span><br><span class="line">            dataItem.unBefore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="insert-3"><a href="#insert-3" class="headerlink" title="insert()"></a><code>insert()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在B+树的节点中插入一个键值对的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> uid, <span class="type">long</span> key)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取节点中的键的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">    <span class="comment">// 初始化插入位置的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">kth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到第一个大于或等于要插入的键的键的位置</span></span><br><span class="line">    <span class="keyword">while</span> (kth &lt; noKeys) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">        <span class="keyword">if</span> (ik &lt; key) &#123;</span><br><span class="line">            kth++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果所有的键都被遍历过，并且存在兄弟节点，插入失败</span></span><br><span class="line">    <span class="keyword">if</span> (kth == noKeys &amp;&amp; getRawSibling(raw) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (getRawIfLeaf(raw)) &#123;</span><br><span class="line">        <span class="comment">// 在插入位置后的所有键和子节点向后移动一位</span></span><br><span class="line">        shiftRawKth(raw, kth);</span><br><span class="line">        <span class="comment">// 在插入位置插入新的键和子节点的UID</span></span><br><span class="line">        setRawKthKey(raw, key, kth);</span><br><span class="line">        setRawKthSon(raw, uid, kth);</span><br><span class="line">        <span class="comment">// 更新节点中的键的数量</span></span><br><span class="line">        setRawNoKeys(raw, noKeys + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果节点是非叶子节点</span></span><br><span class="line">        <span class="comment">// 获取插入位置的键</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">kk</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">        <span class="comment">// 在插入位置插入新的键</span></span><br><span class="line">        setRawKthKey(raw, key, kth);</span><br><span class="line">        <span class="comment">// 在插入位置后的所有键和子节点向后移动一位</span></span><br><span class="line">        shiftRawKth(raw, kth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在插入位置的下一个位置插入原来的键和新的子节点的UID</span></span><br><span class="line">        setRawKthKey(raw, kk, kth + <span class="number">1</span>);</span><br><span class="line">        setRawKthSon(raw, uid, kth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新节点中的键的数量</span></span><br><span class="line">        setRawNoKeys(raw, noKeys + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="split"><a href="#split" class="headerlink" title="split()"></a><code>split()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SplitRes</span> &#123;</span><br><span class="line">    <span class="type">long</span> newSon, newKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分裂B+树的节点。</span></span><br><span class="line"><span class="comment"> * 当一个节点的键的数量达到 `BALANCE_NUMBER * 2` 时，就意味着这个节点已经满了，需要进行分裂操作。</span></span><br><span class="line"><span class="comment"> * 分裂操作的目的是将一个满的节点分裂成两个节点，每个节点包含一半的键。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> SplitRes <span class="title function_">split</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的字节数组，用于存储新节点的原始数据</span></span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">nodeRaw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line">    <span class="comment">// 设置新节点的叶子节点标志，与原节点相同</span></span><br><span class="line">    setRawIsLeaf(nodeRaw, getRawIfLeaf(raw));</span><br><span class="line">    <span class="comment">// 设置新节点的键的数量为BALANCE_NUMBER</span></span><br><span class="line">    setRawNoKeys(nodeRaw, BALANCE_NUMBER);</span><br><span class="line">    <span class="comment">// 设置新节点的兄弟节点的UID，与原节点的兄弟节点的UID相同</span></span><br><span class="line">    setRawSibling(nodeRaw, getRawSibling(raw));</span><br><span class="line">    <span class="comment">// 从原节点的原始字节数组中复制一部分数据到新节点的原始字节数组中</span></span><br><span class="line">    copyRawFromKth(raw, nodeRaw, BALANCE_NUMBER);</span><br><span class="line">    <span class="comment">// 在数据管理器中插入新节点的原始数据，并获取新节点的UID</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">son</span> <span class="operator">=</span> tree.dm.insert(TransactionManagerImpl.SUPER_XID, nodeRaw.raw);</span><br><span class="line">    <span class="comment">// 更新原节点的键的数量为BALANCE_NUMBER</span></span><br><span class="line">    setRawNoKeys(raw, BALANCE_NUMBER);</span><br><span class="line">    <span class="comment">// 更新原节点的兄弟节点的UID为新节点的UID</span></span><br><span class="line">    setRawSibling(raw, son);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个SplitRes对象，用于存储分裂结果</span></span><br><span class="line">    <span class="type">SplitRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SplitRes</span>();</span><br><span class="line">    <span class="comment">// 设置新节点的UID</span></span><br><span class="line">    res.newSon = son;</span><br><span class="line">    <span class="comment">// 设置新键为新节点的第一个键的值</span></span><br><span class="line">    res.newKey = getRawKthKey(nodeRaw, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 返回分裂结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Table-Manager-TBM-表结构管理器"><a href="#Table-Manager-TBM-表结构管理器" class="headerlink" title="Table Manager (TBM) 表结构管理器"></a>Table Manager (TBM) 表结构管理器</h2><p>本章概述 TBM，即表管理器的实现。TBM 实现了对字段结构和表结构的管理。同时简要介绍 MYDB 使用的类 SQL 语句的解析。</p>
<h3 id="SQL-解析器"><a href="#SQL-解析器" class="headerlink" title="SQL 解析器"></a>SQL 解析器</h3><p><code>**Parser**</code> 实现了对类 <code>**SQL**</code> 语句的结构化解析，将语句中包含的信息封装为对应语句的类，这些类可见 <code>**top.guoziyang.mydb.backend.parser.statement**</code> 包。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">begin</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">begin</span> [isolation level (read committedrepeatable read)]</span><br><span class="line">        <span class="keyword">begin</span> isolation level read committed</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">commit</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">commit</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>abort statement<span class="operator">&gt;</span></span><br><span class="line">    abort</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">create</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">create table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    [(index <span class="operator">&lt;</span>field name list<span class="operator">&gt;</span>)]</span><br><span class="line">        <span class="keyword">create table</span> students</span><br><span class="line">        id int32,</span><br><span class="line">        name string,</span><br><span class="line">        age int32,</span><br><span class="line">        (index id name)</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">drop</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">drop</span> <span class="keyword">table</span> students</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> (<span class="operator">*</span><span class="operator">&lt;</span>field name list<span class="operator">&gt;</span>) <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> [<span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">select</span> name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">4</span></span><br><span class="line">        <span class="keyword">select</span> name, age, id <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">insert into</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="keyword">values</span> <span class="operator">&lt;</span><span class="keyword">value</span> list<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">insert into</span> student <span class="keyword">values</span> <span class="number">5</span> &quot;Zhang Yuanjia&quot; <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">delete</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="operator">=</span> &quot;Zhang Yuanjia&quot;</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">update</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="operator">&lt;</span>field name<span class="operator">&gt;=</span><span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span> [<span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> &quot;ZYJ&quot; <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">where</span> <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> (<span class="operator">&gt;</span><span class="operator">&lt;=</span>) <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span> [(andor) <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> (<span class="operator">&gt;</span><span class="operator">&lt;=</span>) <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">or</span> age <span class="operator">&lt;</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">    [a<span class="operator">-</span>zA<span class="operator">-</span>Z][a<span class="operator">-</span>zA<span class="operator">-</span>Z0<span class="number">-9</span>_]<span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    int32 int64 string</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span></span><br><span class="line">    .<span class="operator">*</span></span><br></pre></td></tr></table></figure>
<h4 id="Tokenizer类："><a href="#Tokenizer类：" class="headerlink" title="Tokenizer类："></a>Tokenizer类：</h4><ul>
<li>Tokenizer类用于对语句进行逐字节解析，根据空白符或者特定的词法规则，将语句切割成多个token。</li>
<li>提供了peek()和pop()方法，方便取出Token进行解析。</li>
<li>具体的切割实现在内部，不在此段内容中赘述。</li>
</ul>
<h5 id="peek"><a href="#peek" class="headerlink" title="peek()"></a><code>peek()</code></h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251021163347.png" alt="20251021163347"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前的标记，如果需要的话，会生成新的标记。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">peek</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flushToken) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            token = next();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            err = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        currentToken = token;</span><br><span class="line">        flushToken = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentToken;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下一个标记。如果存在错误，将抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;  <span class="comment">// 如果存在错误，抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextMetaState();  <span class="comment">// 否则，获取下一个元状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下一个元状态。元状态可以是一个符号、引号包围的字符串或者一个由字母、数字或下划线组成的标记。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">nextMetaState</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> peekByte();  <span class="comment">// 获取下一个字节</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  <span class="comment">// 如果没有下一个字节，返回空字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isBlank(b)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 如果下一个字节不是空白字符，跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        popByte();  <span class="comment">// 否则，跳过这个字节</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> peekByte();  <span class="comment">// 获取下一个字节</span></span><br><span class="line">    <span class="keyword">if</span> (isSymbol(b)) &#123;</span><br><span class="line">        popByte();  <span class="comment">// 如果这个字节是一个符号，跳过这个字节</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;b&#125;);  <span class="comment">// 并返回这个符号</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="string">&#x27;&quot;&#x27;</span> || b == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextQuoteState();  <span class="comment">// 如果这个字节是引号，获取下一个引号状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAlphaBeta(b) || isDigit(b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextTokenState();  <span class="comment">// 如果这个字节是字母、数字或下划线，获取下一个标记状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = Error.InvalidCommandException;  <span class="comment">// 否则，设置错误状态为无效的命令异常</span></span><br><span class="line">        <span class="keyword">throw</span> err;  <span class="comment">// 并抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下一个标记。标记是由字母、数字或下划线组成的字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">nextTokenState</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  <span class="comment">// 创建一个StringBuilder，用于存储标记</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> peekByte();  <span class="comment">// 获取下一个字节</span></span><br><span class="line">        <span class="comment">// 如果没有下一个字节，或者下一个字节不是字母、数字或下划线，那么结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span> || !(isAlphaBeta(b) || isDigit(b) || b == <span class="string">&#x27;_&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果下一个字节是空白字符，那么跳过这个字节</span></span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span> &amp;&amp; isBlank(b)) &#123;</span><br><span class="line">                popByte();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回标记</span></span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果下一个字节是字母、数字或下划线，那么将这个字节添加到StringBuilder中</span></span><br><span class="line">        sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;b&#125;));</span><br><span class="line">        popByte();  <span class="comment">// 跳过这个字节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理引号状态，即处理被引号包围的字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">nextQuoteState</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">quote</span> <span class="operator">=</span> peekByte();  <span class="comment">// 获取下一个字节，这应该是一个引号</span></span><br><span class="line">    popByte();  <span class="comment">// 跳过这个引号</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  <span class="comment">// 创建一个StringBuilder，用于存储被引号包围的字符串</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> peekByte();  <span class="comment">// 获取下一个字节</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">            err = Error.InvalidCommandException;  <span class="comment">// 如果没有下一个字节，设置错误状态为无效的命令异常</span></span><br><span class="line">            <span class="keyword">throw</span> err;  <span class="comment">// 并抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b == quote) &#123;</span><br><span class="line">            popByte();  <span class="comment">// 如果这个字节是引号，跳过这个字节，并跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;b&#125;));  <span class="comment">// 如果这个字节不是引号，将这个字节添加到StringBuilder中</span></span><br><span class="line">        popByte();  <span class="comment">// 并跳过这个字节</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();  <span class="comment">// 返回被引号包围的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a><code>pop()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前的标记设置为需要刷新，这样下次调用peek()时会生成新的标记。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    flushToken = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 跳过该字节，指向下一个字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">popByte</span><span class="params">()</span> &#123;</span><br><span class="line">    pos++;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; stat.length) &#123;</span><br><span class="line">        pos = stat.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Parser类"><a href="#Parser类" class="headerlink" title="Parser类"></a>Parser类</h4><ul>
<li>Parser类直接对外提供了Parse(byte[] statement)方法，用于解析语句。</li>
<li>解析过程核心是调用Tokenizer类来分割Token，并根据词法规则将Token包装成具体的Statement类，并返回。</li>
<li>解析过程相对简单，仅根据第一个Token来区分语句类型，并分别处理。</li>
<li>解析过程自己查看几遍源码即可，这里不多赘述</li>
</ul>
<h6 id="parse"><a href="#parse" class="headerlink" title="parse()"></a><code>parse()</code></h6><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251021163414.png" alt="20251021163414"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析输入的字节流，根据不同的标记（token）调用不同的解析方法，生成对应的语句对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">Parse</span><span class="params">(<span class="type">byte</span>[] statement)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Tokenizer</span> <span class="variable">tokenizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tokenizer</span>(statement);  <span class="comment">// 创建一个Tokenizer对象，用于获取标记</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> tokenizer.peek();  <span class="comment">// 获取下一个标记</span></span><br><span class="line">    tokenizer.pop();  <span class="comment">// 跳过这个标记</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 用于存储生成的语句对象</span></span><br><span class="line">    <span class="type">Exception</span> <span class="variable">statErr</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 用于存储错误信息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据标记的值，调用对应的解析方法</span></span><br><span class="line">        <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;begin&quot;</span>:</span><br><span class="line">                stat = parseBegin(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;commit&quot;</span>:</span><br><span class="line">                stat = parseCommit(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;abort&quot;</span>:</span><br><span class="line">                stat = parseAbort(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;create&quot;</span>:</span><br><span class="line">                stat = parseCreate(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;drop&quot;</span>:</span><br><span class="line">                stat = parseDrop(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;select&quot;</span>:</span><br><span class="line">                stat = parseSelect(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;insert&quot;</span>:</span><br><span class="line">                stat = parseInsert(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;delete&quot;</span>:</span><br><span class="line">                stat = parseDelete(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;update&quot;</span>:</span><br><span class="line">                stat = parseUpdate(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                stat = parseShow(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> Error.InvalidCommandException;  <span class="comment">// 如果标记的值不符合预期，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        statErr = e;  <span class="comment">// 如果在解析过程中出现错误，保存错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> tokenizer.peek();  <span class="comment">// 获取下一个标记</span></span><br><span class="line">        <span class="comment">// 如果还有未处理的标记，那么抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(next)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] errStat = tokenizer.errStat();</span><br><span class="line">            statErr = <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid statement: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(errStat));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="type">byte</span>[] errStat = tokenizer.errStat();</span><br><span class="line">        statErr = <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid statement: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(errStat));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在错误，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (statErr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> statErr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回生成的语句对象</span></span><br><span class="line">    <span class="keyword">return</span> stat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="字段与表管理"><a href="#字段与表管理" class="headerlink" title="字段与表管理"></a>字段与表管理</h3><p>注意，这里的字段与表管理，不是管理各个条目中不同的字段的数值等信息，而是管理表和字段的结构数据，例如表名、表字段信息和字段索引等。</p>
<h4 id="结构数据"><a href="#结构数据" class="headerlink" title="结构数据"></a>结构数据</h4><ol>
<li><strong>数据存储结构：</strong> 表和字段的信息以二进制形式存储在数据库的 Entry 中。</li>
<li><strong>字段信息表示：</strong> 字段的二进制表示包含字段名（FieldName）、字段类型（TypeName）和索引UID（IndexUid）。<ul>
<li>字段名和字段类型以及其他信息都以字节形式的字符串存储。</li>
<li><code>**[FieldName] [TypeName] [IndexUid]**</code></li>
<li>为了明确字符串的存储边界，采用了一种规定的字符串存储方式，即在字符串数据之前存储了字符串的长度信息。</li>
<li><code>**[StringLength] [StringData]**</code></li>
</ul>
</li>
<li><strong>字段类型限定：</strong> 字段的类型被限定为 int32、int64 和 string 类型。</li>
<li><strong>索引表示：</strong> 如果字段被索引，则IndexUid指向了索引二叉树的根节点；否则该字段的IndexUid为0。</li>
<li><strong>读取和解析：</strong> 通过唯一标识符（UID）从虚拟内存（VM）中读取字段信息，并根据上述结构解析该信息。</li>
</ol>
<h4 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h4><p><strong>基本定义</strong><br>对于Table的表结构是如下的：</p>
<ul>
<li><code>**[TableName] [NextTable] [Field1Uid][Field2Uid]...[FieldNUid]**</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table 维护了表结构</span></span><br><span class="line"><span class="comment"> * 二进制结构如下：</span></span><br><span class="line"><span class="comment"> * [TableName][NextTable]</span></span><br><span class="line"><span class="comment"> * [Field1Uid][Field2Uid]...[FieldNUid]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">    TableManager tbm; <span class="comment">// 表管理器，用于管理数据库表</span></span><br><span class="line">    <span class="type">long</span> uid; <span class="comment">// 表的唯一标识符</span></span><br><span class="line">    String name; <span class="comment">// 表的名称</span></span><br><span class="line">    <span class="type">byte</span> status; <span class="comment">// 表的状态</span></span><br><span class="line">    <span class="type">long</span> nextUid; <span class="comment">// 下一个表的唯一标识符</span></span><br><span class="line">    List&lt;Field&gt; fields = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 表的字段列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="createTable"><a href="#createTable" class="headerlink" title="createTable()"></a><code>createTable()</code></h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251021164132.png" alt="20251021164132"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的数据库表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tbm     表管理器，用于管理数据库表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nextUid 下一个表的唯一标识符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xid     事务ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> create  创建表的语句</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 创建的表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Table <span class="title function_">createTable</span><span class="params">(TableManager tbm, <span class="type">long</span> nextUid, <span class="type">long</span> xid, Create create)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的表对象</span></span><br><span class="line">    <span class="type">Table</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>(tbm, create.tableName, nextUid);</span><br><span class="line">    <span class="comment">// 遍历创建表语句中的所有字段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; create.fieldName.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取字段名和字段类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> create.fieldName[i];</span><br><span class="line">        <span class="type">String</span> <span class="variable">fieldType</span> <span class="operator">=</span> create.fieldType[i];</span><br><span class="line">        <span class="comment">// 判断该字段是否需要建立索引</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">indexed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; create.index.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fieldName.equals(create.index[j])) &#123;</span><br><span class="line">                indexed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个新的字段对象，并添加到表对象中</span></span><br><span class="line">        tb.fields.add(Field.createField(tb, xid, fieldName, fieldType, indexed));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将表对象的状态持久化到存储系统中，并返回表对象</span></span><br><span class="line">    <span class="keyword">return</span> tb.persistSelf(xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="persistSelf"><a href="#persistSelf" class="headerlink" title="persistSelf()"></a><code>persistSelf()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Table对象的状态持久化到存储系统中。 [TableName] [NextTable] [Field1Uid][Field2Uid]...[FieldNUid]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xid 事务ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前Table对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 如果存在错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Table <span class="title function_">persistSelf</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 将表名转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] nameRaw = Parser.string2Byte(name);</span><br><span class="line">    <span class="comment">// 将下一个uid转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] nextRaw = Parser.long2Byte(nextUid);</span><br><span class="line">    <span class="comment">// 创建一个空的字节数组，用于存储字段的uid</span></span><br><span class="line">    <span class="type">byte</span>[] fieldRaw = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 遍历所有的字段</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="comment">// 将字段的uid转换为字节数组，并添加到fieldRaw中</span></span><br><span class="line">        fieldRaw = Bytes.concat(fieldRaw, Parser.long2Byte(field.uid));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将表名、下一个uid和所有字段的uid插入到存储系统中，返回插入的uid</span></span><br><span class="line">    uid = ((TableManagerImpl) tbm).vm.insert(xid, Bytes.concat(nameRaw, nextRaw, fieldRaw));</span><br><span class="line">    <span class="comment">// 返回当前Table对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="loadTable"><a href="#loadTable" class="headerlink" title="loadTable()"></a><code>loadTable()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个静态方法用于从数据库中加载一个表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Table <span class="title function_">loadTable</span><span class="params">(TableManager tbm, <span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个字节数组用于存储从数据库中读取的原始数据</span></span><br><span class="line">    <span class="type">byte</span>[] raw = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用表管理器的版本管理器从数据库中读取指定uid的表的原始数据</span></span><br><span class="line">        raw = ((TableManagerImpl) tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果在读取过程中发生异常，调用Panic.panic方法处理异常</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断言原始数据不为空</span></span><br><span class="line">    <span class="keyword">assert</span> raw != <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 创建一个新的表对象</span></span><br><span class="line">    <span class="type">Table</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>(tbm, uid);</span><br><span class="line">    <span class="comment">// 使用原始数据解析表对象，并返回这个表对象</span></span><br><span class="line">    <span class="keyword">return</span> tb.parseSelf(raw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="parseSelf"><a href="#parseSelf" class="headerlink" title="parseSelf()"></a><code>parseSelf()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法用于解析表对象</span></span><br><span class="line"><span class="comment">// [TableName] [NextTable] [Field1Uid][Field2Uid]...[FieldNUid]</span></span><br><span class="line"><span class="keyword">private</span> Table <span class="title function_">parseSelf</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化位置变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 使用Parser.parseString方法解析原始数据中的字符串</span></span><br><span class="line">    <span class="type">ParseStringRes</span> <span class="variable">res</span> <span class="operator">=</span> Parser.parseString(raw);</span><br><span class="line">    <span class="comment">// 将解析出的字符串赋值给表的名称</span></span><br><span class="line">    name = res.str;</span><br><span class="line">    <span class="comment">// 更新位置变量</span></span><br><span class="line">    position += res.next;</span><br><span class="line">    <span class="comment">// 使用Parser.parseLong方法解析原始数据中的长整数，并赋值给下一个uid</span></span><br><span class="line">    nextUid = Parser.parseLong(Arrays.copyOfRange(raw, position, position + <span class="number">8</span>));</span><br><span class="line">    <span class="comment">// 更新位置变量</span></span><br><span class="line">    position += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当位置变量小于原始数据的长度时，继续循环</span></span><br><span class="line">    <span class="keyword">while</span> (position &lt; raw.length) &#123;</span><br><span class="line">        <span class="comment">// 使用Parser.parseLong方法解析原始数据中的长整数，并赋值给uid</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">uid</span> <span class="operator">=</span> Parser.parseLong(Arrays.copyOfRange(raw, position, position + <span class="number">8</span>));</span><br><span class="line">        <span class="comment">// 更新位置变量</span></span><br><span class="line">        position += <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// 使用Field.loadField方法加载字段，并添加到表的字段列表中</span></span><br><span class="line">        fields.add(Field.loadField(<span class="built_in">this</span>, uid));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回当前表对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><p><strong>基本定义</strong><br>对于字段结构的定义是如下的：</p>
<ul>
<li><code>**[FieldName] [TypeName] [IndexUid]**</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * field 表示字段信息</span></span><br><span class="line"><span class="comment"> * 二进制格式为：</span></span><br><span class="line"><span class="comment"> * [FieldName][TypeName][IndexUid]</span></span><br><span class="line"><span class="comment"> * 如果field无索引，IndexUid为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Field</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唯一标识符，用于标识每个Field对象</span></span><br><span class="line">    <span class="type">long</span> uid;</span><br><span class="line">    <span class="comment">// Field对象所属的表</span></span><br><span class="line">    <span class="keyword">private</span> Table tb;</span><br><span class="line">    <span class="comment">// 字段名，用于标识表中的每个字段</span></span><br><span class="line">    String fieldName;</span><br><span class="line">    <span class="comment">// 字段类型，用于标识字段的数据类型</span></span><br><span class="line">    String fieldType;</span><br><span class="line">    <span class="comment">// 索引，用于标识字段是否有索引，如果索引为0，表示没有索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> index;</span><br><span class="line">    <span class="comment">// B+树，用于存储索引，如果字段有索引，这个B+树会被加载</span></span><br><span class="line">    <span class="keyword">private</span> BPlusTree bt;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="createField"><a href="#createField" class="headerlink" title="createField()"></a><code>createField()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的Field对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tb        表对象，Field对象所属的表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xid       事务ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fieldName 字段名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fieldType 字段类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> indexed   是否创建索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回创建的Field对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 如果字段类型无效或者创建B+树索引失败，会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">createField</span><span class="params">(Table tb, <span class="type">long</span> xid, String fieldName, String fieldType, <span class="type">boolean</span> indexed)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    typeCheck(fieldType);  <span class="comment">// 检查字段类型是否有效</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Field</span>(tb, fieldName, fieldType, <span class="number">0</span>);  <span class="comment">// 创建一个新的Field对象</span></span><br><span class="line">    <span class="keyword">if</span> (indexed) &#123;  <span class="comment">// 如果需要创建索引</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> BPlusTree.create(((TableManagerImpl) tb.tbm).dm);  <span class="comment">// 创建一个新的B+树索引</span></span><br><span class="line">        <span class="type">BPlusTree</span> <span class="variable">bt</span> <span class="operator">=</span> BPlusTree.load(index, ((TableManagerImpl) tb.tbm).dm);  <span class="comment">// 加载这个B+树索引</span></span><br><span class="line">        f.index = index;  <span class="comment">// 设置Field对象的索引</span></span><br><span class="line">        f.bt = bt;  <span class="comment">// 设置Field对象的B+树</span></span><br><span class="line">    &#125;</span><br><span class="line">    f.persistSelf(xid);  <span class="comment">// 将Field对象持久化到存储中</span></span><br><span class="line">    <span class="keyword">return</span> f;  <span class="comment">// 返回创建的Field对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">typeCheck</span><span class="params">(String fieldType)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;int32&quot;</span>.equals(fieldType) &amp;&amp; !<span class="string">&quot;int64&quot;</span>.equals(fieldType) &amp;&amp; !<span class="string">&quot;string&quot;</span>.equals(fieldType)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.InvalidFieldException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="persistSelf-1"><a href="#persistSelf-1" class="headerlink" title="persistSelf()"></a><code>persistSelf()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前Field对象持久化到存储中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">persistSelf</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 将字段名转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] nameRaw = Parser.string2Byte(fieldName);</span><br><span class="line">    <span class="comment">// 将字段类型转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] typeRaw = Parser.string2Byte(fieldType);</span><br><span class="line">    <span class="comment">// 将索引转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] indexRaw = Parser.long2Byte(index);</span><br><span class="line">    <span class="comment">// 将字段名、字段类型和索引的字节数组合并，然后插入到持久化存储中</span></span><br><span class="line">    <span class="comment">// 插入成功后，会返回一个唯一的uid，将这个uid设置为当前Field对象的uid</span></span><br><span class="line">    <span class="built_in">this</span>.uid = ((TableManagerImpl) tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="loadField"><a href="#loadField" class="headerlink" title="loadField()"></a><code>loadField()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从持久化存储中加载一个Field对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">loadField</span><span class="params">(Table tb, <span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] raw = <span class="literal">null</span>;  <span class="comment">// 用于存储从持久化存储中读取的原始字节数据</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从持久化存储中读取uid对应的原始字节数据</span></span><br><span class="line">        raw = ((TableManagerImpl) tb.tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果读取过程中出现异常，调用Panic.panic方法处理异常</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断言原始字节数据不为null，如果为null，那么会抛出AssertionError</span></span><br><span class="line">    <span class="keyword">assert</span> raw != <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 创建一个新的Field对象，并调用parseSelf方法解析原始字节数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Field</span>(uid, tb).parseSelf(raw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="parseSelf-1"><a href="#parseSelf-1" class="headerlink" title="parseSelf()"></a><code>parseSelf()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析原始字节数组并设置字段名、字段类型和索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raw 原始字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前Field对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Field <span class="title function_">parseSelf</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 初始化位置为0</span></span><br><span class="line">    <span class="type">ParseStringRes</span> <span class="variable">res</span> <span class="operator">=</span> Parser.parseString(raw);  <span class="comment">// 解析原始字节数组，获取字段名和下一个位置</span></span><br><span class="line">    fieldName = res.str;  <span class="comment">// 设置字段名</span></span><br><span class="line">    position += res.next;  <span class="comment">// 更新位置</span></span><br><span class="line"></span><br><span class="line">    res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));  <span class="comment">// 从新的位置开始解析原始字节数组，获取字段类型和下一个位置</span></span><br><span class="line">    fieldType = res.str;  <span class="comment">// 设置字段类型</span></span><br><span class="line">    position += res.next;  <span class="comment">// 更新位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position + <span class="number">8</span>));  <span class="comment">// 从新的位置开始解析原始字节数组，获取索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;  <span class="comment">// 如果索引不为0，说明存在B+树索引</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bt = BPlusTree.load(index, ((TableManagerImpl) tb.tbm).dm);  <span class="comment">// 加载B+树索引</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Panic.panic(e);  <span class="comment">// 如果加载失败，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;  <span class="comment">// 返回当前Field对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Where查询条件"><a href="#Where查询条件" class="headerlink" title="Where查询条件"></a>Where查询条件</h4><h5 id="parseWhere"><a href="#parseWhere" class="headerlink" title="parseWhere()"></a><code>parseWhere()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析 WHERE 子句并返回满足条件的记录的 uid 列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Long&gt; <span class="title function_">parseWhere</span><span class="params">(Where where)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 初始化搜索范围和标志位</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">l0</span> <span class="operator">=</span> <span class="number">0</span>, r0 = <span class="number">0</span>, l1 = <span class="number">0</span>, r1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">single</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">fd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 WHERE 子句为空，则搜索所有记录</span></span><br><span class="line">    <span class="keyword">if</span> (where == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 寻找第一个有索引的字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.isIndexed()) &#123;</span><br><span class="line">                fd = field;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置搜索范围为整个 uid 空间</span></span><br><span class="line">        l0 = <span class="number">0</span>;</span><br><span class="line">        r0 = Long.MAX_VALUE;</span><br><span class="line">        single = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 WHERE 子句不为空，则根据 WHERE 子句解析搜索范围</span></span><br><span class="line">        <span class="comment">// 寻找 WHERE 子句中涉及的字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.fieldName.equals(where.singleExp1.field)) &#123;</span><br><span class="line">                <span class="comment">// 如果字段没有索引，则抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (!field.isIndexed()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> Error.FieldNotIndexedException;</span><br><span class="line">                &#125;</span><br><span class="line">                fd = field;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果字段不存在，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.FieldNotFoundException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算 WHERE 子句的搜索范围</span></span><br><span class="line">        <span class="type">CalWhereRes</span> <span class="variable">res</span> <span class="operator">=</span> calWhere(fd, where);</span><br><span class="line">        l0 = res.l0;</span><br><span class="line">        r0 = res.r0;</span><br><span class="line">        l1 = res.l1;</span><br><span class="line">        r1 = res.r1;</span><br><span class="line">        single = res.single;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在计算出的搜索范围内搜索记录</span></span><br><span class="line">    List&lt;Long&gt; uids = fd.search(l0, r0);</span><br><span class="line">    <span class="comment">// 如果 WHERE 子句包含 OR 运算符，则需要搜索两个范围，并将结果合并</span></span><br><span class="line">    <span class="keyword">if</span> (!single) &#123;</span><br><span class="line">        List&lt;Long&gt; tmp = fd.search(l1, r1);</span><br><span class="line">        uids.addAll(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回搜索结果</span></span><br><span class="line">    <span class="keyword">return</span> uids;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="calWhere"><a href="#calWhere" class="headerlink" title="calWhere()"></a><code>calWhere()</code></h5><h3 id="Booter"><a href="#Booter" class="headerlink" title="Booter"></a>Booter</h3><p>前言</p>
<h4 id="启动信息管理"><a href="#启动信息管理" class="headerlink" title="启动信息管理"></a>启动信息管理</h4><ul>
<li>MYDB的启动信息存储在<strong>bt</strong>文件中，其中所需的信息只有一个，即头表的UID。</li>
<li><strong>Booter</strong>类提供了<strong>load</strong>和<strong>update</strong>两个方法，用于加载和更新启动信息。</li>
<li><strong>update</strong>方法在修改<strong>bt</strong>文件内容时，采取了一种保证原子性的策略，即先将内容写入一个临时文件<strong>bt_tmp</strong>中，然后通过操作系统的重命名操作将临时文件重命名为<strong>bt</strong>文件。</li>
<li>通过这种方式，利用操作系统重命名文件的原子性，来确保对<strong>bt</strong>文件的修改操作是原子的，从而保证了启动信息的一致性和正确性。</li>
</ul>
<h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 记录第一个表的uid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Booter</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库启动信息文件的后缀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BOOTER_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.bt&quot;</span>;</span><br><span class="line">    <span class="comment">// 数据库启动信息文件的临时后缀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BOOTER_TMP_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.bt_tmp&quot;</span>;</span><br><span class="line">    <span class="comment">// 数据库启动信息文件的路径</span></span><br><span class="line">    String path;</span><br><span class="line">    <span class="comment">// 数据库启动信息文件</span></span><br><span class="line">    File file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="create-and-open"><a href="#create-and-open" class="headerlink" title="create() and open()"></a><code>create() and open()</code></h4><p>通过创建或打开启动信息文件，来进行数据库的校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的Booter对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Booter <span class="title function_">create</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="comment">// 删除可能存在的临时文件</span></span><br><span class="line">    removeBadTmp(path);</span><br><span class="line">    <span class="comment">// 创建一个新的文件对象，文件名是路径加上启动信息文件的后缀</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_SUFFIX);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试创建新的文件，如果文件已存在，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!f.createNewFile()) &#123;</span><br><span class="line">            Panic.panic(Error.FileExistsException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果创建文件过程中出现异常，则处理异常</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查文件是否可读写，如果不可读写，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!f.canRead() || !f.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新创建的Booter对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Booter</span>(path, f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开一个已存在的Booter对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Booter <span class="title function_">open</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="comment">// 删除可能存在的临时文件</span></span><br><span class="line">    removeBadTmp(path);</span><br><span class="line">    <span class="comment">// 创建一个新的文件对象，文件名是路径加上启动信息文件的后缀</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_SUFFIX);</span><br><span class="line">    <span class="comment">// 如果文件不存在，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">        Panic.panic(Error.FileNotExistsException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查文件是否可读写，如果不可读写，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!f.canRead() || !f.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回打开的Booter对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Booter</span>(path, f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除可能存在的临时文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeBadTmp</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="comment">// 删除路径加上临时文件后缀的文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_TMP_SUFFIX).delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="load"><a href="#load" class="headerlink" title="load()"></a><code>load()</code></h4><p>加载文件启动信息文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] load() &#123;</span><br><span class="line">    <span class="type">byte</span>[] buf = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取文件的所有字节</span></span><br><span class="line">        buf = Files.readAllBytes(file.toPath());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="update"><a href="#update" class="headerlink" title="update()"></a><code>update()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新启动信息文件的内容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 要写入文件的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的临时文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_TMP_SUFFIX);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试创建新的临时文件</span></span><br><span class="line">        tmp.createNewFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果创建文件过程中出现异常，则处理异常</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查临时文件是否可读写，如果不可读写，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp.canRead() || !tmp.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(tmp)) &#123;</span><br><span class="line">        <span class="comment">// 将数据写入临时文件</span></span><br><span class="line">        out.write(data);</span><br><span class="line">        <span class="comment">// 刷新输出流，确保数据被写入文件</span></span><br><span class="line">        out.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果写入文件过程中出现异常，则处理异常</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将临时文件移动到启动信息文件的位置，替换原来的文件</span></span><br><span class="line">        Files.move(tmp.toPath(), <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果移动文件过程中出现异常，则处理异常</span></span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新file字段为新的启动信息文件</span></span><br><span class="line">    file = <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_SUFFIX);</span><br><span class="line">    <span class="comment">// 检查新的启动信息文件是否可读写，如果不可读写，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!file.canRead() || !file.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TableManager"><a href="#TableManager" class="headerlink" title="TableManager"></a>TableManager</h3><p><strong>基本定义</strong></p>
<ul>
<li><strong>TableManager</strong>中的方法直接返回执行结果，比如错误信息或者可读的结果信息的字节数组。</li>
<li>这些方法的实现相对简单，主要是调用（VM）相关的方法来完成数据库操作。</li>
<li>在创建新表时，采用了头插法，即每次创建表都将新表插入到链表的头部。这意味着最新创建的表会成为链表的第一个元素。由于使用了头插法，每次创建表都会改变表链表的头部，因此需要更新<strong>Booter</strong>文件，以便记录新的头表的UID。</li>
<li>在创建TBM对象时，会初始化表信息<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TableManager</span> &#123;</span><br><span class="line">    BeginRes <span class="title function_">begin</span><span class="params">(Begin begin)</span>;</span><br><span class="line">    <span class="type">byte</span>[] commit(<span class="type">long</span> xid) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] abort(<span class="type">long</span> xid);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] show(<span class="type">long</span> xid);</span><br><span class="line">    <span class="type">byte</span>[] create(<span class="type">long</span> xid, Create create) <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] insert(<span class="type">long</span> xid, Insert insert) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] read(<span class="type">long</span> xid, Select select) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] update(<span class="type">long</span> xid, Update update) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] delete(<span class="type">long</span> xid, Delete delete) <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">TableManager</span> &#123;</span><br><span class="line">    VersionManager vm; <span class="comment">// 版本管理器，用于管理事务的版本</span></span><br><span class="line">    DataManager dm; <span class="comment">// 数据管理器，用于管理数据的存储和读取</span></span><br><span class="line">    <span class="keyword">private</span> Booter booter; <span class="comment">// 启动信息管理器，用于管理数据库启动信息</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Table&gt; tableCache; <span class="comment">// 表缓存，用于缓存已加载的表，键是表名，值是表对象</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Table&gt;&gt; xidTableCache; <span class="comment">// 事务表缓存，用于缓存每个事务修改过的表，键是事务ID，值是表对象列表</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock; <span class="comment">// 锁，用于同步多线程操作</span></span><br><span class="line">    </span><br><span class="line">    TableManagerImpl(VersionManager vm, DataManager dm, Booter booter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.vm = vm;</span><br><span class="line">        <span class="built_in">this</span>.dm = dm;</span><br><span class="line">        <span class="built_in">this</span>.booter = booter;</span><br><span class="line">        <span class="built_in">this</span>.tableCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.xidTableCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        loadTables();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="loadTables"><a href="#loadTables" class="headerlink" title=" loadTables()"></a><code> loadTables()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载所有的数据库表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadTables</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取第一个表的UID</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">uid</span> <span class="operator">=</span> firstTableUid();</span><br><span class="line">    <span class="comment">// 当UID不为0时，表示还有表需要加载</span></span><br><span class="line">    <span class="keyword">while</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载表，并获取表的UID</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">tb</span> <span class="operator">=</span> Table.loadTable(<span class="built_in">this</span>, uid);</span><br><span class="line">        <span class="comment">// 更新UID为下一个表的UID</span></span><br><span class="line">        uid = tb.nextUid;</span><br><span class="line">        <span class="comment">// 将加载的表添加到表缓存中</span></span><br><span class="line">        tableCache.put(tb.name, tb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 Botter 文件的前八位字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">firstTableUid</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] raw = booter.load();</span><br><span class="line">    <span class="keyword">return</span> Parser.parseLong(raw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="create"><a href="#create" class="headerlink" title="create()"></a><code>create()</code></h4><p>这里主要讲解一下 <code>create</code>方法，其他方法都是调用 VM 层</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251021164705.png" alt="20251021164705"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] create(<span class="type">long</span> xid, Create create) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 加锁，防止多线程并发操作</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查表是否已存在，如果存在则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (tableCache.containsKey(create.tableName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.DuplicatedTableException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建新的表，并获取表的UID</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> Table.createTable(<span class="built_in">this</span>, firstTableUid(), xid, create);</span><br><span class="line">        <span class="comment">// 更新第一个表的UID</span></span><br><span class="line">        updateFirstTableUid(table.uid);</span><br><span class="line">        <span class="comment">// 将新创建的表添加到表缓存中</span></span><br><span class="line">        tableCache.put(create.tableName, table);</span><br><span class="line">        <span class="comment">// 如果事务表缓存中没有当前事务ID的条目，则添加一个新的条目</span></span><br><span class="line">        <span class="keyword">if</span> (!xidTableCache.containsKey(xid)) &#123;</span><br><span class="line">            xidTableCache.put(xid, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新创建的表添加到当前事务的表列表中</span></span><br><span class="line">        xidTableCache.get(xid).add(table);</span><br><span class="line">        <span class="comment">// 返回创建成功的消息</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;create &quot;</span> + create.tableName).getBytes();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端客户端的实现及其通信规则"><a href="#服务端客户端的实现及其通信规则" class="headerlink" title="服务端客户端的实现及其通信规则"></a>服务端客户端的实现及其通信规则</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在MYDB 中传输数据使用了一种特殊的二进制格式，用于客户端和通信端之间的通信。在数据的传输和接受之前，会通过<code>Package</code>进行数据的加密以及解密：</p>
<ul>
<li><code>**[Flag] [Data]**</code></li>
<li>若 flag 为 0，表示发送的是数据，那么 data 即为这份数据本身，err 就为空</li>
<li>若 flag 为 1，表示发送的是错误信息，那么 data 为空， err 为错误提示信息<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data; <span class="comment">// 存放数据信息</span></span><br><span class="line">    Exception err; <span class="comment">// 存放错误提示信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Package</span><span class="params">(<span class="type">byte</span>[] data, Exception err)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.err = err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p>用于将数据加密成<strong>十六进制</strong>数据，这样可以避免特殊字符造成的问题，并在信息末尾加上换行符。这样在发送和接受数据时，可以简单使用 <code>BufferedReader</code> 和 <code>BufferedWrite</code>进行读写数据；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Package对象编码为字节数组。</span></span><br><span class="line"><span class="comment">     * 如果Package对象中的错误信息不为空，将错误信息编码为字节数组，并在字节数组前添加一个字节1。</span></span><br><span class="line"><span class="comment">     * 如果Package对象中的错误信息为空，将数据编码为字节数组，并在字节数组前添加一个字节0。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] encode(Package pkg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">err</span> <span class="operator">=</span> pkg.getErr();</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Intern server error!&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (err.getMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">                msg = err.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>&#125;, msg.getBytes());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>&#125;, pkg.getData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字节数组解码为Package对象。</span></span><br><span class="line"><span class="comment">     * 如果字节数组的长度小于1，抛出InvalidPkgDataException异常。</span></span><br><span class="line"><span class="comment">     * 如果字节数组的第一个字节为0，将字节数组的剩余部分解码为数据，创建一个新的Package对象，其中数据为解码后的数据，错误信息为null。</span></span><br><span class="line"><span class="comment">     * 如果字节数组的第一个字节为1，将字节数组的剩余部分解码为错误信息，创建一个新的Package对象，其中数据为null，错误信息为解码后的错误信息。</span></span><br><span class="line"><span class="comment">     * 如果字节数组的第一个字节既不是0也不是1，抛出InvalidPkgDataException异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">decode</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length), <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length))));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Transporter"><a href="#Transporter" class="headerlink" title="Transporter"></a>Transporter</h4><p>编码之后的信息会通过 <code>Transporter</code>类，写入输出流发送出去；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader; <span class="comment">// 字节缓冲流</span></span><br><span class="line">    <span class="keyword">private</span> BufferedWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transporter</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="built_in">this</span>.writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">raw</span> <span class="operator">=</span> hexEncode(data);</span><br><span class="line">        writer.write(raw);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] receive() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexDecode(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        writer.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字节数组转换为十六进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">hexEncode</span><span class="params">(<span class="type">byte</span>[] buf)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(buf, <span class="literal">true</span>)+<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将十六进制字符串转换回字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] hexDecode(String buf) <span class="keyword">throws</span> DecoderException &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.decodeHex(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Packager"><a href="#Packager" class="headerlink" title="Packager"></a>Packager</h4><p><code>Packager</code> 则是 <code>Encoder</code> 和 <code>Transporter</code> 的结合体，直接对外提供 <code>send</code> 和 <code>receive</code> 方法： bmn</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Packager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Transporter transpoter;</span><br><span class="line">    <span class="keyword">private</span> Encoder encoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Packager</span><span class="params">(Transporter transpoter, Encoder encoder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transpoter = transpoter;</span><br><span class="line">        <span class="built_in">this</span>.encoder = encoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将信息编码之后发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = encoder.encode(pkg);</span><br><span class="line">        transpoter.send(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据接收之后解密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">receive</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = transpoter.receive();</span><br><span class="line">        <span class="keyword">return</span> encoder.decode(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        transpoter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="服务端和客户端的实现"><a href="#服务端和客户端的实现" class="headerlink" title="服务端和客户端的实现"></a>服务端和客户端的实现</h3><p>Server 和 Client，都是使用了Java 的 socket；这一块内容属于 Java 网络编程的，可以通过 <a target="_blank" rel="noopener" href="https://www.javabetter.cn/socket/network-base.html">二哥的进阶之路</a> 学习；</p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p><code>**Server**</code>是一个服务器类，主要作用是监听指定的端口号，接受客户端的连接请求，并为每个连接请求创建一个新的线程来处理；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    TableManager tbm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Server</span><span class="params">(<span class="type">int</span> port, TableManager tbm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="built_in">this</span>.tbm = tbm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个ServerSocket对象，用于监听指定的端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server listen to port: &quot;</span> + port);</span><br><span class="line">        <span class="comment">// 创建一个线程池，用于管理处理客户端连接请求的线程</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">tpe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 无限循环，等待并处理客户端的连接请求</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 接收一个客户端的连接请求</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="comment">// 创建一个新的HandleSocket对象，用于处理这个连接请求</span></span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandleSocket</span>(socket, tbm);</span><br><span class="line">                <span class="comment">// 将这个HandleSocket对象提交给线程池，由线程池中的一个线程来执行</span></span><br><span class="line">                tpe.execute(worker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在最后，无论是否发生异常，都要关闭ServerSocket</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="HandleSocket"><a href="#HandleSocket" class="headerlink" title="HandleSocket"></a>HandleSocket</h5><p>HandleSocket 类实现了 <code>**Runnable**</code>** <strong>接口，在建立连接后初始化 <code>**Packager**</code>，随后就循环接收来自客户端的数据并处理；主要通过 <code>**Executor**</code></strong> <strong>对象来执行 <code>**SQL**</code>语句，在接受、执行SQL语句的过程中发生异常的话，将会结束循环，并关闭 <code>**Executor**</code></strong> **和 <code>**Package**</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HandleSocket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> TableManager tbm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandleSocket</span><span class="params">(Socket socket, TableManager tbm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        <span class="built_in">this</span>.tbm = tbm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取远程客户端的地址信息</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> (InetSocketAddress) socket.getRemoteSocketAddress();</span><br><span class="line">        <span class="comment">// 打印客户端的IP地址和端口号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Establish connection: &quot;</span> + address.getAddress().getHostAddress() + <span class="string">&quot;:&quot;</span> + address.getPort());</span><br><span class="line">        <span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个Transporter对象，用于处理网络传输</span></span><br><span class="line">            <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">            <span class="comment">// 创建一个Encoder对象，用于处理数据的编码和解码</span></span><br><span class="line">            <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">            <span class="comment">// 创建一个Packager对象，用于处理数据的打包和解包</span></span><br><span class="line">            packager = <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果在创建Transporter或Encoder时发生异常，打印异常信息并关闭socket</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个Executor对象，用于执行SQL语句</span></span><br><span class="line">        <span class="type">Executor</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Executor</span>(tbm);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从客户端接收数据包</span></span><br><span class="line">                pkg = packager.receive();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 如果在接收数据包时发生异常，结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取数据包中的SQL语句</span></span><br><span class="line">            <span class="type">byte</span>[] sql = pkg.getData();</span><br><span class="line">            <span class="type">byte</span>[] result = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行SQL语句，并获取结果</span></span><br><span class="line">                result = exe.execute(sql);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                <span class="comment">// 如果在执行SQL语句时发生异常，保存异常信息</span></span><br><span class="line">                e = e1;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建一个新的数据包，包含执行结果和可能的异常信息</span></span><br><span class="line">            pkg = <span class="keyword">new</span> <span class="title class_">Package</span>(result, e);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将数据包发送回客户端</span></span><br><span class="line">                packager.send(pkg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                <span class="comment">// 如果在发送数据包时发生异常，打印异常信息并结束循环</span></span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭Executor</span></span><br><span class="line">        exe.close();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭Packager</span></span><br><span class="line">            packager.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果在关闭Packager时发生异常，打印异常信息</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h5><p>这个类是服务器的启动入口，这个类解析了命令行参数。很重要的参数就是<code>-open</code>或者<code>-create</code>。<code>Launcher</code>根据这两个参数，来决定是创建数据库文件，还是启动一个已有的数据库；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">    <span class="comment">// 定义服务器监听的端口号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">    <span class="comment">// 定义默认的内存大小，这里是64MB，用于数据管理器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">DEFALUT_MEM</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) * <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 定义一些内存单位，用于解析命令行参数中的内存大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">KB</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">10</span>; <span class="comment">// 1KB</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MB</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">20</span>; <span class="comment">// 1MB</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">GB</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 1GB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Options</span>();</span><br><span class="line">        options.addOption(<span class="string">&quot;open&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;-open DBPath&quot;</span>);</span><br><span class="line">        options.addOption(<span class="string">&quot;create&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;-create DBPath&quot;</span>);</span><br><span class="line">        options.addOption(<span class="string">&quot;mem&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;-mem 64MB&quot;</span>);</span><br><span class="line">        <span class="type">CommandLineParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultParser</span>();</span><br><span class="line">        <span class="type">CommandLine</span> <span class="variable">cmd</span> <span class="operator">=</span> parser.parse(options, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd.hasOption(<span class="string">&quot;open&quot;</span>)) &#123;</span><br><span class="line">            openDB(cmd.getOptionValue(<span class="string">&quot;open&quot;</span>), parseMem(cmd.getOptionValue(<span class="string">&quot;mem&quot;</span>)));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cmd.hasOption(<span class="string">&quot;create&quot;</span>)) &#123;</span><br><span class="line">            createDB(cmd.getOptionValue(<span class="string">&quot;create&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usage: launcher (open|create) DBPath&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建新的数据库</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 数据库路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createDB</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建事务管理器</span></span><br><span class="line">        <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.create(path);</span><br><span class="line">        <span class="comment">// 创建数据管理器</span></span><br><span class="line">        <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.create(path, DEFALUT_MEM, tm);</span><br><span class="line">        <span class="comment">// 创建版本管理器</span></span><br><span class="line">        <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">        <span class="comment">// 创建表管理器</span></span><br><span class="line">        TableManager.create(path, vm, dm);</span><br><span class="line">        tm.close();</span><br><span class="line">        dm.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动已有的数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">openDB</span><span class="params">(String path, <span class="type">long</span> mem)</span> &#123;</span><br><span class="line">        <span class="comment">// 打开事务管理器</span></span><br><span class="line">        <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.open(path);</span><br><span class="line">        <span class="comment">// 打开数据管理器，传入路径、内存大小和事务管理器</span></span><br><span class="line">        <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.open(path, mem, tm);</span><br><span class="line">        <span class="comment">// 创建版本管理器，传入事务管理器和数据管理器</span></span><br><span class="line">        <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">        <span class="comment">// 打开表管理器，传入路径、版本管理器和数据管理器</span></span><br><span class="line">        <span class="type">TableManager</span> <span class="variable">tbm</span> <span class="operator">=</span> TableManager.open(path, vm, dm);</span><br><span class="line">        <span class="comment">// 创建服务器对象，并启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Server</span>(port, tbm).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法，用于解析命令行参数中的内存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">parseMem</span><span class="params">(String memStr)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果内存大小为空或者为空字符串，那么返回默认的内存大小</span></span><br><span class="line">        <span class="keyword">if</span> (memStr == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(memStr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> DEFALUT_MEM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果内存大小的字符串长度小于2，那么抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (memStr.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Panic.panic(Error.InvalidMemException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取内存大小的单位，即字符串的后两个字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">unit</span> <span class="operator">=</span> memStr.substring(memStr.length() - <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 获取内存大小的数值部分，即字符串的前部分，并转换为数字</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">memNum</span> <span class="operator">=</span> Long.parseLong(memStr.substring(<span class="number">0</span>, memStr.length() - <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 根据内存单位，计算并返回最终的内存大小</span></span><br><span class="line">        <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;KB&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> memNum * KB;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;MB&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> memNum * MB;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;GB&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> memNum * GB;</span><br><span class="line">            <span class="comment">// 如果内存单位不是KB、MB或GB，那么抛出异常</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Panic.panic(Error.InvalidMemException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有匹配到任何情况，那么返回默认的内存大小</span></span><br><span class="line">        <span class="keyword">return</span> DEFALUT_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>解析客户输入的内容；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="comment">// RoundTripper实例，用于处理请求的往返传输</span></span><br><span class="line">    <span class="keyword">private</span> RoundTripper rt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，接收一个Packager对象作为参数，并创建一个新的RoundTripper实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Client</span><span class="params">(Packager packager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rt = <span class="keyword">new</span> <span class="title class_">RoundTripper</span>(packager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execute方法，接收一个字节数组作为参数，将其封装为一个Package对象，并通过RoundTripper发送</span></span><br><span class="line">    <span class="comment">// 如果响应的Package对象中包含错误，那么抛出这个错误</span></span><br><span class="line">    <span class="comment">// 否则，返回响应的Package对象中的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] execute(<span class="type">byte</span>[] stat) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Package</span>(stat, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Package</span> <span class="variable">resPkg</span> <span class="operator">=</span> rt.roundTrip(pkg);</span><br><span class="line">        <span class="keyword">if</span>(resPkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> resPkg.getErr();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resPkg.getData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close方法，关闭RoundTripper</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rt.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RoundTripper"><a href="#RoundTripper" class="headerlink" title="RoundTripper"></a>RoundTripper</h5><p>用于发送请求并接受响应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundTripper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Packager packager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoundTripper</span><span class="params">(Packager packager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.packager = packager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法，用于处理请求的往返传输</span></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">roundTrip</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 发送请求包</span></span><br><span class="line">        packager.send(pkg);</span><br><span class="line">        <span class="comment">// 接收响应包，并返回</span></span><br><span class="line">        <span class="keyword">return</span> packager.receive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        packager.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h5><p>用于接受用户的输入，并调用<code>Client.execute()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Client client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shell</span><span class="params">(Client client)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个运行方法，用于启动客户端的交互式命令行界面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个Scanner对象，用于读取用户的输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环接收用户的输入，直到用户输入&quot;exit&quot;或&quot;quit&quot;</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 打印提示符</span></span><br><span class="line">                System.out.print(<span class="string">&quot;:&gt; &quot;</span>);</span><br><span class="line">                <span class="comment">// 读取用户的输入</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">statStr</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 如果用户输入&quot;exit&quot;或&quot;quit&quot;，则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(statStr) || <span class="string">&quot;quit&quot;</span>.equals(statStr)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 尝试执行用户的输入命令，并打印执行结果</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 将用户的输入转换为字节数组，并执行</span></span><br><span class="line">                    <span class="type">byte</span>[] res = client.execute(statStr.getBytes());</span><br><span class="line">                    <span class="comment">// 将执行结果转换为字符串，并打印</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(res));</span><br><span class="line">                    <span class="comment">// 如果在执行过程中发生异常，打印异常信息</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论是否发生异常，都要关闭Scanner和Client</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭Scanner</span></span><br><span class="line">            sc.close();</span><br><span class="line">            <span class="comment">// 关闭Client</span></span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Launcher-1"><a href="#Launcher-1" class="headerlink" title="Launcher"></a>Launcher</h5><p>启动客户端并连接服务器；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">        <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">        <span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line"></span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>(packager);</span><br><span class="line">        <span class="type">Shell</span> <span class="variable">shell</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shell</span>(client);</span><br><span class="line">        shell.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<div class="article-footer slide-up fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap slide-up" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/10/19/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.19%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.10.19学习日记</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/10/17/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.17%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.10.17学习日记</a></div></section></div>







<footer class="page-footer slide-up footnote"><hr><div class="text"><p>本站由 <a href="/">JakicDong</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0">Stellar 1.30.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper slide-up toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MYDB%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-text">MYDB项目结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TM-Transaction-Manager-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-text">TM(Transaction Manager) 事务管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XID%E6%96%87%E4%BB%B6"><span class="toc-text">XID文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TM%E6%8E%A5%E5%8F%A3"><span class="toc-text">TM接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0TM%E7%9A%84"><span class="toc-text">如何实现TM的?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-text">定义常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#checkXIDCounter"><span class="toc-text">checkXIDCounter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getXidPosition"><span class="toc-text">getXidPosition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#begin"><span class="toc-text">begin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateXid"><span class="toc-text">updateXid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#incrXIDCounter"><span class="toc-text">incrXIDCounter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#checkXID"><span class="toc-text">checkXID</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Manager-DM-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-text">Data Manager (DM) 数据管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6"><span class="toc-text">引用计数缓存框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%BC%93%E5%AD%98"><span class="toc-text">如何实现引用计数缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AbstractCache"><span class="toc-text">AbstractCache&lt;T&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get"><span class="toc-text">get()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#release"><span class="toc-text">release()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#close"><span class="toc-text">close()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84"><span class="toc-text">共享内存数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E6%96%87"><span class="toc-text">原文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA"><span class="toc-text">演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E7%BC%93%E5%AD%98%E5%92%8C%E7%AE%A1%E7%90%86"><span class="toc-text">数据页的缓存和管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getForCache"><span class="toc-text">getForCache()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#releaseForCache"><span class="toc-text">releaseForCache() </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#recoverInsert-%E5%92%8CrecoverUpdate"><span class="toc-text">recoverInsert()和recoverUpdate()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">数据页的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A1%B5"><span class="toc-text">第一页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97%E8%8A%82"><span class="toc-text">启动初始化字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%97%B6%E6%8B%B7%E8%B4%9D%E5%AD%97%E8%8A%82"><span class="toc-text">关闭时拷贝字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%AD%97%E8%8A%82"><span class="toc-text">校验字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E9%A1%B5"><span class="toc-text">普通页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert"><span class="toc-text">insert()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-text">日志文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%AF%BB%E5%86%99"><span class="toc-text">日志读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#internNext"><span class="toc-text">internNext()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#log"><span class="toc-text">log()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="toc-text">恢复策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doInsertLog"><span class="toc-text">doInsertLog()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doUpdateLog"><span class="toc-text">doUpdateLog()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%B4%A2%E5%BC%95"><span class="toc-text">页面索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PageIndex"><span class="toc-text">PageIndex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select-int-spaceSize"><span class="toc-text">select(int spaceSize)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add"><span class="toc-text">add()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fillPageIndex"><span class="toc-text">fillPageIndex()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataItem"><span class="toc-text">DataItem</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#data"><span class="toc-text">data()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#before"><span class="toc-text">before()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unbefore"><span class="toc-text">unbefore()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#after"><span class="toc-text">after()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#release-1"><span class="toc-text">release()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DM%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">DM的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Uid%E7%94%9F%E6%88%90%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%9E%90"><span class="toc-text">Uid生成以及解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getForCache-1"><span class="toc-text">getForCache()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#releaseForCache-1"><span class="toc-text">releaseForCache()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataManager%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">DataManager初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E7%A9%BA%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BAcreate"><span class="toc-text">从空文件创建create()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E5%B7%B2%E6%9C%89%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BAopen"><span class="toc-text">从已有文件创建open()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataManager-%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8A%9F%E8%83%BD"><span class="toc-text">DataManager 提供的三个功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#read%EF%BC%88%EF%BC%89"><span class="toc-text">read（）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#insert-1"><span class="toc-text">insert()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#close-1"><span class="toc-text">close()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Version-Manager-VM-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-text">Version Manager (VM) 版本管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2PL-%E4%B8%8E-MVCC"><span class="toc-text">2PL 与 MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%89%88%E6%9C%AC%E8%AE%B0%E5%BD%95%EF%BC%9F"><span class="toc-text">如何实现版本记录？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Entry%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE"><span class="toc-text">Entry格式数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Entry%E7%BB%93%E6%9E%84"><span class="toc-text">Entry结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">日志格式操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wrapEntryRaw"><span class="toc-text">wrapEntryRaw()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#data-1"><span class="toc-text">data()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setXmax"><span class="toc-text">setXmax()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事物的隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%8F%90%E4%BA%A4"><span class="toc-text">读提交</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E6%8F%90%E4%BA%A4%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%8F%AF%E8%A7%81%E6%80%A7%E9%80%BB%E8%BE%91"><span class="toc-text">读提交的事务可见性逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#readCommited"><span class="toc-text">readCommited()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-text">可重复读</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%8F%AF%E8%A7%81%E6%80%A7%E9%80%BB%E8%BE%91"><span class="toc-text">可重复读的事务可见性逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%BB%93%E6%9E%84"><span class="toc-text">事务结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#repeatableRead"><span class="toc-text">repeatableRead()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-text">死锁检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98"><span class="toc-text">版本跳跃问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E8%B7%B3%E8%B7%83%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="toc-text">版本跳跃的检查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LockTable"><span class="toc-text">LockTable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LockTable%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">LockTable基本结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#add-1"><span class="toc-text">add()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hasDeadLock-and-dfs"><span class="toc-text">hasDeadLock() and dfs()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%BC%94%E7%A4%BA"><span class="toc-text">死锁演示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#remove"><span class="toc-text">remove()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#selectNewXID"><span class="toc-text">selectNewXID()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VM%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">VM的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VM%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-text">VM的基本定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#begin-1"><span class="toc-text">begin()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#commit"><span class="toc-text">commit()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#abort"><span class="toc-text">abort()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#read"><span class="toc-text">read()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#insert-2"><span class="toc-text">insert()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#delete"><span class="toc-text">delete()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Index-Manager-IM-%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-text">Index Manager (IM) 索引管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">Node具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newRootRaw"><span class="toc-text">newRootRaw()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newNilRootRaw"><span class="toc-text">newNilRootRaw()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#searchNext"><span class="toc-text">searchNext()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeafSearchRangeRes"><span class="toc-text">LeafSearchRangeRes()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insertAndSplit"><span class="toc-text">insertAndSplit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-3"><span class="toc-text">insert()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split"><span class="toc-text">split()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Table-Manager-TBM-%E8%A1%A8%E7%BB%93%E6%9E%84%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-text">Table Manager (TBM) 表结构管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">SQL 解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tokenizer%E7%B1%BB%EF%BC%9A"><span class="toc-text">Tokenizer类：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#peek"><span class="toc-text">peek()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop"><span class="toc-text">pop()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parser%E7%B1%BB"><span class="toc-text">Parser类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#parse"><span class="toc-text">parse()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="toc-text">字段与表管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE"><span class="toc-text">结构数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Table"><span class="toc-text">Table</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#createTable"><span class="toc-text">createTable()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#persistSelf"><span class="toc-text">persistSelf()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#loadTable"><span class="toc-text">loadTable()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#parseSelf"><span class="toc-text">parseSelf()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Field"><span class="toc-text">Field</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#createField"><span class="toc-text">createField()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#persistSelf-1"><span class="toc-text">persistSelf()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#loadField"><span class="toc-text">loadField()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#parseSelf-1"><span class="toc-text">parseSelf()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Where%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6"><span class="toc-text">Where查询条件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#parseWhere"><span class="toc-text">parseWhere()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#calWhere"><span class="toc-text">calWhere()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Booter"><span class="toc-text">Booter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86"><span class="toc-text">启动信息管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-text">基本定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#create-and-open"><span class="toc-text">create() and open()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load"><span class="toc-text">load()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update"><span class="toc-text">update()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TableManager"><span class="toc-text">TableManager</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#loadTables"><span class="toc-text"> loadTables()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#create"><span class="toc-text">create()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99"><span class="toc-text">服务端客户端的实现及其通信规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Encoder"><span class="toc-text">Encoder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transporter"><span class="toc-text">Transporter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Packager"><span class="toc-text">Packager</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">服务端和客户端的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Server"><span class="toc-text">Server</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HandleSocket"><span class="toc-text">HandleSocket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Launcher"><span class="toc-text">Launcher</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Client"><span class="toc-text">Client</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RoundTripper"><span class="toc-text">RoundTripper</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Shell"><span class="toc-text">Shell</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Launcher-1"><span class="toc-text">Launcher</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function (response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function (data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function (error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.30.0" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script defer src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const slideUp = {
      distance: `16px`,
      duration: `800`,
      interval: `100`,
      scale: `1`,
      opacity: 0,
      easing: "ease-out"
    };
    ScrollReveal().reveal('.l_left .slide-up', slideUp);
    ScrollReveal().reveal('.l_main .slide-up', slideUp);
    ScrollReveal().reveal('.l_right .slide-up', slideUp);
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script><script src="/js/check-in.js"></script></div></body></html>
