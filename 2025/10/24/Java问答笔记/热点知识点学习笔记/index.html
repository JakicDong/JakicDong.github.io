
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0" theme-name="Stellar" theme-version="1.30.0">
  
  <meta name="generator" content="Hexo 7.0.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>🔥热点知识点学习笔记-炼金丹熔高频考点,布天网擒技术热点 - Jakic's Blog</title>

  
    <meta name="description" content="并发编程为风火轮，分布式是乾坤圈——施主可要参悟这「面试真经」三千大道？">
<meta property="og:type" content="article">
<meta property="og:title" content="🔥热点知识点学习笔记-炼金丹熔高频考点,布天网擒技术热点">
<meta property="og:url" content="https://jakicdong.github.io/2025/10/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%83%AD%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Jakic&#39;s Blog">
<meta property="og:description" content="并发编程为风火轮，分布式是乾坤圈——施主可要参悟这「面试真经」三千大道？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250722101015.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250722101058.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250723102452.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250723111427.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250730111419.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250731094624.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250731095217.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/NIO.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250731095841.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250731103546.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/java%E9%9B%86%E5%90%88%E4%B8%BB%E8%A6%81%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801105907.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801112309.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801112729.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801112820.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801112835.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801112927.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110446.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110550.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110642.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110656.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110718.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110809.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804112738.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250805111458.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807102317.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807102413.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807102739.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807102747.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807102803.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103405.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103452.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103509.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103648.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103717.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103755.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808104808.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808105242.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808110938.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808111222.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808141237.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808142112.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250809102015.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250809104257.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250809104355.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250809104457.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250820212712.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928191717.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928193013.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250930165350.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250930165403.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027082309.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250930165420.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251003165249.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251003170914.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251003171039.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251003171336.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251004132340.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251004132756.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251004145546.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251004152020.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251004152103.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009111617.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009112449.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009141857.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009142009.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009142022.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009143540.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009143612.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009151428.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027092407.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009155017.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009160404.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009160530.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027093600.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009160610.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009160653.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009170605.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009170646.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009170656.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010104933.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105023.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105058.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105204.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105242.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105550.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105607.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105625.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027103144.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027104143.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110039.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110236.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110317.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110343.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110423.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110434.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110511.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110646.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010111648.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010111742.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010111815.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010111849.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150406.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150604.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150844.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150900.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151152.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151210.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151832.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151924.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010153321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010153455.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162108.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162712.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162802.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162812.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162907.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095331.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095524.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095558.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102820.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102844.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102906.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103059.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103352.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103544.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104114.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104247.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104304.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104352.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104424.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105011.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105137.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105431.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105556.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111643.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111737.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612103550.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612112408.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612112435.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161219.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161254.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161338.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161415.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613162534.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613163109.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616093841.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616093925.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616094148.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616101033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616110133.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616112123.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113040.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113305.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113328.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113533.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616151955.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616154016.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616154915.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616154950.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616155054.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616160916.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616162021.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616162445.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616162937.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616163140.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616163309.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250617154612.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618110546.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618110821.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618111513.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618140806.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618142719.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618142740.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618143231.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618143445.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618151308.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618152056.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095220.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095335.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095617.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095723.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619100616.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619101635.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619101736.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619105445.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619105921.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E7%B4%A2%E5%BC%95%E5%8A%A0%E5%BF%AB%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/MYSQL%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250620110109.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/B+%E6%A0%91.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/B+%E6%A0%912.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/B%E6%A0%91.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/b%E6%A0%912.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105348.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105458.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105550.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105601.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105641.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623101840.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/3%E5%B1%82B+%E6%A0%91.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623103448.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623104021.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623104724.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623104917.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/mysql-Sorting_quicksort_anim.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623111022.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623111225.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623111452.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623112230.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/MRR.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113200.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113223.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113305.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113322.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113335.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624093822.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094019.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094631.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094835.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624100243.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624100956.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101013.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101041.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101415.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101535.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101624.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101721.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101751.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101837.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102301.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102354.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102426.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102507.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102546.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625092449.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625093141.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625095630.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625103938.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625104220.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625105204.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625105253.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625110538.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625112428.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011152502.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011152533.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011152635.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011152707.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011152751.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011155649.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011160550.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011162301.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011162620.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011165009.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027183826.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011165026.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011170430.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012183903.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/mysql-20250415152542.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012193756.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012193828.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012193847.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012193913.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194100.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194118.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194134.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194152.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194203.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194215.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194240.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194259.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194333.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194342.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194355.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194406.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194414.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194427.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194443.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194516.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194526.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194544.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012195251.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012195301.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012195335.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012195346.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250725112831.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250725112927.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811101352.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811102451.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811102931.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103014.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103028.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103046.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103115.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103129.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103146.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103203.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103219.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205152.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205641.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205919.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912210551.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912210654.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211024.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211154.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211332.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928161918.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928162003.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928162408.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163257.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163337.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163355.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163542.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163946.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928164026.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928164208.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928165143.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928165506.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095627.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095640.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928170958.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928171009.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022093956.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022094156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022094922.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022095153.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251028151204.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022100013.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022101036.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022105702.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022105811.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110143.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110356.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110609.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110559.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110834.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110950.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111121.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111140.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111245.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023112833.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023160847.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023160907.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023160922.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023160930.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023160946.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161016.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161037.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161053.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161146.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161307.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161344.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162344.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162513.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162536.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162648.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162726.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162805.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023164922.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023164947.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165020.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165052.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165136.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165213.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165228.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165726.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165813.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165854.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165930.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170000.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170235.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170247.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170359.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170416.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170521.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170535.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607100252.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024094421.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024094451.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024094551.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024095121.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024095130.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024095312.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024100031.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024100154.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024100219.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022155254.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022155349.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022155821.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022155845.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022160045.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022160058.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164805.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164814.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164823.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164834.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164849.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164904.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165402.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165409.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165417.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165426.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165435.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165456.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165524.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165715.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165731.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165745.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165756.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165805.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024162351.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024162423.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024163612.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024163711.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024163740.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024163839.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164017.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164058.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164130.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164150.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164332.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164346.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164358.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164722.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164917.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024165053.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024165224.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024165235.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024165247.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024165344.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024184234.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024184604.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024184803.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185126.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/spring-20250714171739.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185306.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185314.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185323.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185332.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185702.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190129.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190137.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190147.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190207.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190258.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190310.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190348.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190356.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190407.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190421.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025143412.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025143839.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715112359.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025144223.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716110915.png">
<meta property="article:published_time" content="2025-10-23T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-28T10:45:45.426Z">
<meta property="article:author" content="JakicDong">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250722101015.png">
  
  
  
  <meta name="keywords" content="基础,Java">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.30.0">


  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/logo.png">
  

  

  
<!-- hexo injector head_end start --><script src="./func.js"></script><!-- hexo injector head_end end --></head>
<link rel="stylesheet" href="/css/check-in.css"><body><div class="sitebg"><div class="siteblur"></div></div>

<div class="l_body content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://avatars.githubusercontent.com/u/130200522?v=4" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Jakic's Blog</div><div class="sub normal cap">学习生活记录</div><div class="sub hover cap" style="opacity:0"> 踏上取经路,比抵达灵山更重要</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客首页" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="打卡墙" href="/check-in" style="color:#1976D2"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="github" target="_blank" rel="noopener" href="https://github.com/JakicDong/" style="color:#1BCDFC"><svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle"> <path fill="#cccccc" d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path> </svg></a><a class="nav-item" title="力扣" target="_blank" rel="noopener" href="https://leetcode.cn/u/dong7/" style="color:#3DC550"><svg width="59" height="22" viewBox="0 0 59 22" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-full w-auto max-w-none"> <path fill-rule="evenodd" clip-rule="evenodd" d="M27.8226 17.4752C28.3202 16.1443 28.7218 14.5458 28.9859 12.6607C29.1277 11.6491 29.2845 10.1658 29.4568 8.20813H35.2561C35.2637 8.20813 35.2713 8.20828 35.2789 8.20857C35.6071 8.22119 35.8628 8.49743 35.8502 8.82558L35.4996 17.9427C35.4873 18.262 35.2249 18.5144 34.9054 18.5144H33.2974C32.8595 18.5144 32.5046 18.8694 32.5046 19.3072C32.5046 19.7451 32.8595 20.1 33.2974 20.1H35.4776C36.3533 20.1 37.0631 19.3901 37.0631 18.5144L37.4595 8.20813C37.4595 7.33244 36.7497 6.62254 35.874 6.62254H29.5913C29.671 5.65054 29.7537 4.58575 29.8394 3.42794C29.8718 2.99129 29.544 2.61109 29.1074 2.57874C28.6707 2.54639 28.2905 2.87414 28.2582 3.3108C28.1689 4.51669 28.0829 5.62069 28.0004 6.62254H25.3695C24.9316 6.62254 24.5767 6.97749 24.5767 7.41534C24.5767 7.85318 24.9316 8.20813 25.3695 8.20813H27.8651C27.7 10.07 27.5501 11.4816 27.4157 12.4407C27.1674 14.2124 26.7941 15.6986 26.3374 16.9199C26.0981 17.5599 25.8527 18.0822 25.6163 18.4944C25.5366 18.6333 25.4649 18.7474 25.4029 18.8378C25.3703 18.8853 25.3512 18.9109 25.3475 18.9155C25.0722 19.256 25.1252 19.7552 25.4657 20.0305C25.8062 20.3057 26.3054 20.2528 26.5806 19.9123C26.6737 19.7971 26.8159 19.5898 26.9917 19.2833C27.271 18.7963 27.5531 18.1959 27.8226 17.4752ZM48.5586 17.3184V7.72969H55.6831C56.3474 7.72969 56.883 8.26047 56.883 8.9117V16.4576C56.883 17.1088 56.3474 17.6396 55.6831 17.6396H53.3916C52.7274 17.6396 52.1918 17.1088 52.1918 16.4576V10.1081C52.1918 9.67022 51.8369 9.31528 51.399 9.31528C50.9612 9.31528 50.6062 9.67022 50.6062 10.1081V16.4576C50.6062 17.9877 51.8548 19.2252 53.3916 19.2252H55.6831C57.2199 19.2252 58.4686 17.9877 58.4686 16.4576V8.9117C58.4686 7.38157 57.2199 6.14411 55.6831 6.14411H48.5586V3.76573C48.5586 3.32788 48.2037 2.97294 47.7658 2.97294C47.328 2.97294 46.9731 3.32788 46.9731 3.76573V6.14411H44.1983C43.7604 6.14411 43.4055 6.49905 43.4055 6.9369C43.4055 7.37475 43.7604 7.72969 44.1983 7.72969H46.9731V12.465L44.3002 13.5341C43.8937 13.6968 43.696 14.1581 43.8586 14.5647C44.0212 14.9712 44.4826 15.1689 44.8891 15.0063L46.9731 14.1727V17.3184C46.9731 18.3666 46.0906 19.2252 44.9911 19.2252C44.5532 19.2252 44.1983 19.5801 44.1983 20.018C44.1983 20.4558 44.5532 20.8108 44.9911 20.8108C46.9567 20.8108 48.5586 19.2522 48.5586 17.3184Z" fill="white"></path> <path d="M13.3797 16.4636C13.874 15.9701 14.674 15.9714 15.1667 16.4665C15.6593 16.9616 15.6581 17.7631 15.1638 18.2566L12.9691 20.4481C10.9443 22.4699 7.64261 22.4992 5.58369 20.5162C5.57179 20.5048 4.655 19.6058 1.63058 16.6402C-0.381491 14.6673 -0.581941 11.5104 1.31147 9.4831L4.84172 5.7031C6.7209 3.69085 10.1849 3.47093 12.3335 5.20847L15.5398 7.80152C16.0828 8.24065 16.1676 9.03757 15.7292 9.58151C15.2909 10.1254 14.4953 10.2104 13.9523 9.77127L10.746 7.17824C9.62238 6.26954 7.65677 6.39434 6.68718 7.43259L3.15688 11.2126C2.23512 12.1996 2.33607 13.7895 3.39833 14.8311C5.61922 17.0088 7.33084 18.6871 7.33282 18.689C8.40324 19.72 10.134 19.7046 11.185 18.6551L13.3797 16.4636Z" fill="#FFA116"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M8.04824 14.2706C7.35039 14.2706 6.78467 13.7039 6.78467 13.0048C6.78467 12.3057 7.35039 11.739 8.04824 11.739H17.3671C18.0649 11.739 18.6306 12.3057 18.6306 13.0048C18.6306 13.7039 18.0649 14.2706 17.3671 14.2706H8.04824Z" fill="#B3B3B3"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M9.79343 0.401024C10.2702 -0.109469 11.0698 -0.136141 11.5794 0.34145C12.089 0.819042 12.1156 1.62004 11.6389 2.13054L3.15692 11.2126C2.23513 12.1995 2.33608 13.7894 3.39827 14.831L7.31536 18.6721C7.81405 19.1611 7.82258 19.9625 7.33442 20.4621C6.84626 20.9616 6.04626 20.9702 5.54757 20.4812L1.63046 16.6401C-0.381492 14.6671 -0.581942 11.5102 1.31155 9.48305L9.79343 0.401024Z" fill="white"></path> </svg></a><a class="nav-item" title="知识星球" target="_blank" rel="noopener" href="https://wx.zsxq.com/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="语雀" target="_blank" rel="noopener" href="https://www.yuque.com/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="sidebar-check-in">
    <div id="sidebar-check-in-calendar"></div>
</div>
<div class="widgets">
<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">专栏：学习博客</span></div><div class="widget-body"><a class="item" href="/2025/10/25/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Elasticsearch学习笔记-开倒排索引通天地,布分词器炼文字丹</span></a><a class="item active" href="/2025/10/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%83%AD%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">🔥热点知识点学习笔记-炼金丹熔高频考点,布天网擒技术热点</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item" href="/2025/10/23/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">场景设计学习笔记-闯架构天宫演诸法,降需求心魔定禅心</span></a><a class="item" href="/2025/10/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%AC%AC%E4%BA%8C%E7%89%88)/"><span class="title">Spring学习笔记(第二版)-炼金丹炉铸Bean山 布注解阵控轮回盘</span></a><a class="item" href="/2025/10/18/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/MYDB%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">MYDB项目笔记</span></a><a class="item" href="/2025/10/17/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RAG%E7%9F%A5%E8%AF%86%E5%BA%93%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">RAG知识库项目笔记</span></a><a class="item" href="/2025/10/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">SQL刷题笔记-执SQL咒扫乾坤表,祭联合影擒数据妖</span></a><a class="item" href="/2025/10/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记-窥内存洞天观玄机,调GC轮回掌生死</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">微服务学习笔记-化整为零散作星,聚沙成塔架云台</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">设计模式学习笔记-布天罡阵降需求妖,演变化术破代码劫</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">操作系统学习笔记-掌轮回内核定纲常,渡进程内存化阴阳</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">分布式学习笔记-架天网布分布式,炼金丹渡一致劫</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">RocketMQ学习笔记-架消息桥通三界路 施持久咒定乾坤轮</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">MyBatis学习笔记-架映射桥通人神境 写SQL咒调数据兵</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Linux学习笔记-踏终端登灵霄殿,执符咒驭众生器</span></a><a class="item" href="/2025/09/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%AE%80%E5%8E%86%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="title">简历对应知识点</span></a><a class="item" href="/2025/09/09/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Elasticsearch(ES)%E4%B8%8B%E8%BD%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><span class="title">Elasticsearch(ES)下载使用指南</span></a><a class="item" href="/2025/08/30/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/git%E7%A7%98%E9%92%A5%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86/"><span class="title">Redis学习笔记</span></a><a class="item" href="/2025/08/08/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java并发编程学习笔记-布天罗网锁线程妖,设八卦阵伏竞态魔</span></a><a class="item" href="/2025/08/06/3DGS/SSH%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"><span class="title">SSH远程调用开发环境</span></a><a class="item" href="/2025/08/05/3DGS/Ubuntu20%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%ACCUDA/"><span class="title">Ubuntu20使用多个版本CUDA</span></a><a class="item" href="/2025/08/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Thymeleaf%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"><span class="title">Thymeleaf模版引擎</span></a><a class="item" href="/2025/08/01/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架学习笔记-开乾坤袋纳百川 布玲珑局定山河</span></a><a class="item" href="/2025/07/30/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Natapp/"><span class="title">Natapp内网穿透使用</span></a><a class="item" href="/2025/07/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"><span class="title">微信扫码登录</span></a><a class="item" href="/2025/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%81%B5%E8%8C%B6%E5%B1%B1%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">灵茶山算法基础笔记</span></a><a class="item" href="/2025/07/25/Go%E5%9F%BA%E7%A1%80/Go%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">Go基础笔记</span></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄</span></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JavaSE学习笔记-筑基篇开修行路,炼气层破语法障</span></a><a class="item" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/"><span class="title">程序员养生指南-调阴阳戒久坐劫 通经脉战代码妖</span></a><a class="item" href="/2025/07/14/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">计算机网络学习笔记-布协议栈通三界,架路由桥渡万维</span></a><a class="item" href="/2025/07/12/3DGS/%E4%BD%BF%E7%94%A8Postshot%E8%AE%AD%E7%BB%833DGS%E6%B5%81%E7%A8%8B/"><span class="title">使用Postshot训练3DGS模型流程</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/%E8%B7%A8%E5%9F%9F%E6%94%AF%E6%8C%81%E7%AC%94%E8%AE%B0/"><span class="title">跨域支持笔记</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/MybatisPlus%E7%AC%94%E8%AE%B0/"><span class="title">MybatisPlus笔记</span></a><a class="item" href="/2025/06/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/TecHub%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">TecHub项目笔记</span></a><a class="item" href="/2025/06/24/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"><span class="title">技术派项目环境问题</span></a><a class="item" href="/2025/06/24/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"><span class="title">Unity游戏开发笔记</span></a><a class="item" href="/2025/06/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82B%E6%A0%91/"><span class="title">一次性搞懂B树</span></a><a class="item" href="/2025/06/12/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Spring学习笔记-开IOC瓶纳百川水 织AOP网覆三界尘</span></a><a class="item" href="/2025/06/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/nvm%E6%9B%B4%E6%94%B9node%E7%89%88%E6%9C%AC/"><span class="title">nvm更改node版本</span></a><a class="item" href="/2025/06/11/3DGS/3DGS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">3DGS学习笔记-撒神经点布星云阵 炼辐射场塑造化身</span></a><a class="item" href="/2025/06/11/3DGS/3DGS-Ubuntu%E7%8E%AF%E5%A2%83/"><span class="title">3DGS-Ubuntu环境.md</span></a><a class="item" href="/2025/06/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Mysql学习笔记-布B+树阵锁苍龙 写SQL真言召天兵</span></a><a class="item" href="/2025/06/10/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架笔记</span></a><a class="item" href="/2025/06/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记</span></a><a class="item" href="/2025/06/07/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%AF%87/"><span class="title">Java并发篇</span></a><a class="item" href="/2025/06/06/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E9%94%AE%E8%AE%B0%E5%BD%95/"><span class="title">常用组合键记录-结印诀腾挪三界,弹指间呼风唤雨</span></a><a class="item" href="/2025/06/06/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/java30%E5%A4%A9%E7%AC%94%E8%AE%B0/"><span class="title">java30天学习笔记</span></a><a class="item" href="/2025/06/05/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/hello-world/"><span class="title">Hello World</span></a><a class="item" href="/2025/06/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">技术派项目笔记</span></a><a class="item" href="/2025/06/02/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"><span class="title">个人博客搭建指南-架祥云自建菩提境,点慧灯独照博客天</span></a><a class="item" href="/2025/06/01/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RabbitMQ%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/"><span class="title">RabbitMQ项目使用</span></a><a class="item" href="/2025/06/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">数据结构算法学习笔记-布天罡阵伏算法妖 炼金石破数据结构</span></a></div></widget>

<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/10/28/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.28%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.28学习日记</span></a><a class="item title" href="/2025/10/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">SQL刷题笔记-执SQL咒扫乾坤表,祭联合影擒数据妖</span></a><a class="item title" href="/2025/06/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">数据结构算法学习笔记-布天罡阵伏算法妖 炼金石破数据结构</span></a><a class="item title" href="/2025/10/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%83%AD%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">🔥热点知识点学习笔记-炼金丹熔高频考点,布天网擒技术热点</span></a><a class="item title" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄</span></a><a class="item title" href="/2025/09/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%AE%80%E5%8E%86%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="title">简历对应知识点</span></a><a class="item title" href="/2025/06/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">技术派项目笔记</span></a><a class="item title" href="/2025/10/27/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.27%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.27学习日记</span></a><a class="item title" href="/2025/06/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Mysql学习笔记-布B+树阵锁苍龙 写SQL真言召天兵</span></a><a class="item title" href="/2025/08/08/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java并发编程学习笔记-布天罗网锁线程妖,设八卦阵伏竞态魔</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/10/25/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习博客</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-10-23T16:00:00.000Z">2025-10-24</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-10-28T10:45:45.426Z">2025-10-28</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>🔥热点知识点学习笔记-炼金丹熔高频考点,布天网擒技术热点</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content slide-up"><h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><h3 id="1-🌟什么是-Java？"><a href="#1-🌟什么是-Java？" class="headerlink" title="1.🌟什么是 Java？"></a>1.🌟什么是 Java？</h3><p>Java 是一门面向对象的编程语言，由 Sun 公司的詹姆斯·高斯林团队于 1995 年推出。吸收了 C++ 语言中大量的优点，但又抛弃了 C++ 中容易出错的地方，如垃圾回收、指针。</p>
<p>同时，Java 又是一门平台无关的编程语言，即一次编译，处处运行。</p>
<p>只需要在对应的平台上安装 JDK，就可以实现跨平台，在 Windows、macOS、Linux 操作系统上运行。</p>
<h4 id="Java-语言和-C-语言有哪些区别？"><a href="#Java-语言和-C-语言有哪些区别？" class="headerlink" title="Java 语言和 C 语言有哪些区别？"></a>Java 语言和 C 语言有哪些区别？</h4><p>Java 是一种<strong>跨平台的编程语言</strong>，通过在不同操作系统上安装对应版本的 JVM 以实现“一次编译，处处运行”的目的。而 C 语言需要在不同的操作系统上重新编译。</p>
<p>Java 实现了<strong>内存的自动管理</strong>，而 C 语言需要使用 malloc 和 free 来手动管理内存。</p>
<h3 id="7-🌟Java-有哪些数据类型？"><a href="#7-🌟Java-有哪些数据类型？" class="headerlink" title="7.🌟Java 有哪些数据类型？"></a>7.🌟Java 有哪些数据类型？</h3><p>Java 的数据类型可以分为两种：<code>基本数据类型</code>和<code>引用数据类型</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250722101015.png" alt="20250722101015"></p>
<p>基本数据类型有：<br>①、数值型</p>
<ul>
<li>整数类型（byte、short、int、long）</li>
<li>浮点类型（float、double）</li>
</ul>
<p>②、字符型（char）<br>③、布尔型（boolean）<br>它们的默认值和占用大小如下所示：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250722101058.png" alt="20250722101058"></p>
<p>引用数据类型有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/object-class.html">类</a>（class）</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/interface.html">接口</a>（interface）</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/array/array.html">数组</a>（<code>[]</code>）</li>
</ul>
<h4 id="boolean-类型实际占用几个字节？"><a href="#boolean-类型实际占用几个字节？" class="headerlink" title="boolean 类型实际占用几个字节？"></a>boolean 类型实际占用几个字节？</h4><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/basic-grammar/basic-data-type.html">Java 进阶之路：基本数据类型篇</a></p>
<p>这要依据具体的 JVM 实现细节。Java 虚拟机规范中，并没有明确规定 boolean 类型的大小，只规定了 boolean 类型的取值 true 或 false。</p>
<blockquote>
<p>boolean: The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true&#x2F;false conditions. This data type represents one bit of information, but its “size” isn’t something that’s precisely defined.</p>
</blockquote>
<p>我本机的 64 位 JDK 中，通过 JOL 工具查看单独的 boolean 类型，以及 boolean 数组，所占用的空间都是 1 个字节。</p>
<h4 id="给Integer最大值-1，是什么结果？"><a href="#给Integer最大值-1，是什么结果？" class="headerlink" title="给Integer最大值+1，是什么结果？"></a>给Integer最大值+1，是什么结果？</h4><p>当给 <code>Integer.MAX_VALUE</code> 加 1 时，会发生溢出，变成 <code>Integer.MIN_VALUE</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">System.out.println(<span class="string">&quot;Integer.MAX_VALUE = &quot;</span> + maxValue); <span class="comment">// Integer.MAX_VALUE = 2147483647</span></span><br><span class="line">System.out.println(<span class="string">&quot;Integer.MAX_VALUE + 1 = &quot;</span> + (maxValue + <span class="number">1</span>)); <span class="comment">// Integer.MAX_VALUE + 1 = -2147483648</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用二进制来表示最大值和最小值</span></span><br><span class="line">System.out.println(<span class="string">&quot;Integer.MAX_VALUE in binary: &quot;</span> + Integer.toBinaryString(maxValue)); <span class="comment">// Integer.MAX_VALUE in binary: 1111111111111111111111111111111</span></span><br><span class="line">System.out.println(<span class="string">&quot;Integer.MIN_VALUE in binary: &quot;</span> + Integer.toBinaryString(Integer.MIN_VALUE)); <span class="comment">// Integer.MIN_VALUE in binary: 10000000000000000000000000000000</span></span><br></pre></td></tr></table></figure>
<p>这是因为 Java 的整数类型采用的是<code>二进制补码表示法</code>，<strong>溢出时值会变成最小值</strong>。</p>
<ul>
<li><code>Integer.MAX_VALUE </code>的二进制表示是 <code>01111111 11111111 11111111 11111111</code>（32 位）。</li>
<li>加 1 后结果变成 <code>10000000 00000000 00000000 00000000</code>，即 -2147483648（Integer.MIN_VALUE）。</li>
</ul>
<h3 id="18-🌟面向对象编程有哪些特性？"><a href="#18-🌟面向对象编程有哪些特性？" class="headerlink" title="18.🌟面向对象编程有哪些特性？"></a>18.🌟面向对象编程有哪些特性？</h3><p>推荐阅读：深入理解 Java 三大特性</p>
<p>面向对象编程有三大特性：封装、继承、多态。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250723102452.png" alt="20250723102452"></p>
<h4 id="封装是什么？"><a href="#封装是什么？" class="headerlink" title="封装是什么？"></a>封装是什么？</h4><p>封装是指将数据（属性，或者叫字段）和操作数据的方法（行为）捆绑在一起，形成一个独立的对象（类的实例）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Nvshen</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看得出，女神类对外没有提供 <code>age</code> 的 <code>getter</code> 方法，因为女神的年龄要保密。</p>
<p>所以，封装是把一个对象的属性私有化，同时提供一些可以被外界访问的方法。</p>
<h4 id="继承是什么？"><a href="#继承是什么？" class="headerlink" title="继承是什么？"></a>继承是什么？</h4><p>继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。以提高代码的复用性，<strong>建立类之间的层次关系</strong>。</p>
<p>同时，子类还可以<strong>重写或者扩展</strong>从父类继承来的属性和方法，从而实现多态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String school;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Student 类继承了 Person 类的属性（name、age）和方法（eat），同时还有自己的属性（school）和方法（study）。</p>
<h4 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h4><p>多态允许不同类的对象<strong>对同一消息做出响应，但表现出不同的行为</strong>（即<strong>方法的多样性</strong>）。</p>
<p>多态其实是一种能力——同一个行为具有不同的表现形式；换句话说就是，执行一段代码，Java 在运行时能根据对象类型的不同产生不同的结果。</p>
<p>多态的前置条件有三个：</p>
<ul>
<li>子类<strong>继承</strong>父类</li>
<li>子类<strong>重写</strong>父类的方法</li>
<li><strong>父类引用指向子类</strong>的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wangxiaoer</span> <span class="keyword">extends</span> <span class="title class_">Wanger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123; <span class="comment">// 子类重写父类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;记住仇恨，表明我们要奋发图强的心智&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        <span class="type">Wanger</span> <span class="variable">wanger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wangxiaoer</span>();</span><br><span class="line">        wanger.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wanger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;王二是沙雕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么Java里面要多组合少继承？"><a href="#为什么Java里面要多组合少继承？" class="headerlink" title="为什么Java里面要多组合少继承？"></a>为什么Java里面要多组合少继承？</h4><p><strong>继承适合描述“is-a”的关系</strong>，但继承容易导致类之间的强耦合，一旦父类发生改变，子类也要随之改变，违背了开闭原则（尽量不修改现有代码，而是添加新的代码来实现）。</p>
<p><strong>组合适合描述“has-a”或“can-do”的关系</strong>，通过在类中组合其他类，能够更灵活地扩展功能。组合避免了复杂的类继承体系，同时遵循了<strong>开闭原则和松耦合的设计原则。</strong></p>
<p>举个例子，假设我们采用继承，每种形状和样式的组合都会<strong>导致类的急剧增加</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a shape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带红色的圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedCircle</span> <span class="keyword">extends</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a red circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带绿色的圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreenCircle</span> <span class="keyword">extends</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a green circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似的，对于矩形也要创建多个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedRectangle</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a red rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>组合模式</strong>更加灵活，可以将形状和颜色分开，松耦合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形状接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">applyColor</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形状干形状的事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆形的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Color color;  <span class="comment">// 通过组合的方式持有颜色对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Drawing a circle with &quot;</span>);</span><br><span class="line">        color.applyColor();  <span class="comment">// 调用颜色的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Drawing a rectangle with &quot;</span>);</span><br><span class="line">        color.applyColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>颜色干颜色的事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红色的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedColor</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyColor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;red color&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绿色的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreenColor</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyColor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;green color&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="23-🌟抽象类和接口有什么区别？"><a href="#23-🌟抽象类和接口有什么区别？" class="headerlink" title="23.🌟抽象类和接口有什么区别？"></a>23.🌟抽象类和接口有什么区别？</h3><p><strong>一个类只能继承一个抽象类</strong>；<strong>但一个类可以实现多个接口</strong>。所以我们在新建线程类的时候一般推荐使用实现 <code>Runnable</code> 接口的方式，这样线程类还可以继承其他类，而不单单是 <code>Thread</code> 类。</p>
<p><strong>抽象类</strong>符合 <code>is-a</code> 的关系，而<strong>接口</strong>更像是 <code>has-a</code> 的关系，比如说一个类可以序列化的时候，它只需要实现 <code>Serializable</code> 接口就可以了，不需要去继承一个序列化类。</p>
<p>抽象类更多地是用来为多个相关的类<strong>提供一个共同的基础框架</strong>，包括状态的初始化，而接口则是<strong>定义一套行为标准</strong>，让不同的类可以实现同一接口，提供行为的多样化实现。</p>
<h4 id="抽象类可以定义构造方法吗？"><a href="#抽象类可以定义构造方法吗？" class="headerlink" title="抽象类可以定义构造方法吗？"></a>抽象类可以定义构造方法吗？</h4><p>可以，抽象类可以有构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);  <span class="comment">// 调用抽象类的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; says: Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口可以定义构造方法吗？"><a href="#接口可以定义构造方法吗？" class="headerlink" title="接口可以定义构造方法吗？"></a>接口可以定义构造方法吗？</h4><p>不能，接口主要用于定义一组方法规范，<strong>没有具体的实现细节</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250723111427.png" alt="20250723111427"></p>
<h4 id="Java支持多继承吗？"><a href="#Java支持多继承吗？" class="headerlink" title="Java支持多继承吗？"></a>Java支持多继承吗？</h4><p>Java 不支持多继承，一个类只能继承一个类，多继承会引发菱形继承问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;C&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 Java 支持多继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">B</span>, C &#123;</span><br><span class="line">    <span class="comment">// 调用 show() 方法时，D 应该调用 B 的 show() 还是 C 的 show()？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口可以多继承吗？"><a href="#接口可以多继承吗？" class="headerlink" title="接口可以多继承吗？"></a>接口可以多继承吗？</h4><p><strong>接口可以多继承，一个接口可以继承多个接口，使用逗号分隔</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceB</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceC</span> <span class="keyword">extends</span> <span class="title class_">InterfaceA</span>, InterfaceB &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">InterfaceC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        myClass.methodA();</span><br><span class="line">        myClass.methodB();</span><br><span class="line">        myClass.methodC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，InterfaceA 和 InterfaceB 是两个独立的接口。</p>
<p>InterfaceC 继承了 InterfaceA 和 InterfaceB，并且定义了自己的方法 methodC。</p>
<p>MyClass 实现了 InterfaceC，因此需要实现 InterfaceA 和 InterfaceB 中的方法 methodA 和 methodB，以及 InterfaceC 中的方法 methodC。</p>
<h4 id="继承和抽象的区别？"><a href="#继承和抽象的区别？" class="headerlink" title="继承和抽象的区别？"></a>继承和抽象的区别？</h4><p>继承是一种允许子类继承父类属性和方法的机制。通过继承，<strong>子类可以重用父类的代码</strong>。</p>
<p>抽象是一种隐藏复杂性和只显示必要部分的技术。在面向对象编程中，抽象可以通过抽象类和接口实现。</p>
<h4 id="抽象类和普通类的区别？"><a href="#抽象类和普通类的区别？" class="headerlink" title="抽象类和普通类的区别？"></a>抽象类和普通类的区别？</h4><p>抽象类使用 <code>abstract</code> 关键字定义，不能被实例化，只能作为其他类的父类。普通类没有 abstract 关键字，可以直接实例化。</p>
<p>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须由子类实现。普通类只能包含非抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 实现抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.makeSound(); <span class="comment">// 输出 &quot;Woof&quot;</span></span><br><span class="line">        dog.eat(); <span class="comment">// 输出 &quot;This animal is eating.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类使用 <code>abstract</code> 关键字定义，不能被实例化，只能作为其他类的父类。普通类没有 abstract 关键字，可以直接实例化。</p>
<p><strong>抽象类</strong>可以包含<strong>抽象方法和非抽象方法</strong>。抽象方法没有方法体，必须由子类实现。普通类只能包含非抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 实现抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.makeSound(); <span class="comment">// 输出 &quot;Woof&quot;</span></span><br><span class="line">        dog.eat(); <span class="comment">// 输出 &quot;This animal is eating.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="29-🌟为什么重写-equals-时必须重写-hashCode-⽅法？"><a href="#29-🌟为什么重写-equals-时必须重写-hashCode-⽅法？" class="headerlink" title="29.🌟为什么重写 equals 时必须重写 hashCode ⽅法？"></a>29.🌟为什么重写 equals 时必须重写 hashCode ⽅法？</h3><p>因为基于哈希的集合类（如 HashMap）需要基于这一点来正确存储和查找对象。</p>
<p>具体地说，HashMap 通过对象的哈希码将其存储在不同的“桶”中，当查找对象时，它需要使用 key 的哈希码来确定对象在哪个桶中，然后再通过 <code>equals()</code> 方法找到对应的对象。</p>
<p>如果重写了 <code>equals()</code>方法而没有重写 <code>hashCode()</code>方法，那么被认为相等的对象可能会有不同的哈希码，从而导致无法在 HashMap 中正确处理这些对象。</p>
<h4 id="什么是-hashCode-方法？"><a href="#什么是-hashCode-方法？" class="headerlink" title="什么是 hashCode 方法？"></a>什么是 hashCode 方法？</h4><p><code>hashCode()</code> 方法的作⽤是获取哈希码，它会返回⼀个 int 整数，定义在 <a target="_blank" rel="noopener" href="https://javabetter.cn/oo/object-class.html">Object 类</a>中， 是一个本地⽅法。</p>
<p> <code>public native int hashCode();</code></p>
<h4 id="为什么要有-hashCode-方法？"><a href="#为什么要有-hashCode-方法？" class="headerlink" title="为什么要有 hashCode 方法？"></a>为什么要有 hashCode 方法？</h4><p><code>hashCode</code> 方法主要用来获取对象的哈希码，哈希码是由对象的内存地址或者对象的属性计算出来的，它是⼀个 int 类型的整数，通常是不会重复的，因此可以用来作为键值对的建，以提高查询效率。</p>
<p>例如 <a target="_blank" rel="noopener" href="https://javabetter.cn/collection/hashmap.html#_01%E3%80%81hash%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86">HashMap</a> 中的 key 就是通过 <code>hashCode</code> 来实现的，通过调用 <code>hashCode</code> 方法获取键的哈希码，并将其与右移 16 位的哈希码进行异或运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"> <span class="type">int</span> h;</span><br><span class="line"> <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么两个对象有相同的-hashcode-值，它们也不⼀定相等？"><a href="#为什么两个对象有相同的-hashcode-值，它们也不⼀定相等？" class="headerlink" title="为什么两个对象有相同的 hashcode 值，它们也不⼀定相等？"></a>为什么两个对象有相同的 hashcode 值，它们也不⼀定相等？</h4><p>这主要是由于哈希码（hashCode）的本质和目的所决定的。</p>
<p>哈希码是通过<code>哈希函数</code>将对象中映射成一个整数值，其主要目的是在哈希表中快速定位对象的存储位置。</p>
<p>由于哈希函数将一个<code>较大的输入域</code>映射到一个<code>较小的输出域</code>，不同的输入值（即不同的对象）可能会产生相同的输出值（即相同的哈希码）。</p>
<p>这种情况被称为<strong>哈希冲突</strong>。当两个不相等的对象发生哈希冲突时，它们会有相同的 <code>hashCode</code>。</p>
<p>为了解决哈希冲突的问题，哈希表在处理键时，不仅会比较键对象的哈希码，还会使用 <code>equals</code> 方法来检查键对象是否真正相等。如果两个对象的哈希码相同，但通过 equals 方法比较结果为 false，那么这两个对象就不被视为相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line"> ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"> e = p;</span><br></pre></td></tr></table></figure>

<h4 id="hashCode-和-equals-方法的关系？"><a href="#hashCode-和-equals-方法的关系？" class="headerlink" title="hashCode 和 equals 方法的关系？"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/sidebar/sanfene/javase.html#hashcode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB">hashCode 和 equals 方法的关系？</a></h4><p>如果两个对象通过 <code>equals</code> 相等，它们的 <code>hashCode</code> 必须相等。否则会导致哈希表类数据结构（如 HashMap、HashSet）的行为异常。</p>
<p>在哈希表中，如果 <code>equals</code> 相等但 <code>hashCode</code> 不相等，哈希表可能无法正确处理这些对象，导致重复元素或键值冲突等问题。</p>
<h3 id="34-🌟String-和-StringBuilder、StringBuffer-的区别？"><a href="#34-🌟String-和-StringBuilder、StringBuffer-的区别？" class="headerlink" title="34.🌟String 和 StringBuilder、StringBuffer 的区别？"></a>34.🌟String 和 StringBuilder、StringBuffer 的区别？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/string/builder-buffer.html">StringBuffer 和 StringBuilder 两兄弟</a></p>
<p><code>String</code>、<code>StringBuilder</code>和<code>StringBuffer</code>在 Java 中都是用于处理字符串的，它们之间的区别是，String 是<code>不可变的</code>，平常开发用得最多，当遇到大量字符串连接时，就用 StringBuilder，它不会生成很多新的对象，<code>StringBuffer</code> 和 StringBuilder 类似，但每个方法上都加了 <code>synchronized</code> 关键字，所以是线程安全的。</p>
<h4 id="请说说-String-的特点"><a href="#请说说-String-的特点" class="headerlink" title="请说说 String 的特点"></a>请说说 String 的特点</h4><ul>
<li><code>String</code>类的对象是<a target="_blank" rel="noopener" href="https://javabetter.cn/string/immutable.html">不可变的</a>。也就是说，一旦一个<code>String</code>对象被创建，它所包含的字符串内容是不可改变的。</li>
<li>每次对<code>String</code>对象进行修改操作（如拼接、替换等）实际上都会生成一个新的<code>String</code>对象，而不是修改原有对象。这可能会导致内存和性能开销，尤其是在大量字符串操作的情况下。</li>
</ul>
<h4 id="请说说-StringBuilder-的特点"><a href="#请说说-StringBuilder-的特点" class="headerlink" title="请说说 StringBuilder 的特点"></a>请说说 StringBuilder 的特点</h4><ul>
<li><code>StringBuilder</code>提供了一系列的方法来进行字符串的增删改查操作，这些操作都是直接在原有字符串对象的底层数组上进行的，而<strong>不是生成新的 String 对象</strong>。</li>
<li><code>StringBuilder</code>不是线程安全的。这意味着在没有外部同步的情况下，它不适用于多线程环境。</li>
<li>相比于<code>String</code>，在进行频繁的字符串修改操作时，<code>StringBuilder</code>能提供更好的性能。 Java 中的字符串连<code>+</code>操作其实就是通过<code>StringBuilder</code>实现的。</li>
</ul>
<h4 id="请说说-StringBuffer-的特点"><a href="#请说说-StringBuffer-的特点" class="headerlink" title="请说说 StringBuffer 的特点"></a>请说说 StringBuffer 的特点</h4><p><code>StringBuffer</code>和<code>StringBuilder</code>类似，但<code>StringBuffer</code>是线程安全的，方法前面都加了<code>synchronized</code>关键字。</p>
<h4 id="请总结一下使用场景"><a href="#请总结一下使用场景" class="headerlink" title="请总结一下使用场景"></a>请总结一下使用场景</h4><ul>
<li><strong>String</strong>：适用于字符串内容<strong>不会改变</strong>的场景，比如说作为 HashMap 的 key。</li>
<li><strong>StringBuilder</strong>：适用于<strong>单线程环境下</strong>需要频繁修改字符串内容的场景，比如在循环中拼接或修改字符串，是 String 的完美替代品。</li>
<li><strong>StringBuffer</strong>：现在已经不怎么用了，因为一般不会在多线程场景下去频繁的修改字符串内容。</li>
</ul>
<h3 id="41-🌟Java-中异常处理体系"><a href="#41-🌟Java-中异常处理体系" class="headerlink" title="41.🌟Java 中异常处理体系?"></a>41.🌟Java 中异常处理体系?</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/exception/gailan.html">一文彻底搞懂 Java 异常处理</a></p>
<p>Java 中的异常处理机制用于处理程序运行过程中可能发生的各种异常情况，通常通过 try-catch-finally 语句和 throw 关键字来实现。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250730111419.png" alt="20250730111419"></p>
<p><code>Throwable</code> 是 Java 语言中所有错误和异常的基类。它有两个主要的子类：<code>Error</code> 和 <code>Exception</code>，这两个类分别代表了 Java 异常处理体系中的两个分支。</p>
<p>Error 类代表那些<strong>严重的错误</strong>，这类错误通常是程序无法处理的。比如，<code>OutOfMemoryError</code> 表示内存不足，<code>StackOverflowError</code> 表示栈溢出。这些错误通常与 JVM 的运行状态有关，一旦发生，<strong>应用程序通常无法恢复</strong>。</p>
<p><code>Exception</code> 类代表<strong>程序可以处理的异常</strong>。它分为两大类：编译时异常（Checked Exception）和运行时异常（Runtime Exception）。</p>
<p>①、编译时异常（Checked Exception）：这类异常在<strong>编译时必须被显式处理</strong>（捕获或声明抛出）。</p>
<p>如果方法可能抛出某种编译时异常，但没有捕获它（try-catch）或没有在方法声明中用 throws 子句声明它，那么编译将不会通过。例如：IOException、SQLException 等。</p>
<p>②、运行时异常（Runtime Exception）：这类异常在运行时抛出，它们都是 <code>RuntimeException</code> 的子类。对于运行时异常，Java 编译器不要求必须处理它们（即不需要捕获也不需要声明抛出）。</p>
<p>运行时异常通常是由<strong>程序逻辑错误</strong>导致的，如<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code> 等。</p>
<h3 id="46-🌟BIO、NIO、AIO-之间的区别？"><a href="#46-🌟BIO、NIO、AIO-之间的区别？" class="headerlink" title="46.🌟BIO、NIO、AIO 之间的区别？"></a>46.🌟BIO、NIO、AIO 之间的区别？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/nio/nio-better-io.html">Java NIO 比传统 IO 强在哪里？</a></p>
<p>Java 常见的 IO 模型有三种：BIO、NIO 和 AIO。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250731094624.png" alt="20250731094624"></p>
<p>BIO：采用阻塞式 I&#x2F;O 模型，线程在执行 I&#x2F;O 操作时被阻塞，无法处理其他任务，适用于连接数较少的场景。</p>
<p>NIO：采用<code>非阻塞 I/O 模型</code>，线程在等待 I&#x2F;O 时可执行其他任务，通过 <code>Selector</code> 监控多个 <code>Channel</code> 上的事件，适用于连接数多但连接时间短的场景。</p>
<p>AIO：使用<code>异步 I/O 模型</code>，线程发起 I&#x2F;O 请求后立即返回，当 I&#x2F;O 操作完成时通过回调函数通知线程，适用于连接数多且连接时间长的场景。</p>
<h4 id="简单说一下-BIO？"><a href="#简单说一下-BIO？" class="headerlink" title="简单说一下 BIO？"></a>简单说一下 BIO？</h4><p>BIO，也就是传统的 IO，基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，基于 <code>Socket</code> 和 <code>ServerSocket</code> 进行网络通信。</p>
<p>对于每个连接，都需要创建一个独立的线程来处理读写操作。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250731095217.png" alt="20250731095217"></p>
<h4 id="简单说下-NIO？"><a href="#简单说下-NIO？" class="headerlink" title="简单说下 NIO？"></a>简单说下 NIO？</h4><p>NIO，JDK 1.4 时引入，放在 java.nio 包下，提供了 Channel、Buffer、Selector 等新的抽象，基于 RandomAccessFile、FileChannel、ByteBuffer 进行文件读写，基于 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 进行网络通信。</p>
<p>实际上，“旧”的 I&#x2F;O 包已经使用 NIO 重新实现过，所以在进行文件读写时，NIO 并无法体现出比 BIO 更可靠的性能。</p>
<p>NIO 的魅力主要体现在<code>网络编程</code>中，服务器可以用一个线程处理多个客户端连接，通过 Selector 监听多个 Channel 来实现多路复用，极大地提高了网络编程的性能。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/NIO.png" alt="NIO"></p>
<p>缓冲区 Buffer 也能极大提升一次 IO 操作的效率。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250731095841.png" alt="20250731095841"></p>
<h4 id="简单说下-AIO？"><a href="#简单说下-AIO？" class="headerlink" title="简单说下 AIO？"></a>简单说下 AIO？</h4><p>AIO 是 Java 7 引入的，放在 <code>java.nio.channels</code> 包下，提供了 AsynchronousFileChannel、AsynchronousSocketChannel 等异步 Channel。</p>
<p>它引入了异步通道的概念，使得 I&#x2F;O 操作可以异步进行。这意味着线程发起一个读写操作后不必等待其完成，可以立即进行其他任务，并且当读写操作真正完成时，线程会被异步地通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;test.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">Future&lt;Integer&gt; result = fileChannel.read(buffer, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (!result.isDone()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="52-🌟什么是反射？应用？原理？"><a href="#52-🌟什么是反射？应用？原理？" class="headerlink" title="52.🌟什么是反射？应用？原理？"></a>52.🌟什么是反射？应用？原理？</h3><p>反射允许 Java 在运行时检查和操作类的方法和字段。通过反射，可以动态地获取类的字段、方法、构造方法等信息，并在运行时调用方法或访问字段。</p>
<p>比如创建一个对象是通过 new 关键字来实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>
<p>Person 类的信息在编译时就确定了，那假如在编译期无法确定类的信息，但又想在运行时获取类的信息、创建类的实例、调用类的方法，这时候就要用到反射。</p>
<p>反射功能主要通过 <code>java.lang.Class</code> 类及 <code>java.lang.reflect</code> 包中的类如 Method, Field, Constructor 等来实现。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250731103546.png" alt="20250731103546"></p>
<p>比如说我们可以装来动态加载类并创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure>
<p>比如说我们可以这样来访问字段和方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 加载并实例化类</span></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.util.Date&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并调用方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;getTime&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj);</span><br><span class="line">System.out.println(<span class="string">&quot;Time: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> cls.getDeclaredField(<span class="string">&quot;fastTime&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>); <span class="comment">// 对于私有字段需要这样做</span></span><br><span class="line">System.out.println(<span class="string">&quot;fastTime: &quot;</span> + field.getLong(obj));</span><br></pre></td></tr></table></figure>
<h4 id="反射有哪些应用场景？"><a href="#反射有哪些应用场景？" class="headerlink" title="反射有哪些应用场景？"></a>反射有哪些应用场景？</h4><p>①、Spring 框架就大量使用了反射来动态加载和管理 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br></pre></td></tr></table></figure>
<p>②、Java 的动态代理（Dynamic Proxy）机制就使用了反射来创建代理类。代理类可以在运行时动态处理方法调用，这在实现 AOP 和拦截器时非常有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个处理器实例,负责实际方法的调用逻辑</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>();</span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">    MyInterface.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; MyInterface.class &#125;,</span><br><span class="line">    handler</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>③、JUnit 和 TestNG 等测试框架使用反射机制来发现和执行测试方法。反射允许框架扫描类，查找带有特定注解（如 @Test）的方法，并在运行时调用它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">testMethod</span> <span class="operator">=</span> testClass.getMethod(<span class="string">&quot;testSomething&quot;</span>);</span><br><span class="line">testMethod.invoke(testInstance);</span><br></pre></td></tr></table></figure>
<h4 id="反射的原理是什么？"><a href="#反射的原理是什么？" class="headerlink" title="反射的原理是什么？"></a>反射的原理是什么？</h4><p>Java 程序的执行分为<code>编译</code>和<code>运行</code>两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。</p>
<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><h3 id="1-🌟说说有哪些常见的集合框架？"><a href="#1-🌟说说有哪些常见的集合框架？" class="headerlink" title="1.🌟说说有哪些常见的集合框架？"></a>1.🌟说说有哪些常见的集合框架？</h3><ul>
<li>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/collection/gailan.html">二哥的 Java 进阶之路：Java 集合框架</a></li>
<li>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/BlockingQueue.html">阻塞队列 BlockingQueue</a>。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/java%E9%9B%86%E5%90%88%E4%B8%BB%E8%A6%81%E5%85%B3%E7%B3%BB.png" alt="java集合主要关系"></p>
<p>集合框架可以分为两条大的支线：</p>
<p>①、第一条支线 <code>Collection</code>，主要由 List、Set、Queue 组成：</p>
<ul>
<li>List 代表有序、可重复的集合，典型代表就是封装了动态数组的 <a target="_blank" rel="noopener" href="https://javabetter.cn/collection/arraylist.html">ArrayList</a> 和封装了链表的 <a target="_blank" rel="noopener" href="https://javabetter.cn/collection/linkedlist.html">LinkedList</a>；</li>
<li>Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；</li>
<li>Queue 代表队列，典型代表就是双端队列 <a target="_blank" rel="noopener" href="https://javabetter.cn/collection/arraydeque.html">ArrayDeque</a>，以及优先级队列 <a target="_blank" rel="noopener" href="https://javabetter.cn/collection/PriorityQueue.html">PriorityQueue</a>。</li>
</ul>
<p>②、第二条支线 <code>Map</code>，代表键值对的集合，典型代表就是 <a target="_blank" rel="noopener" href="https://javabetter.cn/collection/hashmap.html">HashMap</a>。</p>
<p>另外一个回答版本：</p>
<p>①、<code>Collection</code> 接口：最基本的集合框架表示方式，提供了添加、删除、清空等基本操作，它主要有三个子接口：</p>
<ul>
<li><code>List</code>：一个有序的集合，可以包含重复的元素。实现类包括 ArrayList、LinkedList 等。</li>
<li><code>Set</code>：一个不包含重复元素的集合。实现类包括 HashSet、LinkedHashSet、TreeSet 等。</li>
<li><code>Queue</code>：一个用于保持元素队列的集合。实现类包括 PriorityQueue、ArrayDeque 等。</li>
</ul>
<p>②、<code>Map</code> 接口：表示键值对的集合，一个键映射到一个值。键不能重复，每个键只能对应一个值。Map 接口的实现类包括 HashMap、LinkedHashMap、TreeMap 等。</p>
<h4 id="集合框架有哪几个常用工具类？"><a href="#集合框架有哪几个常用工具类？" class="headerlink" title="集合框架有哪几个常用工具类？"></a>集合框架有哪几个常用工具类？</h4><p>集合框架位于 <code>java.util</code> 包下，提供了两个常用的工具类：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/common-tool/collections.html">Collections</a>：提供了一些对集合进行排序、二分查找、同步的静态方法。</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/common-tool/arrays.html">Arrays</a>：提供了一些对数组进行排序、打印、和 List 进行转换的静态方法。</li>
</ul>
<h4 id="简单介绍一下队列"><a href="#简单介绍一下队列" class="headerlink" title="简单介绍一下队列"></a>简单介绍一下队列</h4><p>Java 中的队列主要通过 <code>Queue</code> 接口和并发包下的 <code>BlockingQueue</code> 两个接口来实现。</p>
<p>优先级队列 <code>PriorityQueue</code> 实现了 <code>Queue</code> 接口，是一个无界队列，它的元素按照自然顺序排序或者 <code>Comparator</code> 比较器进行排序。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801105907.png" alt="20250801105907"></p>
<p>双端队列 <code>ArrayDeque</code> 也实现了 <code>Queue</code> 接口，是一个基于数组的，可以在两端插入和删除元素的队列。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801112309.png" alt="20250801112309"></p>
<p>LinkedList 实现了 Queue 接口的子类 Deque，所以也可以当做双端队列来使用。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801112729.png" alt="20250801112729"></p>
<h4 id="用过哪些集合类，它们的优劣？"><a href="#用过哪些集合类，它们的优劣？" class="headerlink" title="用过哪些集合类，它们的优劣？"></a>用过哪些集合类，它们的优劣？</h4><p>我常用的集合类有 ArrayList、LinkedList、HashMap、LinkedHashMap。</p>
<ol>
<li><p>ArrayList 可以看作是一个<strong>动态数组</strong>，可以在需要时动态扩容数组的容量，只不过需要复制元素到新的数组。优点是访问速度快，可以通过索引直接查找到元素。缺点是插入和删除元素可能需要移动或者复制元素。</p>
</li>
<li><p>LinkedList 是一个<strong>双向链表</strong>，适合频繁的插入和删除操作。优点是插入和删除元素的时候只需要改变节点的前后指针，缺点是访问元素时需要遍历链表。</p>
</li>
<li><p>HashMap 是一个基于哈希表的键值对集合。优点是可以根据键的哈希值快速查找到值，但有可能会发生哈希冲突，并且不保留键值对的插入顺序。</p>
</li>
<li><p>LinkedHashMap 在 HashMap 的基础上增加了一个双向链表来保持键值对的插入顺序。</p>
</li>
</ol>
<h4 id="队列和栈的区别了解吗？"><a href="#队列和栈的区别了解吗？" class="headerlink" title="队列和栈的区别了解吗？"></a>队列和栈的区别了解吗？</h4><p>队列是一种先进先出（FIFO, First-In-First-Out）的数据结构，第一个加入队列的元素会成为第一个被移除的元素。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801112820.png" alt="20250801112820"></p>
<p>栈是一种后进先出（LIFO, Last-In-First-Out）的数据结构，最后一个加入栈的元素会成为第一个被移除的元素。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801112835.png" alt="20250801112835"></p>
<h4 id="哪些是线程安全的容器？"><a href="#哪些是线程安全的容器？" class="headerlink" title="哪些是线程安全的容器？"></a>哪些是线程安全的容器？</h4><p>像 Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue 都是线程安全的。</p>
<h4 id="Collection-继承了哪些接口？"><a href="#Collection-继承了哪些接口？" class="headerlink" title="Collection 继承了哪些接口？"></a>Collection 继承了哪些接口？</h4><p>Collection 继承了 <code>Iterable</code> 接口，这意味着所有实现 <code>Collection</code> 接口的类都必须实现 <code>iterator()</code> 方法，之后就可以使用增强型 for 循环遍历集合中的元素了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250801112927.png" alt="20250801112927"></p>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/sidebar/sanfene/collection.html#list">List 推荐阅读文章</a></p>
<h3 id="2-🌟ArrayList-和-LinkedList-有什么区别？"><a href="#2-🌟ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="2.🌟ArrayList 和 LinkedList 有什么区别？"></a>2.🌟ArrayList 和 LinkedList 有什么区别？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/collection/list-war-2.html">二哥的 Java 进阶之路：ArrayList 和 LinkedList</a></p>
<p>ArrayList 是基于<strong>数组</strong>实现的，LinkedList 是基于<strong>链表</strong>实现的。</p>
<h4 id="ArrayList-和-LinkedList-的用途有什么不同？"><a href="#ArrayList-和-LinkedList-的用途有什么不同？" class="headerlink" title="ArrayList 和 LinkedList 的用途有什么不同？"></a>ArrayList 和 LinkedList 的用途有什么不同？</h4><p>多数情况下，ArrayList 更利于<code>查找</code>，LinkedList 更利于<code>增删</code>。</p>
<p>①、由于 ArrayList 是基于数组实现的，所以 <code>get(int index)</code> 可以直接通过数组下标获取，时间复杂度是 O(1)；LinkedList 是基于链表实现的，<code>get(int index)</code> 需要遍历链表，时间复杂度是 O(n)。</p>
<p>当然，<code>get(E element)</code> 这种查找，两种集合都需要遍历通过 equals 比较获取元素，所以时间复杂度都是 O(n)。</p>
<p>②、ArrayList 如果增删的是数组的尾部，时间复杂度是 O(1)；如果 add 的时候涉及到扩容，时间复杂度会上升到 O(n)。</p>
<p>但如果插入的是中间的位置，就需要把插入位置后的元素向前或者向后移动，甚至还有可能触发扩容，效率就会低很多，变成 O(n)。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110446.png" alt="20250804110446"></p>
<p><code>LinkedList</code> 因为是链表结构，插入和删除只需要改变前置节点、后置节点和插入节点的引用，因此不需要移动元素。</p>
<p>如果是在链表的头部插入或者删除，时间复杂度是 O(1)；如果是在链表的中间插入或者删除，时间复杂度是 O(n)，因为需要遍历链表找到插入位置；如果是在链表的尾部插入或者删除，时间复杂度是 O(1)。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110550.png" alt="20250804110550"></p>
<h4 id="ArrayList-和-LinkedList-是否支持随机访问？"><a href="#ArrayList-和-LinkedList-是否支持随机访问？" class="headerlink" title="ArrayList 和 LinkedList 是否支持随机访问？"></a>ArrayList 和 LinkedList 是否支持随机访问？</h4><p>①、ArrayList 是基于数组的，也实现了 <code>RandomAccess</code> 接口，所以它支持随机访问，可以通过下标直接获取元素。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110642.png" alt="20250804110642"></p>
<p>②、LinkedList 是基于链表的，所以它没法根据下标直接获取元素，不支持随机访问。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110656.png" alt="20250804110656"></p>
<h4 id="ArrayList-和-LinkedList-内存占用有何不同？"><a href="#ArrayList-和-LinkedList-内存占用有何不同？" class="headerlink" title="ArrayList 和 LinkedList 内存占用有何不同？"></a>ArrayList 和 LinkedList 内存占用有何不同？</h4><p>ArrayList 是基于数组的，是一块连续的内存空间，所以它的内存占用是比较紧凑的；但如果涉及到扩容，就会重新分配内存，空间是原来的 1.5 倍。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110718.png" alt="20250804110718"></p>
<p>LinkedList 是基于链表的，每个节点都有一个指向下一个节点和上一个节点的引用，于是每个节点占用的内存空间比 ArrayList 稍微大一点。</p>
<h4 id="ArrayList-和-LinkedList-的使用场景有什么不同？"><a href="#ArrayList-和-LinkedList-的使用场景有什么不同？" class="headerlink" title="ArrayList 和 LinkedList 的使用场景有什么不同？"></a>ArrayList 和 LinkedList 的使用场景有什么不同？</h4><p>ArrayList 适用于：</p>
<ul>
<li>随机访问频繁：需要频繁通过索引访问元素的场景。</li>
<li>读取操作远多于写入操作：如存储不经常改变的列表。</li>
<li>末尾添加元素：需要频繁在列表末尾添加元素的场景。</li>
</ul>
<p>LinkedList 适用于：</p>
<ul>
<li>频繁插入和删除：在列表中间频繁插入和删除元素的场景。</li>
<li>不需要快速随机访问：顺序访问多于随机访问的场景。</li>
<li>队列和栈：由于其双向链表的特性，LinkedList 可以实现队列（FIFO）和栈（LIFO）。</li>
</ul>
<h4 id="链表和数组有什么区别？"><a href="#链表和数组有什么区别？" class="headerlink" title="链表和数组有什么区别？"></a>链表和数组有什么区别？</h4><ul>
<li>数组在内存中占用的是一块连续的存储空间，因此我们可以通过数组下标快速访问任意元素。数组在创建时必须指定大小，一旦分配内存，数组的大小就固定了。</li>
<li>链表的元素存储在于内存中的任意位置，每个节点通过指针指向下一个节点。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804110809.png" alt="20250804110809"></p>
<h3 id="8-🌟能说一下-HashMap-的底层数据结构吗？"><a href="#8-🌟能说一下-HashMap-的底层数据结构吗？" class="headerlink" title="8.🌟能说一下 HashMap 的底层数据结构吗？"></a>8.🌟能说一下 HashMap 的底层数据结构吗？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/collection/hashmap.html">二哥的 Java 进阶之路：详解 HashMap</a></p>
<p>JDK 8 中 HashMap 的数据结构是<code>数组</code>+<code>链表</code>+<code>红黑树</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250804112738.png" alt="20250804112738"></p>
<p>数组用来存储键值对，每个键值对可以通过索引直接拿到，索引是通过对键的哈希值进行进一步的 <code>hash()</code> 处理得到的。</p>
<p>当多个键经过哈希处理后得到相同的索引时，需要通过链表来解决哈希冲突——将具有相同索引的键值对通过链表存储起来。</p>
<p>不过，<code>链表</code>过长时，查询效率会比较低，于是当<code>链表</code>的长度超过 8 时（且数组的长度大于 64），<code>链表</code>就会转换为<code>红黑树</code>。红黑树的查询效率是<code> O(logn)</code>，比链表的 <code>O(n)</code> 要快。</p>
<p><code>hash()</code> 方法的目标是尽量减少哈希冲突，保证元素能够均匀地分布在数组的每个位置上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果键的哈希值已经在数组中存在，其对应的值将被新值覆盖。</p>
<p>HashMap 的初始容量是 16，随着元素的不断添加，HashMap 就需要进行扩容，阈值是<code>capacity * loadFactor</code>，capacity 为容量，loadFactor 为负载因子，默认为 0.75。</p>
<p>扩容后的数组大小是原来的 2 倍，然后把原来的元素重新计算哈希值，放到新的数组中。</p>
<h3 id="11-🌟HashMap-的-put-流程知道吗？"><a href="#11-🌟HashMap-的-put-流程知道吗？" class="headerlink" title="11.🌟HashMap 的 put 流程知道吗？"></a>11.🌟HashMap 的 put 流程知道吗？</h3><p>哈希寻址 → 处理哈希冲突（链表还是红黑树）→ 判断是否需要扩容 → 插入&#x2F;覆盖节点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250805111458.png" alt="20250805111458"></p>
<p>详细版：</p>
<p>第一步，通过 <code>hash</code> 方法进一步扰动哈希值，以减少哈希冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，进行第一次的数组扩容；并使用哈希值和数组长度进行取模运算，确定索引位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>如果当前位置为空，直接将键值对插入该位置；<br>否则判断当前位置的第一个节点是否与新节点的 key 相同，如果相同直接覆盖 value，如果不同，说明发生哈希冲突。</p>
<p>如果是链表，将新节点添加到链表的尾部；如果<strong>链表长度大于等于 8</strong>，则将链表转换为红黑树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果 table 为空，先进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算索引位置，并找到对应的桶</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>); <span class="comment">// 如果桶为空，直接插入</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 检查第一个节点是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">// 覆盖</span></span><br><span class="line">        <span class="comment">// 如果是树节点，放入树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 如果是链表，遍历插入到尾部</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表长度达到阈值，转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 覆盖</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// 如果找到匹配的 key，则覆盖旧值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize(); <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次插入新元素后，检查是否需要扩容，如果当前元素个数大于阈值（<code>capacity * loadFactor</code>），则进行扩容，扩容后的数组大小是原来的 2 倍；并且重新计算每个节点的索引，进行数据重新分布。</p>
<h4 id="只重写元素的-equals-方法没重写-hashCode，put-的时候会发生什么"><a href="#只重写元素的-equals-方法没重写-hashCode，put-的时候会发生什么" class="headerlink" title="只重写元素的 equals 方法没重写 hashCode，put 的时候会发生什么?"></a>只重写元素的 equals 方法没重写 hashCode，put 的时候会发生什么?</h4><p>如果只重写 <code>equals</code> 方法，没有重写 <code>hashCode</code> 方法，那么会导致 <code>equals</code> 相等的两个对象，<code>hashCode</code> 不相等，这样的话，两个对象会被 <code>put</code> 到数组中不同的位置，导致 <code>get</code> 的时候，无法获取到正确的值。</p>
<h3 id="21-🌟HashMap的扩容机制了解吗？"><a href="#21-🌟HashMap的扩容机制了解吗？" class="headerlink" title="21.🌟HashMap的扩容机制了解吗？"></a>21.🌟HashMap的扩容机制了解吗？</h3><p>扩容时，HashMap 会创建一个新的数组，其容量是原来的<strong>两倍</strong>。然后遍历旧哈希表中的元素，将其重新分配到新的哈希表中。</p>
<p>如果当前桶中只有一个元素，那么直接通过键的哈希值与数组大小取模锁定新的索引位置：<code>e.hash &amp; (newCap - 1)</code>。</p>
<p>如果当前桶是红黑树，那么会调用 <code>split()</code> 方法分裂树节点，以保证树的平衡。</p>
<p>如果当前桶是链表，会通过旧键的哈希值与旧的数组大小取模 <code>(e.hash &amp; oldCap) == 0</code> 来作为判断条件，如果条件为真，元素保留在原索引的位置；否则元素移动到原索引 + 旧数组大小的位置。</p>
<h4 id="JDK-7-扩容的时候有什么问题？"><a href="#JDK-7-扩容的时候有什么问题？" class="headerlink" title="JDK 7 扩容的时候有什么问题？"></a>JDK 7 扩容的时候有什么问题？</h4><p>JDK 7 在扩容的时候使用头插法来重新插入链表节点，这样会导致链表无法保持原有的顺序。</p>
<p>详细解释一下。</p>
<p>JDK 7 是通过哈希值与数组大小-1 进行与运算确定元素下标的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来假设：</p>
<ul>
<li>数组 table 的长度为 2</li>
<li>键的哈希值为 3、7、5</li>
</ul>
<p>取模运算后，键发生了哈希冲突，它们都需要放到 table[1] 的桶上。那么扩容前就是这个样子：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807102317.png" alt="20250807102317"></p>
<p>假设负载因子 <code>loadFactor</code> 为 1，也就是当元素的个数大于 table 的长度时进行扩容。</p>
<p>扩容后的数组容量为 4。</p>
<ul>
<li>key 3 取模（3%4）后是 3，放在 <code>table[3]</code> 上。</li>
<li>key 7 取模（7%4）后是 3，放在 <code>table[3]</code> 上的链表头部。</li>
<li>key 5 取模（5%4）后是 1，放在 <code>table[1]</code> 上。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807102413.png" alt="20250807102413"></p>
<p>可以看到，由于 JDK 采用的是头插法，7 跑到 3 的前面了，原来的顺序是 3、7、5，7 在 3 的后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e : oldTable) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">null</span> != e) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">        e.next = newTable[i];</span><br><span class="line">        newTable[i] = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好的情况就是，扩容后的 7 还在 3 的后面，保持原来的顺序。</p>
<h4 id="JDK-8-是怎么解决这个问题的？"><a href="#JDK-8-是怎么解决这个问题的？" class="headerlink" title="JDK 8 是怎么解决这个问题的？"></a>JDK 8 是怎么解决这个问题的？</h4><p>JDK 8 改用了尾插法，并且当 <code>(e.hash &amp; oldCap) == 0</code> 时，元素保留在原索引的位置；否则元素移动到<code>原索引 + 旧数组大小</code>的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line"><span class="keyword">if</span> (hiHead != <span class="literal">null</span>)</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br></pre></td></tr></table></figure>
<p>由于扩容时，数组长度会翻倍，例如：16 → 32， 因此，新数组的索引范围是原索引范围的两倍。</p>
<p>原索引 <code>index = (n - 1) &amp; hash</code>，扩容后的新索引就是 <code>index = (2n - 1) &amp; hash</code>。</p>
<p>也就是说，如果 <code>(e.hash &amp; oldCap) == 0</code>，元素在新数组中的位置与旧位置相同；否则，元素在新数组中的位置是旧位置 + 旧数组大小。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807102739.png" alt="20250807102739"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807102747.png" alt="20250807102747"></p>
<p>这样可以避免重新计算所有元素的哈希值，<strong>只需检查高位的某一位</strong>，就可以快速确定新位置。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807102803.png" alt="20250807102803"></p>
<h4 id="扩容的时候每个节点都要进行位运算吗？"><a href="#扩容的时候每个节点都要进行位运算吗？" class="headerlink" title="扩容的时候每个节点都要进行位运算吗？"></a>扩容的时候每个节点都要进行位运算吗？</h4><p>不需要。HashMap 会通过 <code>(e.hash &amp; oldCap)</code> 来判断节点是否需要移动，0 的话保留原索引；1 才需要移动到新索引（原索引 + oldCap）。</p>
<p>这样就避免了 <code>hashCode</code> 的重新计算，大大提升了扩容的性能。</p>
<p>所以，哪怕有几十万条数据，可能只有一半的数据才需要移动到新位置。另外，位运算的计算速度非常快，因此，尽管扩容操作涉及到遍历整个哈希表并对每个节点进行判断，但这部分操作的计算成本是相对较低的。</p>
<h3 id="24-🌟HashMap-是线程安全的吗？"><a href="#24-🌟HashMap-是线程安全的吗？" class="headerlink" title="24.🌟HashMap 是线程安全的吗？"></a>24.🌟HashMap 是线程安全的吗？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/collection/hashmap.html#_04%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8">HashMap 详解</a></p>
<p>HashMap 不是线程安全的，主要有以下几个问题：</p>
<p>①、多线程下扩容会死循环。JDK7 中的 HashMap 使用的是头插法来处理链表，在多线程环境下扩容会出现环形链表，造成死循环。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103405.png" alt="20250807103405"></p>
<p>不过，JDK 8 时通过尾插法修复了这个问题，扩容时会保持链表原来的顺序。</p>
<p>②、多线程在进行 put 元素的时候，可能会导致元素丢失。因为计算出来的位置可能会被其他线程覆盖掉，比如说一个县城 put 3 的时候，另外一个线程 put 了 7，就把 3 给弄丢了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103452.png" alt="20250807103452"></p>
<p>③、put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而扩容，线程 2 此时执行 get，就有可能出现这个问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103509.png" alt="20250807103509"></p>
<p>因为线程 1 执行完 table &#x3D; newTab 之后，线程 2 中的 table 已经发生了改变，比如说索引 3 的键值对移动到了索引 7 的位置，此时线程 2 去 get 索引 3 的元素就 get 不到了。</p>
<h3 id="25-🌟怎么解决-HashMap-线程不安全的问题呢？"><a href="#25-🌟怎么解决-HashMap-线程不安全的问题呢？" class="headerlink" title="25.🌟怎么解决 HashMap 线程不安全的问题呢？"></a>25.🌟怎么解决 HashMap 线程不安全的问题呢？</h3><p>在早期的 JDK 版本中，可以用 <code>Hashtable</code> 来保证线程安全。<code>Hashtable</code> 在方法上加了 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103648.png" alt="20250807103648"></p>
<p>另外，可以通过 <code>Collections.synchronizedMap</code> 方法返回一个线程安全的 Map，内部是通过 <code>synchronized</code> 对象锁来保证线程安全的，比在方法上直接加 <code>synchronized</code> 关键字更轻量级。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103717.png" alt="20250807103717"></p>
<p>更优雅的解决方案是使用并发工具包下的 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a>，使用了<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/cas.html">CAS</a>+ <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>来保证线程安全。<br>(分段锁+CAS)<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250807103755.png" alt="20250807103755"></p>
<h2 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h2><h3 id="2-🌟说说进程和线程的区别？"><a href="#2-🌟说说进程和线程的区别？" class="headerlink" title="2.🌟说说进程和线程的区别？"></a>2.🌟说说进程和线程的区别？</h3><p>推荐阅读:<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/why-need-thread.html">进程与线程的区别是什么？</a></p>
<p><code>进程</code>说简单点就是我们在电脑上启动的一个个应用。它是操作系统分配资源的最小单位。</p>
<p><code>线程</code>是进程中的独立执行单元。多个线程可以共享同一个进程的资源，如内存；每个线程都有自己独立的栈和寄存器。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808104808.png" alt="20250808104808"></p>
<h4 id="如何理解协程？"><a href="#如何理解协程？" class="headerlink" title="如何理解协程？"></a>如何理解协程？</h4><p><code>协程</code>被视为比线程更轻量级的并发单元，可以在单线程中实现并发执行，由我们开发者显式调度。</p>
<p><code>协程</code>是在用户态进行调度的，避免了线程切换时的内核态开销。</p>
<p><code>Java</code> 自身是不支持携程的，我们可以使用 <code>Quasar</code>、<code>Kotlin</code> 等框架来实现协程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程间是如何进行通信的？"><a href="#线程间是如何进行通信的？" class="headerlink" title="线程间是如何进行通信的？"></a>线程间是如何进行通信的？</h4><p>原则上可以通过<strong>消息传递</strong>和<strong>共享内存</strong>两种方法来实现。<code>Java</code> 采用的是共享内存的并发模型。</p>
<p>这个模型被称为 <code>Java</code> 内存模型，简写为 <code>JMM</code>，它决定了一个线程对共享变量的写入，何时对另外一个线程可见。当然了，本地内存是 <code>JMM</code> 的一个抽象概念，并不真实存在。</p>
<p>用一句话来概括就是：<strong>共享变量</strong>存储在主内存中，每个线程的私有本地内存，存储的是这个<strong>共享变量的副本</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808105242.png" alt="20250808105242"></p>
<p>线程 A 与线程 B 之间如要通信，需要要经历 2 个步骤：</p>
<ol>
<li>线程 A 把本地内存 A 中的共享变量副本刷新到主内存中。</li>
<li>线程 B 到主内存中读取线程 A 刷新过的共享变量，再同步到自己的共享变量副本中。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808110938.png" alt="20250808110938"></p>
<h3 id="3-🌟说说线程有几种创建方式？"><a href="#3-🌟说说线程有几种创建方式？" class="headerlink" title="3.🌟说说线程有几种创建方式？"></a>3.🌟说说线程有几种创建方式？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/wangzhe-thread.html">室友打了一把王者就学会了 Java 多线程</a></p>
<p>有三种，分别是继承 <code>Thread</code> 类、实现 <code>Runnable</code> 接口、实现 <code>Callable</code> 接口。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808111222.png" alt="20250808111222"></p>
<p>第一种需要重写父类 <code>Thread</code> 的 <code>run()</code> 方法，并且调用 <code>start()</code> 方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTask</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;看完二哥的 Java 进阶之路，上岸了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTask</span>();</span><br><span class="line">        task.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法的缺点是，如果 <code>ThreadTask</code> 已经继承了另外一个类，就不能再继承 <code>Thread</code> 类了，因为 <code>Java</code> 不支持多重继承。</p>
<p>第二种需要重写 <code>Runnable</code> 接口的 <code>run()</code> 方法，并将实现类的对象作为参数传递给 <code>Thread</code> 对象的构造方法，最后调用 <code>start()</code> 方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;看完二哥的 Java 进阶之路，上岸了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTask</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法的优点是可以避免 <code>Java</code> 的单继承限制，并且更符合面向对象的编程思想，因为 <code>Runnable</code> 接口将任务代码和线程控制的代码解耦了。</p>
<p>第三种需要重写 <code>Callable</code> 接口的 <code>call()</code> 方法，然后创建 <code>FutureTask</code> 对象，参数为 <code>Callable</code> 实现类的对象；紧接着创建 <code>Thread</code> 对象，参数为 <code>FutureTask</code> 对象，最后调用 <code>start()</code> 方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;看完二哥的 Java 进阶之路，上岸了!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">CallableTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableTask</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法的优点是可以获取线程的执行结果。</p>
<h4 id="一个-8G-内存的系统最多能创建多少个线程"><a href="#一个-8G-内存的系统最多能创建多少个线程" class="headerlink" title="一个 8G 内存的系统最多能创建多少个线程?"></a>一个 8G 内存的系统最多能创建多少个线程?</h4><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/neicun-jiegou.html">深入理解 JVM 的运行时数据区</a></p>
<p>理论上大约 <code>8000</code> 个。</p>
<p>创建线程的时候，至少需要分配一个虚拟机栈，在 64 位操作系统中，默认大小为 <code>1M</code>，因此一个线程大约需要 <code>1M</code> 的内存。</p>
<p>但 <code>JVM</code>、操作系统本身的运行就要占一定的内存空间，所以实际上可以创建的线程数远比 <code>8000</code> 少。</p>
<p>详细解释一下。</p>
<p>可以通过 <code>java -XX:+PrintFlagsFinal -version | grep ThreadStackSize</code> 命令查看 JVM 栈的默认大小。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808141237.png" alt="20250808141237"></p>
<p>其中 <code>ThreadStackSize</code> 的单位是 <code>KB</code>，也就是说默认的 <code>JVM</code> 栈大小是 <code>1024 KB</code>，也就是 <code>1M</code>。</p>
<h4 id="启动一个-Java-程序，你能说说里面有哪些线程吗？"><a href="#启动一个-Java-程序，你能说说里面有哪些线程吗？" class="headerlink" title="启动一个 Java 程序，你能说说里面有哪些线程吗？"></a>启动一个 Java 程序，你能说说里面有哪些线程吗？</h4><p>首先是 <code>main</code> 线程，这是程序执行的入口。</p>
<p>然后是<code>垃圾回收线程</code>，它是一个后台线程，负责回收不再使用的对象。</p>
<p>还有<code>编译器线程</code>，比如 <code>JIT</code>，负责把一部分热点代码编译后放到 <code>codeCache</code> 中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250808142112.png" alt="20250808142112"></p>
<p>可以通过下面的代码进行检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLister</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取所有线程的堆栈跟踪</span></span><br><span class="line">        Map&lt;Thread, StackTraceElement[]&gt; threads = Thread.getAllStackTraces();</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread: &quot;</span> + thread.getName() + <span class="string">&quot; (ID=&quot;</span> + thread.getId() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread: Monitor Ctrl-Break (ID=5)</span><br><span class="line">Thread: Reference Handler (ID=2)</span><br><span class="line">Thread: main (ID=1)</span><br><span class="line">Thread: Signal Dispatcher (ID=4)</span><br><span class="line">Thread: Finalizer (ID=3)</span><br></pre></td></tr></table></figure>

<p>简单解释下：</p>
<ul>
<li><code>Thread: main (ID=1)</code> - 主线程，Java 程序启动时由 JVM 创建。</li>
<li><code>Thread: Reference Handler (ID=2)</code> - 这个线程是用来处理引用对象的，如软引用、弱引用和虚引用。负责清理被 JVM 回收的对象。</li>
<li><code>Thread: Finalizer (ID=3)</code> - 终结器线程，负责调用对象的 finalize 方法。对象在垃圾回收器标记为可回收之前，由该线程执行其 finalize 方法，用于执行特定的资源释放操作。</li>
<li><code>Thread: Signal Dispatcher (ID=4)</code> - 信号调度线程，处理来自操作系统的信号，将它们转发给 JVM 进行进一步处理，例如响应中断、停止等信号。</li>
<li><code>Thread: Monitor Ctrl-Break (ID=5)</code> - 监视器线程，通常由一些特定的 IDE 创建，用于在开发过程中监控和管理程序执行或者处理中断。</li>
</ul>
<h3 id="4-🌟调用-start-方法时会执行-run-方法，那怎么不直接调用-run方法？"><a href="#4-🌟调用-start-方法时会执行-run-方法，那怎么不直接调用-run方法？" class="headerlink" title="4.🌟调用 start 方法时会执行 run 方法，那怎么不直接调用 run方法？"></a>4.🌟调用 start 方法时会执行 run 方法，那怎么不直接调用 run方法？</h3><p>调用 <code>start()</code> 会创建一个新的线程，并异步执行 <code>run()</code> 方法中的代码。</p>
<p>直接调用 <code>run()</code> 方法只是一个普通的同步方法调用，所有代码都在当前线程中执行，<strong>不会创建新线程</strong>。没有新的线程创建，也就达不到多线程并发的目的。</p>
<p>通过敲代码体验一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start(); <span class="comment">// 正确的方式，创建一个新线程，并在新线程中执行 run()</span></span><br><span class="line">        t1.run(); <span class="comment">// 仅在主线程中执行 run()，没有创建新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">Thread-0</span><br></pre></td></tr></table></figure>

<p>也就是说，调用 <code>start()</code> 方法会通知 <code>JVM</code>，去调用底层的线程调度机制来启动新线程。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250809102015.png" alt="20250809102015"></p>
<p>调用 <code>start()</code> 后，线程进入就绪状态，等待操作系统调度；一旦调度执行，线程会执行其 <code>run()</code> 方法中的代码。</p>
<h3 id="6-🌟线程有几种状态？"><a href="#6-🌟线程有几种状态？" class="headerlink" title="6.🌟线程有几种状态？"></a>6.🌟线程有几种状态？</h3><p>6 种。</p>
<ul>
<li><code>new</code> 代表线程被创建但未启动；</li>
<li><code>runnable</code> 代表线程处于就绪或正在运行状态，由操作系统调度；</li>
<li><code>blocked</code> 代表线程被阻塞，等待获取锁；</li>
<li><code>waiting</code> 代表线程等待其他线程的通知或中断；</li>
<li><code>timed_waiting</code> 代表线程会等待一段时间，超时后自动恢复；</li>
<li><code>terminated</code> 代表线程执行完毕，生命周期结束。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250809104257.png" alt="20250809104257"></p>
<p>也就是说，线程的生命周期可以分为五个主要阶段：新建、就绪、运行、阻塞和终止。线程在运行过程中会根据状态的变化在这些阶段之间切换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadStateExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// TIMED_WAITING</span></span><br><span class="line">                <span class="keyword">synchronized</span> (ThreadStateExample.class) &#123;</span><br><span class="line">                    ThreadStateExample.class.wait(); <span class="comment">// WAITING</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;State after creation: &quot;</span> + thread.getState()); <span class="comment">// NEW</span></span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;State after start: &quot;</span> + thread.getState()); <span class="comment">// RUNNABLE</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;State while sleeping: &quot;</span> + thread.getState()); <span class="comment">// TIMED_WAITING</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (ThreadStateExample.class) &#123;</span><br><span class="line">            ThreadStateExample.class.notify(); <span class="comment">// 唤醒线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;State after termination: &quot;</span> + thread.getState()); <span class="comment">// TERMINATED</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一个表格来做个总结：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250809104355.png" alt="20250809104355"></p>
<h4 id="如何强制终止线程？"><a href="#如何强制终止线程？" class="headerlink" title="如何强制终止线程？"></a>如何强制终止线程？</h4><p>第一步，调用线程的 <code>interrupt()</code> 方法，请求终止线程。</p>
<p>第二步，在线程的 <code>run()</code> 方法中检查中断状态，如果线程被中断，就退出线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获中断异常后，重置中断状态</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread interrupted, exiting...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); <span class="comment">// 主线程等待3秒</span></span><br><span class="line">        thread.interrupt(); <span class="comment">// 请求终止线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断结果：  </p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250809104457.png" alt="20250809104457"></p>
<h3 id="10-🌟请说说-sleep-和-wait-的区别？（补充）"><a href="#10-🌟请说说-sleep-和-wait-的区别？（补充）" class="headerlink" title="10.🌟请说说 sleep 和 wait 的区别？（补充）"></a>10.🌟请说说 sleep 和 wait 的区别？（补充）</h3><p><code>sleep</code> 会让当前线程休眠，不需要获取对象锁，属于 Thread 类的方法；<br><code>wait</code> 会让获得对象锁的线程等待，要提前获得对象锁，属于 Object 类的方法。</p>
<p>①、所属类不同</p>
<ul>
<li><code>sleep()</code> 方法专属于 <code>Thread</code> 类。</li>
<li><code>wait()</code> 方法专属于 <code>Object</code> 类。</li>
</ul>
<p>②、锁行为不同</p>
<p>如果一个线程在持有某个对象锁时调用了 <code>sleep</code> 方法，它在睡眠期间仍然会持有这个锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepDoesNotReleaseLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">sleepingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 会继续持有锁，并且进入睡眠状态&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 醒来了，并且释放了锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 进入同步代码块&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        sleepingThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        waitingThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 会继续持有锁，并且进入睡眠状态</span><br><span class="line">Thread 1 醒来了，并且释放了锁</span><br><span class="line">Thread 2 进入同步代码块</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从输出中我们可以看到，<code>waitingThread</code> 必须等待 <code>sleepingThread</code> 完成睡眠后才能进入同步代码块。</p>
<p>而当线程执行 <code>wait</code> 方法时，它会释放持有的对象锁，因此其他线程也有机会获取该对象的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitReleasesLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 持有锁，准备等待 5 秒&quot;</span>);</span><br><span class="line">                    lock.wait(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 醒来了，并且退出同步代码块&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">notifyingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 尝试唤醒等待中的线程&quot;</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 执行完了 notify&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        waitingThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        notifyingThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 持有锁，准备等待 5 秒</span><br><span class="line">Thread 2 尝试唤醒等待中的线程</span><br><span class="line">Thread 2 执行完了 notify</span><br><span class="line">Thread 1 醒来了，并且退出同步代码块</span><br></pre></td></tr></table></figure>

<p>这表明 waitingThread 在调用 wait 后确实释放了锁。</p>
<p>③、使用条件不同</p>
<p><code>sleep()</code> 方法可以在任何地方被调用。<br><code>wait()</code> 方法必须在同步代码块或同步方法中被调用，这是因为调用 <code>wait()</code> 方法的前提是当前线程必须持有对象的锁。否则会抛出 <code>IllegalMonitorStateException</code> 异常。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250820212712.png" alt="20250820212712"></p>
<p>④、唤醒方式不同</p>
<p>调用 <code>sleep</code> 方法后，线程会进入 <code>TIMED_WAITING</code> 状态，即在指定的时间内暂停执行。当指定的时间结束后，线程会自动恢复到 <code>RUNNABLE</code> 状态，等待 CPU 调度再次执行。</p>
<p>调用 <code>wait</code> 方法后，线程会进入 <code>WAITING</code> 状态，直到有其他线程在同一对象上调用 <code>notify</code> 或 <code>notifyAll</code> 方法，线程才会从 <code>WAITING</code> 状态转变为 <code>RUNNABLE</code> 状态，准备再次获得 CPU 的执行权。</p>
<p>我们来通过代码再感受一下 <code>sleep</code> 和 <code>wait</code> 在用法上的区别，先看 <code>sleep</code> 的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程准备休眠 2 秒&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 线程将睡眠2秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程醒来了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看 wait() 的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程准备等待 2 秒&quot;</span>);</span><br><span class="line">                    lock.wait(<span class="number">2000</span>); <span class="comment">// 线程会等待2秒，或者直到其他线程调用 lock.notify()/notifyAll()</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程结束等待&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="11-🌟怎么保证线程安全？（补充）"><a href="#11-🌟怎么保证线程安全？（补充）" class="headerlink" title="11.🌟怎么保证线程安全？（补充）"></a>11.🌟怎么保证线程安全？（补充）</h3><p>线程安全是指在并发环境下，多个线程访问共享资源时，程序能够正确地执行，而不会出现数据不一致的问题。</p>
<p>为了保证线程安全，可以使用 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>对方法加锁，对代码块加锁。线程在执行同步方法、同步代码块时，会获取类锁或者对象锁，其他线程就会阻塞并等待锁。</p>
<p>如果需要更细粒度的锁，可以使用 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock 并发重入锁</a>等。</p>
<p>如果需要保证变量的内存可见性，可以使用 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/volatile.html">volatile 关键字</a>。</p>
<p>对于简单的原子变量操作，还可以使用 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/atomic.html">Atomic 原子类</a>。</p>
<p>对于线程独立的数据，可以使用 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ThreadLocal.html">ThreadLocal</a> 来为每个线程提供专属的变量副本。</p>
<p>对于需要并发容器的地方，可以使用 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a>、<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/CopyOnWriteArrayList.html">CopyOnWriteArrayList</a> 等。</p>
<h4 id="有个int的变量为0，十个线程轮流对其进行-操作（循环10000次），结果大于10-万还是小于等于10万，为什么？"><a href="#有个int的变量为0，十个线程轮流对其进行-操作（循环10000次），结果大于10-万还是小于等于10万，为什么？" class="headerlink" title="有个int的变量为0，十个线程轮流对其进行++操作（循环10000次），结果大于10 万还是小于等于10万，为什么？"></a>有个int的变量为0，十个线程轮流对其进行++操作（循环10000次），结果大于10 万还是小于等于10万，为什么？</h4><p>在这个场景中，最终的结果会小于 100000，原因是多线程环境下，++ 操作并不是一个原子操作，而是分为读取、加 1、写回三个步骤。</p>
<ol>
<li>读取变量的值。</li>
<li>将读取到的值加 1。</li>
<li>将结果写回变量。</li>
</ol>
<p>这样的话，就会有多个线程读取到相同的值，然后对这个值进行加 1 操作，最终导致结果小于 100000。</p>
<p>详细解释下。</p>
<p>多个线程在并发执行 ++ 操作时，可能出现以下竞态条件：</p>
<ul>
<li>线程 1 读取变量值为 0。</li>
<li>线程 2 也读取变量值为 0。</li>
<li>线程 1 进行加法运算并将结果 1 写回变量。</li>
<li>线程 2 进行加法运算并将结果 1 写回变量，覆盖了线程 1 的结果。</li>
</ul>
<p>可以通过 synchronized 关键字为 ++ 操作加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main.class) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">            threads.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用 AtomicInteger 的 <code>incrementAndGet()</code> 方法来替代 ++ 操作，保证变量的原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">            threads.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景-有一个-key-对应的-value-是一个json-结构，json-当中有好几个子任务，这些子任务如果对-key-进行修改的话，会不会存在线程安全的问题？"><a href="#场景-有一个-key-对应的-value-是一个json-结构，json-当中有好几个子任务，这些子任务如果对-key-进行修改的话，会不会存在线程安全的问题？" class="headerlink" title="场景:有一个 key 对应的 value 是一个json 结构，json 当中有好几个子任务，这些子任务如果对 key 进行修改的话，会不会存在线程安全的问题？"></a>场景:有一个 key 对应的 value 是一个json 结构，json 当中有好几个子任务，这些子任务如果对 key 进行修改的话，会不会存在线程安全的问题？</h4><p>会。</p>
<p>在单节点环境中，可以使用 synchronized 关键字或 ReentrantLock 来保证对 key 的修改操作是原子的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KeyManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;tasks\&quot;: [\&quot;task1\&quot;, \&quot;task2\&quot;]&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readKey</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateKey</span><span class="params">(String newKey)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = newKey;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多节点环境中，可以使用分布式锁 Redisson 来保证对 key 的修改操作是原子的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DistributedKeyManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedissonClient redisson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedKeyManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.redisson = Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateKey</span><span class="params">(String key, String newValue)</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(key);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟读取和更新操作</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">currentValue</span> <span class="operator">=</span> readFromDatabase(key); <span class="comment">// 假设读取 JSON 数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">updatedValue</span> <span class="operator">=</span> modifyJson(currentValue, newValue); <span class="comment">// 修改 JSON</span></span><br><span class="line">            writeToDatabase(key, updatedValue); <span class="comment">// 写回数据库</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">readFromDatabase</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟从数据库读取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;tasks\&quot;: [\&quot;task1\&quot;, \&quot;task2\&quot;]&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">modifyJson</span><span class="params">(String json, String newValue)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 JSON 库解析并修改</span></span><br><span class="line">        <span class="keyword">return</span> json.replace(<span class="string">&quot;task1&quot;</span>, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeToDatabase</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟写回数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说一个线程安全的使用场景？"><a href="#说一个线程安全的使用场景？" class="headerlink" title="说一个线程安全的使用场景？"></a>说一个线程安全的使用场景？</h4><p>单例模式。在多线程环境下，如果多个线程同时尝试创建实例，单例类必须确保只创建一个实例，并提供一个全局访问点。</p>
<p>饿汉式是一种比较直接的实现方式，它通过在类加载时就立即初始化单例对象来保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式单例则在第一次使用时初始化单例对象，这种方式需要使用双重检查锁定来确保线程安全，volatile 关键字用来保证可见性，syncronized 关键字用来保证同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="能说一下-Hashtable-的底层数据结构吗？"><a href="#能说一下-Hashtable-的底层数据结构吗？" class="headerlink" title="能说一下 Hashtable 的底层数据结构吗？"></a>能说一下 Hashtable 的底层数据结构吗？</h4><p>与 HashMap 类似，Hashtable 的底层数据结构也是一个数组加上链表的方式，然后通过 synchronized 加锁来保证线程安全。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928191717.png" alt="20250928191717"><br>二哥的Java 进阶之路：Hashtable源码</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N741127FH/">ThreadLocal 全面解析</a></p>
<h3 id="12-🌟ThreadLocal-是什么？"><a href="#12-🌟ThreadLocal-是什么？" class="headerlink" title="12.🌟ThreadLocal 是什么？"></a>12.🌟ThreadLocal 是什么？</h3><p><a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ThreadLocal.html">ThreadLocal</a> 是一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928193013.png" alt="20250928193013"><br>三分恶面渣逆袭：ThreadLocal线程副本</p>
<p>使用 ThreadLocal 通常分为四步：</p>
<p>①、创建 ThreadLocal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ThreadLocal变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>②、设置 ThreadLocal 的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置ThreadLocal变量的值</span></span><br><span class="line">localVariable.set(<span class="string">&quot;沉默王二是沙雕&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>③、获取 ThreadLocal 的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ThreadLocal变量的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> localVariable.get();</span><br></pre></td></tr></table></figure>

<p>④、删除 ThreadLocal 的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除ThreadLocal变量的值</span></span><br><span class="line">localVariable.remove();</span><br></pre></td></tr></table></figure>

<p>在 Web 应用中，可以使用 ThreadLocal 存储用户会话信息，这样每个线程在处理用户请求时都能方便地访问当前用户的会话信息。</p>
<p>在数据库操作中，可以使用 ThreadLocal 存储数据库连接对象，每个线程有自己独立的数据库连接，从而避免了多线程竞争同一数据库连接的问题。</p>
<p>在格式化操作中，例如日期格式化，可以使用 ThreadLocal 存储 SimpleDateFormat 实例，避免多线程共享同一实例导致的线程安全问题。</p>
<h4 id="ThreadLocal-有哪些优点？"><a href="#ThreadLocal-有哪些优点？" class="headerlink" title="ThreadLocal 有哪些优点？"></a>ThreadLocal 有哪些优点？</h4><p>每个线程访问的变量副本都是独立的，避免了共享变量引起的线程安全问题。由于 ThreadLocal 实现了变量的线程独占，使得变量不需要同步处理，因此能够避免资源竞争。</p>
<p>ThreadLocal 可用于跨方法、跨类时传递上下文数据，不需要在方法间传递参数。</p>
<h3 id="14-🌟ThreadLocal-怎么实现的呢？"><a href="#14-🌟ThreadLocal-怎么实现的呢？" class="headerlink" title="14.🌟ThreadLocal 怎么实现的呢？"></a>14.🌟ThreadLocal 怎么实现的呢？</h3><p>当我们创建一个 ThreadLocal 对象并调用 set 方法时，其实是在当前线程中初始化了一个 ThreadLocalMap。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250930165350.png" alt="20250930165350"><br>二哥的 Java 进阶之路：ThreadLocalMap</p>
<p>ThreadLocalMap 是 ThreadLocal 的一个静态内部类，它内部维护了一个 Entry 数组，key 是 ThreadLocal 对象，value 是线程的局部变量，这样就相当于为每个线程维护了一个变量副本。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250930165403.png" alt="20250930165403"><br>三分恶面渣逆袭：ThreadLoca结构图</p>
<p>Entry 继承了 WeakReference，它限定了 key 是一个弱引用，弱引用的好处是当内存不足时，JVM 会回收 ThreadLocal 对象，并且将其对应的 Entry.value 设置为 null，这样可以在很大程度上避免内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点类</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">//key赋值</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        <span class="comment">//value赋值</span></span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<p>ThreadLocal 的实现原理是，每个线程维护一个 Map，key 为 ThreadLocal 对象，value 为想要实现线程隔离的对象。</p>
<p>1、通过 ThreadLocal 的 set 方法将对象存入 Map 中。</p>
<p>2、通过 ThreadLocal 的 get 方法从 Map 中取出对象。</p>
<p>3、Map 的大小由 ThreadLocal 对象的多少决定。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027082309.png" alt="20251027082309"><br>ThreadLocal 的结构</p>
<h4 id="什么是弱引用，什么是强引用？"><a href="#什么是弱引用，什么是强引用？" class="headerlink" title="什么是弱引用，什么是强引用？"></a>什么是弱引用，什么是强引用？</h4><p>我先说一下强引用，比如 <code>User user = new User(&quot;沉默王二&quot;)</code> 中，user 就是一个强引用，<code>new User(&quot;沉默王二&quot;)</code> 就是强引用对象。</p>
<p>当 user 被置为 null 时（<code>user = null</code>），<code>new User(&quot;沉默王二&quot;)</code> 对象就会被垃圾回收；否则即便是内存空间不足，JVM 也不会回收 <code>new User(&quot;沉默王二&quot;)</code> 这个强引用对象，宁愿抛出 OutOfMemoryError。</p>
<p>弱引用，比如说在使用 ThreadLocal 中，Entry 的 key 就是一个弱引用对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;User&gt; userThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">userThreadLocal.set(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;沉默王二&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>userThreadLocal 是一个强引用，<code>new ThreadLocal&lt;&gt;()</code> 是一个强引用对象；</p>
<p><code>new User(&quot;沉默王二&quot;)</code> 是一个强引用对象。</p>
<p>调用 set 方法后，会将 <code>key = new ThreadLocal&lt;&gt;()</code> 放入 ThreadLocalMap 中，此时的 key 是一个弱引用对象。当 JVM 进行垃圾回收时，如果发现了弱引用对象，就会将其回收。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250930165420.png" alt="20250930165420"><br>三分恶面渣逆袭：ThreadLocal内存分配</p>
<p>其关系链就是：</p>
<ul>
<li>ThreadLocal 强引用 -&gt; ThreadLocal 对象。</li>
<li>Thread 强引用 -&gt; ThreadLocalMap。</li>
<li><code>ThreadLocalMap[i]</code> 强引用了 -&gt; Entry。</li>
<li>Entry.key 弱引用 -&gt; ThreadLocal 对象。</li>
<li>Entry.value 强引用 -&gt; 线程的局部变量对象。</li>
</ul>
<h3 id="15-🌟ThreadLocal-内存泄露是怎么回事？"><a href="#15-🌟ThreadLocal-内存泄露是怎么回事？" class="headerlink" title="15.🌟ThreadLocal 内存泄露是怎么回事？"></a>15.🌟ThreadLocal 内存泄露是怎么回事？</h3><p>ThreadLocalMap 的 Key 是 弱引用，但 Value 是强引用。</p>
<p>如果一个线程一直在运行，并且 value 一直指向某个强引用对象，那么这个对象就不会被回收，从而导致内存泄漏。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251003165249.png" alt="20251003165249"><br>二哥的 Java 进阶之路：ThreadLocalMap 内存溢出</p>
<h4 id="那怎么解决内存泄漏问题呢？"><a href="#那怎么解决内存泄漏问题呢？" class="headerlink" title="那怎么解决内存泄漏问题呢？"></a>那怎么解决内存泄漏问题呢？</h4><p>很简单，使用完 ThreadLocal 后，及时调用 <code>remove()</code> 方法释放内存空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(value);</span><br><span class="line">    <span class="comment">// 执行业务操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove(); <span class="comment">// 确保能够执行清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>remove()</code> 会调用 ThreadLocalMap 的 remove 方法遍历哈希表，找到 key 等于当前 ThreadLocal 的 Entry，找到后会调用 Entry 的 clear 方法，将 Entry 的 value 设置为 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 计算 key 的 hash 值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 遍历数组，找到 key 为 null 的 Entry</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">            e != <span class="literal">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 将该 Entry 的 key 置为 null（即 Entry 失效）</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 清理过期的 entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.referent = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行 <code>expungeStaleEntry()</code> 方法，清除 key 为 null 的 Entry。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251003170914.png" alt="20251003170914"><br>二哥的Java进阶之路：expungeStaleEntry</p>
<h4 id="那为什么-key-要设计成弱引用？"><a href="#那为什么-key-要设计成弱引用？" class="headerlink" title="那为什么 key 要设计成弱引用？"></a>那为什么 key 要设计成弱引用？</h4><p>弱引用的好处是，当内存不足的时候，JVM 能够及时回收掉弱引用的对象。</p>
<p>比如说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WeakReference</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>());</span><br></pre></td></tr></table></figure>

<p>key 是弱引用，<code>new WeakReference(new ThreadLocal())</code> 是弱引用对象，当 JVM 进行垃圾回收时，只要发现了弱引用对象，就会将其回收。</p>
<p>一旦 key 被回收，ThreadLocalMap 在进行 set、get 的时候就会对 key 为 null 的 Entry 进行清理。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251003171039.png" alt="20251003171039"><br>二哥的 Java 进阶之路：清理 entry</p>
<p>总结一下，在 ThreadLocal 被垃圾收集后，下一次访问 ThreadLocalMap 时，Java 会自动清理那些键为 null 的 entry，这个过程会在执行 <code>get()</code>、<code>set()</code>、<code>remove()</code>时触发。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251003171336.png" alt="20251003171336"><br>二哥的 Java 进阶之路：replaceStaleEntry方法</p>
<h4 id="你了解哪些-ThreadLocal-的改进方案？"><a href="#你了解哪些-ThreadLocal-的改进方案？" class="headerlink" title="你了解哪些 ThreadLocal 的改进方案？"></a>你了解哪些 ThreadLocal 的改进方案？</h4><p>在 JDK 20 Early-Access Build 28 版本中，出现了 ThreadLocal 的改进方案，即 <code>ScopedValue</code>。</p>
<p>还有 Netty 中的 FastThreadLocal，它是 Netty 对 ThreadLocal 的优化，内部维护了一个索引常量 index，每次创建 FastThreadLocal 中都会自动+1，用来取代 hash 冲突带来的损耗，用空间换时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FastThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">    index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextVariableIndex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nextIndex.getAndIncrement();</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        nextIndex.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及阿里的 TransmittableThreadLocal，不仅实现了子线程可以继承父线程 ThreadLocal 的功能，并且还可以跨线程池传递值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TransmittableThreadLocal&lt;String&gt; context = <span class="keyword">new</span> <span class="title class_">TransmittableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在父线程中设置</span></span><br><span class="line">context.set(<span class="string">&quot;value-set-in-parent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子线程中可以读取，值是&quot;value-set-in-parent&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> context.get();</span><br></pre></td></tr></table></figure>



<h3 id="20-🌟说一下你对-Java-内存模型的理解？"><a href="#20-🌟说一下你对-Java-内存模型的理解？" class="headerlink" title="20.🌟说一下你对 Java 内存模型的理解？"></a>20.🌟说一下你对 Java 内存模型的理解？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/jmm.html">说说 Java 的内存模型</a></p>
<p>Java 内存模型是 Java 虚拟机规范中定义的一个抽象模型，用来描述多线程环境中共享变量的内存可见性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251004132340.png" alt="20251004132340"><br>深入浅出 Java 多线程：Java内存模型</p>
<p>共享变量存储在<code>主内存</code>中，每个线程都有一个私有的<code>本地内存</code>，存储了共享变量的副本。</p>
<ul>
<li>当一个线程更改了本地内存中共享变量的副本，它需要 JVM 刷新到主内存中，以确保其他线程可以看到这些更改。</li>
<li>当一个线程需要读取共享变量时，它一版会从本地内存中读取。如果本地内存中的副本是过时的，JVM 会将主内存中的共享变量最新值刷新到本地内存中。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251004132756.png" alt="20251004132756"><br>三分恶面渣逆袭：实际线程工作模型</p>
<h4 id="为什么线程要用自己的内存？"><a href="#为什么线程要用自己的内存？" class="headerlink" title="为什么线程要用自己的内存？"></a>为什么线程要用自己的内存？</h4><p>线程从主内存拷贝变量到工作内存，可以减少 CPU 访问 RAM 的开销。</p>
<p>每个线程都有自己的变量副本，可以避免多个线程同时修改共享变量导致的数据冲突。</p>
<h3 id="25-🌟volatile-了解吗？"><a href="#25-🌟volatile-了解吗？" class="headerlink" title="25.🌟volatile 了解吗？"></a>25.🌟volatile 了解吗？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/volatile.html">volatile 关键字解析</a></p>
<p>了解。</p>
<p>第一，保证可见性，线程修改 volatile 变量后，其他线程能够立即看到最新值；第二，防止指令重排，volatile 变量的写入不会被重排序到它之前的代码。</p>
<h4 id="volatile-怎么保证可见性的？"><a href="#volatile-怎么保证可见性的？" class="headerlink" title="volatile 怎么保证可见性的？"></a>volatile 怎么保证可见性的？</h4><p>当线程对 volatile 变量进行写操作时，JVM 会在这个变量写入之后插入一个写屏障指令，这个指令会强制将本地内存中的变量值刷新到主内存中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251004145546.png" alt="20251004145546"><br>三分恶面渣逆袭：volatile写插入内存屏障后生成的指令序列示意图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StoreStore;   <span class="comment">// 保证写入之前的操作不会重排</span></span><br><span class="line">volatile_write(); <span class="comment">// 写入 volatile 变量</span></span><br><span class="line">StoreLoad;    <span class="comment">// 保证写入后，其他线程立即可见</span></span><br></pre></td></tr></table></figure>

<p>在 x86 架构下，通常会使用 <code>lock</code> 指令来实现写屏障，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov [a], <span class="number">2</span>          ; 将值 <span class="number">2</span> 写入内存地址 a</span><br><span class="line">lock add [a], <span class="number">0</span>     ; lock 指令充当写屏障，确保内存可见性</span><br></pre></td></tr></table></figure>

<p>当线程对 volatile 变量进行读操作时，JVM 会插入一个读屏障指令，这个指令会强制让本地内存中的变量值失效，从而重新从主内存中读取最新的值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251004152020.png" alt="20251004152020"><br>三分恶面渣逆袭：volatile写插入内存屏障后生成的指令序列示意图</p>
<p>我们来声明一个 volatile 变量 x：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>线程 A 对 x 写入后会将其最新的值刷新到主内存中，线程 B 读取 x 时由于本地内存中的 x 失效了，就会从主内存中读取最新的值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251004152103.png" alt="20251004152103"><br>三分恶面渣逆袭：volatile内存可见性</p>
<h4 id="volatile-怎么保证有序性的？"><a href="#volatile-怎么保证有序性的？" class="headerlink" title="volatile 怎么保证有序性的？"></a>volatile 怎么保证有序性的？</h4><p>JVM 会在 volatile 变量的读写前后插入 “内存屏障”，以约束 CPU 和编译器的优化行为：</p>
<ul>
<li>StoreStore 屏障可以禁止<code>volatile 写</code>操作与<code>普通写</code>操作的重排</li>
<li>StoreLoad 屏障会禁止<code>volatile 写</code>与<code>volatile 读</code>重排</li>
<li>LoadLoad 屏障会禁止<code>volatile 读</code>与后续<code>普通读</code>操作重排</li>
<li>LoadStore 屏障会禁止<code>volatile 读</code>与后续<code>普通写</code>操作重排</li>
</ul>
<h4 id="volatile-和-synchronized-的区别？"><a href="#volatile-和-synchronized-的区别？" class="headerlink" title="volatile 和 synchronized 的区别？"></a>volatile 和 synchronized 的区别？</h4><p>volatile 关键字用于修饰变量，确保该变量的更新操作对所有线程是可见的，即一旦某个线程修改了 volatile 变量，其他线程会立即看到最新的值。</p>
<p>synchronized 关键字用于修饰方法或代码块，确保同一时刻只有一个线程能够执行该方法或代码块，从而实现互斥访问。</p>
<h4 id="volatile-加在基本类型和对象上的区别？"><a href="#volatile-加在基本类型和对象上的区别？" class="headerlink" title="volatile 加在基本类型和对象上的区别？"></a>volatile 加在基本类型和对象上的区别？</h4><p>当 <code>volatile</code> 用于基本数据类型时，能确保该变量的读写操作是直接从主内存中读取或写入的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>当 <code>volatile</code> 用于引用类型时，能确保引用本身的可见性，即确保引用指向的对象地址是最新的。</p>
<p>但是，<code>volatile</code> 并不能保证引用对象内部状态的线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">SomeObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeObject</span>();</span><br></pre></td></tr></table></figure>

<p>虽然 <code>volatile</code> 确保了 <code>obj</code> 引用的可见性，但对 <code>obj</code> 引用的 <code>new SomeObject()</code> 对象并不受 <code>volatile</code> 保护。</p>
<p>如果需要保证引用对象内部状态的线程安全，需要使用 <code>synchronized</code> 或 <code>ReentrantLock</code> 等锁机制。</p>
<h3 id="29-🌟synchronized-锁升级了解吗？"><a href="#29-🌟synchronized-锁升级了解吗？" class="headerlink" title="29.🌟synchronized 锁升级了解吗？"></a>29.🌟synchronized 锁升级了解吗？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/synchronized.html">偏向锁、轻量级锁、重量级锁到底是什么？</a></p>
<p>JDK 1.6 的时候，为了提升 synchronized 的性能，引入了锁升级机制，从低开销的锁逐步升级到高开销的锁，以最大程度减少锁的竞争。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009111617.png" alt="20251009111617"><br>三分恶面渣逆袭：Mark Word变化</p>
<p>没有线程竞争时，就使用低开销的“偏向锁”，此时没有额外的 CAS 操作；轻度竞争时，使用“轻量级锁”，采用 CAS 自旋，避免线程阻塞；只有在重度竞争时，才使用“重量级锁”，由 Monitor 机制实现，需要线程阻塞。</p>
<h4 id="了解-synchronized-四种锁状态吗？"><a href="#了解-synchronized-四种锁状态吗？" class="headerlink" title="了解 synchronized 四种锁状态吗？"></a>了解 synchronized 四种锁状态吗？</h4><p>了解。</p>
<p>①、无锁状态，对象未被锁定，Mark Word 存储对象的哈希码等信息。</p>
<p>②、偏向锁，当线程第一次获取锁时，会进入偏向模式。Mark Word 会记录线程 ID，后续同一线程再次获取锁时，可以直接进入 synchronized 加锁的代码，无需额外加锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009112449.png" alt="20251009112449"><br>博客园boluo1230：偏向锁</p>
<p>③、轻量级锁，当多个线程在不同时段获取同一把锁，即不存在锁竞争的情况时，JVM 会采用轻量级锁来避免线程阻塞。</p>
<p>未持有锁的线程通过<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/cas.html">CAS 自旋</a>等待锁释放。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009141857.png" alt="20251009141857"><br>TodoCoder：自旋和阻塞的区别</p>
<p>当线程进入 synchronized 加锁的代码时，如果对象的锁状态为偏向锁，也就是锁类型为“01”，偏向锁标记为“0”的状态。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009142009.png" alt="20251009142009"><br>博客园wade&amp;luffy：Mark Word</p>
<p>然后采用 CAS 自旋的方式，尝试将对象头中的 Mark Word 替换为指向 Lock Record 的指针，并将 Lock Record 中的 owner 指针指向对象的 Mark Word。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009142022.png" alt="20251009142022"><br>博客园boluo1230：轻量级锁</p>
<p>如果这个替换动作成功了，线程就拥有了该对象的锁，对象头 Mark Word 的锁标志位会更新为“00”，表示对象处于轻量级锁状态。</p>
<p>④、重量级锁，如果自旋超过一定的次数，或者一个线程持有锁，一个自旋，又有第三个线程进入 synchronized 加锁的代码时，轻量级锁就会升级为重量级锁。</p>
<p>此时，对象头的锁类型会更新为“10”，Mark Word 会存储指向 Monitor 对象的指针，其他等待锁的线程都会进入阻塞状态。</p>
<h4 id="synchronized-做了哪些优化？"><a href="#synchronized-做了哪些优化？" class="headerlink" title="synchronized 做了哪些优化？"></a>synchronized 做了哪些优化？</h4><p>在 JDK 1.6 之前，synchronized 是直接调用 ObjectMonitor 的 enter 和 exit 指令实现的，这种锁也被称为<strong>重量级锁</strong>，性能较差。</p>
<p>随着 JDK 版本的更新，synchronized 的性能得到了极大的优化：</p>
<p><strong>①、偏向锁</strong>：同一个线程可以多次获取同一把锁，无需重复加锁。</p>
<p><strong>②、轻量级锁</strong>：当没有线程竞争时，通过 CAS 自旋等待锁，避免直接进入阻塞。</p>
<p><strong>③、锁消除</strong>：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/jit.html">JIT</a> 可以在运行时进行代码分析，如果发现某些锁操作不可能被多个线程同时访问，就会对这些锁进行消除，从而减少上锁开销。</p>
<h4 id="请详细说说锁升级的过程？"><a href="#请详细说说锁升级的过程？" class="headerlink" title="请详细说说锁升级的过程？"></a>请详细说说锁升级的过程？</h4><p>懵逼状态下的回答：锁升级会从无锁升级为偏向锁，再升级为轻量级锁，最后升级为重量级锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009143540.png" alt="20251009143540"><br>三分恶面渣逆袭：锁升级简略过程</p>
<p>知道一点，但不深入的回答：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009143612.png" alt="20251009143612"><br>三分恶面渣逆袭：synchronized 锁升级过程</p>
<p>①、偏向锁：当一个线程第一次获取锁时，JVM 会在对象头的 Mark Word 记录这个线程 ID，下次进入 synchronized 时，如果还是同一个线程，可以直接执行，无需额外加锁。</p>
<p>②、轻量级锁：当多个线程尝试获取锁但不是同一个时段，偏向锁会升级为轻量级锁，等待锁的线程通过 CAS 自旋避免进入阻塞状态。</p>
<p>③、重量级锁：如果自旋失败，锁会升级为重量级锁，等待锁的线程会进入阻塞状态，等待监视器 Monitor 进行调度。</p>
<p>详细解释一下：</p>
<p><strong>①、从无锁到偏向锁：</strong></p>
<p>当一个线程首次访问同步代码时，如果此对象处于无锁状态且偏向锁未被禁用，JVM 会将该对象头的锁标记改为偏向锁状态，并记录当前线程 ID。此时，对象头中的 Mark Word 中存储了持有偏向锁的线程 ID。</p>
<p>如果另一个线程尝试获取这个已被偏向的锁，JVM 会检查当前持有偏向锁的线程是否活跃。如果持有偏向锁的线程不活跃，可以将锁偏向给新的线程；否则撤销偏向锁，升级为轻量级锁。</p>
<p><strong>②、偏向锁的轻量级锁：</strong></p>
<p>进行偏向锁撤销时，会遍历堆栈的所有锁记录，暂停拥有偏向锁的线程，并检查锁对象。如果这个过程中发现有其他线程试图获取这个锁，JVM 会撤销偏向锁，并将锁升级为轻量级锁。</p>
<p>当有两个或以上线程竞争同一个偏向锁时，偏向锁模式不再有效，此时偏向锁会被撤销，对象的锁状态会升级为轻量级锁。</p>
<p><strong>③、轻量级锁到重量级锁：</strong></p>
<p>轻量级锁通过自旋来等待锁释放。如果自旋超过预定次数（自旋次数是可调的，并且是自适应的，失败次数多自旋次数就少），表明锁竞争激烈。</p>
<p>当自旋多次失败，或者有线程在等待队列中等待相同的轻量级锁时，轻量级锁会升级为重量级锁。在这种情况下，JVM 会在操作系统层面创建一个互斥锁——Mutex，所有进一步尝试获取该锁的线程将会被阻塞，直到锁被释放。</p>
<h3 id="30-🌟synchronized-和-ReentrantLock-的区别了解吗？"><a href="#30-🌟synchronized-和-ReentrantLock-的区别了解吗？" class="headerlink" title="30.🌟synchronized 和 ReentrantLock 的区别了解吗？"></a>30.🌟synchronized 和 ReentrantLock 的区别了解吗？</h3><p>两句话回答：<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/synchronized-1.html">synchronized</a> 由 JVM 内部的 Monitor 机制实现，<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a>基于 AQS 实现。</p>
<p>synchronized 可以自动加锁和解锁，ReentrantLock 需要手动 <code>lock()</code> 和 <code>unlock()</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009151428.png" alt="20251009151428"><br>三分恶面渣逆袭：synchronized和ReentrantLock的区别</p>
<p>如果面试官还想知道更多，可以继续回答：</p>
<p>①、ReentrantLock 可以实现多路选择通知，绑定多个 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/condition.html">Condition</a>，而 synchronized 只能通过 wait 和 notify 唤醒，属于单路通知；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure>

<p>②、synchronized 可以在方法和代码块上加锁，ReentrantLock 只能在代码块上加锁，但可以指定是公平锁还是非公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized 修饰方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized 修饰代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock 加锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③、ReentrantLock 提供了一种能够中断等待锁的线程机制，通过 <code>lock.lockInterruptibly()</code> 来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并发量大的情况下，使用-synchronized-还是-ReentrantLock？"><a href="#并发量大的情况下，使用-synchronized-还是-ReentrantLock？" class="headerlink" title="并发量大的情况下，使用 synchronized 还是 ReentrantLock？"></a>并发量大的情况下，使用 synchronized 还是 ReentrantLock？</h4><p>我更倾向于 ReentrantLock，因为：</p>
<ul>
<li>ReentrantLock 提供了超时和公平锁等特性，可以应对更复杂的并发场景。</li>
<li>ReentrantLock 允许更细粒度的锁控制，能有效减少锁竞争。</li>
<li>ReentrantLock 支持条件变量 Condition，可以实现比 synchronized 更友好的线程间通信机制。</li>
</ul>
<h4 id="Lock-了解吗？"><a href="#Lock-了解吗？" class="headerlink" title="Lock 了解吗？"></a>Lock 了解吗？</h4><p>Lock 是 JUC 中的一个接口，最常用的实现类包括可重入锁 ReentrantLock、读写锁 ReentrantReadWriteLock 等。</p>
<h4 id="ReentrantLock-的-lock-方法实现逻辑了解吗？"><a href="#ReentrantLock-的-lock-方法实现逻辑了解吗？" class="headerlink" title="ReentrantLock 的 lock() 方法实现逻辑了解吗？"></a>ReentrantLock 的 lock() 方法实现逻辑了解吗？</h4><p>lock 方法的具体实现由 ReentrantLock 内部的 Sync 类来实现，涉及到线程的自旋、阻塞队列、CAS、AQS 等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027092407.png" alt="20251027092407"><br>二哥的Java 进阶之路：Lock.lock() 方法源码</p>
<p>lock 方法会首先尝试通过 CAS 来获取锁。如果当前锁没有被持有，会将锁状态设置为 1，表示锁已被占用。否则，会将当前线程加入到 AQS 的等待队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))  <span class="comment">// 尝试直接获取锁</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);  <span class="comment">// 如果获取失败，进入AQS队列等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="32-🌟说说-ReentrantLock-的实现原理？"><a href="#32-🌟说说-ReentrantLock-的实现原理？" class="headerlink" title="32.🌟说说 ReentrantLock 的实现原理？"></a>32.🌟说说 ReentrantLock 的实现原理？</h3><p><a target="_blank" rel="noopener" href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a> 是基于 AQS 实现的 可重入排他锁，使用 CAS 尝试获取锁，失败的话，会进入 CLH 阻塞队列，支持公平锁、非公平锁，可以中断、超时等待。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009155017.png" alt="20251009155017"><br>三分恶面渣逆袭：ReentrantLock 非公平锁加锁流程简图</p>
<p>内部通过一个计数器 state 来跟踪锁的状态和持有次数。当线程调用 <code>lock()</code> 方法获取锁时，ReentrantLock 会检查 state 的值，如果为 0，通过 CAS 修改为 1，表示成功加锁。否则根据当前线程的公平性策略，加入到等待队列中。</p>
<p>线程首次获取锁时，state 值设为 1；如果同一个线程再次获取锁时，state 加 1；每释放一次锁，state 减 1。</p>
<p>当线程调用 <code>unlock()</code> 方法时，ReentrantLock 会将持有锁的 state 减 1，如果 <code>state = 0</code>，则释放锁，并唤醒等待队列中的线程来竞争锁。</p>
<p>使用方式非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CounterWithLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();  <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new ReentrantLock()</code> 默认创建的是非公平锁 NonfairSync。在非公平锁模式下，锁可能会授予刚刚请求它的线程，而不考虑等待时间。当切换到公平锁模式下，锁会授予等待时间最长的线程。</p>
<h3 id="34-🌟CAS-了解多少？"><a href="#34-🌟CAS-了解多少？" class="headerlink" title="34.🌟CAS 了解多少？"></a>34.🌟CAS 了解多少？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/cas.html">一文彻底搞清楚 Java 实现 CAS 的原理</a></p>
<p>CAS 是一种乐观锁，用于比较一个变量的当前值是否等于预期值，如果相等，则更新值，否则重试。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009160404.png" alt="20251009160404"><br>CAS 原子性：博客园的紫薇哥哥</p>
<p>在 CAS 中，有三个值：</p>
<ul>
<li>V：要更新的变量(var)</li>
<li>E：预期值(expected)</li>
<li>N：新值(new)</li>
</ul>
<p>先判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，当前线程就放弃更新。</p>
<p>这个比较和替换的操作需要是原子的，不可中断的。Java 中的 CAS 是由 Unsafe 类实现的。</p>
<p>AtomicInteger 类的 compareAndSet 就是一个 CAS 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">expect</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">atomicInteger.compareAndSet(expect, update);</span><br></pre></td></tr></table></figure>

<p>它调用的是 Unsafe 的 compareAndSwapInt。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009160530.png" alt="20251009160530"><br>二哥的 Java 进阶之路：compareAndSwapInt</p>
<h4 id="怎么保证-CAS-的原子性？"><a href="#怎么保证-CAS-的原子性？" class="headerlink" title="怎么保证 CAS 的原子性？"></a><a href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81-cas-%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7">怎么保证 CAS 的原子性？</a></h4><p>CPU 会发出一个 LOCK 指令进行总线锁定，阻止其他处理器对内存地址进行操作，直到当前指令执行完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock cmpxchg [esi], eax  ; 比较 esi 地址中的值与 eax，如果相等则替换</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027093600.png" alt="20251027093600"><br>总线锁定：博客园的紫薇哥哥</p>
<h3 id="35-🌟CAS-有什么问题？"><a href="#35-🌟CAS-有什么问题？" class="headerlink" title="35.🌟CAS 有什么问题？"></a>35.🌟CAS 有什么问题？</h3><p>CAS 存在三个经典问题，ABA 问题、自旋开销大、只能操作一个变量等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009160610.png" alt="20251009160610"><br>三分恶面渣逆袭：CAS三大问题</p>
<h4 id="什么是-ABA-问题？"><a href="#什么是-ABA-问题？" class="headerlink" title="什么是 ABA 问题？"></a>什么是 ABA 问题？</h4><p>ABA 问题指的是，一个值原来是 A，后来被改为 B，再后来又被改回 A，这时 CAS 会误认为这个值没有发生变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程 <span class="number">1</span>：CAS(A → B)，修改变量 A → B</span><br><span class="line">线程 <span class="number">2</span>：CAS(B → A)，变量又变回 A</span><br><span class="line">线程 <span class="number">3</span>：CAS(A → C)，CAS 成功，但实际数据已被修改过！</span><br></pre></td></tr></table></figure>

<p>可以使用版本号&#x2F;时间戳的方式来解决 ABA 问题。</p>
<p>比如说，每次变量更新时，不仅更新变量的值，还更新一个版本号。CAS 操作时，不仅比较变量的值，还比较版本号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OptimisticLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">updateValue</span><span class="params">(<span class="type">int</span> newValue, <span class="type">int</span> currentVersion)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.version == currentVersion) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = newValue;</span><br><span class="line">            <span class="built_in">this</span>.version++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 的 AtomicStampedReference 就增加了版本号，它会同时检查引用值和 stamp 是否都相等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009160653.png" alt="20251009160653"><br>二哥的 Java 进阶之路：AtomicStampedReference</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ABAFix</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;100&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            ref.compareAndSet(<span class="string">&quot;100&quot;</span>, <span class="string">&quot;200&quot;</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            ref.compareAndSet(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;100&quot;</span>, ref.getStamp(), ref.getStamp() + <span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;CAS 结果：&quot;</span> + ref.compareAndSet(<span class="string">&quot;100&quot;</span>, <span class="string">&quot;300&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自旋开销大怎么解决？"><a href="#自旋开销大怎么解决？" class="headerlink" title="自旋开销大怎么解决？"></a>自旋开销大怎么解决？</h4><p>CAS 失败时会不断自旋重试，如果一直不成功，会给 CPU 带来非常大的执行开销。</p>
<p>可以加一个自旋次数的限制，超过一定次数，就切换到 synchronized 挂起线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">MAX_RETRIES</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!atomicInt.compareAndSet(expect, update)) &#123;</span><br><span class="line">    retries++;</span><br><span class="line">    <span class="keyword">if</span> (retries &gt; MAX_RETRIES) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 超过次数，使用 synchronized 处理</span></span><br><span class="line">            <span class="keyword">if</span> (atomicInt.get() == expect) &#123;</span><br><span class="line">                atomicInt.set(update);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="涉及到多个变量同时更新怎么办？"><a href="#涉及到多个变量同时更新怎么办？" class="headerlink" title="涉及到多个变量同时更新怎么办？"></a>涉及到多个变量同时更新怎么办？</h4><p>可以将多个变量封装为一个对象，使用 AtomicReference 进行 CAS 更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Balance</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> money;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> points;</span><br><span class="line"></span><br><span class="line">        Balance(<span class="type">int</span> money, <span class="type">int</span> points) &#123;</span><br><span class="line">            <span class="built_in">this</span>.money = money;</span><br><span class="line">            <span class="built_in">this</span>.points = points;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Balance&gt; balance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Balance</span>(<span class="number">100</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> newMoney, <span class="type">int</span> newPoints)</span> &#123;</span><br><span class="line">        Balance oldBalance, newBalance;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldBalance = balance.get();</span><br><span class="line">            newBalance = <span class="keyword">new</span> <span class="title class_">Balance</span>(newMoney, newPoints);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!balance.compareAndSet(oldBalance, newBalance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="40-🌟死锁问题怎么排查呢？"><a href="#40-🌟死锁问题怎么排查呢？" class="headerlink" title="40.🌟死锁问题怎么排查呢？"></a>40.🌟死锁问题怎么排查呢？</h3><p>首先从系统级别上排查，比如说在 Linux 生产环境中，可以先使用 <code>top</code> <code>ps</code> 等命令查看进程状态，看看是否有进程占用了过多的资源。</p>
<p>接着，使用 JDK 自带的一些性能监控工具进行排查，比如说 使用 <code>jps -l</code> 查看当前进程，然后使用 <code>jstack 进程号</code> 查看当前进程的线程堆栈信息，看看是否有线程在等待锁资源。</p>
<p>也可以使用一些可视化的性能监控工具，比如说 JConsole、VisualVM 等，查看线程的运行状态、锁的竞争情况等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009170605.png" alt="20251009170605"><br>三分恶面渣逆袭：线程死锁检测</p>
<p>我们来通过实际代码说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1获取到了锁1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1获取到了锁2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2获取到了锁2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2获取到了锁1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个线程，每个线程都试图按照不同的顺序获取两个<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/thread-bring-some-problem.html#%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98">锁（lock1 和 lock2）</a>。</p>
<p>锁的获取顺序不一致很容易导致死锁。运行这段代码，会发现两个线程都无法继续执行，进入了死锁状态。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009170646.png" alt="20251009170646"><br>二哥的 Java 进阶之路：死锁发生了</p>
<p>运行 <code>jstack pid</code> 命令，可以看到死锁的线程信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251009170656.png" alt="20251009170656"><br>jstack pid 查看死锁信息</p>
<p>编码时，尽量使用 <code>tryLock()</code> 代替 <code>lock()</code>，<code>tryLock()</code> 可以设置超时时间，避免线程一直等待。</p>
<p>同时，尽量避免一个线程同时获取多个锁，如果需要多个锁，可以按照固定的顺序获取。</p>
<p>推荐阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/console-tools.html">JVM 性能监控工具之命令行篇</a></li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/view-tools.html">JVM 性能监控工具之可视化篇</a></li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/arthas.html">阿里开源的 Java 诊断神器 Arthas</a></li>
</ul>
<h3 id="42-🌟聊聊悲观锁和乐观锁？（补充）"><a href="#42-🌟聊聊悲观锁和乐观锁？（补充）" class="headerlink" title="42.🌟聊聊悲观锁和乐观锁？（补充）"></a>42.🌟聊聊悲观锁和乐观锁？（补充）</h3><p>好的。</p>
<p>悲观锁认为每次访问共享资源时都会发生冲突，所在在操作前一定要先加锁，防止其他线程修改数据。</p>
<p>乐观锁认为冲突不会总是发生，所以在操作前不加锁，而是在更新数据时检查是否有其他线程修改了数据。如果发现数据被修改了，就会重试。</p>
<h4 id="乐观锁发现有线程过来修改数据，怎么办？"><a href="#乐观锁发现有线程过来修改数据，怎么办？" class="headerlink" title="乐观锁发现有线程过来修改数据，怎么办？"></a>乐观锁发现有线程过来修改数据，怎么办？</h4><p>可以重新读取数据，然后再尝试更新，直到成功为止或达到最大重试次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取数据 -&gt; 尝试更新 -&gt; 成功（返回成功）</span><br><span class="line">               |</span><br><span class="line">               -&gt; 失败 -&gt; 重试 -&gt; 达到最大次数 -&gt; 返回失败</span><br></pre></td></tr></table></figure>

<p>写个代码演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CasRetryExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RETRIES</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (retries &lt; MAX_RETRIES) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentValue</span> <span class="operator">=</span> counter.get();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">updated</span> <span class="operator">=</span> counter.compareAndSet(currentValue, currentValue + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (updated) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;更新成功，当前值: &quot;</span> + counter.get());</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                retries++;</span><br><span class="line">                System.out.println(<span class="string">&quot;更新失败，进行第 &quot;</span> + retries + <span class="string">&quot; 次重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;达到最大重试次数，操作失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="48-🌟能说一下-ConcurrentHashMap-的实现吗？（补充）"><a href="#48-🌟能说一下-ConcurrentHashMap-的实现吗？（补充）" class="headerlink" title="48.🌟能说一下 ConcurrentHashMap 的实现吗？（补充）"></a>48.🌟能说一下 ConcurrentHashMap 的实现吗？（补充）</h3><p>好的。<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a> 是 HashMap 的线程安全版本。</p>
<p>JDK 7 采用的是分段锁，整个 Map 会被分为若干段，每个段都可以独立加锁。不同的线程可以同时操作不同的段，从而实现并发。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010104933.png" alt="20251010104933"><br>初念初恋：JDK 7 ConcurrentHashMap</p>
<p>JDK 8 使用了一种更加细粒度的锁——桶锁，再配合 CAS + synchronized 代码块控制并发写入，以最大程度减少锁的竞争。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105023.png" alt="20251010105023"><br>初念初恋：JDK 8 ConcurrentHashMap</p>
<p>对于读操作，ConcurrentHashMap 使用了 volatile 变量来保证内存可见性。</p>
<p>对于写操作，ConcurrentHashMap 优先使用 CAS 尝试插入，如果成功就直接返回；否则使用 synchronized 代码块进行加锁处理。</p>
<h4 id="说一下-JDK-7-中-ConcurrentHashMap-的实现原理？"><a href="#说一下-JDK-7-中-ConcurrentHashMap-的实现原理？" class="headerlink" title="说一下 JDK 7 中 ConcurrentHashMap 的实现原理？"></a>说一下 JDK 7 中 ConcurrentHashMap 的实现原理？</h4><p>好的。</p>
<p>JDK 7 的 ConcurrentHashMap 采用的是分段锁，整个 Map 会被分为若干段，每个段都可以独立加锁，每个段类似一个 Hashtable。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105058.png" alt="20251010105058"><br>三分恶面渣逆袭：ConcurrentHashMap示意图</p>
<p>每个段维护一个键值对数组 <code>HashEntry&lt;K, V&gt;[] table</code>，HashEntry 是一个单项链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>段继承了 ReentrantLock，所以每个段都是一个可重入锁，不同的线程可以同时操作不同的段，从而实现并发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说一下-JDK-7-中-ConcurrentHashMap-的-put-流程？"><a href="#说一下-JDK-7-中-ConcurrentHashMap-的-put-流程？" class="headerlink" title="说一下 JDK 7 中 ConcurrentHashMap 的 put 流程？"></a>说一下 JDK 7 中 ConcurrentHashMap 的 put 流程？</h4><p>put 流程和 HashMap 非常类似，只不过是先定位到具体的段，再通过 ReentrantLock 去操作而已。一共可以分为 4 个步骤：</p>
<p>第一步，计算 key 的 hash，定位到段，段如果是空就先初始化；</p>
<p>第二步，使用 ReentrantLock 进行加锁，如果加锁失败就自旋，自旋超过次数就阻塞，保证一定能获取到锁；</p>
<p>第三步，遍历段中的键值对 HashEntry，key 相同直接替换，key 不存在就插入。</p>
<p>第四步，释放锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105204.png" alt="20251010105204"><br>三分恶面渣逆袭：JDK7 put 流程</p>
<h4 id="说一下-JDK-7-中-ConcurrentHashMap-的-get-流程？"><a href="#说一下-JDK-7-中-ConcurrentHashMap-的-get-流程？" class="headerlink" title="说一下 JDK 7 中 ConcurrentHashMap 的 get 流程？"></a>说一下 JDK 7 中 ConcurrentHashMap 的 get 流程？</h4><p>get 就更简单了，先计算 key 的 hash 找到段，再遍历段中的键值对，找到就直接返回 value。</p>
<p>get 不用加锁，因为是 value 是 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/volatile.html">volatile</a> 的，所以线程读取 value 时不会出现可见性问题。</p>
<h4 id="说一下-JDK-8-中-ConcurrentHashMap-的实现原理？"><a href="#说一下-JDK-8-中-ConcurrentHashMap-的实现原理？" class="headerlink" title="说一下 JDK 8 中 ConcurrentHashMap 的实现原理？"></a>说一下 JDK 8 中 ConcurrentHashMap 的实现原理？</h4><p>好的。</p>
<p>JDK 8 中的 ConcurrentHashMap 取消了分段锁，采用 CAS + synchronized 来实现更细粒度的桶锁，并且使用红黑树来优化链表以提高哈希冲突时的查询效率，性能比 JDK 7 有了很大的提升。</p>
<h4 id="说一下-JDK-8-中-ConcurrentHashMap-的-put-流程？"><a href="#说一下-JDK-8-中-ConcurrentHashMap-的-put-流程？" class="headerlink" title="说一下 JDK 8 中 ConcurrentHashMap 的 put 流程？"></a>说一下 JDK 8 中 ConcurrentHashMap 的 put 流程？</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105242.png" alt="20251010105242"><br>三分恶面渣逆袭：Java 8 put 流程</p>
<p>第一步，计算 key 的 hash，以确定桶在数组中的位置。如果数组为空，采用 CAS 的方式初始化，以确保只有一个线程在初始化数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 hash</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    tab = initTable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算桶的位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash;</span><br></pre></td></tr></table></figure>

<p>第二步，如果桶为空，直接 CAS 插入节点。如果 CAS 操作失败，会退化为 synchronized 代码块来插入节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CAS 插入节点</span></span><br><span class="line"><span class="keyword">if</span> (tabAt(tab, i) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则，使用 synchronized 代码块插入节点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (f) &#123;  <span class="comment">// **只锁当前桶**</span></span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 确保未被其他线程修改</span></span><br><span class="line">            <span class="keyword">if</span> (f.hash &gt;= <span class="number">0</span>) &#123; <span class="comment">// 链表处理</span></span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;;) &#123;</span><br><span class="line">                    K ek;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                        e.val = value;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// **红黑树处理**</span></span><br><span class="line">                ((TreeBin&lt;K,V&gt;) f).putTreeVal(hash, key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入的过程中会判断桶的哈希是否小于 0（<code>f.hash &gt;= 0</code>），小于 0 说明是红黑树，大于等于 0 说明是链表。</p>
<p>这里补充一点：在 ConcurrentHashMap 的实现中，红黑树节点 TreeBin 的 hash 值固定为 -2。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105550.png" alt="20251010105550"><br>二哥的 Java 进阶之路：TreeBin 的哈希值固定为 -2</p>
<p>第三步，如果链表长度超过 8，转换为红黑树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">    treeifyBin(tab, i);</span><br></pre></td></tr></table></figure>

<p>第四步，在插入新节点后，会调用 <code>addCount()</code> 方法检查是否需要扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addCount(<span class="number">1L</span>, binCount);</span><br></pre></td></tr></table></figure>

<h4 id="说一下-JDK-8-中-ConcurrentHashMap-的-get-流程？"><a href="#说一下-JDK-8-中-ConcurrentHashMap-的-get-流程？" class="headerlink" title="说一下 JDK 8 中 ConcurrentHashMap 的 get 流程？"></a>说一下 JDK 8 中 ConcurrentHashMap 的 get 流程？</h4><p>get 也是通过 key 的 hash 进行定位，如果该位置节点的哈希匹配且键相等，则直接返回值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105607.png" alt="20251010105607"><br>二哥的 Java 进阶之路：HashMap 和 ConcurrentHashMap 的 get 方法</p>
<p>如果节点的哈希为负数，说明是个特殊节点，比如说如树节点或者正在迁移的节点，就调用<code>find</code>方法查找。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010105625.png" alt="20251010105625"><br>二哥的 Java 进阶之路：ForwardingNode和TreeNode的 find 方法</p>
<p>否则遍历链表查找匹配的键。如果都没找到，返回 null。</p>
<h4 id="说一下-HashMap-和-ConcurrentHashMap-的区别？"><a href="#说一下-HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="说一下 HashMap 和 ConcurrentHashMap 的区别？"></a>说一下 HashMap 和 ConcurrentHashMap 的区别？</h4><p>HashMap 是非线程安全的，多线程环境下应该使用 ConcurrentHashMap。</p>
<h4 id="你项目中怎么使用-ConcurrentHashMap-的？"><a href="#你项目中怎么使用-ConcurrentHashMap-的？" class="headerlink" title="你项目中怎么使用 ConcurrentHashMap 的？"></a>你项目中怎么使用 ConcurrentHashMap 的？</h4><p>在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，很多地方都用到了 ConcurrentHashMap，比如说在异步工具类 AsyncUtil 中，就使用了 ConcurrentHashMap 来存储任务的名称和它们的运行时间，以便观察和分析任务的执行情况。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027103144.png" alt="20251027103144"><br>二哥的 Java 进阶之路：技术派的源码封装 ConcurrentHashMap</p>
<h4 id="说一下-ConcurrentHashMap-对-HashMap-的改进？"><a href="#说一下-ConcurrentHashMap-对-HashMap-的改进？" class="headerlink" title="说一下 ConcurrentHashMap 对 HashMap 的改进？"></a>说一下 ConcurrentHashMap 对 HashMap 的改进？</h4><p>首先是 hash 的计算方法上，ConcurrentHashMap 的 spread 方法接收一个已经计算好的 hashCode，然后将这个哈希码的高 16 位与自身进行异或运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比 HashMap 的 hash 计算多了一个 <code>&amp; HASH_BITS</code> 的操作。这里的 HASH_BITS 是一个常数，值为 0x7fffffff，它确保结果是一个非负整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，ConcurrentHashMap 对节点 Node 做了进一步的封装，比如说用 Forwarding Node 来表示正在进行扩容的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="built_in">super</span>(MOVED, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是 put 方法，通过 CAS + synchronized 代码块来进行并发写入。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027104143.png" alt="20251027104143"><br>二哥的 Java 进阶之路：ConcurrentHashMap 的源码</p>
<h4 id="为什么-ConcurrentHashMap-在-JDK-1-7-中要用-ReentrantLock，而在-JDK-1-8-要用-synchronized"><a href="#为什么-ConcurrentHashMap-在-JDK-1-7-中要用-ReentrantLock，而在-JDK-1-8-要用-synchronized" class="headerlink" title="为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized"></a>为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized</h4><p>JDK 1.7 中的 ConcurrentHashMap 使用了分段锁机制，每个 Segment 都继承了 ReentrantLock，这样可以保证每个 Segment 都可以独立地加锁。</p>
<p>而在 JDK 1.8 中，ConcurrentHashMap 取消了 Segment 分段锁，采用了更加精细化的锁——桶锁，以及 CAS 无锁算法，每个桶都可以独立地加锁，只有在 CAS 失败时才会使用 synchronized 代码块加锁，这样可以减少锁的竞争，提高并发性能。</p>
<h3 id="53-🌟什么是线程池？"><a href="#53-🌟什么是线程池？" class="headerlink" title="53.🌟什么是线程池？"></a>53.🌟什么是线程池？</h3><p>线程池是用来管理和复用线程的工具，它可以减少线程的创建和销毁开销。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110039.png" alt="20251010110039"><br>三分恶面渣逆袭：管理线程的池子</p>
<p>在 Java 中，ThreadPoolExecutor 是线程池的核心实现，它通过核心线程数、最大线程数、任务队列和拒绝策略来控制线程的创建和执行。</p>
<p>举个例子：就像你开了一家餐厅，线程池就相当于固定数量的服务员，顾客（任务）来了就安排空闲的服务员（线程）处理，避免了频繁招人和解雇的成本。</p>
<h3 id="55-🌟说一下线程池的工作流程？"><a href="#55-🌟说一下线程池的工作流程？" class="headerlink" title="55.🌟说一下线程池的工作流程？"></a>55.🌟说一下线程池的工作流程？</h3><p>可以简单总结为：</p>
<p>任务提交 → 核心线程执行 → 任务队列缓存 → 非核心线程执行 → 拒绝策略处理。</p>
<p>第一步，线程池通过 <code>submit()</code> 提交任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">threadPool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;办理业务&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第二步，线程池会先创建核心线程来执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，如果核心线程都在忙，任务会被放入任务队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workQueue.offer(task);</span><br></pre></td></tr></table></figure>

<p>第四步，如果任务队列已满，且当前线程数量小于最大线程数，线程池会创建新的线程来处理任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br></pre></td></tr></table></figure>

<p>第五步，如果线程池中的线程数量已经达到最大线程数，且任务队列已满，线程池会执行拒绝策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.rejectedExecution(command, <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>另外一版回答。</p>
<p>第一步，创建线程池。</p>
<p>第二步，调用线程池的 <code>execute()</code>方法，准备执行任务。</p>
<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么线程池会创建一个新的线程来执行这个任务；</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么线程池会将这个任务放入等待队列；</li>
<li>如果等待队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么线程池会创建新的线程来执行这个任务；</li>
<li>如果等待队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会执行拒绝策略。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110236.png" alt="20251010110236"><br>三分恶面渣逆袭：线程池执行流程</p>
<p>第三步，线程执行完毕后，线程并不会立即销毁，而是继续保持在池中等待下一个任务。</p>
<p>第四步，当线程空闲时间超出指定时间，且当前线程数量大于核心线程数时，线程会被回收。</p>
<h4 id="能用一个生活中的例子说明下吗？"><a href="#能用一个生活中的例子说明下吗？" class="headerlink" title="能用一个生活中的例子说明下吗？"></a>能用一个生活中的例子说明下吗？</h4><p>可以。有个名叫“你一定暴富”的银行，该银行有 6 个窗口，现在开放了 3 个窗口，坐着 3 个小姐姐在办理业务。</p>
<p>靓仔小二去办理业务，会遇到什么情况呢？</p>
<p>第一情况，小二发现有个空闲的小姐姐，正在翘首以盼，于是小二就快马加鞭跑过去办理了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110317.png" alt="20251010110317"><br>三分恶面渣逆袭：直接办理</p>
<p>第二种情况，小姐姐们都在忙，接待员小美招呼小二去排队区区取号排队，让小二稍安勿躁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110343.png" alt="20251010110343"><br>三分恶面渣逆袭：排队等待</p>
<p>第三种情况，不仅小姐姐们都在忙，排队区也满了，小二着急用钱，于是脾气就上来了，和接待员小美对线了起来，要求开放另外 3 个空闲的窗口。</p>
<p>小美迫于小二的压力，开放了另外 3 个窗口，排队区的人立马就冲了过去。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110423.png" alt="20251010110423"><br>三分恶面渣逆袭：排队区满</p>
<p>第四种情况，6 个窗口的小姐姐都在忙，排队区也满了。。。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110434.png" alt="20251010110434"><br>三分恶面渣逆袭：等待区，排队区都满</p>
<p>接待员小美给了小二 4 个选项：</p>
<ol>
<li>对不起，我们暴富银行系统瘫痪了。</li>
<li>没看忙着呢，谁叫你来办的你找谁去！</li>
<li>靓仔，看你比较急，去队里偷偷加个塞。</li>
<li>不好意思，今天没办法，你改天再来吧。</li>
</ol>
<p>这个流程和线程池不能说一模一样，简直就是一模一样：</p>
<ol>
<li>corePoolSize 对应营业窗口数 3</li>
<li>maximumPoolSize 对应最大窗口数 6</li>
<li>workQueue 对应排队区</li>
<li>handler 对应接待员小美</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">6</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">0</span>, <span class="comment">// 线程空闲时间</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), <span class="comment">// 等待队列</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 模拟 10 个顾客来银行办理业务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;办理业务&quot;</span> + tempInt);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-🌟线程池的主要参数有哪些？"><a href="#56-🌟线程池的主要参数有哪些？" class="headerlink" title="56.🌟线程池的主要参数有哪些？"></a>56.🌟线程池的主要参数有哪些？</h3><p>线程池有 7 个参数，需要重点关注的有核心线程数、最大线程数、等待队列、拒绝策略。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110511.png" alt="20251010110511"><br>三分恶面渣逆袭：线程池参数</p>
<p><strong>①、corePoolSize</strong>：核心线程数，长期存活，执行任务的主力。</p>
<p><strong>②、maximumPoolSize</strong>：线程池允许的最大线程数。</p>
<p><strong>③、workQueue</strong>：任务队列，存储等待执行的任务。</p>
<p><strong>④、handler</strong>：拒绝策略，任务超载时的处理方式。也就是线程数达到 maximumPoolSiz，任务队列也满了的时候，就会触发拒绝策略。</p>
<p><strong>⑤、threadFactory</strong>：线程工厂，用于创建线程，可自定义线程名。</p>
<p><strong>⑥、keepAliveTime</strong>：非核心线程的存活时间，空闲时间超过该值就销毁。</p>
<p><strong>⑦、unit</strong>：keepAliveTime 参数的时间单位：</p>
<ul>
<li>TimeUnit.DAYS; 天</li>
<li>TimeUnit.HOURS; 小时</li>
<li>TimeUnit.MINUTES; 分钟</li>
<li>TimeUnit.SECONDS; 秒</li>
<li>TimeUnit.MILLISECONDS; 毫秒</li>
<li>TimeUnit.MICROSECONDS; 微秒</li>
<li>TimeUnit.NANOSECONDS; 纳秒</li>
</ul>
<h4 id="能简单说一下参数之间的关系吗？"><a href="#能简单说一下参数之间的关系吗？" class="headerlink" title="能简单说一下参数之间的关系吗？"></a>能简单说一下参数之间的关系吗？</h4><p>一句话：任务优先使用核心线程执行，满了进入等待队列，队列满了启用非核心线程备用，线程池达到最大线程数量后触发拒绝策略，非核心线程的空闲时间超过存活时间就被回收。</p>
<h4 id="核心线程数不够会怎么进行处理？"><a href="#核心线程数不够会怎么进行处理？" class="headerlink" title="核心线程数不够会怎么进行处理？"></a>核心线程数不够会怎么进行处理？</h4><p>当提交的任务数超过了 corePoolSize，但是小于 maximumPoolSize 时，线程池会创建新的线程来处理任务。</p>
<p>当提交的任务数超过了 maximumPoolSize 时，线程池会根据拒绝策略来处理任务。</p>
<h4 id="举个例子说一下这些参数的变化？"><a href="#举个例子说一下这些参数的变化？" class="headerlink" title="举个例子说一下这些参数的变化？"></a>举个例子说一下这些参数的变化？</h4><p>假设一个场景，线程池的配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize = <span class="number">5</span></span><br><span class="line">maximumPoolSize = <span class="number">10</span></span><br><span class="line">keepAliveTime = <span class="number">60</span>秒</span><br><span class="line">workQueue = LinkedBlockingQueue（容量为<span class="number">100</span>）</span><br><span class="line">handler = ThreadPoolExecutor.AbortPolicy()</span><br></pre></td></tr></table></figure>

<p><strong>场景一</strong>：当系统启动后，有 10 个任务提交到线程池。</p>
<ul>
<li>前 5 个任务会立即执行，因为核心线程数足够容纳它们。</li>
<li>随后的 5 个任务会被放入等待队列。</li>
</ul>
<p><strong>场景二</strong>：如果此时再有 100 个任务提交到线程池。</p>
<ul>
<li>工作队列已满，线程池会创建额外的线程来执行这些任务，直到线程总数达到 10。</li>
<li>如果任务继续增加，超过了工作队列+最大线程数的限制，新来的任务会被 AbortPolicy 拒绝，抛出 RejectedExecutionException 异常。</li>
</ul>
<p><strong>场景三</strong>：如果任务突然减少：</p>
<p>核心线程会一直运行，而超出核心线程数的线程，会在 60 秒后回收。</p>
<h3 id="57-🌟线程池的拒绝策略有哪些？"><a href="#57-🌟线程池的拒绝策略有哪些？" class="headerlink" title="57.🌟线程池的拒绝策略有哪些？"></a>57.🌟线程池的拒绝策略有哪些？</h3><p>有四种：</p>
<ul>
<li>AbortPolicy：默认的拒绝策略，会抛 RejectedExecutionException 异常。</li>
<li>CallerRunsPolicy：让提交任务的线程自己来执行这个任务，也就是调用 execute 方法的线程。</li>
<li>DiscardOldestPolicy：等待队列会丢弃队列中最老的一个任务，也就是队列中等待最久的任务，然后尝试重新提交被拒绝的任务。</li>
<li>DiscardPolicy：丢弃被拒绝的任务，不做任何处理也不抛出异常。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010110646.png" alt="20251010110646"><br>三分恶面渣逆袭：四种策略</p>
<p>分别对应着小二去银行办理业务被经理“薄纱”的四个场景：“我们系统瘫痪了”、“谁叫你来办的你找谁去”、“看你比较急，去队里加个塞”、“今天没办法，不行你看改一天”。</p>
<p>当线程池无法接受新的任务时，也就是线程数达到 maximumPoolSize，任务队列也满了的时候，就会触发拒绝策略。</p>
<p>如果默认策略不能满足需求，可以通过实现 RejectedExecutionHandler 接口来定义自己的淘汰策略。例如：记录被拒绝任务的日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomRejectedHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义拒绝策略</span></span><br><span class="line">        <span class="type">RejectedExecutionHandler</span> <span class="variable">rejectedHandler</span> <span class="operator">=</span> (r, executor) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task &quot;</span> + r.toString() + <span class="string">&quot; rejected. Queue size: &quot;</span> </span><br><span class="line">                               + executor.getQueue().size());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">2</span>,                      <span class="comment">// 核心线程数</span></span><br><span class="line">            <span class="number">4</span>,                      <span class="comment">// 最大线程数</span></span><br><span class="line">            <span class="number">10</span>,                     <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>),  <span class="comment">// 阻塞队列容量</span></span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            rejectedHandler          <span class="comment">// 自定义拒绝策略</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskNumber</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Executing task &quot;</span> + taskNumber);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="67-🌟线程池调优了解吗？（补充）"><a href="#67-🌟线程池调优了解吗？（补充）" class="headerlink" title="67.🌟线程池调优了解吗？（补充）"></a>67.🌟线程池调优了解吗？（补充）</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010111648.png" alt="20251010111648"><br>三分恶面渣逆袭：线程池调优</p>
<p>首先我会根据任务类型设置核心线程数参数，比如 IO 密集型任务会设置为 CPU 核心数*2 的经验值。</p>
<p>其次我会结合线程池动态调整的能力，在流量波动时通过 setCorePoolSize 平滑扩容，或者直接使用 DynamicTp 实现线程池参数的自动化调整。</p>
<p>最后，我会通过内置的监控指标建立容量预警机制。比如通过 JMX 监控线程池的运行状态，设置阈值，当线程池的任务队列长度超过阈值时，触发告警。</p>
<h3 id="69-🌟你能设计实现一个线程池吗？"><a href="#69-🌟你能设计实现一个线程池吗？" class="headerlink" title="69.🌟你能设计实现一个线程池吗？"></a>69.🌟你能设计实现一个线程池吗？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Exy7pRGND9TCjRd9TZK4jg">三分恶线程池原理</a></p>
<p>线程池的主要目的是为了避免频繁地创建和销毁线程。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010111742.png" alt="20251010111742"><br>三分恶面渣逆袭：线程池主要实现流程</p>
<p>我会把线程池看作一个工厂，里面有一群“工人”，也就是线程了，专门用来做任务。</p>
<p>当任务来了，需要先判断有没有空闲的工人，如果有就把任务交给他们；如果没有，就把任务暂存到一个任务队列里，等工人忙完了再去处理。</p>
<p>如果队列满了，还没有空闲的工人，就要考虑扩容，让预备的工人过来干活，但不能超过预定的最大值，防止工厂被挤爆。</p>
<p>如果连扩容也没法解决，就需要一个拒绝策略，可能直接拒绝任务或者报个错。</p>
<p>核心线程池类（可参考）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeUnit unit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isShutdown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentPoolSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit,</span></span><br><span class="line"><span class="params">                                    BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="built_in">this</span>.unit = unit;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;ThreadPool is shutdown&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程数小于核心线程数，直接创建新线程</span></span><br><span class="line">            <span class="keyword">if</span> (currentPoolSize &lt; corePoolSize) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Worker</span>(task).start();</span><br><span class="line">                currentPoolSize++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试将任务添加到队列中</span></span><br><span class="line">            <span class="keyword">if</span> (!workQueue.offer(task)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentPoolSize &lt; maximumPoolSize) &#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Worker</span>(task).start();</span><br><span class="line">                    currentPoolSize++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用拒绝策略</span></span><br><span class="line">                    handler.rejectedExecution(task, <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        isShutdown = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        Worker(Runnable task) &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列中获取任务</span></span><br><span class="line">        <span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> workQueue.poll(keepAliveTime, unit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拒绝策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拒绝策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomRejectedExecutionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AbortPolicy 抛出异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() + <span class="string">&quot; rejected from &quot;</span> + e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DiscardPolicy 什么都不做</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DiscardOldestPolicy 丢弃队列中最旧的任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">CustomThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CustomRejectedExecutionHandler</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + index + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010111815.png" alt="20251010111815"><br>二哥的 Java 进阶之路：自定义线程池</p>
<h4 id="手写一个数据库连接池，可以吗？"><a href="#手写一个数据库连接池，可以吗？" class="headerlink" title="手写一个数据库连接池，可以吗？"></a>手写一个数据库连接池，可以吗？</h4><p>可以的，我的思路是这样的：数据库连接池主要是为了避免每次操作数据库时都去创建连接，因为那样很浪费资源。所以我打算在初始化时预先创建好固定数量的连接，然后把它们放到一个线程安全的容器里，后续有请求的时候就从队列里拿，使用完后再归还到队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleConnectionPool</span> &#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    <span class="keyword">private</span> String jdbcUrl;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxConnections;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Connection&gt; connectionPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleConnectionPool</span><span class="params">(String jdbcUrl, String username, String password, <span class="type">int</span> maxConnections)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="built_in">this</span>.jdbcUrl = jdbcUrl;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.maxConnections = maxConnections;</span><br><span class="line">        <span class="built_in">this</span>.connectionPool = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(maxConnections);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化连接池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxConnections; i++) &#123;</span><br><span class="line">            connectionPool.add(createNewConnection());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新连接</span></span><br><span class="line">    <span class="keyword">private</span> Connection <span class="title function_">createNewConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(jdbcUrl, username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionPool.poll(timeout, unit); <span class="comment">// 等待指定时间获取连接</span></span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;Timeout: Unable to acquire a connection.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseConnection</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection.isClosed()) &#123;</span><br><span class="line">                <span class="comment">// 如果连接已关闭，创建一个新连接补充到池中</span></span><br><span class="line">                connectionPool.add(createNewConnection());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将连接归还到池中</span></span><br><span class="line">                connectionPool.offer(connection);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭所有连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeAllConnections</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connection connection : connectionPool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!connection.isClosed()) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试用例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleConnectionPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleConnectionPool</span>(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://localhost:3306/pai_coding&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">5</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> pool.getConnection(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用连接（示例查询）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Connection acquired: &quot;</span> + conn);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟查询</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 归还连接</span></span><br><span class="line">            pool.releaseConnection(conn);</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection returned.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭所有连接</span></span><br><span class="line">            pool.closeAllConnections();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010111849.png" alt="20251010111849"><br>二哥的Java 进阶之路：数据库连接池</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="3-🌟能说一下-JVM-的内存区域吗？"><a href="#3-🌟能说一下-JVM-的内存区域吗？" class="headerlink" title="3.🌟能说一下 JVM 的内存区域吗？"></a>3.🌟能说一下 JVM 的内存区域吗？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/neicun-jiegou.html">深入理解 JVM 的运行时数据区</a></p>
<p>按照 Java 虚拟机规范，JVM 的内存区域可以细分为<code>程序计数器</code>、<code>虚拟机栈</code>、<code>本地方法栈</code>、<code>堆</code>和<code>方法区</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150406.png" alt="20251010150406"><br>三分恶面渣逆袭：Java虚拟机运行时数据区</p>
<p>其中<code>方法区</code>和<code>堆</code>是线程共享的，<code>虚拟机栈</code>、<code>本地方法栈</code>和<code>程序计数器</code>是线程私有的。</p>
<h4 id="介绍一下程序计数器？"><a href="#介绍一下程序计数器？" class="headerlink" title="介绍一下程序计数器？"></a>介绍一下程序计数器？</h4><p>程序计数器也被称为 PC 寄存器，是一块较小的内存空间。它可以看作是当前线程所执行的字节码行号指示器。</p>
<h4 id="介绍一下-Java-虚拟机栈？"><a href="#介绍一下-Java-虚拟机栈？" class="headerlink" title="介绍一下 Java 虚拟机栈？"></a>介绍一下 Java 虚拟机栈？</h4><p>Java 虚拟机栈的生命周期与线程相同。</p>
<p>当线程执行一个方法时，会创建一个对应的<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/stack-frame.html">栈帧</a>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，然后栈帧会被压入虚拟机栈中。当方法执行完毕后，栈帧会从虚拟机栈中移除。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150604.png" alt="20251010150604"><br>三分恶面渣逆袭：Java虚拟机栈</p>
<h4 id="一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？"><a href="#一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？" class="headerlink" title="一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？"></a>一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？</h4><p>对于<a target="_blank" rel="noopener" href="https://javabetter.cn/oo/static.html">静态方法</a>，由于不需要访问实例对象 this，因此在局部变量表中不会有任何变量。</p>
<p>对于非静态方法，即使是一个完全空的方法，局部变量表中也会有一个用于存储 this 引用的变量。this 引用指向当前实例对象，在方法调用时被隐式传入。</p>
<p>详细解释一下：</p>
<p>比如说有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">emptyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 什么都没有</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticEmptyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 什么都没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>javap -v VarDemo1</code> 命令查看编译后的字节码，就可以在 emptyMethod 中看到这样的内容：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150844.png" alt="20251010150844"><br>二哥的 Java 进阶之路：javap emptyMethod</p>
<p>这里的 <code>locals=1</code> 表示局部变量表有一个变量，即 this，Slot 0 位置存储了 this 引用。</p>
<p>而在静态方法 staticEmptyMethod 中，你会看到这样的内容：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150900.png" alt="20251010150900"><br>二哥的 Java 进阶之路：javap staticEmptyMethod</p>
<p>这里的 locals&#x3D;0 表示局部变量表为空，因为静态方法属于类级别方法，不需要 this 引用，也就没有局部变量。</p>
<h4 id="介绍一下本地方法栈？"><a href="#介绍一下本地方法栈？" class="headerlink" title="介绍一下本地方法栈？"></a>介绍一下本地方法栈？</h4><p>本地方法栈与虚拟机栈相似，区别在于虚拟机栈是为 JVM 执行 Java 编写的方法服务的，而本地方法栈是为 Java 调用<a target="_blank" rel="noopener" href="https://javabetter.cn/oo/native-method.html">本地 native 方法</a>服务的，通常由 C&#x2F;C++ 编写。</p>
<p>在本地方法栈中，主要存放了 native 方法的局部变量、动态链接和方法出口等信息。当一个 Java 程序调用一个 native 方法时，JVM 会切换到本地方法栈来执行这个方法。</p>
<h4 id="介绍一下本地方法栈的运行场景？"><a href="#介绍一下本地方法栈的运行场景？" class="headerlink" title="介绍一下本地方法栈的运行场景？"></a>介绍一下本地方法栈的运行场景？</h4><p>当 Java 应用需要与操作系统底层或硬件交互时，通常会用到本地方法栈。</p>
<p>比如调用操作系统的特定功能，如内存管理、文件操作、系统时间、系统调用等。</p>
<p>详细说明一下：</p>
<p>比如说获取系统时间的 <code>System.currentTimeMillis()</code> 方法就是调用本地方法，来获取操作系统当前时间的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151152.png" alt="20251010151152"><br>二哥的Java 进阶之路：currentTimeMillis方法源码</p>
<p>再比如 JVM 自身的一些底层功能也需要通过本地方法来实现。像 Object 类中的 <code>hashCode()</code> 方法、<code>clone()</code> 方法等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151210.png" alt="20251010151210"><br>二哥的Java 进阶之路：hashCode方法源码</p>
<h4 id="native-方法解释一下？"><a href="#native-方法解释一下？" class="headerlink" title="native 方法解释一下？"></a>native 方法解释一下？</h4><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/oo/native-method.html">手把手教你用 C语言实现 Java native 本地方法</a></p>
<p>native 方法是在 Java 中通过 <a target="_blank" rel="noopener" href="https://javabetter.cn/basic-extra-meal/48-keywords.html">native 关键字</a>声明的，用于调用非 Java 语言，如 C&#x2F;C++ 编写的代码。Java 可以通过 JNI，也就是 Java Native Interface 与底层系统、硬件设备、或者本地库进行交互。</p>
<h4 id="介绍一下-Java-堆？"><a href="#介绍一下-Java-堆？" class="headerlink" title="介绍一下 Java 堆？"></a>介绍一下 Java 堆？</h4><p>堆是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储 new 出来的对象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151832.png" alt="20251010151832"><br>二哥的 Java 进阶之路：堆</p>
<p>Java 中“几乎”所有的对象都会在堆中分配，堆也是<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/gc-collector.html">垃圾收集器</a>管理的目标区域。</p>
<p>从内存回收的角度来看，由于垃圾收集器大部分都是基于分代收集理论设计的，所以堆又被细分为<code>新生代</code>、<code>老年代</code>、<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151924.png" alt="20251010151924"><br>三分恶面渣逆袭：Java 堆内存结构</p>
<p>随着 <a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/jit.html">JIT 编译器</a>的发展和逃逸技术的逐渐成熟，“所有的对象都会分配到堆上”就不再那么绝对了。</p>
<p>从 JDK 7 开始，JVM 默认开启了逃逸分析，意味着如果某些方法中的对象引用没有被返回或者没有在方法体外使用，也就是未逃逸出去，那么对象可以直接在栈上分配内存。</p>
<h4 id="堆和栈的区别是什么？"><a href="#堆和栈的区别是什么？" class="headerlink" title="堆和栈的区别是什么？"></a>堆和栈的区别是什么？</h4><p>堆属于线程共享的内存区域，几乎所有 new 出来的对象都会堆上分配，生命周期不由单个方法调用所决定，可以在方法调用结束后继续存在，直到不再被任何变量引用，最后被垃圾收集器回收。</p>
<p>栈属于线程私有的内存区域，主要存储局部变量、方法参数、对象引用等，通常随着方法调用的结束而自动释放，不需要垃圾收集器处理。</p>
<h4 id="介绍一下方法区？"><a href="#介绍一下方法区？" class="headerlink" title="介绍一下方法区？"></a>介绍一下方法区？</h4><p>方法区并不真实存在，属于 Java 虚拟机规范中的一个逻辑概念，用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p>在 HotSpot 虚拟机中，方法区的实现称为永久代 PermGen，但在 Java 8 及之后的版本中，已经被元空间 Metaspace 所替代。</p>
<h4 id="变量存在堆栈的什么位置？"><a href="#变量存在堆栈的什么位置？" class="headerlink" title="变量存在堆栈的什么位置？"></a>变量存在堆栈的什么位置？</h4><p>对于局部变量，它存储在当前方法栈帧中的局部变量表中。当方法执行完毕，栈帧被回收，局部变量也会被释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">100</span>;  <span class="comment">// 局部变量，存储在栈帧中的局部变量表里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于静态变量来说，它存储在 Java 虚拟机规范中的方法区中，在 Java 7 中是永久代，在 Java8 及以后 是元空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticVarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">100</span>;  <span class="comment">// 静态变量，存储在方法区中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-🌟对象创建的过程了解吗？"><a href="#6-🌟对象创建的过程了解吗？" class="headerlink" title="6.🌟对象创建的过程了解吗？"></a>6.🌟对象创建的过程了解吗？</h3><p>当我们使用 new 关键字创建一个对象时，JVM 首先会检查 new 指令的参数是否能在常量池中定位到类的符号引用，然后检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，就先执行类加载。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010153321.png" alt="20251010153321"><br>二哥的 Java 进阶之路：对象的创建过程</p>
<p>如果已经加载，JVM 会为对象分配内存完成初始化，比如数值类型的成员变量初始值是 0，布尔类型是 false，对象类型是 null。</p>
<p>接下来会设置对象头，里面包含了对象是哪个类的实例、对象的哈希码、对象的 GC 分代年龄等信息。</p>
<p>最后，JVM 会执行构造方法 <code>&lt;init&gt;</code> 完成赋值操作，将成员变量赋值为预期的值，比如 <code>int age = 18</code>，这样一个对象就创建完成了。</p>
<h4 id="对象的销毁过程了解吗？"><a href="#对象的销毁过程了解吗？" class="headerlink" title="对象的销毁过程了解吗？"></a>对象的销毁过程了解吗？</h4><p>当对象不再被任何引用指向时，就会变成垃圾。垃圾收集器会通过可达性分析算法判断对象是否存活，如果对象不可达，就会被回收。</p>
<p>垃圾收集器通过标记清除、标记复制、标记整理等算法来回收内存，将对象占用的内存空间释放出来。</p>
<p>可以通过 <code>java -XX:+PrintCommandLineFlags -version</code> 和 <code>java -XX:+PrintGCDetails -version</code> 命令查看 JVM 的 GC 收集器。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010153455.png" alt="20251010153455"><br>二哥的 Java 进阶之路：JVM 使用的垃圾收集器</p>
<p>可以看到，我本机安装的 JDK 8 默认使用的是 <code>Parallel Scavenge + Parallel Old</code>。</p>
<p>不同参数代表对应的垃圾收集器表单：</p>
<table>
<thead>
<tr>
<th>新生代</th>
<th>老年代</th>
<th>JVM参数</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>Serial</td>
<td>-XX:+UseSerialGC</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>Serial</td>
<td>-XX:+UseParallelGC -XX:-UseParallelOldGC</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>Parallel Old</td>
<td>-XX:+UseParallelGC -XX:+UseParallelOldGC</td>
</tr>
<tr>
<td>Parallel New</td>
<td>CMS</td>
<td>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</td>
</tr>
<tr>
<td>G1</td>
<td></td>
<td>-XX:+UseG1GC</td>
</tr>
</tbody></table>
<h3 id="14-🌟对象什么时候会进入老年代？"><a href="#14-🌟对象什么时候会进入老年代？" class="headerlink" title="14.🌟对象什么时候会进入老年代？"></a>14.🌟对象什么时候会进入老年代？</h3><p>对象通常会在年轻代中分配，随着时间的推移和垃圾收集的进程，某些满足条件的对象会进入到老年代中，如长期存活的对象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162108.png" alt="20251010162108"><br>二哥的 Java 进阶之路：对象进入老年代</p>
<h4 id="长期存活的对象如何判断？"><a href="#长期存活的对象如何判断？" class="headerlink" title="长期存活的对象如何判断？"></a>长期存活的对象如何判断？</h4><p>JVM 会为对象维护一个“年龄”计数器，记录对象在新生代中经历 Minor GC 的次数。每次 GC 未被回收的对象，其年龄会加 1。</p>
<p>当超过一个特定阈值，默认值是 15，就会被认为老对象了，需要重点关照。这个年龄阈值可以通过 JVM 参数<code>-XX:MaxTenuringThreshold</code>来设置。</p>
<p>可以通过 <code>jinfo -flag MaxTenuringThreshold $(jps | grep -i nacos | awk &#39;&#123;print $1&#125;&#39;)</code> 来查看当前 JVM 的年龄阈值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162712.png" alt="20251010162712"><br>二哥的 Java 进阶之路：年龄阈值</p>
<ol>
<li>如果应用中的对象存活时间较短，可以适当调大这个值，让对象在新生代多待一会儿</li>
<li>如果对象存活时间较长，可以适当调小这个值，让对象更快进入老年代，减少在新生代的复制次数</li>
</ol>
<h4 id="大对象如何判断？"><a href="#大对象如何判断？" class="headerlink" title="大对象如何判断？"></a>大对象如何判断？</h4><p>大对象是指占用内存较大的对象，如大数组、长字符串等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1000000</span>]);</span><br></pre></td></tr></table></figure>

<p>其大小由 JVM 参数 <code>-XX:PretenureSizeThreshold</code> 控制，但在 JDK 8 中，默认值为 0，也就是说默认情况下，对象仅根据 GC 存活的次数来判断是否进入老年代。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162802.png" alt="20251010162802"><br>二哥的 Java 进阶之路：PretenureSizeThreshold</p>
<p>G1 垃圾收集器中，大对象会直接分配到 HUMONGOUS 区域。当对象大小超过一个 Region 容量的 50% 时，会被认为是大对象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162812.png" alt="20251010162812"><br>有梦想的肥宅：G1</p>
<p>Region 的大小可以通过 JVM 参数 <code>-XX:G1HeapRegionSize</code> 来设置，默认情况下从 1MB 到 32MB 不等，会根据堆内存大小动态调整。</p>
<p>可以通过 <code>java -XX:+UseG1GC -XX:+PrintGCDetails -version</code> 查看 G1 垃圾收集器的相关信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162907.png" alt="20251010162907"><br>二哥的 Java 进阶之路：UseG1GC</p>
<p>从结果上来看，我本机上 G1 的堆大小为 2GB，Region 的大小为 4MB。</p>
<h4 id="动态年龄判定了解吗？"><a href="#动态年龄判定了解吗？" class="headerlink" title="动态年龄判定了解吗？"></a>动态年龄判定了解吗？</h4><p>如果 Survivor 区中所有对象的总大小超过了一定比例，通常是 Survivor 区的一半，那么年龄较小的对象也可能会被提前晋升到老年代。</p>
<p>这是因为如果年龄较小的对象在 Survivor 区中占用了较大的空间，会导致 Survivor 区中的对象复制次数增多，影响垃圾回收的效率。</p>
<h3 id="23-🌟讲讲-JVM-的垃圾回收机制（补充）"><a href="#23-🌟讲讲-JVM-的垃圾回收机制（补充）" class="headerlink" title="23.🌟讲讲 JVM 的垃圾回收机制（补充）"></a>23.🌟讲讲 JVM 的垃圾回收机制（补充）</h3><blockquote>
<p>本题是增补的内容 参照：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/gc.html">深入理解 JVM 的垃圾回收机制</a></p>
</blockquote>
<p>垃圾回收就是对内存堆中已经死亡的或者长时间没有使用的对象进行清除或回收。</p>
<p>JVM 在做 GC 之前，会先搞清楚什么是垃圾，什么不是垃圾，通常会通过可达性分析算法来判断对象是否存活。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095331.png" alt="20251011095331"><br>二哥的 Java 进阶之路：可达性分析</p>
<p>在确定了哪些垃圾可以被回收后，垃圾收集器（如 CMS、G1、ZGC）要做的事情就是进行垃圾回收，可以采用标记清除算法、复制算法、标记整理算法、分代收集算法等。</p>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派</a>项目使用的 JDK 8，采用的是 CMS 垃圾收集器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseConcMarkSweepGC \</span><br><span class="line">     -XX:+UseParNewGC \</span><br><span class="line">     -XX:CMSInitiatingOccupancyFraction=<span class="number">75</span> \</span><br><span class="line">     -XX:+UseCMSInitiatingOccupancyOnly \</span><br><span class="line">     -jar your-application.jar</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收的过程是什么？"><a href="#垃圾回收的过程是什么？" class="headerlink" title="垃圾回收的过程是什么？"></a>垃圾回收的过程是什么？</h4><p>Java 的垃圾回收过程主要分为标记存活对象、清除无用对象、以及内存压缩&#x2F;整理三个阶段。不同的垃圾回收器在执行这些步骤时会采用不同的策略和算法。</p>
<h3 id="24-🌟如何判断对象仍然存活？"><a href="#24-🌟如何判断对象仍然存活？" class="headerlink" title="24.🌟如何判断对象仍然存活？"></a>24.🌟如何判断对象仍然存活？</h3><p>Java 通过可达性分析算法来判断一个对象是否还存活。</p>
<p>通过一组名为 “GC Roots” 的根对象，进行递归扫描，无法从根对象到达的对象就是“垃圾”，可以被回收。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095524.png" alt="20251011095524"><br>三分恶面渣逆袭：GC Root</p>
<p>这也是 G1、CMS 等主流垃圾收集器使用的主要算法。</p>
<h4 id="什么是引用计数法？"><a href="#什么是引用计数法？" class="headerlink" title="什么是引用计数法？"></a>什么是引用计数法？</h4><p>每个对象有一个引用计数器，记录引用它的次数。当计数器为零时，对象可以被回收。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095558.png" alt="20251011095558"><br>三分恶面渣逆袭：引用计数法</p>
<p>引用计数法无法解决循环引用的问题。例如，两个对象互相引用，但不再被其他对象引用，它们的引用计数都不为零，因此不会被回收。</p>
<h4 id="做可达性分析的时候，应该有哪些前置性的操作？"><a href="#做可达性分析的时候，应该有哪些前置性的操作？" class="headerlink" title="做可达性分析的时候，应该有哪些前置性的操作？"></a>做可达性分析的时候，应该有哪些前置性的操作？</h4><p>在进行垃圾回收之前，JVM 会暂停所有正在执行的应用线程。</p>
<p>这是因为可达性分析过程必须确保在执行分析时，内存中的对象关系不会被应用线程修改。如果不暂停应用线程，可能会出现对象引用的改变，导致垃圾回收过程中判断对象是否可达的结果不一致，从而引发严重的内存错误或数据丢失。</p>
<h3 id="27-🌟垃圾收集算法了解吗？"><a href="#27-🌟垃圾收集算法了解吗？" class="headerlink" title="27.🌟垃圾收集算法了解吗？"></a>27.🌟垃圾收集算法了解吗？</h3><p>垃圾收集算法主要有三种，分别是标记-清除算法、标记-复制算法和标记-整理算法。</p>
<h4 id="说说标记-清除算法？"><a href="#说说标记-清除算法？" class="headerlink" title="说说标记-清除算法？"></a>说说标记-清除算法？</h4><p><code>标记-清除</code>算法分为两个阶段：</p>
<ul>
<li><strong>标记</strong>：标记所有需要回收的对象</li>
<li><strong>清除</strong>：回收所有被标记的对象</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102820.png" alt="20251011102820"><br>三分恶面渣逆袭：标记-清除算法</p>
<p>优点是实现简单，缺点是回收过程中会产生内存碎片。</p>
<h4 id="说说标记-复制算法？"><a href="#说说标记-复制算法？" class="headerlink" title="说说标记-复制算法？"></a>说说标记-复制算法？</h4><p><code>标记-复制</code>算法可以解决标记-清除算法的内存碎片问题，因为它将内存空间划分为两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后清理掉这一块。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102844.png" alt="20251011102844"><br>三分恶面渣逆袭：标记-复制算法</p>
<p>缺点是浪费了一半的内存空间。</p>
<h4 id="说说标记-整理算法？"><a href="#说说标记-整理算法？" class="headerlink" title="说说标记-整理算法？"></a>说说标记-整理算法？</h4><p><code>标记-整理</code>算法是标记-清除复制算法的升级版，它不再划分内存空间，而是将存活的对象向内存的一端移动，然后清理边界以外的内存。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102906.png" alt="20251011102906"><br>标记-整理算法</p>
<p>缺点是移动对象的成本比较高。</p>
<h4 id="说说分代收集算法？"><a href="#说说分代收集算法？" class="headerlink" title="说说分代收集算法？"></a>说说分代收集算法？</h4><p><code>分代收集</code>算法是目前主流的垃圾收集算法，它根据对象存活周期的不同将内存划分为几块，一般分为新生代和老年代。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103059.png" alt="20251011103059"><br>二哥的 Java 进阶之路：Java 堆划分</p>
<p>新生代用复制算法，因为大部分对象生命周期短。老年代用标记-整理算法，因为对象存活率较高。</p>
<h4 id="为什么要用分代收集呢？"><a href="#为什么要用分代收集呢？" class="headerlink" title="为什么要用分代收集呢？"></a>为什么要用分代收集呢？</h4><p>分代收集算法的核心思想是根据对象的生命周期优化垃圾回收。</p>
<p>新生代的对象生命周期短，使用复制算法可以快速回收。老年代的对象生命周期长，使用标记-整理算法可以减少移动对象的成本。</p>
<h4 id="标记复制的标记过程和复制过程会不会停顿？"><a href="#标记复制的标记过程和复制过程会不会停顿？" class="headerlink" title="标记复制的标记过程和复制过程会不会停顿？"></a>标记复制的标记过程和复制过程会不会停顿？</h4><p>在标记-复制算法 中，标记阶段和复制阶段都会触发STW。</p>
<ul>
<li>标记阶段停顿是为了保证对象的引用关系不被修改。</li>
<li>复制阶段停顿是防止对象在复制过程中被修改。</li>
</ul>
<h3 id="31-🌟知道哪些垃圾收集器？"><a href="#31-🌟知道哪些垃圾收集器？" class="headerlink" title="31.🌟知道哪些垃圾收集器？"></a>31.🌟知道哪些垃圾收集器？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/gc-collector.html">深入理解 JVM 的垃圾收集器：CMS、G1、ZGC</a></p>
<p>JVM 的垃圾收集器主要分为两大类：分代收集器和分区收集器，分代收集器的代表是 CMS，分区收集器的代表是 G1 和 ZGC。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103352.png" alt="20251011103352"><br>三分恶面渣逆袭：HotSpot虚拟机垃圾收集器</p>
<p>CMS 是第一个关注 GC 停顿时间的垃圾收集器，JDK 1.5 时引入，JDK9 被标记弃用，JDK14 被移除。</p>
<p>G1 在 JDK 1.7 时引入，在 JDK 9 时取代 CMS 成为了默认的垃圾收集器。</p>
<p>ZGC 是 JDK11 推出的一款低延迟垃圾收集器，适用于大内存低延迟服务的内存管理和回收，在 128G 的大堆下，最大停顿时间才 1.68 ms，性能远胜于 G1 和 CMS。</p>
<h4 id="说说-Serial-收集器？"><a href="#说说-Serial-收集器？" class="headerlink" title="说说 Serial 收集器？"></a>说说 Serial 收集器？</h4><p>Serial 收集器是最基础、历史最悠久的收集器。</p>
<p>如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。</p>
<p>Serial&#x2F;Serial Old 收集器的运行过程如图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103544.png" alt="20251011103544"><br>三分恶面渣逆袭：Serial&#x2F;Serial Old收集器运行示意图</p>
<h4 id="说说-ParNew-收集器？"><a href="#说说-ParNew-收集器？" class="headerlink" title="说说 ParNew 收集器？"></a>说说 ParNew 收集器？</h4><p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本，使用多条线程进行垃圾收集。</p>
<p>ParNew&#x2F;Serial Old 收集器运行示意图如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104114.png" alt="20251011104114"><br>三分恶面渣逆袭：ParNew&#x2F;Serial Old收集器运行示意图</p>
<h4 id="说说-Parallel-Scavenge-收集器？"><a href="#说说-Parallel-Scavenge-收集器？" class="headerlink" title="说说 Parallel Scavenge 收集器？"></a>说说 Parallel Scavenge 收集器？</h4><p>Parallel Scavenge 收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU 用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104156.png" alt="20251011104156"><br>三分恶面渣逆袭：吞吐量</p>
<p>根据对象存活周期的不同会将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<h4 id="说说-Serial-Old-收集器？"><a href="#说说-Serial-Old-收集器？" class="headerlink" title="说说 Serial Old 收集器？"></a>说说 Serial Old 收集器？</h4><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>
<h4 id="说说-Parallel-Old-收集器？"><a href="#说说-Parallel-Old-收集器？" class="headerlink" title="说说 Parallel Old 收集器？"></a>说说 Parallel Old 收集器？</h4><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，基于标记-整理算法实现，使用多条 GC 线程在 STW 期间同时进行垃圾回收。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104247.png" alt="20251011104247"><br>三分恶面渣逆袭：Parallel Old收集器</p>
<h4 id="说说-CMS-收集器？"><a href="#说说-CMS-收集器？" class="headerlink" title="说说 CMS 收集器？"></a>说说 CMS 收集器？</h4><p>CMS 在 JDK 1.5 时引入，JDK 9 时被标记弃用，JDK 14 时被移除。</p>
<p>CMS 是一种低延迟的垃圾收集器，采用标记-清除算法，分为初始标记、并发标记、重新标记和并发清除四个阶段，优点是垃圾回收线程和应用线程同时运行，停顿时间短，适合延迟敏感的应用，但容易产生内存碎片，可能触发 Full GC。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104304.png" alt="20251011104304"><br>小潘：CMS</p>
<h4 id="说说-G1-收集器？"><a href="#说说-G1-收集器？" class="headerlink" title="说说 G1 收集器？"></a>说说 G1 收集器？</h4><p>G1 在 JDK 1.7 时引入，在 JDK 9 时取代 CMS 成为默认的垃圾收集器。</p>
<p>G1 是一种面向大内存、高吞吐场景的垃圾收集器，它将堆划分为多个小的 Region，通过标记-整理算法，避免了内存碎片问题。优点是停顿时间可控，适合大堆场景，但调优较复杂。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104352.png" alt="20251011104352"><br>有梦想的肥宅：G1</p>
<h4 id="说说-ZGC-收集器？"><a href="#说说-ZGC-收集器？" class="headerlink" title="说说 ZGC 收集器？"></a>说说 ZGC 收集器？</h4><p>ZGC 是 JDK 11 时引入的一款低延迟的垃圾收集器，最大特点是将垃圾收集的停顿时间控制在 10ms 以内，即使在 TB 级别的堆内存下也能保持较低的停顿时间。</p>
<p>它通过并发标记和重定位来避免大部分 Stop-The-World 停顿，主要依赖指针染色来管理对象状态。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104424.png" alt="20251011104424"><br>得物技术：指针染色</p>
<ul>
<li><strong>标记对象的可达性</strong>：通过在指针上增加标记位，不需要额外的标记位即可判断对象的存活状态。</li>
<li><strong>重定位状态</strong>：在对象被移动时，可以通过指针染色来更新对象的引用，而不需要等待全局同步。</li>
</ul>
<p>适用于需要超低延迟的场景，比如金融交易系统、电商平台。</p>
<h4 id="垃圾回收器的作用是什么？"><a href="#垃圾回收器的作用是什么？" class="headerlink" title="垃圾回收器的作用是什么？"></a>垃圾回收器的作用是什么？</h4><p>垃圾回收器的核心作用是自动管理 Java 应用程序的运行时内存。它负责识别哪些内存是不再被应用程序使用的，并释放这些内存以便重新使用。</p>
<p>这一过程减少了程序员手动管理内存的负担，降低了内存泄漏和溢出错误的风险。</p>
<h3 id="32-🌟能详细说一下-CMS-的垃圾收集过程吗？"><a href="#32-🌟能详细说一下-CMS-的垃圾收集过程吗？" class="headerlink" title="32.🌟能详细说一下 CMS 的垃圾收集过程吗？"></a>32.🌟能详细说一下 CMS 的垃圾收集过程吗？</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105011.png" alt="20251011105011"><br>三分恶面渣逆袭：Concurrent Mark Sweep收集器运行示意图</p>
<p>CMS 使用<strong>标记-清除</strong>算法进行垃圾收集，分 4 大步：</p>
<ul>
<li><strong>初始标记</strong>：标记所有从 GC Roots 直接可达的对象，这个阶段需要 STW，但速度很快。</li>
<li><strong>并发标记</strong>：从初始标记的对象出发，遍历所有对象，标记所有可达的对象。这个阶段是并发进行的。</li>
<li><strong>重新标记</strong>：完成剩余的标记工作，包括处理并发阶段遗留下来的少量变动，这个阶段通常需要短暂的 STW 停顿。</li>
<li><strong>并发清除</strong>：清除未被标记的对象，回收它们占用的内存空间。</li>
</ul>
<h4 id="你提到了remark，那它remark具体是怎么执行的？三色标记法？"><a href="#你提到了remark，那它remark具体是怎么执行的？三色标记法？" class="headerlink" title="你提到了remark，那它remark具体是怎么执行的？三色标记法？"></a>你提到了remark，那它remark具体是怎么执行的？三色标记法？</h4><p>是的，remark 阶段通常会结合三色标记法来执行，确保在并发标记期间所有存活对象都被正确标记。目的是修正并发标记阶段中可能遗漏的对象引用变化。</p>
<p>在 remark 阶段，垃圾收集器会停止应用线程，以确保在这个阶段不会有引用关系的进一步变化。这种暂停通常很短暂。remark 阶段主要包括以下操作：</p>
<ol>
<li>处理写屏障记录的引用变化：在并发标记阶段，应用程序可能会更新对象的引用（比如一个黑色对象新增了对一个白色对象的引用），这些变化通过写屏障记录下来。在 remark 阶段，GC 会处理这些记录，确保所有可达对象都正确地标记为灰色或黑色。</li>
<li>扫描灰色对象：再次遍历灰色对象，处理它们的所有引用，确保引用的对象正确标记为灰色或黑色。</li>
<li>清理：确保所有引用关系正确处理后，灰色对象标记为黑色，白色对象保持不变。这一步完成后，所有存活对象都应当是黑色的。</li>
</ol>
<h4 id="什么是三色标记法？"><a href="#什么是三色标记法？" class="headerlink" title="什么是三色标记法？"></a>什么是三色标记法？</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105137.png" alt="20251011105137"><br>Java全栈架构师：三色标记法</p>
<p>三色标记法用于标记对象的存活状态，它将对象分为三类：</p>
<ol>
<li>白色（White）：尚未访问的对象。垃圾回收结束后，仍然为白色的对象会被认为是不可达的对象，可以回收。</li>
<li>灰色（Gray）：已经访问到但未标记完其引用的对象。灰色对象是需要进一步处理的。</li>
<li>黑色（Black）：已经访问到并且其所有引用对象都已经标记过。黑色对象是完全处理过的，不需要再处理。</li>
</ol>
<p>三色标记法的工作流程：</p>
<p>①、初始标记（Initial Marking）：从 GC Roots 开始，标记所有直接可达的对象为灰色。</p>
<p>②、并发标记（Concurrent Marking）：在此阶段，标记所有灰色对象引用的对象为灰色，然后将灰色对象自身标记为黑色。这个过程是并发的，和应用线程同时进行。</p>
<p>此阶段的一个问题是，应用线程可能在并发标记期间修改对象的引用关系，导致一些对象的标记状态不准确。</p>
<p>③、重新标记（Remarking）：重新标记阶段的目标是处理并发标记阶段遗漏的引用变化。为了确保所有存活对象都被正确标记，remark 需要在 STW 暂停期间执行。</p>
<p>④、使用写屏障（Write Barrier）来捕捉并发标记阶段应用线程对对象引用的更新。通过遍历这些更新的引用来修正标记状态，确保遗漏的对象不会被错误地回收。</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaodaoge_it/article/details/121890145">小道哥的三色标记</a></p>
<h3 id="33-🌟G1-垃圾收集器了解吗？"><a href="#33-🌟G1-垃圾收集器了解吗？" class="headerlink" title="33.🌟G1 垃圾收集器了解吗？"></a>33.🌟G1 垃圾收集器了解吗？</h3><p>G1 在 JDK 1.7 时引入，在 JDK 9 时取代 CMS 成为默认的垃圾收集器。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105431.png" alt="20251011105431"><br>有梦想的肥宅：G1 收集器</p>
<p>G1 把 Java 堆划分为多个大小相等的独立区域Region，每个区域都可以扮演新生代或老年代的角色。</p>
<p>同时，G1 还有一个专门为大对象设计的 Region，叫 Humongous 区。</p>
<blockquote>
<p>大对象的判定规则是，如果一个大对象超过了一个 Region 大小的 50%，比如每个 Region 是 2M，只要一个对象超过了 1M，就会被放入 Humongous 中。</p>
</blockquote>
<p>这种区域化管理使得 G1 可以更灵活地进行垃圾收集，只回收部分区域而不是整个新生代或老年代。</p>
<p>G1 收集器的运行过程大致可划分为这几个步骤：</p>
<p>①、<strong>并发标记</strong>，G1 通过并发标记的方式找出堆中的垃圾对象。并发标记阶段与应用线程同时执行，不会导致应用线程暂停。</p>
<p>②、<strong>混合收集</strong>，在并发标记完成后，G1 会计算出哪些区域的回收价值最高（也就是包含最多垃圾的区域），然后优先回收这些区域。这种回收方式包括了部分新生代区域和老年代区域。</p>
<p>选择回收成本低而收益高的区域进行回收，可以提高回收效率和减少停顿时间。</p>
<p>③、<strong>可预测的停顿</strong>，G1 在垃圾回收期间仍然需要「Stop the World」。不过，G1 在停顿时间上添加了预测机制，用户可以 JVM 启动时指定期望停顿时间，G1 会尽可能地在这个时间内完成垃圾回收。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105556.png" alt="20251011105556"><br>三分恶面渣逆袭：G1收集器运行示意图</p>
<h3 id="45-🌟了解类的加载机制吗？（补充）"><a href="#45-🌟了解类的加载机制吗？（补充）" class="headerlink" title="45.🌟了解类的加载机制吗？（补充）"></a>45.🌟了解类的加载机制吗？（补充）</h3><p>了解。</p>
<p>JVM 的操作对象是 Class 文件，JVM 把 Class 文件中描述类的数据结构加载到内存中，并对数据进行校验、解析和初始化，最终转化成可以被 JVM 直接使用的类型，这个过程被称为类加载机制。</p>
<p>其中最重要的三个概念就是：类加载器、类加载过程和双亲委派模型。</p>
<ul>
<li><strong>类加载器</strong>：负责加载类文件，将类文件加载到内存中，生成 Class 对象。</li>
<li><strong>类加载过程</strong>：包括加载、验证、准备、解析和初始化等步骤。</li>
<li><strong>双亲委派模型</strong>：当一个类加载器接收到类加载请求时，它会把请求委派给父——类加载器去完成，依次递归，直到最顶层的类加载器，如果父——类加载器无法完成加载请求，子类加载器才会尝试自己去加载。</li>
</ul>
<h3 id="48-🌟类装载的过程知道吗？"><a href="#48-🌟类装载的过程知道吗？" class="headerlink" title="48.🌟类装载的过程知道吗？"></a>48.🌟类装载的过程知道吗？</h3><blockquote>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/class-load.html">一文彻底搞懂 Java 类加载机制</a></p>
</blockquote>
<p>知道。</p>
<p>类装载过程包括三个阶段：载入、链接和初始化。</p>
<p>①、载入：将类的二进制字节码加载到内存中。</p>
<p>②、链接可以细分为三个小的阶段：</p>
<ul>
<li>验证：检查类文件格式是否符合 JVM 规范</li>
<li>准备：为类的静态变量分配内存并设置默认值。</li>
<li>解析：将符号引用替换为直接引用。</li>
</ul>
<p>③、初始化：执行静态代码块和静态变量初始化。</p>
<p>在准备阶段，静态变量已经被赋过默认初始值了，在初始化阶段，静态变量将被赋值为代码期望赋的值。比如说 <code>static int a = 1;</code>，在准备阶段，<code>a</code> 的值为 0，在初始化阶段，<code>a</code> 的值为 1。</p>
<p>换句话说，初始化阶段是在执行类的构造方法，也就是 <a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/bytecode.html">javap</a> 中看到的 <code>&lt;clinit&gt;()</code>。</p>
<h4 id="载入过程-JVM-会做什么？"><a href="#载入过程-JVM-会做什么？" class="headerlink" title="载入过程 JVM 会做什么？"></a>载入过程 JVM 会做什么？</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111643.png" alt="20251011111643"><br>三分恶面渣逆袭：载入</p>
<ul>
<li>1）通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>3）在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为这个类的访问入口。</li>
</ul>
<h3 id="49-🌟什么是双亲委派模型？"><a href="#49-🌟什么是双亲委派模型？" class="headerlink" title="49.🌟什么是双亲委派模型？"></a>49.🌟什么是双亲委派模型？</h3><p>双亲委派模型要求类加载器在加载类时，先委托父加载器尝试加载，只有父加载器无法加载时，子加载器才会加载。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111737.png" alt="20251011111737"><br>三分恶面渣逆袭：双亲委派模型</p>
<p>这个过程会一直向上递归，也就是说，从子加载器到父加载器，再到更上层的加载器，一直到最顶层的启动类加载器。</p>
<p>启动类加载器会尝试加载这个类。如果它能够加载这个类，就直接返回；如果它不能加载这个类，就会将加载任务返回给委托它的子加载器。</p>
<p>子加载器尝试加载这个类。如果子加载器也无法加载这个类，它就会继续向下传递这个加载任务，依此类推。</p>
<p>直到某个加载器能够加载这个类，或者所有加载器都无法加载这个类，最终抛出 ClassNotFoundException。</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="🌟0-什么是MYSQL"><a href="#🌟0-什么是MYSQL" class="headerlink" title="🌟0.什么是MYSQL"></a>🌟0.什么是MYSQL</h3><p>MySQL 是⼀个开源的关系型数据库，现在⾪属于 Oracle 公司。</p>
<h4 id="删除-创建一张表"><a href="#删除-创建一张表" class="headerlink" title="删除&#x2F;创建一张表"></a>删除&#x2F;创建一张表</h4><p><code>DROP TABLE</code> 删除表<br><code>CREATE TABLE</code> 创建表<br>创建表的时候，可以通过 <code>PRIMARY KEY</code> 设定主键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="写一个升序-降序的SQL语句"><a href="#写一个升序-降序的SQL语句" class="headerlink" title="写一个升序&#x2F;降序的SQL语句"></a>写一个升序&#x2F;降序的SQL语句</h4><p>可以使用<code>ORDER BY</code>字句对查询结果进行排序.<br>默认情况下是升序排序.如需要降序,使用关键字<code>DESC</code><br>例子:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>如若对多个字段进行排序:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>, name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<p>优先级从左到右,相当于先按工资降序,工资相同再按照姓名升序.</p>
<h4 id="MYSQL出现性能差的原因"><a href="#MYSQL出现性能差的原因" class="headerlink" title="MYSQL出现性能差的原因"></a>MYSQL出现性能差的原因</h4><p>可能是 SQL 查询使⽤了<strong>全表扫描</strong>，也可能是<strong>查询语句过于复杂</strong>，如多表<code>JOIN</code>或嵌套⼦查询。<br>也有可能是单表数据量过⼤。</p>
<p>通常情况下,增加索引就可以解决大部分的性能问题.对于热点数据,增加redis缓存,减轻对数据库的压力.</p>
<h3 id="9-🌟如何存储emoji"><a href="#9-🌟如何存储emoji" class="headerlink" title="9.🌟如何存储emoji?"></a>9.🌟如何存储emoji?</h3><p>因为 emoji是 4 个字节的 UTF-8 字符，⽽ MySQL 的 utf8 字符集只⽀持最多 3 个字节的 UTF-8 字符，所以在 MySQL 中存储 emoji 时，需要使⽤ utf8mb4 字符集。</p>
<p>MySQL 8.0 已经默认⽀持 utf8mb4 字符集，可以通过 <code>SHOW VARIABLES WHERE Variable_name LIKE &#39;character\_set\_%&#39; OR Variable_name LIKE &#39;collation%&#39;;</code> 查看。</p>
<h3 id="21-🌟一条查询语句SELECT是如何执行的？"><a href="#21-🌟一条查询语句SELECT是如何执行的？" class="headerlink" title="21.🌟一条查询语句SELECT是如何执行的？"></a>21.🌟一条查询语句SELECT是如何执行的？</h3><p>当我们执行一条 SELECT 语句时，MySQL 并不会直接去磁盘读取数据，而是经过 6 个步骤来解析、优化、执行，然后再返回结果。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612103550.png" alt="20250612103550"><br>第一步，客户端<strong>发送 SQL 查询语句到 MySQL 服务器</strong>。</p>
<p>第二步，MySQL 服务器的<strong>连接器开始处理这个请求</strong>，跟客户端建立连接、获取权限、管理连接。</p>
<p>第三步，<strong>解析器对 SQL 语句进行解析</strong>，检查语句是否符合 SQL 语法规则，确保数据库、表和列都是存在的，并处理 SQL 语句中的名称解析和权限验证。</p>
<p>第四步，<strong>优化器负责确定 SQL 语句的执行计划</strong>，这包括选择使用哪些索引，以及决定表之间的连接顺序等。</p>
<p>第五步，<strong>执行器会调用存储引擎的 API</strong>来进行数据的读写。</p>
<p>第六步，<strong>存储引擎负责查询数据，并将执行结果返回给客户端</strong>。客户端接收到查询结果，完成这次查询请求。</p>
<h3 id="24-🌟MySQL-有哪些常见存储引擎？"><a href="#24-🌟MySQL-有哪些常见存储引擎？" class="headerlink" title="24.🌟MySQL 有哪些常见存储引擎？"></a>24.🌟MySQL 有哪些常见存储引擎？</h3><p>MySQL 支持多种存储引擎，常见的有 <code>MyISAM</code>、<code>InnoDB</code>、<code>MEMORY</code> 等。<br>—这部分是帮助理解 start，面试中可不背—<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612112408.png" alt="20250612112408"><br>我来做一个表格对比：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612112435.png" alt="20250612112435"><br>—这部分是帮助理解 end，面试中可不背—<br>除此之外，我还了解到：<br>①、MySQL 5.5 之前，默认存储引擎是 <code>MyISAM</code>，5.5 之后是 <code>InnoDB</code>。<br>②、<code>InnoDB</code> 支持的哈希索引是自适应的，不能人为干预。<br>③、<code>InnoDB</code> 从 MySQL 5.6 开始，支持全文索引。<br>④、<code>InnoDB</code> 的最小表空间略小于 10M，最大表空间取决于页面大小。<br>如何切换 MySQL 的数据引擎？<br>可以通过 <code>alter table</code> 语句来切换 MySQL 的数据引擎。<br><code>ALTER TABLE your_table_name ENGINE=InnoDB;</code><br>不过不建议，<strong>应该提前设计好到底用哪一种存储引擎</strong>。</p>
<h3 id="28-🌟MySQL-日志文件有哪些？"><a href="#28-🌟MySQL-日志文件有哪些？" class="headerlink" title="28.🌟MySQL 日志文件有哪些？"></a>28.🌟MySQL 日志文件有哪些？</h3><p>有 6 大类，其中<code>错误日志</code>用于<strong>问题诊断</strong>，<code>慢查询日志</code>用于 <strong>SQL 性能分析</strong>，<code>general log</code> 用于<strong>记录所有的 SQL 语句</strong>，<code>binlog</code> 用于<strong>主从复制和数据恢复</strong>，<code>redo log</code> 用于<strong>保证事务持久性</strong>，<code>undo log</code> 用于<strong>事务回滚和 MVCC</strong>。</p>
<p>—-这部分是帮助理解 start，面试中可不背—-</p>
<p>①、<code>错误日志（Error Log）</code>：记录 MySQL 服务器<strong>启动、运行或停止</strong>时出现的问题。<br>②、<code>慢查询日志（Slow Query Log）</code>：记录执行时间超过 <code>long_query_time</code> 值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。<br>③、<code>一般查询日志（General Query Log）</code>：记录 MySQL 服务器的启动关闭信息，客户端的连接信息，以及更新、查询的 SQL 语句等。<br>④、<code>二进制日志（Binary Log）</code>：记录所有<strong>修改数据库状态的 SQL 语句</strong>，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作。<br>⑤、<code>重做日志（Redo Log）</code>：记录对于 InnoDB 表的每个写操作，不是 SQL 级别的，而是物理级别的，主要用于崩溃恢复。<br>⑥、<code>回滚日志（Undo Log，或者叫事务日志）</code>：记录数据被修改前的值，用于事务的回滚。</p>
<p>—-这部分是帮助理解 end，面试中可不背—-</p>
<h4 id="请重点说说-binlog？"><a href="#请重点说说-binlog？" class="headerlink" title="请重点说说 binlog？"></a>请重点说说 binlog？</h4><p>binlog 是一种物理日志，<strong>会在磁盘上记录数据库的所有修改操作</strong>。<br>如果误删了数据，就可以使用 binlog 进行回退到误删之前的状态。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 步骤<span class="number">1</span>：恢复全量备份</span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p <span class="operator">&lt;</span> full_backup.sql</span><br><span class="line"># 步骤<span class="number">2</span>：应用Binlog到指定时间点</span><br><span class="line">mysqlbinlog <span class="comment">--start-datetime=&quot;2025-03-13 14:00:00&quot; --stop-datetime=&quot;2025-03-13 15:00:00&quot; binlog.000001 | mysql -u root -p</span></span><br></pre></td></tr></table></figure>
<p>如果要搭建主从复制，就可以让从库定时读取主库的 binlog。<br>MySQL 提供了三种格式的 binlog：<code>Statement</code>、<code>Row</code> 和 <code>Mixed</code>，分别对应 SQL 语句级别、行级别和混合级别，默认为行级别。<br>从后缀名上来看，binlog 文件分为两类：以 <code>.index</code> 结尾的<strong>索引文件</strong>，以 <code>.00000*</code> 结尾的<strong>二进制日志文件</strong>。<br><strong>binlog 默认是没有启用的。</strong></p>
<p>生产环境中是一定要启用的，可以通过在 <code>my.cnf</code> 文件中配置 <code>log_bin</code> 参数，以启用 binlog。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">log_bin <span class="operator">=</span> mysql<span class="operator">-</span>bin #开启binlog</span><br><span class="line">#mysql<span class="operator">-</span>bin.<span class="operator">*</span>日志文件最大字节（单位：字节）</span><br><span class="line">#设置最大<span class="number">100</span>MB</span><br><span class="line">max_binlog_size<span class="operator">=</span><span class="number">104857600</span></span><br><span class="line"></span><br><span class="line">#设置了只保留<span class="number">7</span>天BINLOG（单位：天）</span><br><span class="line">expire_logs_days <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">#binlog日志只记录指定库的更新</span><br><span class="line">#binlog<span class="operator">-</span>do<span class="operator">-</span>db<span class="operator">=</span>db_name</span><br><span class="line"></span><br><span class="line">#binlog日志不记录指定库的更新</span><br><span class="line">#binlog<span class="operator">-</span>ignore<span class="operator">-</span>db<span class="operator">=</span>db_name</span><br><span class="line"></span><br><span class="line">#写缓冲多少次，刷一次磁盘，默认<span class="number">0</span></span><br><span class="line">sync_binlog<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="binlog-的配置参数都了解哪些？"><a href="#binlog-的配置参数都了解哪些？" class="headerlink" title="binlog 的配置参数都了解哪些？"></a>binlog 的配置参数都了解哪些？</h4><p><code>log_bin = mysql-bin </code>用于<strong>启用 binlog</strong>，这样就可以在 MySQL 的数据目录中找到 db-bin.000001、db-bin.000002 等日志文件。<br><code>max_binlog_size=104857600</code> 用于设置<strong>每个 binlog 文件的大小</strong>，不建议设置太大，网络传送起来比较麻烦。<br>当 binlog 文件达到 <code>max_binlog_size</code> 时，MySQL 会关闭当前文件并创建一个新的 binlog 文件。<br><code>expire_logs_days = 7</code> 用于设置 binlog 文件的<strong>自动过期时间为 7 天</strong>。过期的 binlog 文件会被自动删除。防止长时间累积的 binlog 文件占用过多存储空间，所以这个配置很重要。<br><code>binlog-do-db=db_name</code>，<strong>指定哪些数据库表的更新应该被记录</strong>。<br><code>binlog-ignore-db=db_name</code>，指定<strong>忽略哪些数据库表的更新</strong>。<br><code>sync_binlog=0</code>，设置<strong>每多少次 binlog 写操作会触发一次磁盘同步操作</strong>。默认值为 0，表示 MySQL 不会主动触发同步操作，而是依赖操作系统的磁盘缓存策略。<br>即当执行写操作时，数据会先写入缓存，当缓存区满了再由操作系统将数据一次性刷入磁盘。<br>如果设置为 1，表示每次 binlog 写操作后都会同步到磁盘，虽然可以保证数据能够及时写入磁盘，但会降低性能。<br>可以通过 <code>show variables like &#39;%log_bin%&#39;;</code> 查看 <code>binlog</code> 是否开启。</p>
<h4 id="有了binlog为什么还要undolog-redolog？"><a href="#有了binlog为什么还要undolog-redolog？" class="headerlink" title="有了binlog为什么还要undolog redolog？"></a>有了binlog为什么还要undolog redolog？</h4><p><code>binlog</code> 属于 <code>Server</code> 层，与存储引擎无关，<strong>无法直接操作物理数据页</strong>。而 <code>redo log</code> 和 <code>undo log</code> 是 <code>InnoDB</code> 存储引擎实现 ACID的基石。<br>————–ps————-<br><strong>ACID:</strong></p>
<ul>
<li>**原子性(Atomicity)**：<br>事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚<br>通过undo log实现，记录事务开始前的状态，用于回滚</li>
<li>**一致性(Consistency)**：<br>事务执行前后，数据库从一个一致状态转变为另一个一致状态<br>通过其他三个特性(AID)共同保证</li>
<li>**隔离性(Isolation)**：<br>多个并发事务执行时，一个事务的执行不应影响其他事务<br>通过锁机制和MVCC(多版本并发控制)实现</li>
<li>**持久性(Durability)**：<br>事务一旦提交，其结果就是永久性的<br>通过redo log实现，即使系统崩溃也能恢复数据</li>
</ul>
<p>————–ps————-</p>
<p><code>binlog</code> 关注的是<strong>逻辑变更的全局记录</strong>；<code>redo log</code> 用于<strong>确保物理变更的持久性</strong>，确保事务最终能够刷盘成功；<code>undo log</code> 是<strong>逻辑逆向操作日志</strong>，记录的是旧值，方便恢复到事务开始前的状态。</p>
<p><strong>另外一种回答方式。</strong></p>
<p><code>binlog</code> 会记录<strong>整个 SQL 或行变化</strong>；<code>redo log</code> 是为了恢复<strong>已提交但未刷盘</strong>的数据，<code>undo log</code> 是为了<strong>撤销未提交的事务</strong>。</p>
<p>以一次事务更新为例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新数据</span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> age <span class="operator">=</span> age <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"># 提交事务</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p><strong>事务开始</strong>的时候会生成 <code>undo log</code>，记录更新前的数据，比如原值是 18：</p>
<pre><code>undo log: id=1, age=18
</code></pre>
<p>修改数据的时候，会将数据写入到 <code>redo log</code>。</p>
<p>比如数据页 <code>page_id=123</code> 上，id&#x3D;1 的用户被更新为 age&#x3D;26：</p>
<pre><code>redo log (prepare):
page_id=123, offset=0x40, before=18, after=26
</code></pre>
<p>等事务提交的时候，<code>redo log</code> 刷盘，<code>binlog</code> 刷盘。</p>
<p><code>binlog</code> 写完之后，<code>redo log</code> 的状态会变为 <code>commit</code>：</p>
<pre><code>redo log (commit):
page_id=123, offset=0x40, before=18, after=26
</code></pre>
<p>binlog 如果是 <code>Statement</code> 格式，会记录一条 SQL 语句：<br>    UPDATE users SET age &#x3D; age + 1 WHERE id &#x3D; 1;<br>binlog 如果是 <code>Row</code> 格式，会记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表：users</span><br><span class="line">before: id<span class="operator">=</span><span class="number">1</span>, age<span class="operator">=</span><span class="number">18</span></span><br><span class="line">after:  id<span class="operator">=</span><span class="number">1</span>, age<span class="operator">=</span><span class="number">26</span></span><br></pre></td></tr></table></figure>
<p>随后，后台线程会将 redo log 中的变更异步刷新到磁盘。</p>
<h4 id="详细探究一下binlog-长文警告⚠️"><a href="#详细探究一下binlog-长文警告⚠️" class="headerlink" title="详细探究一下binlog(长文警告⚠️):"></a>详细探究一下binlog(长文警告⚠️):</h4><p>MySQL 的 Binlog 日志是一种二进制格式的日志，Binlog 记录所有的 DDL 和 DML 语句(除了数据查询语句SELECT、SHOW等)，以 Event 的形式记录，同时记录语句执行时间。</p>
<h5 id="Binlog-的主要作用有两个："><a href="#Binlog-的主要作用有两个：" class="headerlink" title="Binlog 的主要作用有两个："></a>Binlog 的主要作用有两个：</h5><p><strong>1. 数据恢复:</strong><br>因为 Binlog 详细记录了所有修改数据的 SQL，当某一时刻的数据误操作而导致出问题，或者数据库宕机数据丢失，那么可以根据 Binlog 来回放历史数据。<br><strong>2. 主从复制:</strong><br>想要做多机备份的业务，可以去监听当前写库的 Binlog 日志，同步写库的所有更改。</p>
<p><strong>Binlog 包括两类文件：</strong><br><code>二进制日志索引文件(.index)</code>：记录所有的二进制文件。<br><code>二进制日志文件(.00000*)</code>：记录所有 <code>DDL</code> 和 <code>DML</code> 语句事件。</p>
<p>Binlog 日志功能<strong>默认是开启</strong>的，线上情况下 Binlog 日志的增长速度是很快的，在 MySQL 的配置文件 <code>my.cnf</code> 中提供一些参数来对 Binlog 进行设置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#设置此参数表示启用binlog功能，并制定二进制日志的存储目录</span><br><span class="line">log<span class="operator">-</span>bin<span class="operator">=</span><span class="operator">/</span>home<span class="operator">/</span>mysql<span class="operator">/</span>binlog<span class="operator">/</span></span><br><span class="line"></span><br><span class="line">#mysql<span class="operator">-</span>bin.<span class="operator">*</span>日志文件最大字节（单位：字节）</span><br><span class="line">#设置最大<span class="number">100</span>MB</span><br><span class="line">max_binlog_size<span class="operator">=</span><span class="number">104857600</span></span><br><span class="line"></span><br><span class="line">#设置了只保留<span class="number">7</span>天BINLOG（单位：天）</span><br><span class="line">expire_logs_days <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">#binlog日志只记录指定库的更新</span><br><span class="line">#binlog<span class="operator">-</span>do<span class="operator">-</span>db<span class="operator">=</span>db_name</span><br><span class="line"></span><br><span class="line">#binlog日志不记录指定库的更新</span><br><span class="line">#binlog<span class="operator">-</span>ignore<span class="operator">-</span>db<span class="operator">=</span>db_name</span><br><span class="line"></span><br><span class="line">#写缓冲多少次，刷一次磁盘，默认<span class="number">0</span></span><br><span class="line">sync_binlog<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是：</strong><br><code>max_binlog_size</code> ：Binlog 最大和默认值是 1G，该设置并不能严格控制 Binlog 的大小，尤其是 Binlog 比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性不可能做切换日志的动作，只能将该事务的所有 SQL 都记录进当前日志直到事务结束。所以真实文件有时候会大于 max_binlog_size 设定值。<br><code>expire_logs_days</code> ：Binlog 过期删除不是服务定时执行，是需要借助事件触发才执行，事件包括：</p>
<ul>
<li>服务器重启</li>
<li>服务器被更新</li>
<li>日志达到了最大日志长度 max_binlog_size</li>
<li>日志被刷新</li>
</ul>
<p>二进制日志由配置文件的 <code>log-bin</code> 选项负责启用，MySQL 服务器将在数据根目录创建两个新文件mysql-bin.000001 和 mysql-bin.index，若配置选项没有给出文件名，MySQL 将使用主机名称命名这两个文件，其中 <code>.index</code> 文件包含一份全体日志文件的清单。</p>
<p><code>sync_binlog</code>：这个参数决定了 Binlog 日志的更新频率。默认 0 ，表示该操作由操作系统根据自身负载自行决定多久写一次磁盘。</p>
<p><code>sync_binlog = 1</code> 表示每一条事务提交都会立刻写盘。<code>sync_binlog=n</code> 表示 n 个事务提交才会写盘。</p>
<p>根据 MySQL 文档，写 Binlog 的时机是：<code>SQL transaction</code> 执行完，但任何相关的 Locks 还<strong>未释放</strong>或<strong>事务还未最终 commit</strong> 前。这样保证了 Binlog 记录的操作时序与数据库实际的数据变更顺序一致。</p>
<p><strong>检查 Binlog 文件是否已开启：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>mysql<span class="operator">/</span>data<span class="operator">/</span>binlog       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>mysql<span class="operator">/</span>data<span class="operator">/</span>binlog.index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> OFF                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+------------------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>MySQL 会把用户对所有数据库的内容和结构的修改情况记入 <code>mysql-bin.n</code> 文件，而不会记录 <code>SELECT</code> 和没有实际更新的 <code>UPDATE</code> 语句。</p>
<p>如果你不知道现在有哪些 Binlog 文件，可以使用如下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="type">binary</span> logs; #查看binlog列表</span><br><span class="line"><span class="keyword">show</span> master status; #查看最新的binlog</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="type">binary</span> logs;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name         <span class="operator">|</span> File_size <span class="operator">|</span> Encrypted <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>       <span class="number">179</span> <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span>       <span class="number">156</span> <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+-----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>Binlog 文件是二进制文件，强行打开看到的必然是乱码，MySQL 提供了命令行的方式来展示 Binlog 日志：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> more</span><br></pre></td></tr></table></figure>
<p>mysqlbinlog 命令即可查看。<br>虽然看起来凌乱其实也有迹可循。<code>Binlog</code> 通过事件的方式来管理日志信息，可以通过 <code>show binlog events in</code> 的语法来查看当前 <code>Binlog</code> 文件对应的详细事件信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.000001&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Log_name         <span class="operator">|</span> Pos <span class="operator">|</span> Event_type     <span class="operator">|</span> Server_id <span class="operator">|</span> End_log_pos <span class="operator">|</span> Info                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> Format_desc    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">125</span> <span class="operator">|</span> Server ver: <span class="number">8.0</span><span class="number">.21</span>, Binlog ver: <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">125</span> <span class="operator">|</span> Previous_gtids <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">156</span> <span class="operator">|</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">156</span> <span class="operator">|</span> Stop           <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">179</span> <span class="operator">|</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>这是一份没有任何写入数据的 <code>Binlog</code> 日志文件。<br><code>Binlog</code> 的版本是V4，可以看到日志的结束时间为 Stop。出现 Stop event 有两种情况：</p>
<ol>
<li>是 master shut down 的时候会在 <code>Binlog</code> 文件结尾出现</li>
<li>是备机在关闭的时候会写入 <code>relay log</code> 结尾，或者执行 <code>RESET SLAVE</code> 命令执行</li>
</ol>
<p>本文出现的原因是我有<strong>手动停止过 MySQL 服务</strong>。<br>一般来说一份正常的 <code>Binlog</code> 日志文件会以 Rotate event 结束。当 <code>Binlog</code> 文件超过指定大小，Rotate event 会写在文件最后，指向下一个 <code>Binlog</code> 文件。<br>我们来看看有过数据操作的 <code>Binlog</code> 日志文件是什么样子的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.000002&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Log_name         <span class="operator">|</span> Pos <span class="operator">|</span> Event_type     <span class="operator">|</span> Server_id <span class="operator">|</span> End_log_pos <span class="operator">|</span> Info                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> Format_desc    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">125</span> <span class="operator">|</span> Server ver: <span class="number">8.0</span><span class="number">.21</span>, Binlog ver: <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">125</span> <span class="operator">|</span> Previous_gtids <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">156</span> <span class="operator">|</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>上面是没有任何数据操作且没有被截断的 Binlog。接下来我们插入一条数据，再看看 Binlog 事件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.000002&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Log_name         <span class="operator">|</span> Pos <span class="operator">|</span> Event_type     <span class="operator">|</span> Server_id <span class="operator">|</span> End_log_pos <span class="operator">|</span> Info                                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> Format_desc    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">125</span> <span class="operator">|</span> Server ver: <span class="number">8.0</span><span class="number">.21</span>, Binlog ver: <span class="number">4</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">125</span> <span class="operator">|</span> Previous_gtids <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">156</span> <span class="operator">|</span>                                                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">156</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">235</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">235</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">323</span> <span class="operator">|</span> <span class="keyword">BEGIN</span>                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">323</span> <span class="operator">|</span> Intvar         <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">355</span> <span class="operator">|</span> INSERT_ID<span class="operator">=</span><span class="number">13</span>                                                            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">355</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">494</span> <span class="operator">|</span> use `test_db`; <span class="keyword">INSERT INTO</span> `test_db`.`test_db`(`name`) <span class="keyword">VALUES</span> (<span class="string">&#x27;xdfdf&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">494</span> <span class="operator">|</span> Xid            <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">525</span> <span class="operator">|</span> <span class="keyword">COMMIT</span> <span class="comment">/* xid=192 */</span>                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>这是加入一条数据之后的 <code>Binlog</code> 事件。</p>
<p><strong>我们对 event 查询的数据行关键字段来解释一下：</strong></p>
<ul>
<li><code>Pos</code>：当前事件的开始位置，每个事件都占用固定的字节大小，结束位置(End_log_position)减去Pos，就是这个事件占用的字节数。<br>上面的日志中我们能看到，第一个事件位置并不是从 0 开始，而是从 4。MySQL 通过文件中的前 4 个字节，来判断这是不是一个 Binlog 文件。这种方式很常见，很多格式的文件，如 pdf、doc、jpg等，都会通常<strong>前几个特定字符判断是否是合法文件</strong>。</li>
<li><code>Event_type</code>：表示事件的类型</li>
<li><code>Server_id</code>：表示产生这个事件的 MySQL server_id，通过设置 my.cnf 中的 server-id 选项进行配置</li>
<li><code>End_log_position</code>：下一个事件的开始位置</li>
<li><code>Info</code>：包含事件的具体信息</li>
</ul>
<h5 id="Binlog-日志格式"><a href="#Binlog-日志格式" class="headerlink" title="Binlog 日志格式:"></a>Binlog 日志格式:</h5><p>针对不同的使用场景，<code>Binlog</code> 也提供了可定制化的服务，提供了<strong>三种模式</strong>来提供不同详细程度的日志内容。</p>
<ul>
<li><code>Statement</code> 模式：基于 <code>SQL</code> 语句的复制(statement-based replication-SBR)</li>
<li><code>Row</code> 模式：基于行的复制(row-based replication-RBR)</li>
<li><code>Mixed</code> 模式：混合模式复制(mixed-based replication-MBR)</li>
</ul>
<ol>
<li><p><strong>Statement 模式</strong><br><strong>保存每一条修改数据的SQL。</strong><br>该模式只保存一条普通的SQL语句，不涉及到执行的上下文信息。<br>因为每台 MySQL 数据库的本地环境可能不一样，那么对于依赖到本地环境的函数或者上下文处理的逻辑 SQL 去处理的时候可能同样的语句在不同的机器上执行出来的效果不一致。<br>比如像 sleep()函数，last_insert_id()函数，等等，这些都跟特定时间的本地环境有关。</p>
</li>
<li><p><strong>Row 模式</strong><br>MySQL V5.1.5 版本开始支持Row模式的 Binlog，它与 Statement 模式的区别在于它<strong>不保存具体的 SQL 语句，而是记录具体被修改的信息</strong>。<br>比如一条 update 语句更新10条数据，如果是 Statement 模式那就保存一条 SQL 就够，但是 Row 模式会保存每一行分别更新了什么，有10条数据。<br>Row 模式的优缺点就很明显了。保存每一个更改的详细信息必然会带来<strong>存储空间的快速膨胀</strong>，换来的是<strong>事件操作的详细记录</strong>。所以要求越高代价越高。</p>
</li>
<li><p><strong>Mixed 模式</strong><br>Mixed 模式即以上两种模式的综合体。既然上面两种模式分别走了极简和一丝不苟的极端，那是否可以区分使用场景的情况下将这两种模式综合起来呢？<br>在 Mixed 模式中，<strong>一般的更新语句使用 Statement 模式来保存 Binlog</strong>，但是遇到一些函数操作，<strong>可能会影响数据准确性的操作则使用 Row 模式来保存</strong>。这种方式需要根据每一条具体的 SQL 语句来区分选择哪种模式。<br>MySQL 从 V5.1.8 开始提供 Mixed 模式，V5.7.7 之前的版本默认是Statement 模式，之后默认使用Row模式， <strong>但是在 8.0 以上版本已经默认使用 Mixed 模式了</strong>。</p>
</li>
</ol>
<p>查询当前 Binlog 日志使用格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> binlog_format                   <span class="operator">|</span> MIXED   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> default_week_format             <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> information_schema_stats_expiry <span class="operator">|</span> <span class="number">86400</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_default_row_format       <span class="operator">|</span> <span class="keyword">dynamic</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> require_row_format              <span class="operator">|</span> OFF     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h5 id="如何通过-mysqlbinlog-命令手动恢复数据"><a href="#如何通过-mysqlbinlog-命令手动恢复数据" class="headerlink" title="如何通过 mysqlbinlog 命令手动恢复数据"></a>如何通过 mysqlbinlog 命令手动恢复数据</h5><p>上面说过每一条 event 都有位点信息，如果我们当前的 MySQL 库被无操作或者误删除了，那么该如何通过 Binlog 来恢复到删除之前的数据状态呢？<br>首先发现误操作之后，<strong>先停止 MySQL 服务，防止继续更新</strong>。<br>接着通过 <code>mysqlbinlog</code>命令对二进制文件进行分析，查看误操作之前的位点信息在哪里。<br>接下来肯定就是恢复数据，当前数据库的数据已经是错的，那么就从开始位置到误操作之前位点的数据肯定的都是正确的；如果误操作之后也有正常的数据进来，这一段时间的位点数据也要备份。<br>比如说：<br>误操作的位点开始值为 501，误操作结束的位置为705，之后到800的位点都是正确数据。<br>那么从 0 - 500 ，706 - 800 都是有效数据，接着我们就可以进行数据恢复了。<br><strong>先将数据库备份并清空。</strong><br>接着使用 <code>mysqlbinlog</code> 来恢复数据：<br>0 - 500 的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="comment">--start-position=0  --stop-position=500  bin-log.000003 &gt; /root/back.sql;</span></span><br></pre></td></tr></table></figure>
<p>上面命令的作用就是将 0 -500 位点的数据恢复到自定义的 SQL 文件中。同理 706 - 800 的数据也是一样操作。之后我们执行这两个 SQL 文件就行了。</p>
<p><strong>Binlog 事件类型</strong><br>上面我们说到了 <code>Binlog</code> 日志中的事件，不同的操作会对应着不同的事件类型，且不同的 <code>Binlog</code> 日志模式同一个操作的事件类型也不同，下面我们一起看看常见的事件类型。<br>首先我们看看源码中的事件类型定义：<br>源码位置：&#x2F;libbinlogevents&#x2F;include&#x2F;binlog_event.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Log_event_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    Every time you update this enum (when you add a type), you have to</span></span><br><span class="line"><span class="comment">    fix Format_description_event::Format_description_event().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  UNKNOWN_EVENT= <span class="number">0</span>,</span><br><span class="line">  START_EVENT_V3= <span class="number">1</span>,</span><br><span class="line">  QUERY_EVENT= <span class="number">2</span>,</span><br><span class="line">  STOP_EVENT= <span class="number">3</span>,</span><br><span class="line">  ROTATE_EVENT= <span class="number">4</span>,</span><br><span class="line">  INTVAR_EVENT= <span class="number">5</span>,</span><br><span class="line">  LOAD_EVENT= <span class="number">6</span>,</span><br><span class="line">  SLAVE_EVENT= <span class="number">7</span>,</span><br><span class="line">  CREATE_FILE_EVENT= <span class="number">8</span>,</span><br><span class="line">  APPEND_BLOCK_EVENT= <span class="number">9</span>,</span><br><span class="line">  EXEC_LOAD_EVENT= <span class="number">10</span>,</span><br><span class="line">  DELETE_FILE_EVENT= <span class="number">11</span>,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    NEW_LOAD_EVENT is like LOAD_EVENT except that it has a longer</span></span><br><span class="line"><span class="comment">    sql_ex, allowing multibyte TERMINATED BY etc; both types share the</span></span><br><span class="line"><span class="comment">    same class (Load_event)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  NEW_LOAD_EVENT= <span class="number">12</span>,</span><br><span class="line">  RAND_EVENT= <span class="number">13</span>,</span><br><span class="line">  USER_VAR_EVENT= <span class="number">14</span>,</span><br><span class="line">  FORMAT_DESCRIPTION_EVENT= <span class="number">15</span>,</span><br><span class="line">  XID_EVENT= <span class="number">16</span>,</span><br><span class="line">  BEGIN_LOAD_QUERY_EVENT= <span class="number">17</span>,</span><br><span class="line">  EXECUTE_LOAD_QUERY_EVENT= <span class="number">18</span>,</span><br><span class="line"></span><br><span class="line">  TABLE_MAP_EVENT = <span class="number">19</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    The PRE_GA event numbers were used for 5.1.0 to 5.1.15 and are</span></span><br><span class="line"><span class="comment">    therefore obsolete.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  PRE_GA_WRITE_ROWS_EVENT = <span class="number">20</span>,</span><br><span class="line">  PRE_GA_UPDATE_ROWS_EVENT = <span class="number">21</span>,</span><br><span class="line">  PRE_GA_DELETE_ROWS_EVENT = <span class="number">22</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    The V1 event numbers are used from 5.1.16 until mysql-trunk-xx</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  WRITE_ROWS_EVENT_V1 = <span class="number">23</span>,</span><br><span class="line">  UPDATE_ROWS_EVENT_V1 = <span class="number">24</span>,</span><br><span class="line">  DELETE_ROWS_EVENT_V1 = <span class="number">25</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    Something out of the ordinary happened on the master</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  INCIDENT_EVENT= <span class="number">26</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    Heartbeat event to be send by master at its idle time</span></span><br><span class="line"><span class="comment">    to ensure master&#x27;s online status to slave</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  HEARTBEAT_LOG_EVENT= <span class="number">27</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    In some situations, it is necessary to send over ignorable</span></span><br><span class="line"><span class="comment">    data to the slave: data that a slave can handle in case there</span></span><br><span class="line"><span class="comment">    is code for handling it, but which can be ignored if it is not</span></span><br><span class="line"><span class="comment">    recognized.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  IGNORABLE_LOG_EVENT= <span class="number">28</span>,</span><br><span class="line">  ROWS_QUERY_LOG_EVENT= <span class="number">29</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Version 2 of the Row events */</span></span><br><span class="line">  WRITE_ROWS_EVENT = <span class="number">30</span>,</span><br><span class="line">  UPDATE_ROWS_EVENT = <span class="number">31</span>,</span><br><span class="line">  DELETE_ROWS_EVENT = <span class="number">32</span>,</span><br><span class="line"></span><br><span class="line">  GTID_LOG_EVENT= <span class="number">33</span>,</span><br><span class="line">  ANONYMOUS_GTID_LOG_EVENT= <span class="number">34</span>,</span><br><span class="line"></span><br><span class="line">  PREVIOUS_GTIDS_LOG_EVENT= <span class="number">35</span>,</span><br><span class="line"></span><br><span class="line">  TRANSACTION_CONTEXT_EVENT= <span class="number">36</span>,</span><br><span class="line"></span><br><span class="line">  VIEW_CHANGE_EVENT= <span class="number">37</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prepared XA transaction terminal event similar to Xid */</span></span><br><span class="line">  XA_PREPARE_LOG_EVENT= <span class="number">38</span>,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    Add new events here - right above this comment!</span></span><br><span class="line"><span class="comment">    Existing events (except ENUM_END_EVENT) should never change their numbers</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ENUM_END_EVENT <span class="comment">/* end marker */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这么多的事件类型我们就不一一介绍，挑出来一些常用的来看看。<br><code>FORMAT_DESCRIPTION_EVENT</code><br><code>FORMAT_DESCRIPTION_EVENT</code> 是 Binlog V4 中为了取代之前版本中的 START_EVENT_V3 事件而引入的。它是 Binlog 文件中的第一个事件，而且，该事件只会在 Binlog 中出现一次。MySQL 根据 <code>FORMAT_DESCRIPTION_EVENT</code> 的定义来解析其它事件。<br>它通常指定了 MySQL 的版本，Binlog 的版本，该 Binlog 文件的创建时间。</p>
<p><code>QUERY_EVENT</code></p>
<p><code>QUERY_EVENT</code> 类型的事件通常在以下几种情况下使用：</p>
<p>事务开始时，执行的 BEGIN 操作<br>STATEMENT 格式中的 DML 操作<br>ROW 格式中的 DDL 操作<br>比如上文我们插入一条数据之后的 Binlog 日志：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.000002&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Log_name         <span class="operator">|</span> Pos <span class="operator">|</span> Event_type     <span class="operator">|</span> Server_id <span class="operator">|</span> End_log_pos <span class="operator">|</span> Info                                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> Format_desc    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">125</span> <span class="operator">|</span> Server ver: <span class="number">8.0</span><span class="number">.21</span>, Binlog ver: <span class="number">4</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">125</span> <span class="operator">|</span> Previous_gtids <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">156</span> <span class="operator">|</span>                                                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">156</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">235</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">235</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">323</span> <span class="operator">|</span> <span class="keyword">BEGIN</span>                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">323</span> <span class="operator">|</span> Intvar         <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">355</span> <span class="operator">|</span> INSERT_ID<span class="operator">=</span><span class="number">13</span>                                                            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">355</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">494</span> <span class="operator">|</span> use `test_db`; <span class="keyword">INSERT INTO</span> `test_db`.`test_db`(`name`) <span class="keyword">VALUES</span> (<span class="string">&#x27;xdfdf&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">494</span> <span class="operator">|</span> Xid            <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">525</span> <span class="operator">|</span> <span class="keyword">COMMIT</span> <span class="comment">/* xid=192 */</span>                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><code>XID_EVENT</code><br>在事务提交时，不管是 STATEMENT 还 是ROW 格式的 Binlog，都会在末尾添加一个 <code>XID_EVENT</code> 事件代表<strong>事务的结束</strong>。该事件记录了该事务的 ID，在 MySQL 进行崩溃恢复时，根据事务在 Binlog 中的提交情况来决定是否提交存储引擎中状态为 prepared 的事务。<br><code>ROWS_EVENT</code><br>对于 ROW 格式的 Binlog，所有的 DML 语句都是记录在 <code>ROWS_EVENT</code> 中。<br><code>ROWS_EVENT</code>分为三种：<br><code>WRITE_ROWS_EVENT</code><br><code>UPDATE_ROWS_EVENT</code><br><code>DELETE_ROWS_EVENT</code><br>分别对应 <code>insert</code>，<code>update</code> 和 <code>delete</code> 操作。<br>对于 <code>insert</code> 操作，<code>WRITE_ROWS_EVENT</code> 包含了要插入的数据。<br>对于 <code>update</code> 操作，<code>UPDATE_ROWS_EVENT</code> 不仅包含了修改后的数据，还包含了修改前的值。<br>对于 <code>delete</code> 操作，仅仅需要指定删除的主键（在没有主键的情况下，会给定所有列）。</p>
<p>对比 <code>QUERY_EVENT</code> 事件，是以文本形式记录 DML 操作的。而对于 <code>ROWS_EVENT</code> 事件，<strong>并不是文本形式</strong>，所以在通过 mysqlbinlog 查看基于 ROW 格式的 Binlog 时，需要指定 -vv –base64-output&#x3D;decode-rows。</p>
<p>我们来测试一下，首先将日志格式改为 Rows：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> binlog_format<span class="operator">=</span><span class="type">row</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> flush logs;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>然后刷新一下日志文件，重新开始一个 Binlog 日志。我们插入一条数据之后看一下日志：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;binlog.000008&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----+----------------+-----------+-------------+--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Log_name      <span class="operator">|</span> Pos <span class="operator">|</span> Event_type     <span class="operator">|</span> Server_id <span class="operator">|</span> End_log_pos <span class="operator">|</span> Info                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----+----------------+-----------+-------------+--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> binlog<span class="number">.000008</span> <span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> Format_desc    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">125</span> <span class="operator">|</span> Server ver: <span class="number">8.0</span><span class="number">.21</span>, Binlog ver: <span class="number">4</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog<span class="number">.000008</span> <span class="operator">|</span> <span class="number">125</span> <span class="operator">|</span> Previous_gtids <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">156</span> <span class="operator">|</span>                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog<span class="number">.000008</span> <span class="operator">|</span> <span class="number">156</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">235</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog<span class="number">.000008</span> <span class="operator">|</span> <span class="number">235</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">313</span> <span class="operator">|</span> <span class="keyword">BEGIN</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog<span class="number">.000008</span> <span class="operator">|</span> <span class="number">313</span> <span class="operator">|</span> Table_map      <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">377</span> <span class="operator">|</span> table_id: <span class="number">85</span> (test_db.test_db)       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog<span class="number">.000008</span> <span class="operator">|</span> <span class="number">377</span> <span class="operator">|</span> Write_rows     <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">423</span> <span class="operator">|</span> table_id: <span class="number">85</span> flags: STMT_END_F       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog<span class="number">.000008</span> <span class="operator">|</span> <span class="number">423</span> <span class="operator">|</span> Xid            <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">454</span> <span class="operator">|</span> <span class="keyword">COMMIT</span> <span class="comment">/* xid=44 */</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----+----------------+-----------+-------------+--------------------------------------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>



<h4 id="说说-redo-log-的工作机制？"><a href="#说说-redo-log-的工作机制？" class="headerlink" title="说说 redo log 的工作机制？"></a>说说 redo log 的工作机制？</h4><p>当<strong>事务启动</strong>时，MySQL 会为该事务分配一个唯一标识符。<br>在<strong>事务执行过程中，每次对数据进行修改</strong>，MySQL 都会生成一条 <code>Redo Log</code>，记录修改前后的数据状态。<br>这些 <code>Redo Log</code> 首先会被写入内存中的 <code>Redo Log Buffer</code>。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161219.png" alt="20250613161219"><br>当事务提交时，MySQL 再将 <code>Redo Log Buffer</code> 中的记录刷新到磁盘上的 <code>Redo Log</code> 文件中。<br>只有当<code> Redo Log</code> 成功写入磁盘，事务才算真正提交成功。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161254.png" alt="20250613161254"><br>当 MySQL 崩溃重启时，会先检查 <code>Redo Log</code>。对于已提交的事务，MySQL 会重放 <code>Redo Log</code> 中的记录。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161338.png" alt="20250613161338"><br>对于未提交的事务，MySQL 会通过 <code>Undo Log</code> 回滚这些修改，确保数据恢复到崩溃前的一致性状态。<br><code>Redo Log</code> 是循环使用的，当文件写满后会覆盖最早的记录。<br>为避免覆盖未持久化的记录，MySQL 会定期执行 <code>CheckPoint</code> 操作，将内存中的数据页刷新到磁盘，并记录 <code>CheckPoint</code> 点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161415.png" alt="20250613161415"></p>
<p>重启时，MySQL 只会重放 CheckPoint 之后的 Redo Log，从而提高恢复效率。</p>
<p><strong>省流版:</strong></p>
<ol>
<li>事务开始</li>
<li>记录undo log（旧数据）</li>
<li>修改Buffer Pool中的数据</li>
<li>写入redo log（prepare状态）</li>
<li>写入binlog</li>
<li>提交事务（redo log标记为commit）</li>
<li>后台异步刷脏页到磁盘</li>
</ol>
<h4 id="redo-log-文件的大小是固定的吗？"><a href="#redo-log-文件的大小是固定的吗？" class="headerlink" title="redo log 文件的大小是固定的吗？"></a>redo log 文件的大小是固定的吗？</h4><p><code>redo log</code> 文件是固定大小的，通常配置为一组文件，使用<strong>环形方式</strong>写入，旧的日志会在空间需要时被覆盖。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613162534.png" alt="20250613162534"><br>命名方式为 ib_logfile0、iblogfile1、、、iblogfilen。默认 2 个文件，每个文件大小为 48MB。<br>可以通过 <code>show variables like &#39;innodb_log_file_size&#39;;</code> 查看 redo log 文件的大小；通过 <code>show variables like &#39;innodb_log_files_in_group&#39;;</code> 查看 redo log 文件的数量。</p>
<h4 id="说一说WAL"><a href="#说一说WAL" class="headerlink" title="说一说WAL?"></a>说一说WAL?</h4><pre><code>WAL——Write-Ahead Logging。
</code></pre>
<p>预写日志是 InnoDB <strong>实现事务持久化的核心机制</strong>，它的思想是：<strong>先写日志再刷磁盘</strong>。<br>即在修改数据页之前，先将修改记录写入 <code>Redo Log</code>。<br>这样的话，即使数据页尚未写入磁盘，系统崩溃时也能通过 Redo Log 恢复数据。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613163109.png" alt="20250613163109"><br>—-这部分是帮助理解 start，面试中可不背—-<br><strong>解释一下为什么需要 WAL：</strong><br>数据最终是要写入磁盘的，<strong>但磁盘 IO 很慢</strong>；<br>如果每次更新都立刻把数据页刷盘，性能很差；<br>如果还没写入磁盘就宕机，事务会丢失。<br>WAL 的好处是更新时不直接写数据页，而是先写一份变更记录到 redo log，后台再慢慢把真正的数据页刷盘，一举多得。<br>—-这部分是帮助理解 end，面试中可不背—-</p>
<h3 id="30-🌟为什么要两阶段提交"><a href="#30-🌟为什么要两阶段提交" class="headerlink" title="30.🌟为什么要两阶段提交?"></a>30.🌟为什么要两阶段提交?</h3><p>为了保证 redo log 和 binlog 中的数据一致性，防止主从复制和事务状态不一致。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616093841.png" alt="20250616093841"></p>
<h4 id="为什么-2PC-能保证-redo-log-和-binlog-的强⼀致性？"><a href="#为什么-2PC-能保证-redo-log-和-binlog-的强⼀致性？" class="headerlink" title="为什么 2PC 能保证 redo log 和 binlog 的强⼀致性？"></a>为什么 2PC 能保证 redo log 和 binlog 的强⼀致性？</h4><p>假如 MySQL 在预写 redo log 之后、写入 binlog 之前崩溃。那么 MySQL 重启后 InnoDB 会回滚该事务，因为 redo log 不是提交状态。并且由于 binlog 中没有写入数据，所以从库也不会有该事务的数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616093925.png" alt="20250616093925"></p>
<p>假如 MySQL 在写入 binlog 之后、redo log 提交之前崩溃。那么 MySQL 重启后 InnoDB 会提交该事务，因为 redo log 是提交状态。并且由于 binlog 中有写入数据，所以从库也会同步到该事务的数据。<br>伪代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务开始</span></span><br><span class="line">begin;</span><br><span class="line"><span class="comment">// try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行 SQL</span></span><br><span class="line">    execute SQL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 redo log 并标记为 prepare</span></span><br><span class="line">    write redo log prepare xid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 binlog</span></span><br><span class="line">    write binlog xid sql;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交 redo log</span></span><br><span class="line">    commit redo log xid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// catch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 回滚 redo log</span></span><br><span class="line">    innodb rollback redo log xid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事务结束</span></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h4 id="XID-了解吗？"><a href="#XID-了解吗？" class="headerlink" title="XID 了解吗？"></a>XID 了解吗？</h4><p>XID 是 binlog 中用来<strong>标识事务提交</strong>的唯一标识符。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616094148.png" alt="20250616094148"></p>
<p>在事务提交时，会写入一个 <code>XID_EVENT</code> 到 <code>binlog</code>，表示这个事务真正完成了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Log_name         | Pos  | Event_type     | Server_id | End_log_pos | Info      </span><br><span class="line">| mysql-bin<span class="number">.000003</span> | <span class="number">2005</span> | Gtid           |   <span class="number">1013307</span> |        <span class="number">2070</span> | SET @<span class="meta">@SESSION</span>.GTID_NEXT= <span class="string">&#x27;f971d5f1-d450-11ec-9e7b-5254000a56df:11&#x27;</span>                 |</span><br><span class="line">| mysql-bin<span class="number">.000003</span> | <span class="number">2070</span> | Query          |   <span class="number">1013307</span> |        <span class="number">2142</span> | BEGIN                                                                              |</span><br><span class="line">| mysql-bin<span class="number">.000003</span> | <span class="number">2142</span> | Table_map      |   <span class="number">1013307</span> |        <span class="number">2187</span> | table_id: <span class="number">109</span> (test.t1)                                                            |</span><br><span class="line">| mysql-bin<span class="number">.000003</span> | <span class="number">2187</span> | Write_rows     |   <span class="number">1013307</span> |        <span class="number">2227</span> | table_id: <span class="number">109</span> flags: STMT_END_F                                                    |</span><br><span class="line">| mysql-bin<span class="number">.000003</span> | <span class="number">2227</span> | Xid            |   <span class="number">1013307</span> |        <span class="number">2258</span> | COMMIT <span class="comment">/* xid=121 */</span></span><br></pre></td></tr></table></figure>
<p>它不仅用于<strong>主从复制中事务完整性的判断</strong>，也在<strong>崩溃恢复中对 redo log 和 binlog 的一致性校验</strong>起到关键作用。</p>
<p>XID 可以帮助 MySQL 判断哪些 redo log 是已提交的，哪些是未提交需要回滚的，是两阶段提交机制中非常关键的一环。</p>
<h3 id="31-🌟redo-log-的写入过程了解吗？"><a href="#31-🌟redo-log-的写入过程了解吗？" class="headerlink" title="31.🌟redo log 的写入过程了解吗？"></a>31.🌟redo log 的写入过程了解吗？</h3><p>InnoDB 会先将 Redo Log 写入内存中的 Redo Log Buffer，之后再以一定的频率刷入到磁盘的 Redo Log File 中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616101033.png" alt="20250616101033"></p>
<h4 id="哪些场景会触发-redo-log-的刷盘动作？"><a href="#哪些场景会触发-redo-log-的刷盘动作？" class="headerlink" title="哪些场景会触发 redo log 的刷盘动作？"></a>哪些场景会触发 redo log 的刷盘动作？</h4><p>比如说 <strong>Redo Log Buffer 的空间不足时</strong>，<strong>事务提交时</strong>，<strong>触发 Checkpoint 时</strong>，后台线程定期刷盘时。<br>不过，Redo Log Buffer 刷盘到 Redo Log File 还会涉及到操作系统的磁盘缓存策略，可能不会立即刷盘，而是等待一定时间后才刷盘。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616110133.png" alt="20250616110133"></p>
<h4 id="innodb-flush-log-at-trx-commit-参数你了解多少？"><a href="#innodb-flush-log-at-trx-commit-参数你了解多少？" class="headerlink" title="innodb_flush_log_at_trx_commit 参数你了解多少？"></a>innodb_flush_log_at_trx_commit 参数你了解多少？</h4><p><code>innodb_flush_log_at_trx_commit</code> 参数是用来控制事务提交时，Redo Log 的刷盘策略，一共有三种。</p>
<p>0 表示<strong>事务提交时不刷盘</strong>，而是<strong>交给后台线程每隔 1 秒执行一次</strong>。这种方式性能最好，但是在 MySQL 宕机时<strong>可能会丢失一秒内的事务</strong>。</p>
<p>1 表示<strong>事务提交时会立即刷盘</strong>，确保事务提交后数据就持久化到磁盘。这<strong>种方式是最安全的，也是 InnoDB 的默认值</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616112123.png" alt="20250616112123"></p>
<p>2 表示事务提交时只把 Redo Log Buffer 写入到 Page Cache，由操作系统决定什么时候刷盘。<strong>操作系统宕机时，可能会丢失一部分数据。</strong></p>
<h4 id="一个没有提交事务的-redo-log，会不会刷盘？"><a href="#一个没有提交事务的-redo-log，会不会刷盘？" class="headerlink" title="一个没有提交事务的 redo log，会不会刷盘？"></a>一个没有提交事务的 redo log，会不会刷盘？</h4><p>InnoDB 有一个后台线程，每隔 1 秒会把<code>Redo Log Buffer</code>中的日志写入到文件系统的缓存中，然后调用刷盘操作。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113040.png" alt="20250616113040"></p>
<p>因此，一个没有提交事务的 Redo Log 也可能会被刷新到磁盘中。<br>另外，如果当 <code>Redo Log Buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 的一半时，也会触发刷盘操作。</p>
<h4 id="Redo-Log-Buffer-是顺序写还是随机写？"><a href="#Redo-Log-Buffer-是顺序写还是随机写？" class="headerlink" title="Redo Log Buffer 是顺序写还是随机写？"></a>Redo Log Buffer 是顺序写还是随机写？</h4><p>MySQL 在启动后会向操作系统申请一块连续的内存空间作为 Redo Log Buffer，并将其分为若干个连续的 Redo Log Block。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113305.png" alt="20250616113305"><br>那为了提高写入效率，Redo Log Buffer 采用了顺序写入的方式，会先往前面的 Redo Log Block 中写入，当写满后再往后面的 Block 中写入。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113328.png" alt="20250616113328"><br>于此同时，InnoDB 还提供了一个全局变量 <code>buf_free</code>，来控制后续的 redo log 记录应该写入到 block 中的哪个位置。</p>
<h4 id="buf-next-to-write-了解吗？"><a href="#buf-next-to-write-了解吗？" class="headerlink" title="buf_next_to_write 了解吗？"></a>buf_next_to_write 了解吗？</h4><p><code>buf_next_to_write</code> 指向 Redo Log Buffer 中下一次需要写入硬盘的起始位置。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113533.png" alt="20250616113533"><br>而 buf_free 指向的是 Redo Log Buffer 中空闲区域的起始位置。</p>
<h4 id="了解-MTR-吗？"><a href="#了解-MTR-吗？" class="headerlink" title="了解 MTR 吗？"></a>了解 MTR 吗？</h4><p><code>Mini Transaction </code>是 InnoDB 内部用于操作数据页的原子操作单元。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mtr_t mtr;</span><br><span class="line">mtr_start(&amp;mtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 加锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对待访问的index加锁</span></span><br><span class="line">mtr_s_lock(rw_lock_t, mtr);</span><br><span class="line">mtr_x_lock(rw_lock_t, mtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对待读写的page加锁</span></span><br><span class="line">mtr_memo_push(mtr, buf_block_t, MTR_MEMO_PAGE_S_FIX);</span><br><span class="line">mtr_memo_push(mtr, buf_block_t, MTR_MEMO_PAGE_X_FIX);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 访问或修改page</span></span><br><span class="line">btr_cur_search_to_nth_level</span><br><span class="line">btr_cur_optimistic_insert</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 为修改操作生成redo</span></span><br><span class="line">mlog_open</span><br><span class="line">mlog_write_initial_log_record_fast</span><br><span class="line">mlog_close</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 持久化redo，解锁</span></span><br><span class="line">mtr_commit(&amp;mtr);</span><br></pre></td></tr></table></figure>
<p>多个事务的 Redo Log 会以 MTR 为单位交替写入到 Redo Log Buffer 中，假如事务 1 和事务 2 均有两个 MTR，一旦某个 MTR 结束，就会将其生成的若干条 Redo Log 记录顺序写入到 Redo Log Buffer 中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616151955.png" alt="20250616151955"></p>
<p>也就是说，一个 MTR 会包含一组 Redo Log 记录，是 MySQL 崩溃后恢复事务的最小执行单元。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616154016.png" alt="20250616154016"></p>
<h4 id="Redo-Log-Block-的结构了解吗？"><a href="#Redo-Log-Block-的结构了解吗？" class="headerlink" title="Redo Log Block 的结构了解吗？"></a>Redo Log Block 的结构了解吗？</h4><p><code>Redo Log Block</code> 由日志头、日志体和日志尾组成，一共占用 512 个字节，其中日志头占用 12 个字节，日志尾占用 4 个字节，剩余的 496 个字节用于存储日志体。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616154915.png" alt="20250616154915"><br>日志头包含了当前 Block 的序列号、第一条日志的序列号、类型等信息。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616154950.png" alt="20250616154950"><br>日志尾主要存储的是 LOG_BLOCK_CHECKSUM，也就是 Block 的校验和，主要用于判断 Block 是否完整。</p>
<h4 id="Redo-Log-Block-为什么设计成-512-字节？"><a href="#Redo-Log-Block-为什么设计成-512-字节？" class="headerlink" title="Redo Log Block 为什么设计成 512 字节？"></a>Redo Log Block 为什么设计成 512 字节？</h4><p>因为机械硬盘的物理扇区大小通常为 512 字节，<code>Redo Log Block</code> 也设计为同样的大小，就可以确保每次写入都是整数个扇区，减少对齐开销。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616155054.png" alt="20250616155054"></p>
<p>比如说操作系统的页缓存默认为 4KB，8 个 Redo Log Block 就可以组合成一个页缓存单元，从而提升 Redo Log Buffer 的写入效率。</p>
<h4 id="LSN-了解吗？"><a href="#LSN-了解吗？" class="headerlink" title="LSN 了解吗？"></a>LSN 了解吗？</h4><p>Log Sequence Number 是一个 8 字节的单调递增整数，用来标识事务写入 redo log 的字节总量，存在于 redo log、数据页头部和 checkpoint 中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616160916.png" alt="20250616160916"></p>
<p>—-这部分是帮助理解 start，面试中可不背—-<br>MySQL 在第一次启动时，LSN 的初始值并不为 0，而是 8704；当 MySQL 再次启动时，会继续使用上一次服务停止时的 LSN。</p>
<p>在计算 LSN 的增量时，<strong>不仅需要考虑 log block body 的大小，还需要考虑 log block header 和 log block tail 中部分字节数</strong>。</p>
<p>比如说在上图中，事务 3 的 MTR 总量为 300 字节，那么写入到 Redo Log Buffer 中的 LSN 会增长为 8704 + 300 + 12 &#x3D; 9016。</p>
<p>假如事务 4 的 MTR 总量为 900 字节，那么再次写入到 Redo Log Buffer 中的 LSN 会增长为 9016 + 900 + 12<em>2 + 4</em>2 &#x3D; 9948。</p>
<p>2 个 12 字节的 log block header + 2 个 4 字节的 log block tail。</p>
<p>—-这部分是帮助理解 end，面试中可不背—-</p>
<p><strong>核心作用有三个：</strong></p>
<p>第一，<code>redo log</code> 按照 LSN 递增顺序记录所有数据的修改操作。LSN 的递增量等于每次写入日志的字节数。</p>
<p>第二，InnoDB 的每个数据页头部中，都会记录该页最后一次刷新到磁盘时的 LSN。如果数据页的 LSN 小于 redo log 的 LSN，说明该页需要从日志中恢复；否则说明该页已更新。</p>
<p>第三，checkpoint 通过 LSN 记录已刷新到磁盘的数据页位置，减少恢复时需要处理的日志。</p>
<p>—-这部分是帮助理解 start，面试中可不背—-<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616162021.png" alt="20250616162021"></p>
<p>可以通过 <code>show engine innodb status;</code> 查看当前的 LSN 信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616162445.png" alt="20250616162445"></p>
<ul>
<li>Log sequence number：当前系统最大 LSN（已生成的日志总量）。</li>
<li>Log flushed up to：已写入磁盘的 redo log LSN。</li>
<li>Pages flushed up to：已刷新到数据页的 LSN。</li>
<li>Last checkpoint at：最后一次检查点的 LSN，表示已持久化的数据状态。</li>
</ul>
<p>—-这部分是帮助理解 end，面试中可不背—-</p>
<h4 id="Checkpoint-了解多少？"><a href="#Checkpoint-了解多少？" class="headerlink" title="Checkpoint 了解多少？"></a>Checkpoint 了解多少？</h4><p><code>Checkpoint </code>是 InnoDB 为了保证事务持久性和回收 redo log 空间的一种机制。</p>
<p>它的作用是在合适的时机将部分脏页刷入磁盘，比如说 buffer pool 的容量不足时。并记录当前 <code>LSN</code> 为 <code>Checkpoint LSN</code>，表示这个位置之前的 redo log file 已经安全，可以被覆盖了。</p>
<p>MySQL 崩溃恢复时只需要从 Checkpoint 之后开始恢复 redo log 就可以了，这样可以最大程度减少恢复所花费的时间。</p>
<p>redo log file 的写入是循环的，其中有两个标记位置非常重要，也就是 Checkpoint 和 write pos。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616162937.png" alt="20250616162937"></p>
<p>write pos 是 redo log 当前写入的位置，Checkpoint 是可以被覆盖的位置。</p>
<p>当 write pos 追上 Checkpoint 时，表示 redo log 日志已经写满。这时候就要暂停写入并强制刷盘，释放可覆写的日志空间。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616163140.png" alt="20250616163140"></p>
<h4 id="关于redo-log-的调优参数了解多少？"><a href="#关于redo-log-的调优参数了解多少？" class="headerlink" title="关于redo log 的调优参数了解多少？"></a>关于redo log 的调优参数了解多少？</h4><p>如果是<code>高并发写入</code>的电商系统，可以最大化写入吞吐量，容忍秒级数据丢失的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit = <span class="number">2</span></span><br><span class="line">sync_binlog = <span class="number">1000</span></span><br><span class="line">innodb_redo_log_capacity = 64<span class="type">G</span></span><br><span class="line"><span class="variable">innodb_io_capacity</span> <span class="operator">=</span> <span class="number">5000</span></span><br><span class="line">innodb_lru_scan_depth = <span class="number">512</span></span><br><span class="line">innodb_log_buffer_size = 256M</span><br></pre></td></tr></table></figure>
<p>如果是金融交易系统，需要<code>保证数据零丢失</code>，接受较低的吞吐量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit = <span class="number">1</span></span><br><span class="line">sync_binlog = <span class="number">1</span></span><br><span class="line">innodb_redo_log_capacity = 32<span class="type">G</span></span><br><span class="line"><span class="variable">innodb_io_capacity</span> <span class="operator">=</span> <span class="number">2000</span></span><br><span class="line">innodb_lru_scan_depth = <span class="number">1024</span></span><br></pre></td></tr></table></figure>
<p>核心参数一览表:<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616163309.png" alt="20250616163309"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>对数据一致性要求高的场景，如金融交易使用innodb_flush_log_at_trx_commit&#x3D;1，对写入吞吐量敏感的场景，如日志采集可以使用 &#x3D;2 或 &#x3D;0，需要结合 sync_binlog 参数</li>
<li>sync_binlog 参数控制 binlog 的刷盘策略，可以设置为 0、1、N，0 表示依赖系统刷盘，1 表示每次事务提交都刷盘（推荐与 innodb_flush_log_at_trx_commit&#x3D;1 搭配），N&#x3D;1000 表示累计 1000 次事务后刷盘</li>
<li>innodb_redo_log_capacity 动态调整 Redo Log 总容量，可以根据业务负载情况调整，建议设置为 1 小时写入量的峰值（如每秒 10MB 写入则设为 36GB）</li>
<li>innodb_io_capacity 定义 InnoDB 后台线程的每秒 I&#x2F;O 操作上限，直接影响脏页刷新速率；机械硬盘建议 200-500，SSD 建议 1000-2000，NVMe SSD 可设为 5000+</li>
<li>innodb_lru_scan_depth 控制每个缓冲池实例中 LRU 列表的扫描深度，决定每秒可刷新的脏页数量，默认值 1024 适用于多数场景，I&#x2F;O 密集型负载可适当降低（如 512），减少 CPU 开销。</li>
</ul>
<h3 id="🌟32-什么是慢-SQL？"><a href="#🌟32-什么是慢-SQL？" class="headerlink" title="🌟32.什么是慢 SQL？"></a>🌟32.什么是慢 SQL？</h3><p>拓展阅读: <a target="_blank" rel="noopener" href="https://juejin.cn/post/7048974570228809741">https://juejin.cn/post/7048974570228809741</a><br>MySQL 中有一个叫<code>long_query_time</code>的参数，原则上执行时间超过该参数值的 SQL 就是慢 SQL，会被记录到<strong>慢查询日志</strong>中。</p>
<p>—-这部分是帮助理解 start，面试中可不背—-</p>
<p>可通过 show variables like ‘long_query_time’; 查看当前的 long_query_time 的参数值。<br>—-这部分是帮助理解 end，面试中可不背—-</p>
<h4 id="SQL-的执行过程了解吗？"><a href="#SQL-的执行过程了解吗？" class="headerlink" title="SQL 的执行过程了解吗？"></a>SQL 的执行过程了解吗？</h4><p>SQL 的执行过程大致可以分为六个阶段：<strong>连接管理</strong>、<strong>语法解析</strong>、<strong>语义分析</strong>、<strong>查询优化</strong>、<strong>执行器调度</strong>、<strong>存储引擎读写</strong>等。Server 层负责理解和规划 SQL 怎么执行，存储引擎层负责数据的真正读写。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250617154612.png" alt="20250617154612"></p>
<p>—-这部分是帮助理解 start，面试中可不背—-</p>
<p>来详细拆解一下：</p>
<ol>
<li>客户端发送 SQL 语句给 MySQL 服务器。</li>
<li>如果查询缓存打开则会优先查询缓存，缓存中有对应的结果就直接返回。不过，MySQL 8.0 已经移除了查询缓存。这部分的功能正在被 Redis 等缓存中间件取代。</li>
<li>分析器对 SQL 语句进行语法分析，判断是否有语法错误。</li>
<li>搞清楚 SQL 语句要干嘛后，MySQL 会通过优化器生成执行计划。</li>
<li>执行器调用存储引擎的接口，执行 SQL 语句。</li>
</ol>
<p>SQL 执行过程中，优化器通过成本计算预估出执行效率最高的方式，基本的预估维度为：</p>
<ul>
<li>IO 成本：从磁盘读取数据到内存的开销。</li>
<li>CPU 成本：CPU 处理内存中数据的开销。</li>
</ul>
<p>基于这两个维度，可以得出影响 SQL 执行效率的因素有：</p>
<p>①、<strong>IO 成本，数据量越大，IO 成本越高</strong>。所以要尽量查询必要的字段；尽量分页查询；尽量通过索引加快查询。</p>
<p>②、<strong>CPU 成本</strong>，尽量避免复杂的查询条件，如有必要，考虑对子查询结果进行过滤。</p>
<p>—-这部分是帮助理解 end，面试中可不背—-</p>
<h4 id="如何优化慢SQL"><a href="#如何优化慢SQL" class="headerlink" title="如何优化慢SQL?"></a>如何优化慢SQL?</h4><p>首先，需要找到那些比较慢的 SQL，可以通过启用慢查询日志，记录那些超过指定执行时间的 SQL 查询。</p>
<p>也可以使用 <code>show processlist;</code> 命令查看当前正在执行的 SQL 语句，找出执行时间较长的 SQL。</p>
<p>或者在业务基建中加入对慢 SQL 的监控，常见的方案有字节码插桩、连接池扩展、ORM 框架扩展等。</p>
<p>然后，使用 EXPLAIN 查看慢 SQL 的执行计划，看看有没有用索引，大部分情况下，慢 SQL 的原因都是因为没有用到索引。</p>
<p><code>EXPLAIN SELECT * FROM your_table WHERE conditions;</code><br>最后，根据分析结果，通过<strong>添加索引</strong>、<strong>优化查询条件</strong>、<strong>减少返回字段</strong>等方式进行优化。</p>
<h4 id="慢sql日志怎么开启？"><a href="#慢sql日志怎么开启？" class="headerlink" title="慢sql日志怎么开启？"></a>慢sql日志怎么开启？</h4><p>编辑 MySQL 的配置文件 <code>my.cnf</code>，设置 <code>slow_query_log</code> 参数为 1。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">slow_query_log_file <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>slow.log</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">2</span>  # 记录执行时间超过<span class="number">2</span>秒的查询</span><br></pre></td></tr></table></figure>
<p>然后重启 MySQL 就好了。</p>
<p>也可以通过 set global 命令动态设置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log_file <span class="operator">=</span> <span class="string">&#x27;/var/log/mysql/slow.log&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="🌟33-你知道哪些方法来优化-SQL？"><a href="#🌟33-你知道哪些方法来优化-SQL？" class="headerlink" title="🌟33.你知道哪些方法来优化 SQL？"></a>🌟33.你知道哪些方法来优化 SQL？</h3><p>SQL 优化的方法非常多，但本质上就一句话：<strong>尽可能少地扫描、尽快地返回结果。</strong><br>最常见的做法就是<strong>加索引</strong>、改写 SQL 让它用上索引，比如说使用覆盖索引、让联合索引遵守最左前缀原则等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618110546.png" alt="20250618110546"></p>
<h4 id="如何利用覆盖索引？"><a href="#如何利用覆盖索引？" class="headerlink" title="如何利用覆盖索引？"></a>如何利用覆盖索引？</h4><p>覆盖索引的核心是“<strong>查询所需的字段都在同一个索引里</strong>”，这样 MySQL 就不需要回表，直接从索引中返回结果。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618110821.png" alt="20250618110821"></p>
<p>实际使用中，我会优先考虑把 <code>WHERE</code> 和 <code>SELECT</code> 涉及的字段一起建联合索引，并通过 <code>EXPLAIN</code> 观察结果是否有 <code>Using index</code>，确认命中索引。</p>
<p>—-这部分是帮助理解 start，面试中可不背—-</p>
<p>举个例子，现在要从 <code>test</code> 表中查询 <code>city</code> 为上海的 name 字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> test <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;上海&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果仅在 city 字段上添加索引，那么这条查询语句会先通过索引找到 city 为上海的行，然后再回表查询 name 字段。</p>
<p>为了避免回表查询，可以在 city 和 name 字段上建立联合索引，这样查询结果就可以直接从索引中获取。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> test <span class="keyword">add</span> index index1(city,name);</span><br></pre></td></tr></table></figure>
<p>相当于利用空间换时间,把查询结果都放到了索引里,不需要回表查询。<br>—-这部分是帮助理解 end，面试中可不背—-</p>
<h4 id="如何正确使用联合索引？"><a href="#如何正确使用联合索引？" class="headerlink" title="如何正确使用联合索引？"></a>如何正确使用联合索引？</h4><p>使用联合索引最重要的一条是<strong>遵守最左前缀原则，也就是查询条件需要从索引的左侧字段开始</strong>。</p>
<p>—-这部分是帮助理解 start，面试中可不背—-<br>比如说我们创建了一个三列的联合索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_age_sex <span class="keyword">ON</span> <span class="keyword">user</span>(name, age, sex);</span><br></pre></td></tr></table></figure>
<p>我们来看一下什么样的查询条件可以用到这个索引：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618111513.png" alt="20250618111513"><br>—-这部分是帮助理解 end，面试中可不背—-</p>
<h4 id="如何进行分页优化？"><a href="#如何进行分页优化？" class="headerlink" title="如何进行分页优化？"></a>如何进行分页优化？</h4><p>分页优化的核心是<strong>避免深度偏移(Deep Offset)带来的全表扫描</strong>，可以通过两种方式来优化：<strong>延迟关联和添加书签</strong>。</p>
<p><strong>延迟关联</strong>适用于需要<strong>从多个表中获取数据且主表行数较多的情况</strong>。<br>它首先从索引表中检索出需要的行 ID，然后再根据这些 ID 去关联其他的表获取详细信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.id, e.name, d.details</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> department d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e.id</span><br><span class="line">LIMIT <span class="number">1000</span>, <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>延迟关联后，第一步只查主键，速度快，第二步只处理 20 条数据，效率高。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.id, e.name, d.details</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">    LIMIT <span class="number">1000</span>, <span class="number">20</span></span><br><span class="line">) <span class="keyword">AS</span> sub</span><br><span class="line"><span class="keyword">JOIN</span> employees e <span class="keyword">ON</span> sub.id <span class="operator">=</span> e.id</span><br><span class="line"><span class="keyword">JOIN</span> department d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure>

<p><strong>添加书签</strong>的方式是通过<strong>记住上一次查询返回的最后一行主键值</strong>，然后在下一次查询的时候从这个值开始，从而跳过偏移量计算，仅扫描目标数据，<strong>适合翻页、资讯流</strong>等场景。</p>
<p>假设需要对用户表进行分页。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">LIMIT <span class="number">1000</span>, <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>通过添加书签来优化后，查询不再使用OFFSET，而是从上一页最后一个用户的 ID 开始查询。这种方法可以有效避免不必要的数据扫描，提高了分页查询的效率。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> last_max_id  <span class="comment">-- 假设last_max_id是上一页最后一行的ID</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<h4 id="为什么分页会变慢？"><a href="#为什么分页会变慢？" class="headerlink" title="为什么分页会变慢？"></a>为什么分页会变慢？</h4><p>分页查询的效率问题主要是由于 <code>OFFSET</code> 的存在，<code>OFFSET</code> 会导致 MySQL <strong>必须扫描和跳过 offset + limit 条数据</strong>，这个过程是非常耗时的。</p>
<p>比如说，我们要查询第 100000 条数据，那么 MySQL 就必须扫描 100000 条数据，然后再返回 10 条数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">100000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>数据越多、偏移越大，就越慢！</p>
<h4 id="JOIN-代替子查询有什么好处？"><a href="#JOIN-代替子查询有什么好处？" class="headerlink" title="JOIN 代替子查询有什么好处？"></a>JOIN 代替子查询有什么好处？</h4><p>第一，JOIN 的 ON 条件能<strong>更直接地触发索引</strong>，而<strong>子查询可能因嵌套导致索引失效</strong>。<br>第二，JOIN 的<strong>一次连接操作替代了子查询的多次重复执行</strong>，尤其在大数据量的情况下性能差异明显。</p>
<p>—-这部分是帮助理解 start，面试中可不背—-</p>
<p>比如说我们有两个表 orders 和 customers。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    INDEX idx_customer_id (customer_id)  <span class="comment">-- customer_id字段有索引</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE TABLE</span> customers (</span><br><span class="line">    customer_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>子查询的写法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.order_id, o.amount, </span><br><span class="line">       (<span class="keyword">SELECT</span> c.name </span><br><span class="line">        <span class="keyword">FROM</span> customers c </span><br><span class="line">        <span class="keyword">WHERE</span> c.customer_id <span class="operator">=</span> o.customer_id) <span class="keyword">AS</span> customer_name</span><br><span class="line"><span class="keyword">FROM</span> orders o;</span><br></pre></td></tr></table></figure>
<p>JOIN 的写法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.order_id, o.amount, c.name <span class="keyword">AS</span> customer_name</span><br><span class="line"><span class="keyword">FROM</span> orders o</span><br><span class="line"><span class="keyword">JOIN</span> customers c <span class="keyword">ON</span> o.customer_id <span class="operator">=</span> c.customer_id;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618140806.png" alt="20250618140806"></p>
<p><strong>对于子查询，执行流程是这样的：</strong></p>
<ul>
<li>外层 orders 表的每一行都会触发一次子查询。</li>
<li>如果 orders 表有 1000 条记录，则子查询会执行 1000 次。</li>
<li>每次子查询都需要单独查询 customers 表（即使 customer_id 相同）。</li>
</ul>
<p><strong>而 JOIN 的执行流程是这样的：</strong></p>
<ul>
<li>数据库优化器会将两张表的连接操作合并为一次执行。</li>
<li>通过索引（如 orders.customer_id 和 customers.customer_id）快速关联数据。</li>
<li>仅执行一次关联操作，而非多次子查询。<br>来看一下子查询的执行计划：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> o.order_id, </span><br><span class="line">               (<span class="keyword">SELECT</span> c.name <span class="keyword">FROM</span> customers c <span class="keyword">WHERE</span> c.customer_id <span class="operator">=</span> o.customer_id) </span><br><span class="line">        <span class="keyword">FROM</span> orders o;</span><br></pre></td></tr></table></figure>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618142719.png" alt="20250618142719"><br>子查询（DEPENDENT SUBQUERY）类型表明其依赖外层查询的每一行，导致重复执行。</li>
</ul>
<p>再对比看一下 JOIN 的执行计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> o.order_id, </span><br><span class="line">               (<span class="keyword">SELECT</span> c.name <span class="keyword">FROM</span> customers c <span class="keyword">WHERE</span> c.customer_id <span class="operator">=</span> o.customer_id) </span><br><span class="line">        <span class="keyword">FROM</span> orders o;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618142740.png" alt="20250618142740"><br>JOIN 通过 <code>eq_ref</code> 类型直接利用主键（customers.customer_id）快速关联，减少扫描次数。</p>
<h4 id="JOIN操作为什么要小表驱动大表？"><a href="#JOIN操作为什么要小表驱动大表？" class="headerlink" title="JOIN操作为什么要小表驱动大表？"></a>JOIN操作为什么要小表驱动大表？</h4><ul>
<li><p>第一，如果大表的 JOIN 字段有索引，那么小表的每一行都可以通过索引快速匹配大表。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618143231.png" alt="20250618143231"><br>时间复杂度为**小表行数 N 乘以大表索引查找复杂度 log(大表行数 M)**，总复杂度为 <code>N*log(M)</code>。<br>显然小表做驱动表比大表做驱动表的时间复杂度 <code>M*log(N)</code> 更低。</p>
</li>
<li><p>第二，如果大表没有索引，需要将小表的数据加载到内存，再全表扫描大表进行匹配。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618143445.png" alt="20250618143445"><br>时间复杂度为小表分段数 K 乘以大表行数 M，其中 K &#x3D; 小表行数 N &#x2F; 内存大小 join_buffer_size。<br>显然小表做驱动表的时候 K 的值更小，大表做驱动表的时候需要多次分段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 小表驱动（高效）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> small_table s</span><br><span class="line"><span class="keyword">JOIN</span> large_table l <span class="keyword">ON</span> s.id <span class="operator">=</span> l.id;  <span class="comment">-- l.id有索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 大表驱动（低效）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table l</span><br><span class="line"><span class="keyword">JOIN</span> small_table s <span class="keyword">ON</span> l.id <span class="operator">=</span> s.id;  <span class="comment">-- s.id无索引</span></span><br></pre></td></tr></table></figure></li>
<li><p>当使用 left join 时，左表是驱动表，右表是被驱动表。</p>
</li>
<li><p>当使用 right join 时，刚好相反。</p>
</li>
<li><p>当使用 join 时，MySQL 会选择数据量比较小的表作为驱动表，大表作为被驱动表。</p>
</li>
</ul>
<p>这里的小表指实际参与 JOIN 的数据量，而不是表的总行数。大表经过 where 条件过滤后也可能成为逻辑小表。<br>– <strong>实际参与JOIN的数据量决定小表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table l</span><br><span class="line"><span class="keyword">JOIN</span> small_table s <span class="keyword">ON</span> l.id <span class="operator">=</span> s.id</span><br><span class="line"><span class="keyword">WHERE</span> l.created_at <span class="operator">&gt;</span> <span class="string">&#x27;2025-01-01&#x27;</span>;  <span class="comment">-- l经过过滤后可能成为小表</span></span><br></pre></td></tr></table></figure>
<p>也可以强制通过 <code>STRAIGHT_JOIN</code> 提示 MySQL 使用指定的驱动表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> table_1.col1, table_2.col2, table_3.col2</span><br><span class="line"><span class="keyword">from</span> table_1</span><br><span class="line">straight_join table_2 <span class="keyword">on</span> table_1.col1<span class="operator">=</span>table_2.col1</span><br><span class="line">straight_join table_3 <span class="keyword">on</span> table_1.col1 <span class="operator">=</span> table_3.col1;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> straight_join table_1.col1, table_2.col2, table_3.col2</span><br><span class="line"><span class="keyword">from</span> table_1</span><br><span class="line"><span class="keyword">join</span> table_2 <span class="keyword">on</span> table_1.col1<span class="operator">=</span>table_2.col1</span><br><span class="line"><span class="keyword">join</span> table_3 <span class="keyword">on</span> table_1.col1 <span class="operator">=</span> table_3.col1;</span><br></pre></td></tr></table></figure>

<h4 id="为什么要避免使用-JOIN-关联太多的表？"><a href="#为什么要避免使用-JOIN-关联太多的表？" class="headerlink" title="为什么要避免使用 JOIN 关联太多的表？"></a>为什么要避免使用 JOIN 关联太多的表？</h4><p>第一，多表 JOIN 的执行路径会随着表的数量<strong>呈现指数级增长</strong>，优化器需要估算所有路径的成本，有可能会导致出现大表驱动小表的情况。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.a_id</span><br><span class="line"><span class="keyword">JOIN</span> C <span class="keyword">ON</span> B.id <span class="operator">=</span> C.b_id</span><br><span class="line"><span class="keyword">JOIN</span> D <span class="keyword">ON</span> C.id <span class="operator">=</span> D.c_id</span><br><span class="line"><span class="keyword">JOIN</span> E <span class="keyword">ON</span> D.id <span class="operator">=</span> E.d_id;  <span class="comment">-- 5 个表，优化器需评估 5! = 120 种顺序</span></span><br></pre></td></tr></table></figure>
<p>第二，多表 JOIN 需要缓存中间结果集，可能超出 join_buffer_size，这种情况下内存临时表就会转为磁盘临时表，性能也会急剧下降。<br>《阿里巴巴 Java 开发手册》上就规定，不要使用 join 关联太多的表，<strong>最多不要超过 3 张表</strong>。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618151308.png" alt="20250618151308"></p>
<h4 id="如何进行排序优化？"><a href="#如何进行排序优化？" class="headerlink" title="如何进行排序优化？"></a>如何进行排序优化？</h4><p>第⼀，<strong>对 ORDER BY 涉及的字段创建索引</strong>，避免 filesort。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优化前（可能触发 filesort）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;</span><br><span class="line"><span class="comment">-- 优化后（添加索引）</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">ADD</span> INDEX idx_age (age);</span><br></pre></td></tr></table></figure>
<p>如果是多个字段，联合索引需要保证<strong>ORDER BY 的列是索引的最左前缀</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 联合索引需与 ORDER BY 顺序⼀致（age 在前，name 在后）</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">ADD</span> INDEX idx_age_name (age, name);</span><br><span class="line"><span class="comment">-- 有效利⽤索引的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, name;</span><br><span class="line"><span class="comment">-- ⽆效案例（索引失效，因 name 在索引中排在 age 之后）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, age;</span><br></pre></td></tr></table></figure>
<p>第⼆，可以适当调整排序参数，如增⼤ <code>sort_buffer_size</code>、<code>max_length_for_sort_data </code>等，让排序在内存中完成。<br>—-这部分是帮助理解 start，⾯试中可不背—-</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618152056.png" alt="20250618152056"></p>
<ul>
<li><code>sort_buffer_size</code>：用于控制排序缓冲区的大小，默认为 256KB。也就是说，如果排序的数据量小于 256KB，MySQL 会在内存中直接排序；否则就要在磁盘上进行 filesort。</li>
<li><code>max_length_for_sort_data</code>：单行数据的最大长度，会影响排序算法选择。如果单行数据超过该值，MySQL 会使用双路排序，否则使用单路排序。</li>
<li><code>max_sort_length</code>：限制字符串排序时比较的前缀长度。当 MySQL 不得不对 text、blob 字段进行排序时，会截取前 <code>max_sort_length</code> 个字符进行比较。<br>—-这部分是帮助理解 end，面试中可不背—-<br>第三，可以通过 where 和 limit 限制待排序的数据量，减少排序的开销。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 优化前</span><br><span class="line">SELECT * FROM users ORDER BY age LIMIT <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">-- 优化后（减少数据传输和排序开销）</span><br><span class="line">SELECT id, name, age FROM users ORDER BY age LIMIT <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">-- 深度分页优化（避免 OFFSET 扫描全表）</span><br><span class="line">SELECT * FROM users ORDER BY age LIMIT <span class="number">10000</span>, <span class="number">20</span>;  -- 低效</span><br><span class="line">SELECT * FROM users WHERE age &gt; last_age ORDER BY age LIMIT <span class="number">20</span>;  -- 高效（记录上一页最后一条的 age 值）</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="什么是-filesort？"><a href="#什么是-filesort？" class="headerlink" title="什么是 filesort？"></a>什么是 filesort？</h4><p><a target="_blank" rel="noopener" href="https://petrunia.net/2007/08/29/how-mysql-executes-order-by/">Mysql如何执行ORDER BY</a></p>
<p>当<strong>不能使用索引</strong>生成排序结果的时候，MySQL 需要自己进行排序，<strong>如果数据量比较小，会在内存中进行</strong>；如果数据量比较大就需要写临时文件到磁盘再排序，我们将这个过程称为<strong>文件排序</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095220.png" alt="20250619095220"></p>
<p>—-这部分是帮助理解 start，面试中可不背—-<br>让我们来验证一下 filesort 的情况<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095335.png" alt="20250619095335"></p>
<p>能够看得出来，当 order by id 也就是主键的时候，没有触发 filesort；当 order by age 的时候，由于没有索引，就触发了 filesort。<br>—-这部分是帮助理解 end，面试中可不背—-</p>
<h4 id="全字段排序和-rowid-排序了解多少？"><a href="#全字段排序和-rowid-排序了解多少？" class="headerlink" title="全字段排序和 rowid 排序了解多少？"></a>全字段排序和 rowid 排序了解多少？</h4><p>当排序字段<strong>是索引字段且满足最左前缀原则时</strong>，MySQL 可以<strong>直接利用索引的有序性完成排序</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095617.png" alt="20250619095617"></p>
<p>当无法使用索引排序时，MySQL <strong>需要在内存或磁盘中进行排序操作</strong>，分为<strong>全字段排序</strong>和 <strong>rowid 排序</strong>两种算法。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095723.png" alt="全字段排序"><br>全字段排序会<strong>一次性取出满足条件行的所有字段</strong>，然后在 sort buffer 中进行排序，排序后直接返回结果，无需回表。</p>
<p>以 <code>SELECT * FROM user WHERE name = &quot;王二&quot; ORDER BY age</code> 为例：</p>
<p>从 name 索引中找到第一个满足 name&#x3D;’张三’ 的主键 id；<br>根据主键 id 取出整行所有的字段，存入 sort buffer；<br>重复上述过程直到处理完所有满足条件的行<br>对 sort buffer 中的数据按 age 排序，返回结果。</p>
<ul>
<li>优点是<strong>仅需要一次磁盘 IO</strong></li>
<li>缺点是<strong>内存占用大</strong>，如果数量超过 sort buffer 的话，需要分片读取并借助临时文件合并排序，IO 次数反而会增加。<br>也无法处理包含 text 和 blob 类型的字段。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619100616.png" alt="rowid 排序"></p>
<p>rowid 排序分为两个阶段：</p>
<ul>
<li>第一阶段：根据查询条件取出<strong>排序字段和主键 ID</strong>，存入<code>sort buffer</code>进行排序；</li>
<li>第二阶段：根据排序后的主键 ID 回表<strong>取出其他需要的字段</strong>。</li>
</ul>
<p>同样以 <code>SELECT * FROM user WHERE name = &quot;王二&quot; ORDER BY age </code>为例：</p>
<ul>
<li>从 name 索引中找到第一个满足 name&#x3D;’张三’ 的主键 id；</li>
<li>根据主键 id 取出排序字段 age，连同主键 id 一起存入 sort buffer；</li>
<li>重复上述过程直到处理完所有满足条件的行</li>
<li>对 sort buffer 中的数据按 age 排序；</li>
<li>遍历排序后的主键 id，回表取出其他所需字段，返回结果。</li>
</ul>
<p>优点是<strong>内存占用较少，适合字段多或者数据量大的场景</strong>，缺点是<strong>需要两次磁盘 IO</strong>。</p>
<p>MySQL 会根据系统变量 <code>max_length_for_sort_data</code> 和<strong>查询字段的总大小</strong>来决定使用全字段排序还是 rowid 排序。</p>
<p>如果<strong>查询字段总长度 &lt;&#x3D; max_length_for_sort_data</strong>，MySQL 会使用全字段排序；否则会使用 rowid 排序。</p>
<h4 id="你对-Sort-merge-passes-参数了解吗？"><a href="#你对-Sort-merge-passes-参数了解吗？" class="headerlink" title="你对 Sort_merge_passes 参数了解吗？"></a>你对 Sort_merge_passes 参数了解吗？</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YBWbEahWp0uVN_n9jAFU0A">深入了解 MySQL Order By 文件排序</a><br><code>Sort_merge_passes</code> 是一个状态变量，用于<strong>统计 MySQL 在执行排序操作时进行归并排序的次数</strong>。<br>当 MySQL 需要进行排序但排序数据无法完全放入 <code>sort_buffer_size</code> 定义的内存缓冲区时，就会使用临时文件进行外部排序，这时就会产生 Sort_merge_passes。</p>
<p>如果 <code>Sort_merge_passes</code> 在短时间内快速激增，说明排序操作的数据量较大，<strong>需要调整 sort_buffer_size 或者优化查询语句</strong>。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619101635.png" alt="20250619101635"></p>
<p><strong>MySQL 在执行排序操作时，会经历两个过程：</strong></p>
<ul>
<li><strong>内存排序阶段</strong>，MySQL 首先尝试在 <code>sort buffer</code> 中进行排序。如果数据量小于 <code>sort_buffer_size</code> 缓冲区大小，会完全在内存中完成快速排序。</li>
<li><strong>外部排序阶段</strong>，如果数据量超过 <code>sort_buffer_size</code>，MySQL 会将数据分成多个块，每块单独排序后写入临时文件，然后对这些已排序的块进行<strong>归并排序</strong>。每次归并操作都会增加 Sort_merge_passes 的计数。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619101736.png" alt="20250619101736"></p>
<h4 id="条件下推你了解多少？"><a href="#条件下推你了解多少？" class="headerlink" title="条件下推你了解多少？"></a>条件下推你了解多少？</h4><p>条件下推的核心思想是<strong>将外层的过滤条件</strong>，比如说 where、join 等，<strong>尽可能地下推到查询计划的更底层</strong>，<strong>比如说子查询、连接操作之前，从而减少中间结果的数据量</strong>。</p>
<p>比如说原始查询是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> total <span class="operator">&gt;</span> <span class="number">100</span></span><br><span class="line">) <span class="keyword">AS</span> subquery</span><br><span class="line"><span class="keyword">WHERE</span> subquery.status <span class="operator">=</span> <span class="string">&#x27;shipped&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>就可以将条件下推到子查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> total <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="string">&#x27;shipped&#x27;</span></span><br><span class="line">) <span class="keyword">AS</span> subquery;</span><br></pre></td></tr></table></figure>
<p>这样就可以减少查询返回的数据量，避免外层再过滤。</p>
<p>再比如说 union 中的原始查询是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1) </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>就可以将条件下推到每个子查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> col LIMIT <span class="number">10</span>)</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> col LIMIT <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>每个子查询仅返回前 10 条数据，减少临时表的数据量。</p>
<p>再比如说连接查询 join 中的原始查询是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">JOIN</span> customers <span class="keyword">ON</span> orders.customer_id <span class="operator">=</span> customers.id</span><br><span class="line"><span class="keyword">WHERE</span> customers.country <span class="operator">=</span> <span class="string">&#x27;china&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>就可以将条件下推到表扫描的时候：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> country <span class="operator">=</span> <span class="string">&#x27;china&#x27;</span></span><br><span class="line">) <span class="keyword">AS</span> filtered_customers</span><br><span class="line"><span class="keyword">ON</span> orders.customer_id <span class="operator">=</span> filtered_customers.id;</span><br></pre></td></tr></table></figure>
<p>先过滤 customers 表，减少 join 时的数据量。</p>
<h4 id="为什么要尽量避免使用-select-？"><a href="#为什么要尽量避免使用-select-？" class="headerlink" title="为什么要尽量避免使用 select *？"></a>为什么要尽量避免使用 select *？</h4><p><code>SELECT * </code>会强制 MySQL <strong>读取表中所有字段的数据</strong>，包括应用程序可能并不需要的，比如 text、blob 类型的<strong>大字段</strong>。<br><strong>加载冗余数据会占用更多的缓存空间</strong>，从而挤占其他重要数据的缓存资源，<strong>降低整体系统的吞吐量</strong>。<br>也会<strong>增加网络传输的开销</strong>，尤其是在大字段的情况下。<br>最重要的是，<code>SELECT * </code><strong>可能会导致覆盖索引失效</strong>，本来可以走索引的查询最后变成了全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用覆盖索引（假设索引为 idx_country）</span></span><br><span class="line"><span class="keyword">SELECT</span> id, country <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> country <span class="operator">=</span> <span class="string">&#x27;china&#x27;</span>;  <span class="comment">-- 可能仅扫描索引</span></span><br><span class="line"><span class="comment">-- 使用 SELECT *</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> country <span class="operator">=</span> <span class="string">&#x27;china&#x27;</span>;            <span class="comment">-- 需回表读取所有列</span></span><br></pre></td></tr></table></figure>

<h4 id="你还知道哪些-SQL-优化方法？"><a href="#你还知道哪些-SQL-优化方法？" class="headerlink" title="你还知道哪些 SQL 优化方法？"></a>你还知道哪些 SQL 优化方法？</h4><p>①、避免使用 <code>!=</code> 或者 <code>&lt;&gt;</code> 操作符</p>
<p>!&#x3D; 或者 &lt;&gt; 操作符<strong>会导致 MySQL 无法使用索引</strong>，从而<strong>导致全表扫描</strong>。</p>
<p>可以把column&lt;&gt;’aaa’，改成column&gt;’aaa’ or column&lt;’aaa’。</p>
<p>②、使用前缀索引</p>
<p>比如，邮箱的后缀一般都是固定的@xxx.com，那么类似这种<strong>后面几位为固定值的字段就非常适合定义为前缀索引</strong>：<br><code>alter table test add index index2(email(6));</code><br>需要注意的是，MySQL 无法利用前缀索引做 <code>order by</code> 和 <code>group by </code>操作。</p>
<p>③、避免在列上使用函数</p>
<p>在 where 子句中<strong>直接对列使用函数会导致索引失效</strong>，因为 MySQL 需要对每行的列应用函数后再进行比较。<br><code>select name from test where date_format(create_time,&#39;%Y-%m-%d&#39;)=&#39;2021-01-01&#39;;</code><br>可以改成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> test <span class="keyword">where</span> create_time<span class="operator">&gt;=</span><span class="string">&#x27;2021-01-01 00:00:00&#x27;</span> <span class="keyword">and</span> create_time<span class="operator">&lt;</span><span class="string">&#x27;2021-01-02 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>通过日期的范围查询，而不是在列上使用函数，可以利用 create_time 上的索引。</p>
<h3 id="34-🌟explain平常有用过吗？"><a href="#34-🌟explain平常有用过吗？" class="headerlink" title="34.🌟explain平常有用过吗？"></a>34.🌟explain平常有用过吗？</h3><p>经常用，explain 是 MySQL 提供的一个用于<strong>查看 SQL 执行计划的工具</strong>，可以帮助我们<strong>分析查询语句的性能问题</strong>。</p>
<p>一共有 10 来个输出参数。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619105445.png" alt="20250619105445"></p>
<p>比如说 type&#x3D;ALL,key&#x3D;NULL 表示 SQL 正在全表扫描，可以考虑为 where 字段添加索引进行优化；<br>Extra&#x3D;Using filesort 表示 SQL 正在文件排序，可以考虑为 order by 字段添加索引。</p>
<p>使用方式也非常简单，直接在 select 前加上 explain 关键字就可以了。</p>
<p><code>explain select * from students where name=&#39;王二&#39;;</code><br>更高级的用法可以配合 format&#x3D;json 参数，将 explain 的输出结果以 JSON 格式返回。<br><code>explain format=json select * from students where name=&#39;王二&#39;;</code></p>
<h4 id="explain-输出结果中常见的字段含义理解吗？"><a href="#explain-输出结果中常见的字段含义理解吗？" class="headerlink" title="explain 输出结果中常见的字段含义理解吗？"></a>explain 输出结果中常见的字段含义理解吗？</h4><p>在 EXPLAIN 输出结果中我最关注的字段是 <code>type</code>、<code>key</code>、<code>rows</code> 和 <code>Extra</code>。</p>
<p>我会通过它们判断 SQL <strong>有没有走索引</strong>、<strong>是否全表扫描</strong>、<strong>预估扫描行数是否太大</strong>，以及是否触发了 <strong>filesort 或临时表</strong>。<br>一旦发现问题，比如 type&#x3D;ALL 或者 Extra&#x3D;Using filesort，我会考虑建索引、改写 SQL 或控制查询结果集来做优化。</p>
<p>—-这部分是帮助理解 start，面试中可不背—-<br>以 <code>EXPLAIN SELECT * FROM orders WHERE user_id = 100 </code>的输出为例：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619105921.png" alt="20250619105921"></p>
<p>非表格版本：<br>①、id 列：查询的执行顺序编号。id 相同：同一执行层级，按 table 列从上到下顺序执行（如多表 JOIN）；id 递增：嵌套子查询，数值越大优先级越高，越先执行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>) <span class="keyword">AS</span> sub;</span><br></pre></td></tr></table></figure>
<p>t2 子查询的 id&#x3D;2，优先执行。</p>
<p>②、select_type 列：查询的类型。常见的类型有：</p>
<ul>
<li>SIMPLE：简单查询，不包含子查询或者 UNION。</li>
<li>PRIMARY：查询中如果包含子查询，则最外层查询被标记为 PRIMARY。需要关注子查询或派生表性能。</li>
<li>SUBQUERY：子查询；需要避免多层嵌套，尽量改写为 JOIN。</li>
<li>DERIVED：派生表（FROM 子句中的子查询）。需要减少派生表数据量，或物化为临时表。</li>
</ul>
<p>③、table 列：查的哪个表。</p>
<ul>
<li>derivedN：表示派生表（N 对应 id）。</li>
<li>unionNM,N：表示 UNION 合并的结果（M、N 为参与 UNION 的 id）。</li>
</ul>
<p>④、type 列：表示 MySQL 在表中找到所需行的方式。</p>
<ul>
<li>system，表仅有一行（系统表或衍生表），无需优化。</li>
<li>const：通过主键或唯一索引找到一行（如 WHERE id &#x3D; 1）。理想情况。</li>
<li>eq_ref：对主键&#x2F;唯一索引 JOIN 匹配（如 A JOIN B ON A.id &#x3D; B.id）。确保 JOIN 字段有索引。</li>
<li>ref：非唯一索引匹配（如 WHERE name &#x3D; ‘王二’，name 有普通索引）。</li>
<li>range：只检索给定范围的行，使用索引来检索。在where语句中使用 bettween…and、&lt;、&gt;、&lt;&#x3D;、in 等条件查询 type 都是 range。</li>
<li>index：全索引扫描，如果不需要回表，可接受；否则考虑覆盖索引。</li>
<li>ALL：全表扫描，效率最低。<br>⑤、possible_keys 列：可能会用到的索引，但并不一定实际被使用。</li>
</ul>
<p>⑥、key 列：实际使用的索引。如果为 NULL，则没有使用索引。如果为 PRIMARY，则使用了主键索引。</p>
<p>⑦、key_len 列：使用的索引字节数，反映索引列的利用率。使用联合索引 (a, b)，key_len 是 a 和 b 的字节总和（仅当查询条件用到 a 或 a+b 时有效）。</p>
<p>– 表结构：CREATE TABLE t (a INT, b VARCHAR(20), INDEX idx_a_b (a, b));<br>EXPLAIN SELECT * FROM t WHERE a &#x3D; 1 AND b &#x3D; ‘test’;<br>key_len &#x3D; 4（INT） + 20*3（utf8） + 2 &#x3D; 66 字节。</p>
<p>⑧、ref 列：与索引列比较的值或列。</p>
<ul>
<li>const：常量。例如 WHERE column &#x3D; ‘value’。</li>
<li>func：函数。例如 WHERE column &#x3D; func(column)。</li>
</ul>
<p>⑨、rows 列：优化器估算的需要扫描的行数。数值越小越好，若与实际差距大，可能统计信息过期（需 ANALYZE TABLE）。结合 filtered 字段可以计算最终返回行数（rows × filtered）。</p>
<p>⑩、Extra 列：附加信息。</p>
<ul>
<li>Using index：覆盖索引，无需回表。</li>
<li>Using where：存储引擎返回结果后，Server 层需要再次过滤（条件未完全下推）。</li>
<li>Using temporary ：使用临时表（常见于 GROUP BY、DISTINCT）。</li>
<li>Using filesort：文件排序（常见于 ORDER BY）。考虑为 ORDER BY 字段添加索引。</li>
<li>Select tables optimized away：优化器已优化（如 COUNT(*) 通过索引直接统计）。</li>
<li>Using join buffer：使用连接缓冲区（Block Nested Loop 或 Hash Join）。考虑增大 join_buffer_size。</li>
</ul>
<p>—-这部分是帮助理解 end，面试中可不背—-</p>
<h4 id="type的执行效率等级，达到什么级别比较合适？"><a href="#type的执行效率等级，达到什么级别比较合适？" class="headerlink" title="type的执行效率等级，达到什么级别比较合适？"></a>type的执行效率等级，达到什么级别比较合适？</h4><p>从高到低的效率排序是 <code>system</code>、<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>range</code>、<code>index</code> 和 <code>ALL</code>。</p>
<p>一般情况下，建议 type 值达到<code> const</code>、<code>eq_ref</code> 或 <code>ref</code>，因为这些类型表明查询使用了索引，效率较高。<br>如果是范围查询，range 类型也是可以接受的。<br>ALL 类型表示全表扫描，性能最差，往往不可接受，需要优化。</p>
<h3 id="35-🌟索引为什么能提高MySQL查询效率？"><a href="#35-🌟索引为什么能提高MySQL查询效率？" class="headerlink" title="35.🌟索引为什么能提高MySQL查询效率？"></a>35.🌟索引为什么能提高MySQL查询效率？</h3><p>索引就像一本书的目录，能让 MySQL 快速定位数据，避免全表扫描。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E7%B4%A2%E5%BC%95%E5%8A%A0%E5%BF%AB%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86.png" alt="索引加快查询原理"></p>
<p>它一般是 <code>B+ 树</code>结构，查找效率是 <code>O(log n)</code>，比从头到尾扫一遍数据要快得多。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/MYSQL%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png" alt="MYSQL索引结构"></p>
<p>除了查得快，索引还能加速排序、分组、连接等操作。<br>可以通过 create index 创建索引，比如：<br><code>create index idx_name on students(name);</code></p>
<h3 id="36-🌟能简单说一下索引的分类吗？"><a href="#36-🌟能简单说一下索引的分类吗？" class="headerlink" title="36.🌟能简单说一下索引的分类吗？"></a>36.🌟能简单说一下索引的分类吗？</h3><p>从<strong>功能上分类</strong>的话，有<code>主键索引</code>、<code>唯一索引</code>、<code>全文索引</code>；从<strong>数据结构</strong>上分类的话，有 <code>B+ 树索引</code>、<code>哈希索引</code>；从<strong>存储内容</strong>上分类的话，有<code>聚簇索引</code>、<code>非聚簇索引</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B.png" alt="索引类型"></p>
<h4 id="你对主键索引了解多少？"><a href="#你对主键索引了解多少？" class="headerlink" title="你对主键索引了解多少？"></a>你对主键索引了解多少？</h4><p>主键索引用于唯一标识表中的每条记录，其列值<strong>必须唯一且非空</strong>。创建主键时，MySQL 会<strong>自动生成对应的唯一索引</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png" alt="主键索引"></p>
<p>每个表只能有一个<strong>主键索引</strong>，一般是表中的自增 id 字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> emp6 (emp_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>, name <span class="type">VARCHAR</span>(<span class="number">50</span>));  <span class="comment">-- 单列主键</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> CountryLanguage (</span><br><span class="line">    CountryCode <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">    <span class="keyword">Language</span> <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (CountryCode, <span class="keyword">Language</span>)  <span class="comment">-- 复合主键</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p>如果创建表的时候<strong>没有指定主键</strong>，MySQL 的 InnoDB 存储引擎会<strong>优先选择一个非空的唯一索引作为主键</strong>；如果没有符合条件的索引，MySQL 会<strong>自动生成一个隐藏的 _rowid 列</strong>作为主键。</p>
<p>可以通过 <code>show index from table_name</code> 查看索引信息：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250620110109.png" alt="20250620110109"></p>
<ul>
<li>Table 当前<strong>索引所属的表名</strong>。</li>
<li>Non_unique <strong>是否唯一索引</strong>，0 表示唯一索引（如主键），1 表示非唯一。</li>
<li>Key_name <strong>主键索引默认叫 PRIMARY</strong>；普通索引为自定义名。</li>
<li>Seq_in_index 索引中的<strong>列顺序</strong>，在联合索引中这个字段表示第几列（第 1 个）。</li>
<li>Column_name 当前索引中<strong>包含的字段名</strong>。</li>
<li>Collation A 表示升序（Ascend）；D 表示降序。</li>
<li>Cardinality 索引的基数，即不重复的索引值的数量。越高说明区分度越好（影响优化器是否用此索引）。</li>
<li>Sub_part 前缀索引的长度。</li>
<li>Packed 是否压缩存储索引；一般不用，默认为 NULL。</li>
<li>Null 字段是否允许为 NULL；主键字段不允许为 NULL。</li>
<li>Index_type 索引底层结构，InnoDB 默认是 B+ 树（BTREE）。</li>
<li>Comment 索引的注释。</li>
<li>Visible 是否可见；MySQL 8.0+ 可隐藏索引。<br>—- 这部分是帮助理解 end，面试中可不背 —-</li>
</ul>
<h4 id="唯一索引和主键索引有什么区别？"><a href="#唯一索引和主键索引有什么区别？" class="headerlink" title="唯一索引和主键索引有什么区别？"></a>唯一索引和主键索引有什么区别？</h4><p><code>主键索引=唯一索引+非空</code>。每个表只能有一个<code>主键索引</code>，但可以有<code>多个唯一索引</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 email 列上添加唯一索引</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY uk_email (email)  <span class="comment">-- 唯一索引</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复合唯一索引（保证 user_id 和 role 组合唯一）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> user_roles (</span><br><span class="line">    user_id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    role <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY uk_user_role (user_id, role)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>主键索引<strong>不允许插入 NULL 值</strong>，尝试插入 NULL 会报错；唯一索引<strong>允许插入多个 NULL 值</strong>。</p>
<h4 id="unique-key-和-unique-index-有什么区别？"><a href="#unique-key-和-unique-index-有什么区别？" class="headerlink" title="unique key 和 unique index 有什么区别？"></a>unique key 和 unique index 有什么区别？</h4><p>创建<strong>唯一键</strong>时，MySQL 会<strong>自动生成一个同名的唯一索引</strong>；反之，创建唯一索引也会<strong>隐式添加唯一性约束</strong>。</p>
<p>可通过 <code>UNIQUE KEY uk_name</code> 定义或者 <code>CONSTRAINT uk_name UNIQUE</code> 定义唯一键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="comment">-- 显式命名唯一键</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> uk_email <span class="keyword">UNIQUE</span> (email)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> users3 (</span><br><span class="line">     id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY uk_email (email)  <span class="comment">-- 唯一索引</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可通过 CREATE UNIQUE INDEX 创建唯一索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 手动创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_email <span class="keyword">ON</span> users(email);</span><br></pre></td></tr></table></figure>
<p>通过 <code>SHOW CREATE TABLE table_name</code> 查看表结构时，结果都是一样的。</p>
<h4 id="普通索引和唯一索引有什么区别？"><a href="#普通索引和唯一索引有什么区别？" class="headerlink" title="普通索引和唯一索引有什么区别？"></a>普通索引和唯一索引有什么区别？</h4><p><strong>普通索引仅用于加速查询</strong>，不限制字段值的唯一性；<strong>适用于高频写入的字段、范围查询的字段</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 日志时间戳允许重复，无需唯一性检查</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_log_time <span class="keyword">ON</span> access_logs(access_time);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单状态允许重复，但需频繁按状态过滤数据</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_order_status <span class="keyword">ON</span> orders(status);</span><br></pre></td></tr></table></figure>
<p><strong>唯一索引</strong>强制字段值的唯一性，<strong>插入或更新时会触发唯一性检查</strong>；适<strong>用于业务唯一性约束的字段、防止数据重复插入的字段</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用户邮箱必须唯一</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_email <span class="keyword">ON</span> users(email);</span><br><span class="line"><span class="comment">-- 确保同一用户对同一商品只能有一条未支付订单</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_user_product <span class="keyword">ON</span> orders(user_id, product_id) <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;unpaid&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h4 id="你对全文索引了解多少？"><a href="#你对全文索引了解多少？" class="headerlink" title="你对全文索引了解多少？"></a>你对全文索引了解多少？</h4><p>全文索引是 MySQL 一种<strong>优化文本数据检索的特殊类型索引</strong>，适用于 CHAR、VARCHAR 和 TEXT 等字段。</p>
<p>MySQL 5.7 及以上版本内置了 ngram 解析器，可处理中文、日文和韩文等分词。</p>
<p>建表时通过 <code>FULLTEXT (title, body)</code> 来定义。通过 <code>MATCH(col1, col2) AGAINST(&#39;keyword&#39;)</code> 进行检索，默认按照降序返回结果，支持布尔模式查询。</p>
<ul>
<li><code>+</code> 表示必须包含；</li>
<li><code>-</code> 表示排除；</li>
<li><code>*</code> 表示通配符；<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表时创建全文索引（支持中文）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> articles (</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    content TEXT,</span><br><span class="line">    FULLTEXT(title, content) <span class="keyword">WITH</span> PARSER ngram</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用布尔模式查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;+MySQL -Oracle&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure>
底层使用倒排索引将字段中的文本内容进行分词，然后建立一个倒排表。性能比 LIKE ‘%keyword%’ 高很多。</li>
</ul>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p><strong>倒排索引</strong>通过一个辅助表存储单词与单词自身在一个或多个文档中所在位置之间的映射，通常采用关联数组实现。</p>
<p>有两种表现形式：inverted file index（{单词，单词所在文档的ID}）和full inverted index（{单词，(单词所在文档的ID，在具体文档中的位置)}）</p>
<p>比如有这样一个文档：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DocumentId  Text  </span><br><span class="line"><span class="number">1</span>          Pease porridge hot, pease porridge cold  </span><br><span class="line"><span class="number">2</span>          Pease porridge <span class="keyword">in</span> the pot  </span><br><span class="line"><span class="number">3</span>          Nine days <span class="keyword">old</span>  </span><br><span class="line"><span class="number">4</span>          <span class="keyword">Some</span> <span class="keyword">like</span> it hot, <span class="keyword">some</span> <span class="keyword">like</span> it cold  </span><br><span class="line"><span class="number">5</span>          <span class="keyword">Some</span> <span class="keyword">like</span> it <span class="keyword">in</span> the pot  </span><br><span class="line"><span class="number">6</span>          Nine days <span class="keyword">old</span></span><br></pre></td></tr></table></figure>
<p><code>inverted file index</code> 的关联数组存储形式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">days → <span class="number">3</span>,<span class="number">6</span>  </span><br><span class="line"><span class="keyword">old</span> → <span class="number">3</span>,<span class="number">6</span>  </span><br><span class="line">pease → <span class="number">1</span>,<span class="number">2</span>  </span><br><span class="line">porridge → <span class="number">1</span>,<span class="number">2</span>  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>full inverted index</code> 更加详细：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">days → (<span class="number">3</span>:<span class="number">5</span>),(<span class="number">6</span>:<span class="number">5</span>)  </span><br><span class="line"><span class="keyword">old</span> → (<span class="number">3</span>:<span class="number">11</span>),(<span class="number">6</span>:<span class="number">11</span>)  </span><br><span class="line">pease → (<span class="number">1</span>:<span class="number">1</span>),(<span class="number">1</span>:<span class="number">7</span>),(<span class="number">2</span>:<span class="number">1</span>)  </span><br><span class="line">porridge → (<span class="number">1</span>:<span class="number">7</span>),(<span class="number">2</span>:<span class="number">7</span>)  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>full inverted index</code> 不仅存储了文档 ID，还存储了单词在文档中的具体位置。</p>
<p>InnoDB 采用的是 <code>full inverted index</code> 的方式实现全文索引。</p>
<p>如果需要处理中文分词的话，一定要记得加上 <code>WITH PARSER ngram</code>，否则可能查不出来数据。</p>
<p>不过，对于复杂的中文场景，建议使用 <code>Elasticsearch</code> 等专业搜索引擎替代，技术派项目中就用了这种方案。</p>
<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<h3 id="37-🌟创建索引有哪些注意点？"><a href="#37-🌟创建索引有哪些注意点？" class="headerlink" title="37.🌟创建索引有哪些注意点？"></a>37.🌟创建索引有哪些注意点？</h3><p><strong>第一，选择合适的字段</strong></p>
<ul>
<li>比如说频繁出现在 <code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 中的字段。</li>
<li>优先选择区分度高的字段，比如用户 ID、手机号等唯一值多的，而不是性别、状态等区分度极低的字段，如果真的需要，可以考虑联合索引。</li>
</ul>
<p><strong>第二，要控制索引的数量，避免过度索引</strong>，每个索引都要占用存储空间，单表的索引数量不建议超过 5 个。</p>
<p>要定期通过 <code>SHOW INDEX FROM table_name</code> 查看索引的使用情况，<strong>删除不必要的索引</strong>。比如说已经有联合索引 (a, b)，单索引（a）就是冗余的。</p>
<p><strong>第三，联合索引的时候要遵循最左前缀原则</strong>，即在查询条件中使用联合索引的第一个字段，才能充分利用索引。</p>
<p>比如说联合索引 (A, B, C) 可支持 A、A+B、A+B+C 的查询，但无法支持 B 或 C 的单独查询。</p>
<p><strong>区分度高的字段放在左侧</strong>，<strong>等值查询的字段优先于范围查询的字段</strong>。例如 WHERE A&#x3D;1 AND B&gt;10 AND C&#x3D;2，优先 (A, C, B)。</p>
<p>如果<strong>联合索引包含查询的所需字段，还可以避免回表</strong>，提高查询效率。</p>
<h3 id="38-🌟索引哪些情况下会失效呢？"><a href="#38-🌟索引哪些情况下会失效呢？" class="headerlink" title="38.🌟索引哪些情况下会失效呢？"></a>38.🌟索引哪些情况下会失效呢？</h3><p>简版：<strong>比如索引列使用了函数</strong>、<strong>使用了通配符开头的模糊查询</strong>、<strong>联合索引不满足最左前缀原则</strong>，或者<strong>使用 or 的时候部分字段无索引</strong>等。</p>
<p><strong>第一，对索引列使用函数或表达式会导致索引失效。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(create_time) <span class="operator">=</span> <span class="number">2023</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price<span class="operator">*</span><span class="number">2</span> <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">-- 优化方案（使用范围查询）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> create_time <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p><strong>第二，LIKE 模糊查询以通配符开头会导致索引失效。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;%数据库%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可以使用索引（但范围有限）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;数据库%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解决方案：考虑全文索引或搜索引擎</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title) AGAINST(<span class="string">&#x27;数据库&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>第三，联合索引违反了最左前缀原则，索引会失效。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设有联合索引 (a, b, c)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">-- 索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">-- 只使用a列索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确使用联合索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>联合索引，但 <code>WHERE</code> 不满足最左前缀原则，索引无法起效。例如：<code>SELECT * FROM table WHERE column2 = 2</code>，联合索引为 (column1, column2)。</p>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p><strong>第四，使用 OR 连接非索引列条件，会导致索引失效。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设name有索引但age没有</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">25</span>;  <span class="comment">-- 全表扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化方案1：使用UNION ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">25</span> <span class="keyword">AND</span> name <span class="operator">!=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化方案2：考虑为age添加索引</span></span><br></pre></td></tr></table></figure>
<p><strong>第五，使用 !&#x3D; 或 &lt;&gt; 不等值查询会导致索引失效。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> status <span class="operator">!=</span> <span class="number">1</span>;  <span class="comment">-- 若大部分行 `status=1`，可能全表扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化方案：使用范围查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> status <span class="operator">&lt;</span> <span class="number">1</span> <span class="keyword">OR</span> status <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<h4 id="什么情况下模糊查询不走索引？"><a href="#什么情况下模糊查询不走索引？" class="headerlink" title="什么情况下模糊查询不走索引？"></a>什么情况下模糊查询不走索引？</h4><p>模糊查询主要使用 LIKE 语句，结合通配符来实现。<br><code>%</code>（代表任意多个字符）和 <code>_</code>（代表单个字符）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%xxx%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这个查询会返回所有 column 列中包含 xxx 的记录。<br>但是，如果模糊查询的通配符** % 出现在搜索字符串的开始位置<strong>，如 LIKE ‘%xxx’，MySQL 将无法使用索引，因为数据库</strong>必须扫描全表以匹配任意位置的字符串**。</p>
<h3 id="41-🌟为什么-InnoDB-要使用-B-树作为索引？"><a href="#41-🌟为什么-InnoDB-要使用-B-树作为索引？" class="headerlink" title="41.🌟为什么 InnoDB 要使用 B+树作为索引？"></a>41.🌟为什么 InnoDB 要使用 B+树作为索引？</h3><p>一句话总结：<br>因为<code> B+ 树</code>是一种<strong>高度平衡的多路查找树</strong>，能<strong>有效降低磁盘的 IO 次数</strong>，并且<strong>支持有序遍历和范围查询</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/B+%E6%A0%91.png" alt="B+树"></p>
<p><strong>查询性能非常高</strong>，其结构也适合 MySQL 按照页为单位在磁盘上存储。</p>
<p>像其他选项，比如说<strong>哈希表不支持范围查询</strong>，<strong>二叉树层级太深</strong>，<strong>B 树又不方便范围扫描</strong>，所以最终选择了 B+ 树。</p>
<p>再换一种回答：</p>
<p>相比哈希表：B+ 树<strong>支持范围查询和排序</strong><br>相比二叉树和红黑树：B+ 树更“矮胖”，<strong>层级更少，磁盘 IO 次数更少</strong><br>相比 B 树：B+ 树的<strong>非叶子节点只存储键值</strong>，叶子节点存储数据并通过链表连接，<strong>支持范围查询</strong><br>另外一种回答版本：</p>
<p>B+树是一种<strong>自平衡的多路查找树</strong>，和<strong>红黑树、二叉平衡树</strong>不同，B+树的每个节点可以有 m 个子节点，而红黑树和二叉平衡树都只有 2 个。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/B+%E6%A0%912.png" alt="B+树2"><br>另外，和 B 树不同，B+树的<strong>非叶子节点只存储键值</strong>，<strong>不存储数据</strong>，而叶子节点存储了所有的数据，并且构成了一个<strong>有序链表</strong>。</p>
<p>这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。查询的效率比 B 树更高。</p>
<p>先说说 B 树。<br>B 树是一种自平衡的多路查找树，和红黑树、二叉平衡树不同，B 树的每个节点可以有 m 个子节点，而红黑树和二叉平衡树都只有 2 个。<br>换句话说，红黑树、二叉平衡树是细高个，而 B 树是矮胖子。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/B%E6%A0%91.png" alt="B树"></p>
<p>再来说说内存和磁盘的 IO 读写。</p>
<p>为了提高读写效率，从磁盘往内存中读数据的时候，一次会读取至少一页的数据，如果不满一页，会再多读点。</p>
<p>比如说查询只需要读取 2KB 的数据，但 MySQL 实际上会读取 4KB 的数据，以装满整页。页是 MySQL 进行内存和磁盘交互的最小逻辑单元。</p>
<p>再比如说需要读取 5KB 的数据，实际上 MySQL 会读取 8KB 的数据，刚好两页。</p>
<p>因为读的次数越多，效率就越低。就好比我们在工地上搬砖，一次搬 10 块砖肯定比一次搬 1 块砖的效率要高，反正我每次都搬 10 块（😁）。</p>
<p>对于红黑树、二叉平衡树这种细高个来说，每次搬的砖少，因为力气不够嘛，那来回跑的次数就越多。</p>
<p>通常 B+ 树高度为 3-4 层即可支持 TB 级数据，而每次查询只需 2-4 次磁盘 I&#x2F;O，远低于二叉树或红黑树的 O(log2N) 复杂度</p>
<p>树越高，意味着查找数据时就需要更多的磁盘 IO，因为每一层都可能需要从磁盘加载新的节点。</p>
<p>B 树的节点通常与页的大小对齐，这样每次从磁盘加载一个节点时，正好就是一页的大小。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/b%E6%A0%912.png" alt="b树2"></p>
<p>B 树的一个节点通常包括三个部分：</p>
<ul>
<li>键值：即表中的主键</li>
<li>指针：存储子节点的信息</li>
<li>数据：除主键外的行数据<br>正所谓“祸兮福所倚，福兮祸所伏”，因为 B 树的每个节点上都存储了数据，就导致每个节点能存储的键值和指针变少了，因为每一个节点的大小是固定的，对吧？<br>于是 B+树就来了，B+树的非叶子节点只存储键值，不存储数据，而叶子节点会存储所有的行数据，并且构成一个有序链表。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105348.png" alt="20250621105348"></p>
<p>这样做的好处是，非叶子节点由于没有存储数据，就可以存储更多的键值对，树就变得更加矮胖了，于是就更有劲了，每次搬的砖也就更多了（😂）。</p>
<p>相比 B 树，B+ 树的非叶子节点可容纳的键值更多，一个 16KB 的节点可存储约 1200 个键值，大幅降低树的高度。</p>
<p>由此一来，查找数据进行的磁盘 IO 就更少了，查询的效率也就更高了。</p>
<p>再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。</p>
<p>B 树就做不到这一点。</p>
<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<h4 id="B-树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？"><a href="#B-树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？" class="headerlink" title="B+树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？"></a>B+树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？</h4><p>B+树的叶子节点是通过<strong>双向链表</strong>连接的，这样可以方便范围查询和反向遍历。</p>
<p>当执行范围查询时，可以从范围的开始点或结束点开始，向前或向后遍历。<br>在需要对数据进行逆序处理时，双向链表非常有用。<br>如果需要在 B+树中从大值向小值进行检索，可以先定位到最右侧节点，找到包含最大值的叶子节点。从根节点开始向右遍历树的方式实现。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105458.png" alt="20250621105458"></p>
<p>定位到最右侧的叶子节点后，再利用叶节点间的双向链表向左遍历就好了。</p>
<h4 id="为什么-MongoDB-的索引用-B树，而-MySQL-用-B-树？"><a href="#为什么-MongoDB-的索引用-B树，而-MySQL-用-B-树？" class="headerlink" title="为什么 MongoDB 的索引用 B树，而 MySQL 用 B+ 树？"></a>为什么 MongoDB 的索引用 B树，而 MySQL 用 B+ 树？</h4><p>MongoDB 通常以 JSON 格式存储文档，查询以单键查询（如 find({_id: 123})）为主。B 树的“节点既存键又存数据”的特性<strong>允许查询在非叶子节点提前终止</strong>，从而减少 I&#x2F;O 次数。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105550.png" alt="20250621105550"></p>
<p>MySQL 的查询通常涉及范围（WHERE id &gt; 100）、排序（ORDER BY）、连接（JOIN）等操作。B+ 树的叶子节点是链表结构，天然支持顺序遍历，无需回溯至根节点或中序遍历，效率远高于 B 树。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105601.png" alt="20250621105601"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105641.png" alt="20250621105641"></p>
<h3 id="42-🌟一棵B-树能存储多少条数据呢？"><a href="#42-🌟一棵B-树能存储多少条数据呢？" class="headerlink" title="42.🌟一棵B+树能存储多少条数据呢？"></a>42.🌟一棵B+树能存储多少条数据呢？</h3><p>一句话回复：<br>一棵 B+ 树能存多少数据，<strong>取决于它的分支因子和高度</strong>。在 InnoDB 中，页的默认大小为 16KB，当主键为 bigint 时，3 层 B+ 树通常可以存储约 2000 万条数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623101840.png" alt="20250623101840"></p>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p>先来看一下<strong>计算公式</strong>：</p>
<p><code>最大记录数 = (分支因子)^(树高度-1) × 叶子节点容量</code></p>
<p>再来看一下关键参数：<br>①、页大小，默认 16KB<br>②、主键大小，假设是 bigint 类型，那么它的大小就是 8 个字节。<br>③、页指针大小，InnoDB 源码中设置为 6 字节，4 字节页号 + 2 字节页内偏移。</p>
<p>所以非叶子节点可以存储 16384&#x2F;14(键值+指针)&#x3D;1170 个这样的单元。</p>
<p>当层高为 2 时，根节点可以存储 1170 个指针，指向 1170 个叶子节点，所以总数据量为 1170×16 &#x3D;18720 条。</p>
<p>当层高为 3 时，根节点指向 1170 个非叶子节点，每个非叶子节点再指向 1170 个叶子节点，所以总数据量为 1170×1170×16≈21,902,400 条（约2,190万条）记录。</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6904293886626103309">清幽之地：InnoDB 一棵 B+树可以存放多少行数据？</a></p>
<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<p>现在有一张表 2kw 数据，我这个 b+树的高度有几层？<br>对于 2KW 条数据来说，B+树的高度为 3 层就够了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/3%E5%B1%82B+%E6%A0%91.png" alt="3层B+树"></p>
<h4 id="每个叶子节点能存放多少条数据？"><a href="#每个叶子节点能存放多少条数据？" class="headerlink" title="每个叶子节点能存放多少条数据？"></a>每个叶子节点能存放多少条数据？</h4><p>如果单行数据大小为 1KB，那么每页可存储约 16 行（16KB&#x2F;1KB）数据。</p>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p>假设有这样一个表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">PRIMARY KEY</span>,        <span class="comment">-- 8字节</span></span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,   <span class="comment">-- 实际长度50字节（UTF8MB4，每个字符最多4字节）</span></span><br><span class="line">  `age` TINYINT,                  <span class="comment">-- 1字节</span></span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">255</span>)            <span class="comment">-- 实际长度30字节，可为NULL</span></span><br><span class="line">) ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure>
<p>那么一行数据的大小为：8 + 50 + 1 + 30 &#x3D; 89 字节。</p>
<p>行格式的开销为：行头 5 字节+指针 6 字节+可变长度字段开销 2 字节（name 和 email 各占 1 字节）+ NULL 位图 1 字节 &#x3D; 14 字节。</p>
<p>所以每行数据的实际大小为：89 + 14 &#x3D; 103 字节。</p>
<p>每页大小默认为 16KB，那么每页最多可以存储 16384 &#x2F; 103 ≈ 158 行数据。</p>
<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<h3 id="44-🌟为什么用-B-树而不用-B-树呢？"><a href="#44-🌟为什么用-B-树而不用-B-树呢？" class="headerlink" title="44.🌟为什么用 B+ 树而不用 B 树呢？"></a>44.🌟为什么用 B+ 树而不用 B 树呢？</h3><p>B+ 树相比 B 树有 3 个显著优势：</p>
<p>第一，B 树的每个节点既存储键值，又存储数据和指针，导致<strong>单节点存储的键值数量较少</strong>。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623103448.png" alt="20250623103448"></p>
<p>一个 16KB 的 InnoDB 页，如果数据较大，B 树的非叶子节点只能容纳几十个键值，而 B+ 树的非叶子节点可以容纳上千个键值。</p>
<p>第二，<strong>B 树的范围查询需要通过中序遍历逐层回溯</strong>；而 <strong>B+ 树的叶子节点通过双向链表顺序连接</strong>，范围查询只需定位起始点后顺序遍历链表即可，没有回溯开销。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623104021.png" alt="20250623104021"></p>
<p>第三，<strong>B 树的数据可能存储在任意节点</strong>，假如目标数据恰好位于根节点或上层节点，查询仅需 1-2 次 I&#x2F;O；但如果数据位于底层节点，则需多次 I&#x2F;O，导致查询时间波动较大。</p>
<p>而 <strong>B+ 树的所有数据都存储在叶子节点</strong>，查询路径的长度是固定的，**时间稳定为 O(logN)**，对 MySQL <strong>在高并发场景下的稳定性至关重要</strong>。</p>
<h4 id="B-树的时间复杂度是多少？"><a href="#B-树的时间复杂度是多少？" class="headerlink" title="B+树的时间复杂度是多少？"></a>B+树的时间复杂度是多少？</h4><p><code>O(logN)</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623104724.png" alt="20250623104724"></p>
<h4 id="为什么用-B-树不用跳表呢？"><a href="#为什么用-B-树不用跳表呢？" class="headerlink" title="为什么用 B+树不用跳表呢？"></a>为什么用 B+树不用跳表呢？</h4><p>跳表<strong>本质上还是链表结构</strong>，只不过把某些节点抽到上层做了索引。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623104917.png" alt="20250623104917"></p>
<p>一条数据一个节点，如果需要存放 2000 万条数据，且每次查询都要能达到二分查找的效果，那么跳表的高度大约为 24 层（2 的 24 次方）。</p>
<p>在最坏的情况下，这 24 层数据分散在不同的数据页，查找一次数据就需要 24 次磁盘 I&#x2F;O。</p>
<p>而 2000 万条数据在 B+树中只需要 3 层就可以了。</p>
<h4 id="B-树的范围查找怎么做的？"><a href="#B-树的范围查找怎么做的？" class="headerlink" title="B+树的范围查找怎么做的？"></a>B+树的范围查找怎么做的？</h4><p>一句话回答：</p>
<p>先<strong>通过索引路径定位到第一个满足条件的叶子节点</strong>，然后<strong>顺着叶子节点之间的链表向右&#x2F;向左扫描，直到超过范围</strong>。</p>
<p>详细版：</p>
<p>B+ 树索引的范围查找主要<strong>依赖叶子节点之间的双向链表来完成</strong>。</p>
<p>第一步，从 B+ 树的根节点开始，通过索引键值逐层向下，<strong>找到第一个满足条件的叶子节点</strong>。</p>
<p>第二步，<strong>利用叶子节点之间的双向链表</strong>，从起始节点开始，依次向后遍历每个节点。当索引值超过查询范围，或者遍历到链表末尾时，终止查询。</p>
<h4 id="了解快排吗"><a href="#了解快排吗" class="headerlink" title="了解快排吗"></a>了解快排吗</h4><p>快速排序使用分治法将一个序列分为较小和较大的 2 个子序列，然后递归排序两个子序列，由东尼·霍尔在 1960 年提出。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.tobebetterjavaer.com/stutymore/mysql-Sorting_quicksort_anim.gif">演示</a><br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/mysql-Sorting_quicksort_anim.gif" alt="快排"><br>其核心思想是：</p>
<ul>
<li><strong>选择一个基准值。</strong></li>
<li>将数组分为两部分，<strong>左边小于基准值</strong>，<strong>右边大于或等于基准值</strong>。</li>
<li>对左右两部分递归排序，最终合并。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="46-🌟聚族索引和非聚族索引有什么区别？"><a href="#46-🌟聚族索引和非聚族索引有什么区别？" class="headerlink" title="46.🌟聚族索引和非聚族索引有什么区别？"></a>46.🌟聚族索引和非聚族索引有什么区别？</h3><p><strong>聚簇索引的叶子节点存储了完整的数据行</strong>，数据和索引是在一起的。<strong>InnoDB 的主键索引就是聚簇索引</strong>，叶子节点不仅存储了主键值，还存储了其他列的值，因此按照主键进行查询的速度会非常快。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623111022.png" alt="20250623111022"></p>
<p><strong>每个表只能有一个聚簇索引</strong>，通常由主键定义。如果没有显式指定主键，<strong>InnoDB 会隐式创建一个隐藏的主键索引 row_id</strong>。<br>非聚簇索引的叶子节点只包含了主键值，需要通过回表按照主键去聚簇索引查找其他列的值，<strong>唯一索引、普通索引等非主键索引都是非聚簇索引</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623111225.png" alt="20250623111225"></p>
<p>每个表都可以创建<strong>多个非聚簇索引</strong>，如果不想回表的话，可以通过覆盖索引把要查询的字段也放到索引中。</p>
<p>—- 这部分是帮助大家理解 start，面试中可不背 —-</p>
<p>一张表只能有一个聚簇索引。</p>
<p>CREATE TABLE user (<br>  id INT PRIMARY KEY,<br>  name VARCHAR(100),<br>  age INT<br>);<br>主键 id 是聚簇索引，B+ 树的叶子节点直接存储了 (id, name, age)。</p>
<p>一张表可以有多个非聚簇索引。</p>
<p>CREATE INDEX idx_name ON user(name);<br>CREATE INDEX idx_age ON user(age);<br>idx_name 是非聚簇索引，叶子节点存的是 name -&gt; id，查整行数据要回表。</p>
<p>idx_age 也是非聚簇索引，叶子节点存的是 age -&gt; id，查整行数据也要回表。</p>
<p>想要了解更多聚簇索引和非聚簇索引，推荐阅读：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vipstone/p/16370305.html">https://www.cnblogs.com/vipstone/p/16370305.html</a><br><a target="_blank" rel="noopener" href="https://learnku.com/articles/50096">https://learnku.com/articles/50096</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52226803/article/details/135494499">https://blog.csdn.net/m0_52226803/article/details/135494499</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/F0cEzIqecF4sWg7ZRmHKRQ">https://mp.weixin.qq.com/s/F0cEzIqecF4sWg7ZRmHKRQ</a><br>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<h3 id="47-🌟回表了解吗？"><a href="#47-🌟回表了解吗？" class="headerlink" title="47.🌟回表了解吗？"></a>47.🌟回表了解吗？</h3><p>当使用<strong>非聚簇索引进行查询</strong>时，MySQL 需要<strong>先通过非聚簇索引找到主键值</strong>，然后<strong>再根据主键值回到聚簇索引中查找完整数据行</strong>，这个过程称为<strong>回表</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623111452.png" alt="20250623111452"></p>
<p>假设现在有一张用户表 users：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    INDEX (name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>执行查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;王二&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>查询过程如下：</strong></p>
<ul>
<li>第一步，MySQL 使用 name 列上的非聚簇索引查找所有 name &#x3D; ‘王二’ 的主键 id。</li>
<li>第二步，使用主键 id 到聚簇索引中查找完整记录。</li>
</ul>
<h4 id="回表的代价是什么？"><a href="#回表的代价是什么？" class="headerlink" title="回表的代价是什么？"></a>回表的代价是什么？</h4><p>回表通常<strong>需要访问额外的数据页</strong>，如果数据不在内存中，还需要从磁盘读取，<strong>增加 I&#x2F;O 开销</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623112230.png" alt="20250623112230"></p>
<p>可通过覆盖索引或者联合索引来避免回表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原表结构</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    INDEX idx_name (name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 需要查询name和age</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">-- 这会回表，因为age不在idx_name索引中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化方案1：创建包含age的联合索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">ADD</span> INDEX idx_name_age (name, age);</span><br><span class="line"><span class="comment">-- 现在同样的查询不需要回表</span></span><br></pre></td></tr></table></figure>

<p><strong>什么情况下会触发回表？</strong></p>
<p>第一，当查询字段<strong>不在非聚簇索引中时</strong>，必须回表到主键索引获取数据。<br>第二，查询字段包含非索引列（如 SELECT *），必然触发回表。</p>
<p><strong>回表记录越多好吗？</strong><br><strong>回表记录越多，通常代表性能越差</strong>，因为每条记录都需要通过主键再查询一次完整数据。这个过程涉及内存访问或磁盘 IO，尤其当缓存命中率不高时，<strong>回表会严重影响查询效率</strong>。</p>
<h4 id="了解-MRR-吗？"><a href="#了解-MRR-吗？" class="headerlink" title="了解 MRR 吗？"></a>了解 MRR 吗？</h4><p>MRR 是 InnoDB 为了解决回表带来的大量随机 IO 问题而引入的一种<strong>优化策略</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/MRR.png" alt="MRR"></p>
<p>它会先把非聚簇索引查到的主键值<strong>列表进行排序</strong>，<strong>再按顺序去主键索引中批量回表</strong>，将随机 I&#x2F;O 转换为顺序 I&#x2F;O，以减少磁盘寻道时间。</p>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p>可通过 <code>SHOW VARIABLES LIKE &#39;optimizer_switch&#39;;</code> 查看 MRR 是否启用。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113200.png" alt="20250623113200"></p>
<p>其中 <code>mrr=on</code> 表示启用 MRR，<code>mrr_cost_based=on</code> 表示基于成本决定使用 MRR。</p>
<p>另外可以通过 <code>show variables like &#39;read_rnd_buffer_size&#39;;</code> 查看 MRR 的缓冲区大小，默认是 256KB。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113223.png" alt="20250623113223"><br>我们来创建一个表，插入一些数据，然后执行一个查询来演示 MRR 的效果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> mrr_test; </span><br><span class="line">USE mrr_test; </span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> orders (id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>, user_id <span class="type">INT</span>, order_date <span class="type">DATE</span>, amount <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>), status <span class="type">VARCHAR</span>(<span class="number">20</span>), INDEX idx_user_date(user_id, order_date));</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> generate_test_data()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;=</span> <span class="number">100000</span> DO</span><br><span class="line">        <span class="keyword">INSERT INTO</span> orders (user_id, order_date, amount, status)</span><br><span class="line">        <span class="keyword">VALUES</span> (</span><br><span class="line">            <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">1000</span>),  <span class="comment">-- Random user_id between 1 and 1000</span></span><br><span class="line">            DATE_ADD(<span class="string">&#x27;2023-01-01&#x27;</span>, <span class="type">INTERVAL</span> <span class="built_in">FLOOR</span>(RAND() <span class="operator">*</span> <span class="number">365</span>) <span class="keyword">DAY</span>),  <span class="comment">-- Random date in 2023</span></span><br><span class="line">            ROUND(<span class="number">10</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">990</span>, <span class="number">2</span>),  <span class="comment">-- Random amount between 10 and 1000</span></span><br><span class="line">            ELT(<span class="number">1</span> <span class="operator">+</span> <span class="built_in">FLOOR</span>(RAND() <span class="operator">*</span> <span class="number">3</span>), <span class="string">&#x27;completed&#x27;</span>, <span class="string">&#x27;pending&#x27;</span>, <span class="string">&#x27;cancelled&#x27;</span>)  <span class="comment">-- Random status</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> generate_test_data();</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> generate_test_data;&quot;</span><br></pre></td></tr></table></figure>
<p>查看 MRR 开启和关闭时的性能数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 确保MRR开启并设置足够大的缓冲区</span></span><br><span class="line"><span class="keyword">SET</span> SESSION optimizer_switch<span class="operator">=</span><span class="string">&#x27;mrr=on,mrr_cost_based=off&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> SESSION read_rnd_buffer_size <span class="operator">=</span> <span class="number">16</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清理缓存和状态</span></span><br><span class="line">FLUSH STATUS;</span><br><span class="line">FLUSH TABLES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制使用二级索引并回表查询（通过选择未被索引的列）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Raw data access pattern with MRR ON&#x27;</span> <span class="keyword">as</span> test_case;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ MRR(orders_mrr_test) */</span> id, shipping_address, customer_name</span><br><span class="line"><span class="keyword">FROM</span> orders_mrr_test FORCE INDEX(idx_user_date)</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="keyword">IN</span> (<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>,<span class="number">900</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-03-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-04-01&#x27;</span></span><br><span class="line">LIMIT <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示处理器状态</span></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Handler_%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%mrr%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对比：关闭MRR</span></span><br><span class="line"><span class="keyword">SET</span> SESSION optimizer_switch<span class="operator">=</span><span class="string">&#x27;mrr=off,mrr_cost_based=off&#x27;</span>;</span><br><span class="line">FLUSH STATUS;</span><br><span class="line">FLUSH TABLES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Raw data access pattern with MRR OFF&#x27;</span> <span class="keyword">as</span> test_case;</span><br><span class="line"><span class="keyword">SELECT</span> id, shipping_address, customer_name</span><br><span class="line"><span class="keyword">FROM</span> orders_mrr_test FORCE INDEX(idx_user_date)</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="keyword">IN</span> (<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>,<span class="number">900</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-03-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-04-01&#x27;</span></span><br><span class="line">LIMIT <span class="number">15</span>;</span><br><span class="line"><span class="comment">-- 显示处理器状态</span></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Handler_%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%mrr%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示详细的执行计划</span></span><br><span class="line">EXPLAIN FORMAT<span class="operator">=</span>TREE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ MRR(orders_mrr_test) */</span> id, shipping_address, customer_name</span><br><span class="line"><span class="keyword">FROM</span> orders_mrr_test FORCE INDEX(idx_user_date)</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="keyword">IN</span> (<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>,<span class="number">900</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-03-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-04-01&#x27;</span>;&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到 MRR 开启时的结果对比：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113305.png" alt="20250623113305"></p>
<p>Wrap 也给出了对应的结果说明：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113322.png" alt="20250623113322"><br>也可以在 explain 中确认 MRR 的使用情况。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113335.png" alt="20250623113335"><br>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<h3 id="48-🌟联合索引了解吗？（补充）"><a href="#48-🌟联合索引了解吗？（补充）" class="headerlink" title="48.🌟联合索引了解吗？（补充）"></a>48.🌟联合索引了解吗？（补充）</h3><p>联合索引就是把<strong>多个字段放在一个索引里</strong>，但必须遵守“<strong>最左前缀</strong>”原则，只有从第一个字段开始连续使用，索引才会生效。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png" alt="联合索引"></p>
<p>联合索引会<strong>按字段顺序构建B+树</strong>。例如（age, name）索引会先按照 age 排序，age 相同则按照 name 排序，若两者都相同则按主键排序，确保叶子节点无重复索引项。</p>
<p>创建(A,B,C)联合索引相当于同时创建了(A)、(A,B)和(A,B,C)三个索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建联合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_order_user_product <span class="keyword">ON</span> orders(user_id, product_id, create_time)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 高效查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> user_id<span class="operator">=</span><span class="number">1001</span> <span class="keyword">AND</span> product_id<span class="operator">=</span><span class="number">2002</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h4 id="联合索引底层的存储结构是怎样的？"><a href="#联合索引底层的存储结构是怎样的？" class="headerlink" title="联合索引底层的存储结构是怎样的？"></a>联合索引底层的存储结构是怎样的？</h4><p>联合索引在底层采用 B+ 树结构进行存储，这一点与单列索引相同。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624093822.png" alt="20250624093822"></p>
<p>与单列索引不同的是，联合索引的每个节点会存储所有索引列的值，而不仅仅是第一列的值。例如，对于联合索引(a,b,c)，<strong>每个节点都包含 a、b、c 三列的值</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">非叶子节点示例：  </span><br><span class="line">[(a<span class="operator">=</span><span class="number">1</span>, b<span class="operator">=</span><span class="number">2</span>, c<span class="operator">=</span><span class="number">3</span>) → 子节点<span class="number">1</span>, (a<span class="operator">=</span><span class="number">5</span>, b<span class="operator">=</span><span class="number">3</span>, c<span class="operator">=</span><span class="number">1</span>) → 子节点<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">叶子节点示例（InnoDB）：  </span><br><span class="line">(a<span class="operator">=</span><span class="number">1</span>, b<span class="operator">=</span><span class="number">2</span>, c<span class="operator">=</span><span class="number">3</span>) → PK<span class="operator">=</span><span class="number">100</span> <span class="operator">|</span> (a<span class="operator">=</span><span class="number">1</span>, b<span class="operator">=</span><span class="number">2</span>, c<span class="operator">=</span><span class="number">4</span>) → PK<span class="operator">=</span><span class="number">101</span>  </span><br><span class="line">（通过指针连接形成双向链表）</span><br></pre></td></tr></table></figure>

<h4 id="联合索引的叶子节点存的什么内容"><a href="#联合索引的叶子节点存的什么内容" class="headerlink" title="联合索引的叶子节点存的什么内容?"></a>联合索引的叶子节点存的什么内容?</h4><p>联合索引属于<strong>非聚簇索引</strong>，叶子节点存储的是联合索引各列的值和对应行的主键值，而<strong>不是完整的数据行</strong>。查询非索引字段时，需要通过主键值回表到聚簇索引获取完整数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094019.png" alt="20250624094019"></p>
<p>例如索引<code>(a, b)</code>的叶子节点会完整存储<code>(a, b)</code>的值，并按字段顺序排序（如 a 优先，a 相同则按 b 排序）。如果主键是 id，叶子节点会存储 (a, b, id) 的组合。</p>
<h4 id="49-🌟覆盖索引了解吗？"><a href="#49-🌟覆盖索引了解吗？" class="headerlink" title="49.🌟覆盖索引了解吗？"></a>49.🌟覆盖索引了解吗？</h4><p>覆盖索引指的是：<strong>查询所需的字段全部都在索引中</strong>，<strong>不需要回表</strong>，从索引页就能直接返回结果。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094156.png" alt="20250624094156"></p>
<p><code>empname</code> 和 <code>job</code> 两个字段是一个联合索引，而查询也恰好是这两个字段，这时候单次查询就可以达到目的，不需要回表。</p>
<p>可以<strong>将高频查询的字段（如 WHERE 条件和 SELECT 列）组合为联合索引，实现覆盖索引</strong>。 例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_empname_job <span class="keyword">ON</span> employee(empname, job);</span><br></pre></td></tr></table></figure>
<p>这样查询的时候就可以走索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empname, job <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> empname <span class="operator">=</span> <span class="string">&#x27;王二&#x27;</span> <span class="keyword">AND</span> job <span class="operator">=</span> <span class="string">&#x27;程序员&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>普通索引只用于加速查询条件的匹配，而覆盖索引还能直接提供查询结果。</p>
<p>一个表（name, sex,age,id），select age,id,name from tblname where name&#x3D;’paicoding’;怎么建索引<br>由于查询条件有 name 字段，所以最少应该为 name 字段添加一个索引。、</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> tblname(name);</span><br></pre></td></tr></table></figure>
<p>查询结果中还需要 age、id 字段，可以为这三个字段创建一个联合索引，利用覆盖索引，直接从索引中获取数据，减少回表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_age_id <span class="keyword">ON</span> tblname (name, age, id);</span><br></pre></td></tr></table></figure>

<h3 id="50-🌟什么是最左前缀原则？"><a href="#50-🌟什么是最左前缀原则？" class="headerlink" title="50.🌟什么是最左前缀原则？"></a>50.🌟什么是最左前缀原则？</h3><p>最左前缀原则指的是：MySQL 使用联合索引时，必须从最左边的字段开始匹配，才能命中索引。</p>
<p>假设有一个联合索引 (A, B, C)，其生效条件如下：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094631.png" alt="20250624094631"></p>
<p>如果排序或分组的列是最左前缀的一部分，索引还可以加速操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引(a,b)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b; <span class="comment">-- 可以利用索引排序</span></span><br></pre></td></tr></table></figure>

<h4 id="范围查询后的列还能用索引吗？"><a href="#范围查询后的列还能用索引吗？" class="headerlink" title="范围查询后的列还能用索引吗？"></a>范围查询后的列还能用索引吗？</h4><p>范围查询只能应用于<strong>最左前缀的最后一列</strong>。范围查询之后的列无法使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引(a,b,c)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>; </span><br><span class="line"><span class="comment">-- 只能使用a和b，c无法使用索引</span></span><br></pre></td></tr></table></figure>
<h4 id="为什么不从最左开始查，就无法匹配呢？"><a href="#为什么不从最左开始查，就无法匹配呢？" class="headerlink" title="为什么不从最左开始查，就无法匹配呢？"></a>为什么不从最左开始查，就无法匹配呢？</h4><p>一句话回答：</p>
<p>因为<strong>联合索引在 B+ 树中是按照最左字段优先排序构建的</strong>，如果跳过最左字段，MySQL 无法判断查找范围从哪里开始，自然也就无法使用索引。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094835.png" alt="20250624094835"></p>
<p>比如有一个 user 表，我们给 name 和 age 建立了一个联合索引 (name, age)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> <span class="keyword">user</span> <span class="keyword">add</span> INDEX comidx_name_phone (name,age);</span><br></pre></td></tr></table></figure>
<p>联合索引在 B+ 树中按照从左到右的顺序依次建立搜索树，name 在左，age 在右。</p>
<p>当我们使用 where name&#x3D; ‘王二’ and age &#x3D; ‘20’ 去查询的时候， B+ 树会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。</p>
<p>如果 name 相同的时候再比较 age。</p>
<p>但如果查询条件没有 name，就不知道应该怎么查了，因为 name 是 B+树中的前置条件，没有 name，索引就派不上用场了。</p>
<h4 id="联合索引-a-b-，where-a-1-和-where-b-1，效果是一样的吗"><a href="#联合索引-a-b-，where-a-1-和-where-b-1，效果是一样的吗" class="headerlink" title="联合索引 (a, b)，where a &#x3D; 1 和 where b &#x3D; 1，效果是一样的吗"></a>联合索引 (a, b)，where a &#x3D; 1 和 where b &#x3D; 1，效果是一样的吗</h4><p>不一样。</p>
<p><code>WHERE a = 1</code> 能命中联合索引，因为 a 是联合索引的第一个字段，符合最左前缀匹配原则。而 <code>WHERE b = 1</code> 无法命中联合索引，因为缺少 a 的匹配条件，MySQL 会<strong>全表扫描</strong>。</p>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p>我们来验证一下，假设有一个 ab 表，建立了联合索引 <code>(a, b)</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> ab (</span><br><span class="line"> a <span class="type">INT</span>,</span><br><span class="line"> b <span class="type">INT</span>,</span><br><span class="line"> INDEX ab_index (a, b)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>插入数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> ab (a, b) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>执行查询：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624100243.png" alt="20250624100243"></p>
<p>通过 explain 可以看到，WHERE a &#x3D; 1 使用了联合索引，而 WHERE b &#x3D; 1 需要全表扫描，依次检查每一行。</p>
<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<h4 id="假如有联合索引-abc，下面的-sql-怎么走的联合索引？"><a href="#假如有联合索引-abc，下面的-sql-怎么走的联合索引？" class="headerlink" title="假如有联合索引 abc，下面的 sql 怎么走的联合索引？"></a>假如有联合索引 abc，下面的 sql 怎么走的联合索引？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> c <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>第一条 SQL 语句包含条件 a &#x3D; 2 和 b &#x3D; 2，刚好符合联合索引的前两列。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624100956.png" alt="20250624100956"></p>
<p>第二条 SQL 语句由于未使用最左前缀中的 a，会触发全表扫描。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101013.png" alt="20250624101013"></p>
<p>第三条 SQL 语句在范围条件 a &gt; 2 之后，索引后会停止匹配，b &#x3D; 2 的条件需要额外过滤。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101041.png" alt="20250624101041"></p>
<h4 id="A-B-C-联合索引-select-from-tbn-where-a-and-b-in-and-c-会走索引吗？"><a href="#A-B-C-联合索引-select-from-tbn-where-a-and-b-in-and-c-会走索引吗？" class="headerlink" title="(A,B,C) 联合索引 select * from tbn where a&#x3D;? and b in (?,?) and c&gt;? 会走索引吗？"></a>(A,B,C) 联合索引 select * from tbn where a&#x3D;? and b in (?,?) and c&gt;? 会走索引吗？</h4><p>这个查询<strong>会命中联合索引</strong>，因为 a 是等值匹配，b 是 IN 等值多匹配，c 是 b 之后的范围条件，符合最左前缀原则。</p>
<p>对于 a&#x3D;?：这是一个精确匹配，并且是联合索引的第一个字段，所以一定会命中索引。</p>
<p>对于 b IN (?, ?)：等价于 b&#x3D;? OR b&#x3D;?，属于多值匹配，并且是联合索引的第二个字段，所以也会命中索引。</p>
<p>对于 c&gt;?：这是一个范围条件，属于联合索引的第三个字段，也会命中索引。</p>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p>来验证一下。</p>
<p>第一步，建表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> tbn (A <span class="type">INT</span>, B <span class="type">INT</span>, C <span class="type">INT</span>, D TEXT);</span><br></pre></td></tr></table></figure>
<p>第二步，创建索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_abc <span class="keyword">ON</span> tbn (A, B, C);</span><br></pre></td></tr></table></figure>
<p>第三步，插入数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> tbn <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;First&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> tbn <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="string">&#x27;Second&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> tbn <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;Third&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> tbn <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Fourth&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> tbn <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;Fifth&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>第四步，执行查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbn <span class="keyword">WHERE</span> A<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> B <span class="keyword">IN</span> (<span class="number">2</span>, <span class="number">3</span>) <span class="keyword">AND</span> C<span class="operator">&gt;</span><span class="number">3</span>\G</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101415.png" alt="20250624101415"><br>从 <code>EXPLAIN</code> 输出结果来看，我们可以得到 MySQL 是如何执行查询的一些关键信息：</p>
<ul>
<li>type: 查询类型，这里是 range，表示 MySQL 使用了范围查找，这是因为查询条件包含了 &gt; 操作符。</li>
<li>possible_keys: 可能被用来执行查询的索引，这里是 idx_abc，表示 MySQL 认为 idx_abc 索引会用于查询优化。</li>
<li>key: 实际用来执行查询的索引，也是 idx_abc，这确定这条查询命中了联合索引。</li>
<li>Extra: 提供了关于查询执行的额外信息。Using index condition 表示 MySQL 使用了索引下推（Index Condition Pushdown，ICP），这是 MySQL 的一个优化方式，它允许在索引层面过滤数据。</li>
</ul>
<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<h4 id="联合索引的一个场景题：-a-b-c-联合索引，-b-c-是否会走索引吗？"><a href="#联合索引的一个场景题：-a-b-c-联合索引，-b-c-是否会走索引吗？" class="headerlink" title="联合索引的一个场景题：(a,b,c)联合索引，(b,c)是否会走索引吗？"></a>联合索引的一个场景题：(a,b,c)联合索引，(b,c)是否会走索引吗？</h4><p>根据最左前缀原则，(b,c) 查询不会走索引。</p>
<p>因为联合索引 (a,b,c) 中，a 是最左边的列，联合索引在创建索引树的时候需要先有 a，然后才会有 b 和 c。而查询条件中没有包含 a，所以 MySQL 无法利用这个索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbn <span class="keyword">WHERE</span> B<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> C<span class="operator">=</span><span class="number">1</span>\G</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101535.png" alt="20250624101535"></p>
<h4 id="建立联合索引-a-b-c-，where-c-5-是否会用到索引？为什么？"><a href="#建立联合索引-a-b-c-，where-c-5-是否会用到索引？为什么？" class="headerlink" title="建立联合索引(a,b,c)，where c &#x3D; 5 是否会用到索引？为什么？"></a>建立联合索引(a,b,c)，where c &#x3D; 5 是否会用到索引？为什么？</h4><p>不会。只有索引的第三列 c 被用作查询条件，而前两列 a 和 b 都没有被使用。这<strong>不符合最左前缀原则</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbn <span class="keyword">WHERE</span> C<span class="operator">=</span><span class="number">5</span>\G</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101624.png" alt="20250624101624"></p>
<h4 id="sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引？"><a href="#sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引？" class="headerlink" title="sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引？"></a>sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引？</h4><p>如果查询模式是后缀通配符 <code>LIKE &#39;prefix%&#39;</code>，且该字段有索引，优化器通常会使用索引。否则即便是遵循最左前缀匹配，LIKE 字段也无法命中索引。</p>
<p>如 age &#x3D; 18 and name LIKE ‘%xxx’，MySQL 会先使用联合索引 age_name 找到 age 符合条件的所有行，然后再全表扫描进行 name 字段的过滤。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101721.png" alt="20250624101721"></p>
<p><code>type: ref</code> 表示使用索引查找匹配某个值的所有行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101751.png" alt="20250624101751"></p>
<p>如果是后缀通配符，如 <code>age = 18 and name LIKE &#39;xxx%&#39;</code>，MySQL 会直接使用联合索引 age_name 找到所有符合条件的行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101837.png" alt="20250624101837"></p>
<p><code>type 为 range</code>，表示 MySQL 使用了<strong>索引范围扫描</strong>，filtered 为 100.00%，表示在扫描的行中，所有的行都满足 WHERE 条件。</p>
<h3 id="51-🌟什么是索引下推？"><a href="#51-🌟什么是索引下推？" class="headerlink" title="51.🌟什么是索引下推？"></a>51.🌟什么是索引下推？</h3><p>索引下推是指：MySQL 把 WHERE 条件尽可能“下推”到索引扫描阶段，在存储引擎层提前过滤掉不符合条件的记录。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102101.png" alt="20250624102101"></p>
<p>当查询条件包含索引列但未完全匹配时，ICP 会在存储引擎层<strong>过滤非索引列条件</strong>，以减少回表次数。</p>
<p><strong>传统的查询流程</strong>是，存储引擎通过<strong>联合索引</strong>定位到符合最左前缀条件的主键 ID；回表读取完整数据行并返回给 Server 层；Server 层对所有返回的行进行 WHERE 条件过滤。</p>
<p>有了 ICP 后，存储引擎在索引层<strong>直接过滤可下推的条件</strong>，仅对符合索引条件的记录回表读取数据，再返回给 Server 层进行剩余条件过滤。</p>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p>例如有一张 user 表，建了一个联合索引（name, age），查询语句：<code>select * from user where name like &#39;张%&#39; and age=10;</code>，没有索引下推优化的情况下：</p>
<p>MySQL 会使用索引 name 找到所有 <code>name like &#39;张%&#39;</code> 的主键，根据这些主键，一条条回表查询整行数据，并在 Server 层过滤掉不符合 <code>age=10</code> 的数据行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102301.png" alt="20250624102301"></p>
<p>启用 ICP 后，InnoDB 会通过联合索引直接筛选出符合条件的主键 ID（<code>name like &#39;张%&#39; and age=10</code>），然后再回表查询整行数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102354.png" alt="20250624102354"></p>
<p>换句话说，假设 name like ‘张%’ 找到 10000 行数据，age&#x3D;10 只有其中 10 行，没有索引下推的情况下，MySQL 会回表 10000 次，读取 10000 行数据，然后在 Server 层过滤掉 9990 行。</p>
<p>而有了索引下推后，MySQL 只会回表 10 次，读取 10 行数据。</p>
<p>我们来验证一下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102426.png" alt="20250624102426"></p>
<p>从结果中我们可以清楚地看到 ICP 的效果。ICP 开启时，Extra 列显示”Using index condition”，表明过滤条件被下推到存储引擎层。</p>
<p>ICP关闭时，Extra 列仅显示”Using where”，表明过滤条件在服务器层执行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102507.png" alt="20250624102507"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启ICP</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;index_condition_pushdown=on&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清理状态</span></span><br><span class="line">FLUSH STATUS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Performance test with ICP ON&#x27;</span> <span class="keyword">as</span> test_case;</span><br><span class="line"><span class="comment">-- 执行查询并分析性能</span></span><br><span class="line">EXPLAIN ANALYZE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ICP_ON */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders_mrr_test</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">200</span></span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="operator">&lt;</span> <span class="string">&#x27;2023-02-01&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;2023-01-15%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示处理器状态</span></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Handler_read%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭ICP</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清理状态</span></span><br><span class="line">FLUSH STATUS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Performance test with ICP OFF&#x27;</span> <span class="keyword">as</span> test_case;</span><br><span class="line"><span class="comment">-- 执行相同的查询</span></span><br><span class="line">EXPLAIN ANALYZE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders_mrr_test</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">200</span></span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="operator">&lt;</span> <span class="string">&#x27;2023-02-01&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;2023-01-15%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示处理器状态</span></span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Handler_read%&#x27;</span>;&quot;</span><br></pre></td></tr></table></figure>
<p>实际的性能差距也很大。ICP 开启时，实际扫描行数：1,649 行，执行时间：约12.3 毫秒。关闭时，实际扫描行数：19,959 行，执行时间：约 32.1 毫秒。<br>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102546.png" alt="20250624102546"></p>
<h3 id="53-🌟MySQL-中有哪几种锁？"><a href="#53-🌟MySQL-中有哪几种锁？" class="headerlink" title="53.🌟MySQL 中有哪几种锁？"></a>53.🌟MySQL 中有哪几种锁？</h3><p>MySQL 中有多种类型的锁，可以从不同维度来分类，按<strong>锁粒度</strong>划分的话，有表锁、行锁。</p>
<p>按照<strong>加锁机制</strong>划分的话，有乐观锁和悲观锁。按照<strong>兼容性</strong>划分的话，有共享锁和排他锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625092449.png" alt="20250625092449"></p>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p>表锁：<strong>锁定整个表</strong>，资源开销小，加锁快，但并发度低，不会出现死锁；<strong>适合查询为主、少量更新</strong>的场景（如 MyISAM 引擎）。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625093141.png" alt="20250625093141"></p>
<p>再细分的话，有<strong>表共享读锁</strong>（S锁）：允许多个事务同时读，但阻塞写操作；<strong>表独占写锁</strong>（X锁）：独占表，阻塞其他事务的读写。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625095630.png" alt="20250625095630"></p>
<p>行锁：锁定单行或多行，开销大、加锁慢，可能出现死锁，但并发度高（InnoDB 默认支持）。</p>
<p>再细分的话，有<strong>记录锁</strong>（Record Lock）：锁定索引中的具体记录；<strong>间隙锁</strong>（Gap Lock）：锁定索引记录之间的间隙，防止幻读；<strong>临键锁</strong>（Next-Key Lock）：结合记录锁和间隙锁，锁定一个左开右闭的区间（如 <code>(5, 10]</code>）。</p>
<p><strong>共享锁</strong>（S锁&#x2F;读锁），允许多个事务同时读取数据，但阻塞写操作。语法：<code>SELECT ... LOCK IN SHARE MODE</code></p>
<p><strong>排他锁</strong>（X锁&#x2F;写锁），独占数据，阻塞其他事务的读写。语法：<code>SELECT ... FOR UPDATE</code>。</p>
<p><strong>乐观锁</strong>假设冲突少，通过版本号或 CAS 机制检测冲突（如 <code>UPDATE SET version=version+1 WHERE version=old_version</code>）。</p>
<p><strong>悲观锁</strong>假设并发冲突频繁，先加锁再操作<code>SELECT FOR UPDATE</code>。<br>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<h3 id="55-🌟说说-MySQL-的行锁？"><a href="#55-🌟说说-MySQL-的行锁？" class="headerlink" title="55.🌟说说 MySQL 的行锁？"></a>55.🌟说说 MySQL 的行锁？</h3><p>行锁是 <code>InnoDB</code> 存储引擎中<strong>最细粒度的锁</strong>，它<strong>锁定表中的一行记录</strong>，允许其他事务访问表中的其他行。</p>
<p>底层是通过<strong>给索引加锁</strong>实现的，这就意味着<strong>只有通过索引条件检索数据时</strong>，InnoDB <strong>才能使用行级锁</strong>，否则会退化为表锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625103938.png" alt="20250625103938"></p>
<p>行锁又可以细分为<strong>记录锁</strong>、<strong>间隙锁</strong>和<strong>临键锁</strong>三种形式。通过 <code>SELECT ... FOR UPDATE</code> 可以加排他锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加排他锁，锁定某一行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 对该行进行操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> your_table <span class="keyword">SET</span> column1 <span class="operator">=</span> <span class="string">&#x27;new_value&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 <code>SELECT ...LOCK IN SHARE MODE</code> 可以加共享锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加共享锁，锁定某一行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">-- 只能读取该行，不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<h4 id="select-for-update-有什么需要注意的？"><a href="#select-for-update-有什么需要注意的？" class="headerlink" title="select for update 有什么需要注意的？"></a>select for update 有什么需要注意的？</h4><p>第一，必须<strong>在事务中使用</strong>，否则锁会立即释放。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 对该行进行操作</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>第二，<strong>使用时必须注意是否命中索引</strong>，否则可能锁全表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name 没有索引，会退化为表锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;王二&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>
<p>假设有一张名为 orders 的表，包含以下数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    order_no <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    status <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    INDEX (order_no)  <span class="comment">-- order_no 上有索引</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>表中的数据是这样的：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625104220.png" alt="20250625104220"><br>如果我们通过主键索引执行 <code>SELECT FOR UPDATE</code>，确实只会锁定特定的行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 对 id=1 的行进行操作</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>由于 id 是主键，所以只会锁定 id&#x3D;1 这行，不会影响其他行的操作。其他事务依然可以对 id &#x3D; 2, 3, 4, 5 等行执行更新操作，因为它们没有被锁定。<br>如果使用 order_no 这个普通索引执行 SELECT FOR UPDATE，也只会锁定特定的行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;10001&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 对 order_no=10001 的行进行操作</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>因为 order_no 是唯一索引，所以只会锁定 order_no&#x3D;10001 这行，不会影响其他行的操作。</p>
<p>但如果 WHERE 条件是 status&#x3D;’pending’，而 status 上没有索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;pending&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 对 status=pending 的行进行操作</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>就会退化为表锁，因为在这种情况下，MySQL 需要全表扫描检查每一行的 status。</p>
<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>
<h4 id="说说记录锁吧？"><a href="#说说记录锁吧？" class="headerlink" title="说说记录锁吧？"></a>说说记录锁吧？</h4><p><strong>记录锁</strong>是行锁最基本的表现形式，当我们<strong>使用唯一索引或者主键索引进行等值查询时</strong>，MySQL 会为该记录<strong>自动添加排他锁</strong>，<strong>禁止其他事务读取或者修改锁定记录</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625105204.png" alt="20250625105204"></p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;  <span class="comment">-- 加X锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;王二&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 隐式加X锁</span></span><br></pre></td></tr></table></figure>
<h4 id="间隙锁了解吗？"><a href="#间隙锁了解吗？" class="headerlink" title="间隙锁了解吗？"></a>间隙锁了解吗？</h4><p>间隙锁用于在<strong>范围查询时锁定记录之间的“间隙”</strong>，<strong>防止其他事务在该范围内插入新记录</strong>。仅在可重复读及以上的隔离级别下生效，主要用于防止幻读。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625105253.png" alt="20250625105253"></p>
<p>—- 这部分是帮助大家理解 start，面试中可不背 —-</p>
<p>例如事务 A 锁定了 <code>(1000,2000)</code> 区间，会阻止事务 B 在此区间插入新记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务A</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="keyword">BETWEEN</span> <span class="number">1000</span> <span class="keyword">AND</span> <span class="number">2000</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B尝试插入会被阻塞</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> orders <span class="keyword">VALUES</span>(<span class="keyword">null</span>,<span class="number">1500</span>,<span class="string">&#x27;pending&#x27;</span>);  <span class="comment">-- 阻塞&lt;/code&gt;</span></span><br></pre></td></tr></table></figure>
<p>假设表 test_gaplock 有 id、age、name 三个字段，其中 id 是主键，age 上有索引，并插入了 4 条数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `test_gaplock` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line"> `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line"> KEY `age` (`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> test_gaplock <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>),(<span class="number">6</span>,<span class="number">6</span>,<span class="string">&#x27;吴老二&#x27;</span>),(<span class="number">8</span>,<span class="number">8</span>,<span class="string">&#x27;赵四&#x27;</span>),(<span class="number">12</span>,<span class="number">12</span>,<span class="string">&#x27;熊大&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>间隙锁会锁住：</p>
<ul>
<li><code>(−∞, 1)</code>：最小记录之前的间隙。</li>
<li><code>(1, 6)、(6, 8)、(8, 12)</code>：记录之间的间隙。</li>
<li><code>(12, +∞)</code>：最大记录之后的间隙。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625110538.png" alt="20250625110538"></p>
<p>假设有两个事务，T1 执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_gaplock <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>T2 执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT INTO</span> test_gaplock <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="number">7</span>, <span class="string">&#x27;王五&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>T1 会锁住 <code>(6, 8)</code> 的间隙，防止其他事务在这个范围内插入新记录。</p>
<p>T2 在插入 <code>(7, 7, &#39;王五&#39;)</code> 时，会被阻塞，可以在另外一个会话中执行 <code>SHOW ENGINE INNODB STATUS</code> 查看到间隙锁的信息。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625112428.png" alt="20250625112428"></p>
<h4 id="执行什么命令会加上间隙锁？"><a href="#执行什么命令会加上间隙锁？" class="headerlink" title="执行什么命令会加上间隙锁？"></a>执行什么命令会加上间隙锁？</h4><p>在可重复读隔离级别下，执行<code>FOR UPDATE / LOCK IN SHARE MODE</code>等加锁语句，且<strong>查询条件是范围查询</strong>时，就会自动加上间隙锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SELECT ... FOR UPDATE + 范围查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> score <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- SELECT ... LOCK IN SHARE MODE + 范围查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">AND</span> <span class="number">20</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">-- UPDATE/DELETE + 范围查询</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> score <span class="operator">&lt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure>


<h3 id="58-🌟MySQL的乐观锁和悲观锁了解吗？"><a href="#58-🌟MySQL的乐观锁和悲观锁了解吗？" class="headerlink" title="58.🌟MySQL的乐观锁和悲观锁了解吗？"></a>58.🌟MySQL的乐观锁和悲观锁了解吗？</h3><p>悲观锁是一种”先上锁再操作”的保守策略，它假设数据被外界访问时必然会产生冲突，因此在数据处理过程中全程加锁，保证同一时间只有一个线程可以访问数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011152502.png" alt="20251011152502"><br>牧小农：悲观锁</p>
<p>MySQL 中的行锁和表锁都是悲观锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011152533.png" alt="20251011152533"><br>牧小农：悲观锁的处理思路</p>
<p>乐观锁会假设并发操作不会总发生冲突，属于小概率事件，因此不会在读取数据时加锁，而是在提交更新时才检查数据是否被其他事务修改过。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011152635.png" alt="20251011152635"><br>牧小农：乐观锁</p>
<p>乐观锁并不是 MySQL 内置的锁机制，而是通过程序逻辑实现的，常见的实现方式有版本号机制和时间戳机制。通过在表中增加 version 字段或者 timestamp 字段来实现。</p>
<p>-— 这部分是帮助大家理解 start，面试中可不背 —-</p>
<p>当事务 A 已经上锁后，事务 B 会一直等待事务 A 释放锁；如果事务 A 长时间不释放锁，事务 B 就会报错 <code>Lock wait timeout exceeded; try restarting transaction</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011152707.png" alt="20251011152707"><br>牧小农：的实现方式</p>
<p>事务 A 和事务 B 同时读取同一个主键 ID 的数据，版本号为 0；事务 A 将版本号（version&#x3D;1）作为条件进行数据更新，同时版本号 +1；事务 B 也将 version&#x3D;1 作为更新条件，发现版本号不匹配，更新失败。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011152751.png" alt="20251011152751"><br>牧小农：乐观锁的实现方式</p>
<p>-— 这部分是帮助大家理解 end，面试中可不背 —-</p>
<h4 id="如何通过悲观锁和乐观锁解决库存超卖问题？"><a href="#如何通过悲观锁和乐观锁解决库存超卖问题？" class="headerlink" title="如何通过悲观锁和乐观锁解决库存超卖问题？"></a>如何通过悲观锁和乐观锁解决库存超卖问题？</h4><p>悲观锁通过 <code>SELECT ... FOR UPDATE</code> 在查询时直接锁定记录，确保其他事务必须等待当前事务完成才能操作该行数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 对id=1的商品记录加排他锁</span></span><br><span class="line"><span class="keyword">SELECT</span> stock <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 生成订单</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> orders (user_id, product_id) <span class="keyword">VALUES</span> (<span class="number">123</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 扣减库存</span></span><br><span class="line"><span class="keyword">UPDATE</span> products <span class="keyword">SET</span> stock<span class="operator">=</span>stock<span class="number">-1</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>乐观锁通过在表中增加 version 字段作为判断条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询商品信息，获取版本号</span></span><br><span class="line"><span class="keyword">SELECT</span> stock, version <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新库存时检查版本号</span></span><br><span class="line"><span class="keyword">UPDATE</span> products </span><br><span class="line"><span class="keyword">SET</span> stock<span class="operator">=</span>stock<span class="number">-1</span>, version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> version<span class="operator">=</span>旧版本号;</span><br></pre></td></tr></table></figure>

<p>-— 这部分是帮助大家理解 start，面试中可不背 —-</p>
<p>库存超卖是一个非常经典的问题：</p>
<ul>
<li>事务A查询商品库存，得到库存值为1</li>
<li>事务B也查询同一商品库存，同样得到库存值为1</li>
<li>事务A基于查询结果执行库存扣减，将库存更新为0</li>
<li>事务B也执行库存扣减，将库存更新为-1</li>
</ul>
<p>悲观锁的关键点：</p>
<ul>
<li>必须在一个事务中执行；</li>
<li>通过 <code>SELECT ... FOR UPDATE</code> 锁定行，确保其他事务必须等待当前事务完成才能操作该行数据；</li>
<li>记得给查询条件加索引，避免全表扫描导致锁升级为表锁。</li>
</ul>
<p>乐观锁的关键点：</p>
<ul>
<li>在表中增加 version 字段；</li>
<li>查询时获取当前版本号；</li>
<li>更新时检查版本号是否发生了变化。</li>
</ul>
<p>Java 程序的完整代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductMapper productMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">purchaseWithOptimisticLock</span><span class="params">(Long productId, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retryCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(retryCount &lt; <span class="number">3</span>) &#123; <span class="comment">// 最大重试次数</span></span><br><span class="line">            <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productMapper.selectById(productId);</span><br><span class="line">            <span class="keyword">if</span>(product.getStock() &lt; quantity) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 库存不足</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">updated</span> <span class="operator">=</span> productMapper.reduceStockWithVersion(</span><br><span class="line">                productId, quantity, product.getVersion());</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(updated &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 更新成功</span></span><br><span class="line">            &#125;</span><br><span class="line">            retryCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 更新失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 mapper：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;UPDATE products SET stock=stock-#&#123;quantity&#125;, version=version+1 &quot; +</span></span><br><span class="line"><span class="meta">        &quot;WHERE id=#&#123;productId&#125; AND version=#&#123;version&#125;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">reduceStockWithVersion</span><span class="params">(<span class="meta">@Param(&quot;productId&quot;)</span> Long productId, </span></span><br><span class="line"><span class="params">                          <span class="meta">@Param(&quot;quantity&quot;)</span> <span class="type">int</span> quantity,</span></span><br><span class="line"><span class="params">                          <span class="meta">@Param(&quot;version&quot;)</span> <span class="type">int</span> version)</span>;</span><br></pre></td></tr></table></figure>

<p>时间戳机制实现的乐观锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> products <span class="keyword">SET</span> stock<span class="operator">=</span>stock<span class="number">-1</span>, update_time<span class="operator">=</span>NOW() </span><br><span class="line"><span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> update_time<span class="operator">=</span>旧时间戳;</span><br></pre></td></tr></table></figure>

<p>这两种方式都需要保证操作的原子性，需要将多个 SQL 放在同一个事务中执行。</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mingyueyy/p/13049431.html">牧小农：悲观锁和乐观锁</a></p>
<p>-— 这部分是帮助大家理解 end，面试中可不背 —-</p>
<h3 id="60-🌟MySQL事务的四大特性说一下？"><a href="#60-🌟MySQL事务的四大特性说一下？" class="headerlink" title="60.🌟MySQL事务的四大特性说一下？"></a>60.🌟MySQL事务的四大特性说一下？</h3><p>事务是一条或多条 SQL 语句组成的执行单元。四个特性分别是原子性、一致性、隔离性和持久性。原子性保证事务中的操作要么全部执行、要么全部失败；一致性保证数据从事务开始前的一个一致状态转移到结束后的另外一个一致状态；隔离性保证并发事务之间互不干扰；持久性保证事务提交后数据不会丢失。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011155649.png" alt="20251011155649"><br>北野新津：ACID</p>
<h4 id="详细说一下原子性？"><a href="#详细说一下原子性？" class="headerlink" title="详细说一下原子性？"></a>详细说一下原子性？</h4><p>原子性意味着事务中的所有操作要么全部完成，要么全部不完成，它是不可分割的单位。如果事务中的任何一个操作失败了，整个事务都会回滚到事务开始之前的状态，如同这些操作从未被执行过一样。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 如果第二条语句失败，第一条也会回滚</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>简短回答：原子性要求事务的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务中的操作不能只执行其中一部分。</p>
<h4 id="详细说一下一致性？"><a href="#详细说一下一致性？" class="headerlink" title="详细说一下一致性？"></a>详细说一下一致性？</h4><p>一致性确保事务从一个一致的状态转换到另一个一致的状态。</p>
<p>比如在银行转账事务中，无论发生什么，转账前后两个账户的总金额应保持不变。假如 A 账户（100 块）给 B 账户（10 块）转了 10 块钱，不管成功与否，A 和 B 的总金额都是 110 块。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设 A 账户余额为 100，B 账户余额为 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转账前状态</span></span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">-- 100</span></span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>; <span class="comment">-- 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转账操作</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转账后状态</span></span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">-- 90</span></span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>; <span class="comment">-- 20`</span></span><br><span class="line"><span class="comment">-- 总金额仍然是 110</span></span><br></pre></td></tr></table></figure>

<p>简短回答：一致性确保数据的状态从一个一致状态转变为另一个一致状态。一致性与业务规则有关，比如银行转账，不论事务成功还是失败，转账双方的总金额应该是不变的。</p>
<h4 id="详细说一下隔离性？"><a href="#详细说一下隔离性？" class="headerlink" title="详细说一下隔离性？"></a>详细说一下隔离性？</h4><p>隔离性意味着并发执行的事务是彼此隔离的，一个事务的执行不会被其他事务干扰。事务之间是井水不犯河水的。</p>
<p>隔离性主要是为了解决事务并发执行时可能出现的脏读、不可重复读、幻读等问题。</p>
<p>-— 这部分是帮助大家理解 start，面试中可不背 —-</p>
<p>比如说在读未提交的隔离级别下，会出现脏读现象：一个事务C 读取了事务B 尚未提交的修改数据。如果事务B 最终回滚，事务C 读取的数据就是无效的“脏数据”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话 A</span></span><br><span class="line"><span class="comment">-- 创建模拟并发的测试表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> accounts;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> accounts (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    balance <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> accounts (name, balance) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;王二&#x27;</span>, <span class="number">1000.00</span>),</span><br><span class="line">(<span class="string">&#x27;张三&#x27;</span>, <span class="number">2000.00</span>),</span><br><span class="line">(<span class="string">&#x27;李四&#x27;</span>, <span class="number">3000.00</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话B 中，设置隔离级别为读未提交</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在会话 B 中更新数据但不提交</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">500</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话C 是读为提交级别，读取数据，得到 500</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"><span class="comment">-- 继续别的操作，基于 500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 B 的事务回滚，导致会话 A 读到的数据其实是脏数据</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011160550.png" alt="20251011160550"><br>二哥的 Java 进阶之路：读未提交下出现脏读</p>
<p>通过升级隔离级别为读已提交可以解决脏读的问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话 B 修改为读已提交</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行第一次查询 1000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 C 中，设置隔离级别为读已提交</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="comment">-- 在会话 C 中更新数据但不提交</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">200</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 B 中再次读取数据，结果仍然为 1000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 C 中回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="comment">-- 会话 B 中再次读取数据，结果仍然为 1000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011162301.png" alt="20251011162301"><br>二哥的 Java 进阶之路：读已提交可以解决脏读问题</p>
<p>但会出现不可重复读的问题：事务B 第一次读取某行数据值为X，期间事务C修改该数据为Y并提交，事务B 再次读取时发现值变为Y，导致两次读取结果不一致。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话 B 修改为读已提交</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行第一次查询 1000</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 C 中，设置隔离级别为读已提交</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="comment">-- 在会话 C 中更新数据并提交</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">200</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"><span class="comment">-- 会话 C 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 B 中再次读取数据，结果仍然为 1200</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011162620.png" alt="20251011162620"><br>二哥的 Java 进阶之路：读已提交会出现不可重复读的问题</p>
<p>可以通过升级隔离级别为可重复读来解决不可重复读的问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话 B 修改为可重复读</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开始事务并执行第一次查询 1000</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 C 中，设置隔离级别为可重复读</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="comment">-- 在会话 C 中更新数据并提交</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">200</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"><span class="comment">-- 会话 C 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 B 中再次读取数据，结果仍然为 1000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王二&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011165009.png" alt="20251011165009"><br>二哥的 Java 进阶之路：可重复读级别解决不可重复读的问题</p>
<p>但可重复读级别下仍然会出现幻读的问题：事务B 第一次查询获得 2条数据，事务C 新增 1条数据并提交后，事务B 再次查询时仍然为 2 条数据，但可以更新新增的数据，再次查询时就发现有 3 条数据了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话 B 修改为可重复读</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="comment">-- 执行第一次查询，查到 2 条记录</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> balance <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 C 中，设置隔离级别为可重复读</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="comment">-- 在会话 C 中新增数据并提交</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT INTO</span> accounts (name, balance) <span class="keyword">VALUES</span> (<span class="string">&#x27;王五&#x27;</span>, <span class="number">4000</span>);</span><br><span class="line"><span class="comment">-- 会话 C 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 B 中再次读取数据，结果仍然为 2 条</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> balance <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br><span class="line"><span class="comment">-- 会话 B 中尝试更新王五的余额为 5000，竟然成功了</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">5000</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;王五&#x27;</span>;</span><br><span class="line"><span class="comment">-- 会话 B 中再次读取数据，发现 3 条记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> balance <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251027183826.png" alt="20251027183826"><br>二哥的 Java 进阶之路：可重复读级别下可能出现幻读</p>
<p>可以通过升级隔离级别为串行化来解决幻读的问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话 B 修改为可串行化</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"><span class="comment">-- 执行第一次查询，查到 2 条记录</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> balance <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 C 中，设置隔离级别为可串行化</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"><span class="comment">-- 在会话 C 中新增数据，会卡住</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT INTO</span> accounts (name, balance) <span class="keyword">VALUES</span> (<span class="string">&#x27;王五&#x27;</span>, <span class="number">4000</span>);</span><br><span class="line"><span class="comment">-- 只有等会话 B 提交事务后会话 C 才会继续执行并提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011165026.png" alt="20251011165026"><br>二哥的 Java 进阶之路：串行化隔离级别下不会出现幻读问题</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>是否会脏读</th>
<th>是否会不可重复读</th>
<th>是否会幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted（读未提交）</td>
<td>✅ 可能</td>
<td>✅ 可能</td>
<td>✅ 可能</td>
</tr>
<tr>
<td>Read Committed（读已提交）</td>
<td>❌ 不会</td>
<td>✅ 可能</td>
<td>✅ 可能</td>
</tr>
<tr>
<td>Repeatable Read（可重复读）</td>
<td>❌ 不会</td>
<td>❌ 不会</td>
<td>✅ 可能（但 InnoDB 已解决）</td>
</tr>
<tr>
<td>Serializable（可串行化）</td>
<td>❌ 不会</td>
<td>❌ 不会</td>
<td>❌ 不会</td>
</tr>
</tbody></table>
<p>-— 这部分是帮助大家理解 end，面试中可不背 —-</p>
<p>简短回答：多个并发事务之间需要相互隔离，即一个事务的执行不能被其他事务干扰。</p>
<h4 id="详细说一下持久性？"><a href="#详细说一下持久性？" class="headerlink" title="详细说一下持久性？"></a>详细说一下持久性？</h4><p>持久性确保事务一旦提交，它对数据所做的更改就是永久性的，即使系统发生崩溃，数据也能恢复到最近一次提交的状态。</p>
<p>MySQL 的持久性是通过 InnoDB 引擎的 redo log 实现的。在事务提交时，InnoDB 会先将修改操作写入 redo log，并刷盘持久化。崩溃后，InnoDB 会通过 redo log 恢复数据，从而保证事务提交成功的数据不会丢失。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011170430.png" alt="20251011170430"><br>Mayank Sharma：可持久化</p>
<p>简短回答：一旦事务提交，则其所做的修改将永久保存到 MySQL 中。即使发生系统崩溃，修改的数据也不会丢失。</p>
<h3 id="62-🌟事务的隔离级别有哪些？"><a href="#62-🌟事务的隔离级别有哪些？" class="headerlink" title="62.🌟事务的隔离级别有哪些？"></a>62.🌟事务的隔离级别有哪些？</h3><p>隔离级别定义了一个事务可能受其他事务影响的程度，MySQL 支持四种隔离级别，分别是：读未提交、读已提交、可重复读和串行化。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012183903.png" alt="20251012183903"><br>draven.co：事务的四个隔离级别</p>
<p>读未提交会出现脏读，读已提交会出现不可重复读，可重复读是 InnoDB 默认的隔离级别，可以避免脏读和不可重复读，但会出现幻读。不过通过 MVCC 和临键锁，能够防止大多数并发问题。</p>
<p>串行化最安全，但性能较差，通常不推荐使用。</p>
<h4 id="详细说说读未提交？"><a href="#详细说说读未提交？" class="headerlink" title="详细说说读未提交？"></a>详细说说读未提交？</h4><p>事务可以读取其他未提交事务修改的数据。也就是说，如果未提交的事务一旦回滚，读取到的数据就会变成了“脏数据”，通常不会使用。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/mysql-20250415152542.png" alt="易尘埃：读未提交"></p>
<p>易尘埃：读未提交</p>
<h4 id="什么是读已提交？"><a href="#什么是读已提交？" class="headerlink" title="什么是读已提交？"></a>什么是读已提交？</h4><p>读已提交避免了脏读，但可能会出现不可重复读，即同一事务内多次读取同一数据结果会不同，因为其他事务提交的修改，对当前事务是可见的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012193756.png" alt="20251012193756"><br>易尘埃：读已提交</p>
<p>是 Oracle、SQL Server 等数据库的默认隔离级别。</p>
<h4 id="什么是可重复读？"><a href="#什么是可重复读？" class="headerlink" title="什么是可重复读？"></a>什么是可重复读？</h4><p>可重复读能确保同一事务内多次读取相同数据的结果一致，即使其他事务已提交修改。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012193828.png" alt="20251012193828"><br>易尘埃：可重复读</p>
<p>是 MySQL 默认的隔离级别，避免了“脏读”和“不可重复读”，通过 MVCC 和临键锁也能在一定程度上避免幻读。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Session A:</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">--返回500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Session B:</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span><span class="number">100</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Session A再次查询:</span></span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">--仍返回500(可重复读)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Session A更新后查询:</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span><span class="number">50</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">--基于最新值550更新为600 </span></span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">--返回600</span></span><br></pre></td></tr></table></figure>

<h4 id="什么是串行化？"><a href="#什么是串行化？" class="headerlink" title="什么是串行化？"></a>什么是串行化？</h4><p>串行化是最高的隔离级别，通过强制事务串行执行来解决“幻读”问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012193847.png" alt="20251012193847"><br>易尘埃：串行化</p>
<p>但会导致大量的锁竞争问题，实际应用中很少用。</p>
<h4 id="A-事务未提交，B-事务上查询到的是旧值还是新值？"><a href="#A-事务未提交，B-事务上查询到的是旧值还是新值？" class="headerlink" title="A 事务未提交，B 事务上查询到的是旧值还是新值？"></a>A 事务未提交，B 事务上查询到的是旧值还是新值？</h4><p>如果 B 是普通的 SELECT，也就是快照读，它读的是旧值，即事务 A 修改前的快照，并且不会阻塞；如果 B 是当前读，比如 <code>SELECT … FOR UPDATE</code>，它会被阻塞直到事务 A 提交或回滚。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话 A 中，更新王二的余额</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">8000</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"><span class="comment">-- 此时并没有 COMMIT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 B 中查询王二的余额</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"><span class="comment">-- 会话 B 会读取到 旧值 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话 C 中使用当前读查询王二的余额</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;王二&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 会话 C 会被阻塞，直到会话 A 提交或回滚</span></span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012193913.png" alt="20251012193913"><br>二哥的 Java 进阶之路：快照读和当前读的差别</p>
<h4 id="怎么更改事务的隔离级别？"><a href="#怎么更改事务的隔离级别？" class="headerlink" title="怎么更改事务的隔离级别？"></a>怎么更改事务的隔离级别？</h4><p>MySQL 支持通过 SET 语句修改事务隔离级别，包括全局级别、当前会话，但一般不建议在生产环境中随意修改隔离级别。</p>
<p>测试环境下可以使用 <code>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code> 可以修改当前会话的隔离级别。</p>
<p>使用 <code>SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</code> 可以修改全局隔离级别，影响新的连接，但不会改变现有会话。</p>
<h3 id="64-🌟请详细说说幻读呢？"><a href="#64-🌟请详细说说幻读呢？" class="headerlink" title="64.🌟请详细说说幻读呢？"></a>64.🌟请详细说说幻读呢？</h3><p>幻读是指在同一个事务中，多次执行相同的范围查询，结果却不同。这种现象通常发生在其他事务在两次查询之间插入或删除了符合当前查询条件的数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194100.png" alt="20251012194100"><br>Jenny：Phantom read</p>
<p>-— 这部分是帮助大家理解 start，面试中可以不背 —-</p>
<p>比如说事务 A 在第一次查询某个条件范围的数据行后，事务 B 插入了一条新数据且符合条件范围，事务 A 再次查询时，发现多了一条数据。</p>
<p>我们来验证一下，先创建测试表，插入测试数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `user_info` (</span><br><span class="line">  `id` <span class="type">BIGINT</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `gender` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `user_info` (`id`, `name`, `gender`, `email`) <span class="keyword">VALUES</span> </span><br><span class="line">  (<span class="number">1</span>, <span class="string">&#x27;Curry&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;curry@163.com&#x27;</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">&#x27;Wade&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;wade@163.com&#x27;</span>),</span><br><span class="line">  (<span class="number">3</span>, <span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;james@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们在事务 A 中执行查询 <code>SELECT * FROM user_info WHERE id &gt; 1;</code>，在事务 B 中插入数据 <code>INSERT INTO user_info (name, gender, email) VALUES (&#39;wanger&#39;, &#39;女&#39;, &#39;wanger@163.com&#39;);</code>，再在事务 A 中修改刚刚插入的数据 <code>update user_info set gender=&#39;男&#39; where id = 4;</code>，最后在事务 A 中再次查询 <code>SELECT * FROM user_info WHERE id &gt; 1;</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194118.png" alt="20251012194118"><br>二哥的 Java 进阶之路：可以发现产生幻读了</p>
<p>-— 这部分是帮助大家理解 end，面试中可以不背 —-</p>
<h4 id="如何避免幻读？"><a href="#如何避免幻读？" class="headerlink" title="如何避免幻读？"></a>如何避免幻读？</h4><p>MySQL 在可重复读隔离级别下，通过 MVCC 和临键锁可以在一定程度上避免幻读。</p>
<p>比如说在查询时显示加锁，利用临键锁锁定查询范围，防止其他事务插入新的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">SELECT * FROM user_info WHERE id &gt; 1 FOR UPDATE; -- 加临键锁</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>其他事务在插入数据时，会被阻塞，直到当前事务提交或回滚。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194134.png" alt="20251012194134"><br>二哥的 Java 进阶之路：临键锁能防止幻读</p>
<p>-— 这部分是帮助大家理解 start，面试中可以不背 —-</p>
<p>解释一下。</p>
<p>如果查询语句中包含显式加锁（如 <code>FOR UPDATE</code>），InnoDB 会使用当前读，直接读取最新的数据，并加锁。</p>
<p>在范围查询时，InnoDB 不仅会对符合条件的记录加行锁，还会对相邻的索引间隙加间隙锁，从而形成临键锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194152.png" alt="20251012194152"><br>转转技术：临键锁</p>
<p>临键锁可以防止其他事务在间隙中插入新数据，从而避免幻读。</p>
<p>-— 这部分是帮助大家理解 end，面试中可以不背 —-</p>
<p>比如说在执行查询的事务中，不要尝试去更新其他事务插入&#x2F;删除的数据，利用快照读来避免幻读。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194203.png" alt="20251012194203"><br>二哥的 Java 进阶之路：只用快照读</p>
<p>-— 这部分是帮助大家理解 start，面试中可以不背 —-</p>
<p>使用 SELECT 查询时，如果没有显式加锁，InnoDB 会使用 MVCC 提供一致性视图。</p>
<p>每个事务在启动时都会生成一个 Read View，用来确定哪些数据对当前事务可见。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194215.png" alt="20251012194215"><br>Keep It Simple：Read View</p>
<p>其他事务在当前事务启动后插入的新数据不会被当前事务看到，因此不会出现幻读。</p>
<p>-— 这部分是帮助大家理解 end，面试中可以不背 —-</p>
<h4 id="什么是当前读呢？"><a href="#什么是当前读呢？" class="headerlink" title="什么是当前读呢？"></a>什么是当前读呢？</h4><p>当前读是指读取记录的最新已提交版本，并且在读取时对记录加锁，确保其他并发事务不能修改当前记录。</p>
<p>比如 <code>SELECT ... LOCK IN SHARE MODE</code>、<code>SELECT ... FOR UPDATE</code>，以及 UPDATE、DELETE，都属于当前读。</p>
<h4 id="为什么-UPDATE-和-DELETE-也属于当前读？"><a href="#为什么-UPDATE-和-DELETE-也属于当前读？" class="headerlink" title="为什么 UPDATE 和 DELETE 也属于当前读？"></a>为什么 UPDATE 和 DELETE 也属于当前读？</h4><p>因为更新、删除这些操作，本质上不仅是写操作，还需要在写之前读取数据，然后才能修改或删除。为了保证修改的是最新的数据，并防止并发冲突，InnoDB 必须读取最新版本的数据并加锁，因此 UPDATE 和 DELETE 也属于当前读。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194240.png" alt="20251012194240"><br>溪水静幽：当前读</p>
<table>
<thead>
<tr>
<th>SQL语句</th>
<th>是否当前读</th>
<th>是否加锁</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT * FROM user WHERE id=1</code></td>
<td>❌ 否</td>
<td>❌ 否</td>
</tr>
<tr>
<td><code>SELECT * FROM user WHERE id=1</code> FOR UPDATE</td>
<td>✅ 是</td>
<td>✅ 加排他锁</td>
</tr>
<tr>
<td><code>SELECT * FROM user WHERE id=1 LOCK IN SHARE MODE</code></td>
<td>✅ 是</td>
<td>✅ 加共享锁</td>
</tr>
<tr>
<td><code>UPDATE user SET ... WHERE id=1</code></td>
<td>✅ 是</td>
<td>✅ 加排他锁</td>
</tr>
<tr>
<td><code>DELETE FROM user WHERE id=1</code></td>
<td>✅ 是</td>
<td>✅ 加排他锁</td>
</tr>
</tbody></table>
<h4 id="什么是快照读呢？"><a href="#什么是快照读呢？" class="headerlink" title="什么是快照读呢？"></a>什么是快照读呢？</h4><p>快照读是 InnoDB 通过 MVCC 实现的一种非阻塞读方式。当事务执行 SELECT 查询时，InnoDB 并不会直接读当前最新的数据，而是根据事务开始时生成的 Read View 去判断每条记录的可见性，从而读取符合条件的历史版本。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194259.png" alt="20251012194259"><br>爱吃鱼饼的猫：快照读</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>是否快照读？</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT * FROM t WHERE id=1</code></td>
<td>✅ 是</td>
<td>快照读</td>
</tr>
<tr>
<td><code>SELECT * FROM t WHERE id=1 FOR UPDATE</code></td>
<td>❌ 否</td>
<td>当前读，读取最新版本并加锁</td>
</tr>
<tr>
<td><code>UPDATE / DELETE</code></td>
<td>❌ 否</td>
<td>当前读，必须读取当前版本并加锁</td>
</tr>
<tr>
<td><code>INSERT</code></td>
<td>❌ 否</td>
<td>写操作，不存在历史版本</td>
</tr>
</tbody></table>
<h3 id="65-🌟MVCC-了解吗？"><a href="#65-🌟MVCC-了解吗？" class="headerlink" title="65.🌟MVCC 了解吗？"></a>65.🌟MVCC 了解吗？</h3><p>MVCC 指的是多版本并发控制，每次修改数据时，都会生成一个新的版本，而不是直接在原有数据上进行修改。并且每个事务只能看到在它开始之前已经提交的数据版本。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194321.png" alt="20251012194321"><br>天瑕：undo log 版本链和 ReadView</p>
<p>这样的话，读操作就不会阻塞写操作，写操作也不会阻塞读操作，从而避免加锁带来的性能损耗。</p>
<p>其底层实现主要依赖于 Undo Log 和 Read View。</p>
<p>每次修改数据前，先将记录拷贝到Undo Log，并且每条记录会包含三个隐藏列，DB_TRX_ID 用来记录修改该行的事务 ID，DB_ROLL_PTR 用来指向 Undo Log 中的前一个版本，DB_ROW_ID 用来唯一标识该行数据（仅无主键时生成）。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194333.png" alt="20251012194333"><br>guozhchun：额外的存储信息</p>
<p>每次读取数据时，都会生成一个 ReadView，其中记录了当前活跃事务的 ID 集合、最小事务 ID、最大事务 ID 等信息，通过与 DB_TRX_ID 进行对比，判断当前事务是否可以看到该数据版本。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194342.png" alt="20251012194342"><br>luozhiyun：ReadView</p>
<h4 id="请详细说说什么是版本链？"><a href="#请详细说说什么是版本链？" class="headerlink" title="请详细说说什么是版本链？"></a>请详细说说什么是版本链？</h4><p>版本链是指 InnoDB 中同一条记录的多个历史版本，通过 DB_ROLL_PTR 字段将它们像链表一样串起来，用来支持 MVCC 的快照读。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194355.png" alt="20251012194355"><br>二哥的 Java 进阶之路：版本链</p>
<p>假设有一张<code>hero</code>表，表中有这样一行记录，name 为张三，city 为帝都，插入这行记录的事务 id 是 80。</p>
<p>此时，<code>DB_TRX_ID</code>的值就是 80，<code>DB_ROLL_PTR</code>的值就是指向这条 insert undo 日志的指针。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194406.png" alt="20251012194406"><br>三分恶面渣逆袭：DB_ROLL_PTR</p>
<p>接下来，如果有两个<code>DB_TRX_ID</code>分别为<code>100</code>、<code>200</code>的事务对这条记录进行了<code>update</code>操作，那么这条记录的版本链就会变成下面这样：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194414.png" alt="20251012194414"><br>三分恶面渣逆袭：update 操作</p>
<p>也就是说，当更新一行数据时，InnoDB 不会直接覆盖原有数据，而是创建一个新的数据版本，并更新 DB_TRX_ID 和 DB_ROLL_PTR，使它们指向前一个版本和相关的 undo 日志。</p>
<p>这样，老版本的数据就不会丢失，可以通过版本链找到。</p>
<p>由于 undo 日志会记录每一次的 update，并且新插入的行数据会记录上一条 undo 日志的指针，所以可以通过 DB_ROLL_PTR 这个指针找到上一条记录，这样就形成了一个版本链。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194427.png" alt="20251012194427"><br>三分恶面渣逆袭：版本链</p>
<h4 id="请详细说说什么是ReadView？"><a href="#请详细说说什么是ReadView？" class="headerlink" title="请详细说说什么是ReadView？"></a>请详细说说什么是ReadView？</h4><p>ReadView 是 InnoDB 为每个事务创建的一份“可见性视图”，用于判断在执行快照读时，哪些数据版本是当前这个事务可以看到的，哪些不能看到。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194443.png" alt="20251012194443"><br>二哥的 Java 进阶之路：ReadView</p>
<p>当事务开始执行时，InnoDB 会为该事务创建一个 ReadView，这个 ReadView 会记录 4 个重要的信息：</p>
<ul>
<li>creator_trx_id：创建该 ReadView 的事务 ID。</li>
<li>m_ids：所有活跃事务的 ID 列表，活跃事务是指那些已经开始但尚未提交的事务。</li>
<li>min_trx_id：所有活跃事务中最小的事务 ID。它是 m_ids 数组中最小的事务 ID。</li>
<li>max_trx_id ：事务 ID 的最大值加一。换句话说，它是下一个将要生成的事务 ID。</li>
</ul>
<h4 id="ReadView-是如何判断记录的某个版本是否可见的？"><a href="#ReadView-是如何判断记录的某个版本是否可见的？" class="headerlink" title="ReadView 是如何判断记录的某个版本是否可见的？"></a>ReadView 是如何判断记录的某个版本是否可见的？</h4><p>会通过三个步骤来判断：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194516.png" alt="20251012194516"><br>二哥的 Java 进阶之路：ReadView判断规则</p>
<p>①、如果某个数据版本的 DB_TRX_ID 小于 min_trx_id，则该数据版本在生成 ReadView 之前就已经提交，因此对当前事务是可见的。</p>
<p>②、如果 DB_TRX_ID 大于 max_trx_id，则表示创建该数据版本的事务在生成 ReadView 之后开始，因此对当前事务不可见。</p>
<p>③、如果 DB_TRX_ID 在 min_trx_id 和 max_trx_id 之间，需要判断 DB_TRX_ID 是否在 m_ids 列表中：</p>
<ul>
<li>不在，表示创建该数据版本的事务在生成 ReadView 之后已经提交，因此对当前事务也是可见的。</li>
<li>在，表示事务仍然活跃，或者在当前事务生成 ReadView 之后才开始，因此是不可见的。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194526.png" alt="20251012194526"><br>小许 code：可见性匹配规则</p>
<p>举个实际的例子。</p>
<p>读事务开启了一个 ReadView，这个 ReadView 里面记录了当前活跃事务的 ID 列表（444、555、665），以及最小事务 ID（444）和最大事务 ID（666）。当然还有自己的事务 ID 520，也就是 creator_trx_id。</p>
<p>它要读的这行数据的写事务 ID 是 x，也就是 DB_TRX_ID。</p>
<ul>
<li>如果 x &#x3D; 110，显然在 ReadView 生成之前就提交了，所以这行数据是可见的。</li>
<li>如果 x &#x3D; 667，显然是未知世界，所以这行数据对读操作是不可见的。</li>
<li>如果 x &#x3D; 519，虽然 519 大于 444 小于 666，但是 519 不在活跃事务列表里，所以这行数据是可见的。因为 519 是在 520 生成 ReadView 之前就提交了。</li>
<li>如果 x &#x3D; 555，虽然 555 大于 444 小于 666，但是 555 在活跃事务列表里，所以这行数据是不可见的。因为 555 不确定有没有提交。</li>
</ul>
<h4 id="可重复读和读已提交在-ReadView-上的区别是什么？"><a href="#可重复读和读已提交在-ReadView-上的区别是什么？" class="headerlink" title="可重复读和读已提交在 ReadView 上的区别是什么？"></a>可重复读和读已提交在 ReadView 上的区别是什么？</h4><p>可重复读：在第一次读取数据时生成一个 ReadView，这个 ReadView 会一直保持到事务结束，这样可以保证在事务中多次读取同一行数据时，读取到的数据是一致的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012194544.png" alt="20251012194544"><br>程序员x：readview 在可重复读和读已提交下的不同</p>
<p>读已提交：每次读取数据前都生成一个 ReadView，这样就能保证每次读取的数据都是最新的。</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="http://xiaoyuge.work/mysql-innodb-mvcc/index.html">搞懂Mysql之InnoDB MVCC</a></p>
<h4 id="如果两个-AB-事务并发修改一个变量，那么-A-读到的值是什么，怎么分析。"><a href="#如果两个-AB-事务并发修改一个变量，那么-A-读到的值是什么，怎么分析。" class="headerlink" title="如果两个 AB 事务并发修改一个变量，那么 A 读到的值是什么，怎么分析。"></a>如果两个 AB 事务并发修改一个变量，那么 A 读到的值是什么，怎么分析。</h4><p>事务 A 在读取时是否能读到事务 B 的修改，取决于 A 是快照读还是当前读。如果是快照读，InnoDB 会使用 MVCC 的 ReadView 判断记录版本是否可见，若事务 B 尚未提交或在 A 的视图不可见，则 A 会读到旧值；如果是当前读，则需要加锁，若 B 已提交可直接读取，否则 A 会阻塞直到 B 结束。</p>
<h3 id="70-🌟你们一般是怎么分库的呢？"><a href="#70-🌟你们一般是怎么分库的呢？" class="headerlink" title="70.🌟你们一般是怎么分库的呢？"></a>70.🌟你们一般是怎么分库的呢？</h3><p>分库的策略有两种，第一种是垂直分库：按照业务模块将不同的表拆分到不同的库中，比如说用户、登录、权限等表放在用户库中，商品、分类、库存放在商品库中，优惠券、满减、秒杀放在活动库中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012195251.png" alt="20251012195251"><br>三分恶面渣逆袭：垂直分库</p>
<p>第二种是水平分库：按照一定的策略将一个表中的数据拆分到多个库中，比如哈希分片和范围分片，对用户 id 进行取模运算或者范围划分，将数据分散到不同的库中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012195301.png" alt="20251012195301"><br>三分恶面渣逆袭：水平分库</p>
<p>贴一段使用 ShardingSphere 的 inline 算法定义分片规则：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="type">!SHARDING</span></span><br><span class="line">  <span class="attr">tables:</span></span><br><span class="line">    <span class="attr">order:</span></span><br><span class="line">      <span class="attr">actualDataNodes:</span> <span class="string">db_$&#123;0..3&#125;.order_$&#123;0..15&#125;</span></span><br><span class="line">      <span class="attr">databaseStrategy:</span></span><br><span class="line">        <span class="attr">standard:</span></span><br><span class="line">          <span class="attr">shardingColumn:</span> <span class="string">user_id</span></span><br><span class="line">          <span class="attr">shardingAlgorithmName:</span> <span class="string">db_hash_mod</span></span><br><span class="line">      <span class="attr">tableStrategy:</span></span><br><span class="line">        <span class="attr">standard:</span></span><br><span class="line">          <span class="attr">shardingColumn:</span> <span class="string">order_time</span></span><br><span class="line">          <span class="attr">shardingAlgorithmName:</span> <span class="string">table_interval_yearly</span></span><br><span class="line">  <span class="attr">shardingAlgorithms:</span></span><br><span class="line">    <span class="attr">db_hash_mod:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">HASH_MOD</span></span><br><span class="line">      <span class="attr">props:</span></span><br><span class="line">        <span class="attr">sharding-count:</span> <span class="number">4</span></span><br><span class="line">    <span class="attr">table_interval_yearly:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">INTERVAL</span></span><br><span class="line">      <span class="attr">props:</span></span><br><span class="line">        <span class="attr">datetime-pattern:</span> <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span></span><br><span class="line">        <span class="attr">datetime-lower:</span> <span class="string">&#x27;2024-01-01 00:00:00&#x27;</span></span><br><span class="line">        <span class="attr">datetime-upper:</span> <span class="string">&#x27;2025-01-01 00:00:00&#x27;</span></span><br><span class="line">        <span class="attr">sharding-suffix-pattern:</span> <span class="string">&#x27;yyyy&#x27;</span></span><br><span class="line">        <span class="attr">datetime-interval-amount:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">datetime-interval-unit:</span> <span class="string">&#x27;Years&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="71-🌟那你们是怎么分表的？"><a href="#71-🌟那你们是怎么分表的？" class="headerlink" title="71.🌟那你们是怎么分表的？"></a>71.🌟那你们是怎么分表的？</h3><p>当单表超过 500 万条数据，就可以考虑水平分表了。比如说我们可以将文章表拆分成多个表，如 article_0、article_9999、article_19999 等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012195335.png" alt="20251012195335"><br>三分恶面渣逆袭：表拆分</p>
<p>在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，我们将文章的基本信息和内容详情做了垂直分表处理，因为文章的内容会占用比较大的空间，在只需要查看文章基本信息时把文章详情也带出来的话，就会占用更多的网络 IO 和内存导致查询变慢；而文章的基本信息，如标题、作者、状态等信息占用的空间较小，很适合不需要查询文章详情的场景。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251012195346.png" alt="20251012195346"><br>二哥的 Java 进阶之路：文章和详情垂直分表</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1-🌟说说什么是-Redis"><a href="#1-🌟说说什么是-Redis" class="headerlink" title="1.🌟说说什么是 Redis?"></a>1.🌟说说什么是 Redis?</h3><p><code>Redis</code> 是一种基于键值对的 <code>NoSQL</code> 数据库。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250725112831.png" alt="20250725112831"></p>
<p>它主要的特点是把数据放在<code>内存</code>当中，相比直接访问磁盘的关系型数据库，<strong>读写速度会快很多</strong>，基本上能达到微秒级的响应。</p>
<p>所以在一些对<code>性能要求很高</code>的场景，比如<strong>缓存热点数据、防止接口爆刷</strong>，都会用到 Redis。</p>
<p>不仅如此，Redis 还<code>支持持久化</code>，可以将内存中的数据异步落盘，以便服务宕机重启后能恢复数据。</p>
<h4 id="Redis-和-MySQL-的区别？"><a href="#Redis-和-MySQL-的区别？" class="headerlink" title="Redis 和 MySQL 的区别？"></a>Redis 和 MySQL 的区别？</h4><p>Redis 属于<strong>非关系型数据库</strong>，数据是通过<code>键值对</code>的形式放在内存当中的；MySQL 属于<strong>关系型数据库</strong>，数据以<code>行和列的形式</code>存储在磁盘当中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250725112927.png" alt="20250725112927"></p>
<p>实际开发中，会将 <code>MySQL</code> 作为主存储，<code>Redis</code> 作为缓存，通过先查 <code>Redis</code>，未命中再查 <code>MySQL</code> 并写回<code>Redi</code>s 的方式来提高系统的整体性能。</p>
<h4 id="TecHub项目里哪里用到了-Redis？"><a href="#TecHub项目里哪里用到了-Redis？" class="headerlink" title="TecHub项目里哪里用到了 Redis？"></a>TecHub项目里哪里用到了 Redis？</h4><p>在TecHub实战项目当中，有很多地方都用到了 Redis，比如说<code>用户活跃排行榜</code>用到了 <code>zset</code>，<code>作者白名单</code>用到了 <code>set</code>。<br>还有用户登录后的 <code>Session</code>、站点地图 <code>SiteMap</code>，分别用到了 Redis 的字符串和哈希表两种数据类型。<br>其中比较有挑战性的一个应用是，通过 Lua 脚本封装 Redis 的 setnex 命令来实现<strong>分布式锁</strong>，以保证在高并发场景下，热点文章在短时间内的高频访问不会击穿 MySQL。</p>
<h4 id="部署过-Redis-吗？"><a href="#部署过-Redis-吗？" class="headerlink" title="部署过 Redis 吗？"></a>部署过 Redis 吗？</h4><p>第一种回答版本：</p>
<p>我只在本地部署过单机版，下载 Redis 的安装包，解压后运行 <code>redis-server</code> 命令即可。</p>
<p>第二种回答版本：</p>
<p>我有在生产环境中部署单机版 Redis，从官网下载源码包解压后执行 <code>make &amp;&amp; make install</code> 编译安装。然后编辑 <code>redis.conf</code> 文件，开启远程访问、设置密码、限制内存、设置内存过期淘汰策略、开启 AOF 持久化等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0        # 允许远程访问</span><br><span class="line">requirepass your_password  # 设置密码</span><br><span class="line">maxmemory 4gb      # 限制内存，避免 OOM</span><br><span class="line">maxmemory-policy allkeys-lru  # 内存淘汰策略</span><br><span class="line">appendonly yes     # 开启 AOF 持久化</span><br></pre></td></tr></table></figure>

<p>第三种回答版本：</p>
<p>我有使用 Docker 拉取 Redis 镜像后进行容器化部署。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 redis:7.0-alpine</span><br></pre></td></tr></table></figure>
<h4 id="Redis-的高可用方案有部署过吗？"><a href="#Redis-的高可用方案有部署过吗？" class="headerlink" title="Redis 的高可用方案有部署过吗？"></a>Redis 的高可用方案有部署过吗？</h4><p>有部署过<strong>哨兵机制</strong>，这是一个相对成熟的<strong>高可用解决方案</strong>，我们生产环境部署的是一主两从的 Redis 实例，再加上三个 <code>Sentinel</code> 节点监控它们。<code>Sentinel</code> 的配置相对简单，主要设置了<strong>故障转移的判定条件</strong>和<strong>超时阈值</strong>。</p>
<p>主节点配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">appendonly yes&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>从节点配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 192.168.1.10 6379&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>哨兵节点配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.1.10 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure>

<p>当主节点发生故障时，<code>Sentinel</code> 能够自动检测并协商选出新的主节点，这个过程大概需要 <code>10-15</code> 秒。</p>
<p>另一个大型项目中，我们使用了 <code>Redis Cluster</code> 集群方案。该项目数据量大且增长快，需要水平扩展能力。我们部署了 6 个主节点，每个主节点配备一个从节点，形成了一个 3主3从 的初始集群。<code>Redis Cluster</code> 的设置比<code>Sentinel</code> 复杂一些，需要正确配置<strong>集群节点间通信</strong>、<strong>分片映射</strong>等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 redis-cli 创建集群</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis 会自动将 key 哈希到 16384 个槽位</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主节点均分槽位，从节点自动跟随</span></span><br><span class="line">redis-cli --cluster create \</span><br><span class="line"> 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \</span><br><span class="line"> 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \</span><br><span class="line"> --cluster-replicas 1</span><br></pre></td></tr></table></figure>
<p><code>Redis Cluster</code> 最大的优势是<strong>数据自动分片</strong>，我们可以通过简单地增加节点来扩展集群容量。此外，它的<strong>故障转移也很快</strong>，通常在几秒内就能完成。</p>
<p>对于一些轻量级应用，我也使用过<code>主从复制</code>加<code>手动故障转移</code>的方案。<code>主节点负责读写操作</code>，<code>从节点负责读操作</code>。手动故障转移时，我们会<code>先将从节点提升为主节点</code>，然后重新配置其他从节点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1\. 取消从节点身份</span></span><br><span class="line">redis-cli -h &lt;slave-ip&gt; slaveof no one</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2\. 将其他从节点指向新的主节点</span></span><br><span class="line">redis-cli -h &lt;other-slave-ip&gt; slaveof &lt;new-master-ip&gt; &lt;port&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-🌟Redis有哪些数据类型？"><a href="#3-🌟Redis有哪些数据类型？" class="headerlink" title="3.🌟Redis有哪些数据类型？"></a>3.🌟Redis有哪些数据类型？</h3><p>Redis 支持五种基本数据类型，分别是<code>字符串</code>、<code>列表</code>、<code>哈希</code>、<code>集合</code>和<code>有序集合</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811101352.png" alt="20250811101352"></p>
<p>还有三种扩展数据类型，分别是用于位级操作的 Bitmap、用于基数估算的 HyperLogLog、支持存储和查询地理坐标的 GEO。</p>
<h4 id="详细介绍下字符串？"><a href="#详细介绍下字符串？" class="headerlink" title="详细介绍下字符串？"></a>详细介绍下字符串？</h4><p>字符串是最基本的数据类型，可以存储文本、数字或者二进制数据，最大容量是 <code>512 MB</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811102451.png" alt="20250811102451"></p>
<p>适合缓存单个对象，比如验证码、token、计数器等。</p>
<h4 id="详细介绍下列表？"><a href="#详细介绍下列表？" class="headerlink" title="详细介绍下列表？"></a>详细介绍下列表？</h4><p>列表是一个有序的元素集合，支持从头部或尾部插入&#x2F;删除元素，常用于消息队列或任务列表。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811102931.png" alt="20250811102931"></p>
<h4 id="详细介绍下哈希？"><a href="#详细介绍下哈希？" class="headerlink" title="详细介绍下哈希？"></a>详细介绍下哈希？</h4><p>哈希是一个键值对集合，适合存储对象，如商品信息、用户信息等。比如说 <code>value = &#123;name: &#39;沉默王二&#39;, age: 18&#125;</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103014.png" alt="20250811103014"></p>
<h4 id="详细介绍下集合？"><a href="#详细介绍下集合？" class="headerlink" title="详细介绍下集合？"></a>详细介绍下集合？</h4><p>集合是无序且不重复的，支持交集、并集操作，查询效率能达到 O(1) 级别，主要用于去重、标签、共同好友等场景。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103028.png" alt="20250811103028"></p>
<h4 id="详细介绍下有序集合？"><a href="#详细介绍下有序集合？" class="headerlink" title="详细介绍下有序集合？"></a>详细介绍下有序集合？</h4><p>有序集合的元素按分数进行排序，支持范围查询，适用于排行榜或优先级队列。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103046.png" alt="20250811103046"></p>
<h4 id="详细介绍下Bitmap？"><a href="#详细介绍下Bitmap？" class="headerlink" title="详细介绍下Bitmap？"></a>详细介绍下Bitmap？</h4><p>Bitmap 可以把一组二进制位紧凑地存储在一块连续内存中，每一位代表一个对象的状态，比如是否签到、是否活跃等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103101.png" alt="20250811103101"></p>
<p>比如用户 0 的已签到 1、用户 1 未签到 0、用户 2 已签到，Redis 就会把这些状态放进一个连续的二进制串 101，1 亿用户签到仅需 100,000,000 &#x2F; 8 &#x2F; 1024 ≈ 12MB 的空间，真的省到离谱。</p>
<h4 id="详细介绍下HyperLogLog？"><a href="#详细介绍下HyperLogLog？" class="headerlink" title="详细介绍下HyperLogLog？"></a>详细介绍下HyperLogLog？</h4><p>HyperLogLog 是一种用于基数统计的概率性数据结构，可以在仅有 12KB 的内存空间下，统计海量数据集中不重复元素的个数，误差率仅 0.81%。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103115.png" alt="20250811103115"></p>
<p>底层基于 LogLog 算法改进，先把每个元素哈希成一个二进制串，然后取前 14 位进行分组，放到 16384 个桶中，记录每组最大的前导零数量，最后用一个近似公式推算出总体的基数。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103129.png" alt="20250811103129"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103146.png" alt="20250811103146"></p>
<p>可以发现，哈希值越长前导零越多，也就说明集合里的元素越多。</p>
<p>大型网站 UV 统计系统示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UVCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordVisit</span><span class="params">(String date, String userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;uv:&quot;</span> + date;</span><br><span class="line">        jedis.pfadd(key, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getUV</span><span class="params">(String date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedis.pfcount(<span class="string">&quot;uv:&quot;</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getUVBetween</span><span class="params">(String startDate, String endDate)</span> &#123;</span><br><span class="line">        List&lt;String&gt; keys = getDateKeys(startDate, endDate);</span><br><span class="line">        <span class="keyword">return</span> jedis.pfcount(keys.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="详细介绍下GEO？"><a href="#详细介绍下GEO？" class="headerlink" title="详细介绍下GEO？"></a>详细介绍下GEO？</h4><p>GEO 用于存储和查询地理位置信息，可以用来计算两点之间的距离，查找某位置半径内的其他元素。</p>
<p>常见的应用场景包括：附近的人或者商家、计算外卖员和商家的距离、判断用户是否进入某个区域等。</p>
<p>底层基于 ZSet 实现，通过 Geohash 算法把经纬度编码成 score。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103203.png" alt="20250811103203"></p>
<p>比如说查询附近的商家时，Redis 会根据中心点经纬度反推可能的 Geohash 范围， 在 ZSet 上做范围查询，拿到候选点后，用 Haversine 公式精确计算球面距离，筛选出最终符合要求的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NearbyShopService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHOP_KEY</span> <span class="operator">=</span> <span class="string">&quot;shops:geo&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加商铺</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShop</span><span class="params">(String shopId, <span class="type">double</span> longitude, <span class="type">double</span> latitude)</span> &#123;</span><br><span class="line">        jedis.geoadd(SHOP_KEY, longitude, latitude, shopId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询附近的商铺</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GeoRadiusResponse&gt; <span class="title function_">getNearbyShops</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="type">double</span> longitude, </span></span><br><span class="line"><span class="params">            <span class="type">double</span> latitude, </span></span><br><span class="line"><span class="params">            <span class="type">double</span> radiusKm)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedis.georadius(SHOP_KEY, </span><br><span class="line">                             longitude, </span><br><span class="line">                             latitude, </span><br><span class="line">                             radiusKm, </span><br><span class="line">                             GeoUnit.KM, </span><br><span class="line">                             GeoRadiusParam.geoRadiusParam()</span><br><span class="line">                                         .withCoord()</span><br><span class="line">                                         .withDist()</span><br><span class="line">                                         .sortAscending()</span><br><span class="line">                                         .count(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算两个商铺之间的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getShopDistance</span><span class="params">(String shop1Id, String shop2Id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedis.geodist(SHOP_KEY, </span><br><span class="line">                           shop1Id, </span><br><span class="line">                           shop2Id, </span><br><span class="line">                           GeoUnit.KILOMETERS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么使用-hash-类型而不使用-string-类型序列化存储？"><a href="#为什么使用-hash-类型而不使用-string-类型序列化存储？" class="headerlink" title="为什么使用 hash 类型而不使用 string 类型序列化存储？"></a>为什么使用 hash 类型而不使用 string 类型序列化存储？</h4><p>为什么使用 hash 类型而不使用 string 类型序列化存储？<br>Hash 可以只读取或者修改某一个字段，而 String 需要一次性把整个对象取出来。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103219.png" alt="20250811103219"></p>
<p>比如说有一个用户对象 user &#x3D; {name: ‘沉默王二’, age: 18}，如果使用 Hash 存储，可以直接修改 age 字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<p>如果使用 String 存储，需要先取出整个对象，修改后再存回去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> redis.get(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(userJson, User.class);</span><br><span class="line">user.setAge(<span class="number">19</span>);</span><br><span class="line">redis.set(<span class="string">&quot;user:1&quot;</span>, JSON.toJSONString(user));</span><br></pre></td></tr></table></figure>

<h3 id="4-🌟Redis-为什么快呢？"><a href="#4-🌟Redis-为什么快呢？" class="headerlink" title="4.🌟Redis 为什么快呢？"></a>4.🌟Redis 为什么快呢？</h3><p>第一，Redis 的所有数据都放在内存中，而内存的读写速度本身就比磁盘快几个数量级。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205152.png" alt="20250912205152"></p>
<p>第二，Redis 采用了基于 IO 多路复用技术的事件驱动模型来处理客户端请求和执行 <code>Redis</code> 命令。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205641.png" alt="20250912205641"></p>
<p>其中的 IO 多路复用技术可以在只有一个线程的情况下，同时监听成千上万个客户端连接，解决传统 IO 模型中每个连接都需要一个独立线程带来的性能开销。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205919.png" alt="20250912205919"></p>
<p>Redis 会根据操作系统选择最优的 IO 多路复用技术，比如 Linux 下使用 epoll，macOS 下使用 kqueue 等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll 的创建和使用</span></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">1024</span>); <span class="comment">// 创建 epoll 实例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加监听事件</span></span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = listen_sock;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listen_sock, &amp;ev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件发生</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">        <span class="comment">// 处理就绪的文件描述符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Redis 6.0 之前，包括连接建立、请求读取、响应发送，以及命令执行都是在主线程中顺序执行的，这样可以避免多线程环境下的锁竞争和上下文切换，因为 Redis 的绝大部分操作都是在内存中进行的，性能瓶颈主要是<strong>内存操作</strong>和<strong>网络通信</strong>，而不是 CPU。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912210551.png" alt="20250912210551"></p>
<p>为了进一步解决网络 IO 的性能瓶颈，Redis 6.0 引入了多线程机制，把网络 IO 和命令执行分开，网络 IO 交给线程池来处理，而命令执行仍然在主线程中进行，这样就可以充分利用多核 CPU 的性能。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912210654.png" alt="20250912210654"></p>
<p>主线程专注于命令执行，网络IO 由其他线程分担，在多核 CPU 环境下，Redis 的性能可以得到显著提升。</p>
<p>(有点像单片机的中断机制,保持主线程专注核心任务，让IO操作在后台异步处理，既保证了性能又保证了数据一致性。)</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211024.png" alt="20250912211024"></p>
<p>第三，Redis 对底层数据结构做了极致的优化，比如说 String 的底层数据结构动态字符串支持动态扩容、预分配冗余空间，能够减少内存碎片和内存分配的开销。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211154.png" alt="20250912211154"></p>
<p>总结:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211332.png" alt="20250912211332"></p>
<h3 id="10-🌟Redis的持久化方式有哪些？"><a href="#10-🌟Redis的持久化方式有哪些？" class="headerlink" title="10.🌟Redis的持久化方式有哪些？"></a>10.🌟Redis的持久化方式有哪些？</h3><p>主要有两种，RDB 和 AOF。RDB 通过创建时间点快照来实现持久化，AOF 通过记录每个写操作命令来实现持久化。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928161918.png" alt="20250928161918"><br>三分恶面渣逆袭：Redis持久化的两种方式</p>
<p>这两种方式可以单独使用，也可以同时使用。这样就可以保证 Redis 服务器在重启后不丢失数据，通过 <code>RDB</code> 和 <code>AOF</code> 文件来恢复内存中原有的数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928162003.png" alt="20250928162003"><br>Gaurav：RDB 和 AOF</p>
<h4 id="详细说一下-RDB？"><a href="#详细说一下-RDB？" class="headerlink" title="详细说一下 RDB？"></a>详细说一下 RDB？</h4><p>RDB 持久化机制可以在指定的时间间隔内将 Redis 某一时刻的数据保存到磁盘上的 RDB 文件中，当 Redis 重启时，可以通过加载这个 RDB 文件来恢复数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928162408.png" alt="20250928162408"><br>Animesh Gaitonde：RDB</p>
<p>RDB 持久化可以通过 <code>save</code> 和 <code>bgsave</code> 命令手动触发，也可以通过配置文件中的 <code>save</code> 指令自动触发。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163257.png" alt="20250928163257"><br>三分恶面渣逆袭：save和bgsave</p>
<p>save 命令会阻塞 Redis 进程，直到 RDB 文件创建完成。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163337.png" alt="20250928163337"><br>二哥的 Java 进阶之路：手动执行 RDB</p>
<p>bgsave 命令会在后台 fork 一个子进程来执行 RDB 持久化操作，主进程不会被阻塞。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163355.png" alt="20250928163355"><br>Mr于：Redis bgsave</p>
<h4 id="什么情况下会自动触发-RDB-持久化？"><a href="#什么情况下会自动触发-RDB-持久化？" class="headerlink" title="什么情况下会自动触发 RDB 持久化？"></a>什么情况下会自动触发 RDB 持久化？</h4><p>第一种，在 Redis 配置文件中设置 RDB 持久化参数 <code>save &lt;seconds&gt; &lt;changes&gt;</code>，表示在指定时间间隔内，如果有指定数量的键发生变化，就会自动触发 RDB 持久化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1      # 900 秒（15 分钟）内有 1 个 key 发生变化，触发快照</span><br><span class="line">save 300 10     # 300 秒（5 分钟）内有 10 个 key 发生变化，触发快照</span><br><span class="line">save 60 10000   # 60 秒内有 10000 个 key 发生变化，触发快照</span><br></pre></td></tr></table></figure>

<p>第二种，主从复制时，当从节点第一次连接到主节点时，主节点会自动执行 bgsave 生成 RDB 文件，并将其发送给从节点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163542.png" alt="20250928163542"><br>达摩院的BLOG：Redis 主从复制时 RDB 自动生成</p>
<p>第三种，如果没有开启 AOF，执行 shutdown 命令时，Redis 会自动保存一次 RDB 文件，以确保数据不会丢失。</p>
<h4 id="详细说一下-AOF？"><a href="#详细说一下-AOF？" class="headerlink" title="详细说一下 AOF？"></a>详细说一下 AOF？</h4><p>AOF 通过记录每个写操作命令，并将其追加到 AOF 文件来实现持久化，Redis 服务器宕机后可以通过重新执行这些命令来恢复数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163946.png" alt="20250928163946"><br>Animesh Gaitonde：AOF</p>
<p>当 Redis 执行写操作时，会将写命令追加到 AOF 缓冲区；Redis 会根据同步策略将缓冲区的数据写入到 AOF 文件。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928164026.png" alt="20250928164026"><br>三分恶面渣逆袭：AOF工作流程</p>
<p>当 AOF 文件过大时，Redis 会自动进行 AOF 重写，剔除多余的命令，比如说多次对同一个 key 的 set 和 del，生成一个新的 AOF 文件；当 Redis 重启时，读取 AOF 文件中的命令并重新执行，以恢复数据。</p>
<h4 id="AOF-的刷盘策略了解吗？"><a href="#AOF-的刷盘策略了解吗？" class="headerlink" title="AOF 的刷盘策略了解吗？"></a>AOF 的刷盘策略了解吗？</h4><p>Redis 将 AOF 缓冲区的数据写入到 AOF 文件时，涉及两个系统调用：write 将数据写入到操作系统的缓冲区，fsync 将 OS 缓冲区的数据刷新到磁盘。</p>
<p>这里的刷盘涉及到三种策略：always、everysec 和 no。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928164208.png" alt="20250928164208"><br>bytebytego：Redis AOF 的刷盘策略</p>
<ul>
<li>always：每次写命令执行完，立即调用 fsync 同步到磁盘，这样可以保证数据不丢失，但性能较差。</li>
<li>everysec：每秒调用一次 fsync，将多条命令一次性同步到磁盘，性能较好，数据丢失的时间窗口为 1 秒。</li>
<li>no：不主动调用 fsync，由操作系统决定，性能最好，但数据丢失的时间窗口不确定，依赖于操作系统的缓存策略，可能会丢失大量数据。</li>
</ul>
<p>可以通过配置文件中的 appendfsync 参数进行设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync everysec  # 每秒 fsync 一次</span><br></pre></td></tr></table></figure>

<h4 id="说说AOF的重写机制？"><a href="#说说AOF的重写机制？" class="headerlink" title="说说AOF的重写机制？"></a>说说AOF的重写机制？</h4><p>由于 AOF 文件会随着写操作的增加而不断增长，为了解决这个问题， Redis 提供了重写机制来对 AOF 文件进行压缩和优化。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928165143.png" alt="20250928165143"><br>pdai.tech：AOF 文件瘦身</p>
<p>AOF 重写可以通过两种方式触发，第一种是手动执行 <code>BGREWRITEAOF</code> 命令，适用于需要立即减小AOF文件大小的场景。</p>
<p>第二种是在 Redis 配置文件中设置自动重写参数，比如说 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code>，表示当 AOF 文件大小超过指定值时，自动触发重写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  # 默认值100，表示当前AOF文件大小相比上次重写后大小增长了多少百分比时触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb  # 默认值64MB，表示AOF文件至少要达到这个大小才会考虑重写</span><br></pre></td></tr></table></figure>

<h4 id="AOF-重写的具体过程是怎样的？"><a href="#AOF-重写的具体过程是怎样的？" class="headerlink" title="AOF 重写的具体过程是怎样的？"></a>AOF 重写的具体过程是怎样的？</h4><p>Redis 在收到重写指令后，会创建一个子进程，并 fork 一份与父进程完全相同的数据副本，然后遍历内存中的所有键值对，生成重建它们所需的最少命令。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928165506.png" alt="20250928165506"><br>云烟成雨：Redis 的 AOF 重写机制</p>
<p>比如说多个 RPUSH 命令可以合并为一个带有多个参数的 RPUSH；</p>
<p>比如说一个键被设置后又被删除，这个键的所有操作都不会被写入新 AOF。</p>
<p>比如说使用 <code>SADD key member1 member2 member3</code> 代替多个单独的 <code>SADD key memberX</code>。</p>
<p>子进程在执行 AOF 重写的同时，主进程可以继续处理来自客户端的命令。</p>
<p>为了保证数据一致性，Redis 使用了 AOF 重写缓冲区机制，主进程在执行写操作时，会将命令同时写入旧的 AOF 文件和重写缓冲区。</p>
<p>等子进程完成重写后，会向主进程发送一个信号，主进程收到后将重写缓冲区中的命令追加到新的 AOF 文件中，然后调用操作系统的 rename，将旧的 AOF 文件替换为新的 AOF 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">主进程（fork）  </span><br><span class="line">   │  </span><br><span class="line">   ├─→ 子进程（生成新的 AOF 文件）  </span><br><span class="line">   │       │  </span><br><span class="line">   │       ├─→ 内存快照  </span><br><span class="line">   │       ├─→ 写入临时 AOF 文件  </span><br><span class="line">   │       ├─→ 通知主进程完成  </span><br><span class="line">   │  </span><br><span class="line">   ├─→ 主进程（追加缓冲区到新 AOF 文件）  </span><br><span class="line">   ├─→ 替换旧 AOF 文件  </span><br><span class="line">   ├─→ 重写完成</span><br></pre></td></tr></table></figure>

<p>AOF 重写期间，Redis 服务器会处于特殊状态：</p>
<ul>
<li>aof_child_pid 不为 0，表示有子进程在执行 AOF 重写</li>
<li>aof_rewrite_buf_blocks 链表不为空，存储 AOF 重写缓冲区内容</li>
</ul>
<p>如果在配置文件中设置 no-appendfsync-on-rewrite 为 yes，那么重写期间可能会暂停 AOF 文件的 fsync 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes                # 开启AOF</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;  # AOF文件名</span><br><span class="line">appendfsync everysec          # 写入磁盘策略</span><br><span class="line">no-appendfsync-on-rewrite no  # 重写期间是否临时关闭fsync</span><br><span class="line">auto-aof-rewrite-percentage 100   # AOF文件增长到原来多少百分比时触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb    # AOF文件最小多大时才允许重写</span><br></pre></td></tr></table></figure>

<h4 id="AOF-文件存储的是什么类型的数据？"><a href="#AOF-文件存储的是什么类型的数据？" class="headerlink" title="AOF 文件存储的是什么类型的数据？"></a>AOF 文件存储的是什么类型的数据？</h4><p>AOF 文件存储的是 Redis 服务器接收到的写命令数据，以 Redis 协议格式保存。</p>
<p>这种格式的特点是，每个命令以*开头，后跟参数的数量，每个参数前用<code>$</code>符号，后跟参数字节长度，然后是参数的实际内容。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095627.png" alt="20251016095627"><br>二哥的Java 进阶之路：AOF文件内容格式</p>
<h4 id="AOF重写期间命令可能会写入两次，会造成什么影响？"><a href="#AOF重写期间命令可能会写入两次，会造成什么影响？" class="headerlink" title="AOF重写期间命令可能会写入两次，会造成什么影响？"></a>AOF重写期间命令可能会写入两次，会造成什么影响？</h4><p>AOF 重写期间命令会同时写入现有AOF文件和重写缓冲区，这种机制是有意设计的，并不会导致数据重复或不一致问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095640.png" alt="20251016095640"><br>UStarGao：AOF 双写机制</p>
<p>因为新旧文件是分离的，现有命令写入当前 AOF 文件，重写缓冲区的命令最终写入新的 AOF 文件，完成后，新文件通过原子性的 rename 操作替换旧文件。两个文件是完全分离的，不会导致同一个 AOF 文件中出现重复命令。</p>
<h3 id="14-🌟Redis-4-0-的混合持久化了解吗？"><a href="#14-🌟Redis-4-0-的混合持久化了解吗？" class="headerlink" title="14.🌟Redis 4.0 的混合持久化了解吗？"></a>14.🌟Redis 4.0 的混合持久化了解吗？</h3><p>是的。</p>
<p>混合持久化结合了 RDB 和 AOF 两种方式的优点，解决了它们各自的不足。在 Redis 4.0 之前，我们要么面临 RDB 可能丢失数据的风险，要么承受 AOF 恢复慢的问题，很难两全其美。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928170958.png" alt="20250928170958"><br>Animesh Gaitonde：aof-use-rdb-preamble</p>
<p>混合持久化的工作原理非常巧妙：在 AOF 重写期间，先以 RDB 格式将内存中的数据快照保存到 AOF 文件的开头，再将重写期间的命令以 AOF 格式追加到文件末尾。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928171009.png" alt="20250928171009"><br>三分恶面渣逆袭：混合持久化</p>
<p>这样，当需要恢复数据时，Redis 先加载 RDB 格式的数据来快速恢复大部分的数据，然后通过重放命令恢复最近的数据，这样就能在保证数据完整性的同时，提升恢复速度。</p>
<h4 id="如何设置持久化模式？"><a href="#如何设置持久化模式？" class="headerlink" title="如何设置持久化模式？"></a>如何设置持久化模式？</h4><p>启用混合持久化的方式非常简单，只需要在配置文件中设置 <code>aof-use-rdb-preamble yes</code> 就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<h4 id="你在开发中是怎么配置-RDB-和-AOF-的？"><a href="#你在开发中是怎么配置-RDB-和-AOF-的？" class="headerlink" title="你在开发中是怎么配置 RDB 和 AOF 的？"></a>你在开发中是怎么配置 RDB 和 AOF 的？</h4><p>对于大多数生产环境，我倾向于使用混合持久化方式，结合 RDB 和 AOF 的优点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 启用AOF</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 使用混合持久化</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line"># 每秒同步一次AOF，平衡性能和安全性</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># AOF重写触发条件：文件增长100%且至少达到64MB</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># RDB备份策略</span><br><span class="line">save 900 1    # 15分钟内有1个修改</span><br><span class="line">save 300 10   # 5分钟内有10个修改</span><br><span class="line">save 60 10000 # 1分钟内有10000个修改</span><br></pre></td></tr></table></figure>

<p>对于单纯的缓存场景，或者本地开发，我会只启用 RDB，关闭 AOF：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 禁用AOF</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># 较宽松的RDB策略</span><br><span class="line">save 3600 1    # 1小时内有1个修改</span><br><span class="line">save 300 100   # 5分钟内有100个修改</span><br></pre></td></tr></table></figure>

<p>而对于金融类等高一致性的系统，我通常会在关键时间窗口动态将 <code>appendfsync</code> 设置为 <code>always</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 启用AOF</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 使用混合持久化</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line"># 每个命令都同步（谨慎使用，性能影响大）</span><br><span class="line"># 通常我会在关键时间窗口动态修改为always</span><br><span class="line">appendfsync always</span><br><span class="line"></span><br><span class="line"># 更频繁的RDB快照</span><br><span class="line">save 300 1     # 5分钟内有1个修改</span><br><span class="line">save 60 100    # 1分钟内有100个修改</span><br></pre></td></tr></table></figure>

<p>另外，对于高并发场景，应该设置<code>no-appendfsync-on-rewrite yes</code>，避免 AOF 重写影响主进程性能；对于大型实例，也应该设置 <code>rdb-save-incremental-fsync yes</code> 来减少大型 RDB 保存对性能的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># AOF重写期间不fsync，AOF 重写期间，主进程不会对新写入的 AOF 缓冲区执行 fsync 操作（即不强制刷盘），而是等重写结束后再统一刷盘。</span><br><span class="line">no-appendfsync-on-rewrite yes</span><br><span class="line"># RDB 快照保存时采用增量 fsync，即每写入一定量的数据就执行一次 fsync，将数据分批同步到磁盘。</span><br><span class="line">rdb-save-incremental-fsync yes</span><br></pre></td></tr></table></figure>


<h3 id="29-🌟什么是缓存击穿？"><a href="#29-🌟什么是缓存击穿？" class="headerlink" title="29.🌟什么是缓存击穿？"></a>29.🌟什么是缓存击穿？</h3><p>缓存击穿是指某个热点数据缓存过期时，大量请求就会穿透缓存直接访问数据库，导致数据库瞬间承受的压力巨大。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022093956.png" alt="20251022093956"><br>fengkui.net：缓存击穿</p>
<p>解决缓存击穿有两种常用的策略：</p>
<p>第一种是加互斥锁。当缓存失效时，第一个访问的线程先获取锁并负责重建缓存，其他线程等待或重试。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022094156.png" alt="20251022094156"><br>三分恶面渣逆袭：加锁更新</p>
<p>这种策略虽然会导致部分请求延迟，但实现起来相对简单。在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，我们就使用了 Redisson 的分布式锁来确保只有一个服务实例能更新缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;product::&quot;</span> + productId;</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock::&quot;</span> + productId);</span><br><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = database.queryProductById(productId);</span><br><span class="line">            cache.set(cacheKey, result, <span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 设置缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是永不过期策略。缓存项本身不设置过期时间，也就是永不过期，但在缓存值中维护一个逻辑过期时间。当缓存逻辑上过期时，返回旧值的同时，异步启动一个线程去更新缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">CacheItem</span> <span class="variable">item</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓存不存在，同步加载</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> db.query(key);</span><br><span class="line">        cache.set(key, <span class="keyword">new</span> <span class="title class_">CacheItem</span>(data, System.currentTimeMillis() + expireTime));</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.isLogicalExpired()) &#123;</span><br><span class="line">        <span class="comment">// 逻辑过期，异步刷新</span></span><br><span class="line">        asyncRefresh(key);</span><br><span class="line">        <span class="comment">// 返回旧数据</span></span><br><span class="line">        <span class="keyword">return</span> item.getData();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> item.getData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步刷新缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">asyncRefresh</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">    threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 重新查询数据库</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newData</span> <span class="operator">=</span> db.query(key);</span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        cache.set(key, <span class="keyword">new</span> <span class="title class_">CacheItem</span>(newData, System.currentTimeMillis() + expireTime));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>memo：2025 年 5 月 18 日修改至此，今天给<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">球友改简历时</a>，碰到一个西北工业大学的球友，这又是一所 985 院校，希望这个社群能把所有的 985 院校集齐，也希望去帮助到更多院校的同学，希望都能拿到一个满意的 offer。</p>
<h4 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h4><p>缓存穿透是指查询的数据在缓存中没有命中，因为数据压根不存在，所以请求会直接落到数据库上。如果这种查询非常频繁，就会给数据库造成很大的压力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022094922.png" alt="20251022094922"><br>fengkui.net：缓存穿透</p>
<p>缓存击穿是因为单个热点数据缓存失效导致的，而缓存穿透是因为查询的数据不存在，原因可能是自身的业务代码有问题，或者是恶意攻击造成的，比如爬虫。</p>
<p>常用的解决方案有两种：第一种是布隆过滤器，它是一种空间效率很高的数据结构，可以用来判断一个元素是否在集合中。</p>
<p>我们可以将所有可能存在的数据哈希到布隆过滤器中，查询时先检查布隆过滤器，如果布隆过滤器认为该数据不存在，就直接返回空；否则再去查询缓存，这样就可以避免无效的缓存查询。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022095153.png" alt="20251022095153"><br>酒剑仙：布隆过滤器解决缓存穿透</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存中不存在该key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheResult</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (cacheResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResult;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 布隆过滤器判断key是否可能存在</span></span><br><span class="line">    <span class="keyword">if</span> (!bloomFilter.mightContain(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 一定不存在，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可能存在，查询数据库</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dbResult</span> <span class="operator">=</span> db.query(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将结果放入缓存，包括空值</span></span><br><span class="line">    cache.set(key, dbResult != <span class="literal">null</span> ? dbResult : <span class="string">&quot;&quot;</span>, expireTime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dbResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布隆过滤器存在误判，即可能会认为某个数据存在，但实际上并不存在。但绝不会漏判，即如果布隆过滤器认为某个数据不存在，那它一定不存在。因此它可以有效拦截不存在的数据查询，减轻数据库压力。</p>
<p>第二种是<strong>缓存空值</strong>。对于不存在的数据，我们将空值写入缓存，并设置一个合理的过期时间。这样下次相同的查询就能直接从缓存返回，而不再访问数据库。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251028151204.png" alt="20251028151204"><br>三分恶面渣逆袭：缓存空值&#x2F;默认值</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheResult</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存命中，包括空值</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 特殊值表示空结果</span></span><br><span class="line">        <span class="keyword">if</span> (cacheResult.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheResult;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存未命中，查询数据库</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dbResult</span> <span class="operator">=</span> db.query(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入缓存，空值也缓存，但设置较短的过期时间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expireTime</span> <span class="operator">=</span> dbResult == <span class="literal">null</span> ? EMPTY_EXPIRE_TIME : NORMAL_EXPIRE_TIME;</span><br><span class="line">    cache.set(key, dbResult != <span class="literal">null</span> ? dbResult : <span class="string">&quot;&quot;</span>, expireTime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dbResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存空值的方法实现起来比较简单，但需要给空值设置一个合理的过期时间，以免数据库中新增了这些数据后，缓存仍然返回空值。</p>
<p>在实际的项目当中，还需要在接口层面做一些处理，比如说对参数进行校验，拦截明显不合理的请求；或者对疑似攻击的 IP 进行限流和封禁。</p>
<h4 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h4><p>缓存雪崩是指在某一时间段，大量缓存同时失效或者缓存服务突然宕机了，导致大量请求直接涌向数据库，导致数据库压力剧增，甚至引发系统崩溃的现象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022100013.png" alt="20251022100013"><br>三分恶面渣逆袭：缓存雪崩</p>
<p>缓存击穿是单个热点数据失效导致的，缓存穿透是因为请求不存在的数据，而缓存雪崩是因为大范围的缓存失效。</p>
<p>缓存雪崩主要有三种成因和应对策略。</p>
<p>第一种，大量缓存同时过期，解决方法是添加随机过期时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCache</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">    <span class="comment">// 基础过期时间，例如30分钟</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">baseExpireSeconds</span> <span class="operator">=</span> <span class="number">1800</span>;</span><br><span class="line">    <span class="comment">// 增加随机过期时间，范围0-300秒</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomSeconds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 最终过期时间为基础时间加随机时间</span></span><br><span class="line">    cache.set(key, value, baseExpireSeconds + randomSeconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，缓存服务崩溃，解决方法是使用高可用的缓存集群。</p>
<p>比如说使用 Redis Cluster 构建多节点集群，确保数据在多个节点上有备份，并且支持自动故障转移。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022101036.png" alt="20251022101036"><br>Rajat Pachauri：Redis Cluster</p>
<p>对于一些高频关键数据，可以配置本地缓存作为二级缓存，缓解 Redis 的压力。在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，我们就采用了多级缓存的策略，其中就包括使用本地缓存 Caffeine 来作为二级缓存，当 Redis 出现问题时自动切换到本地缓存。</p>
<p>这个过程称为“缓存降级”，保证 Redis 发生故障时，系统能够继续提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, UserPermissions&gt; permissionsCache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1000</span>)</span><br><span class="line">    .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build(<span class="built_in">this</span>::loadPermissionsFromRedis);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> UserPermissions <span class="title function_">loadPermissionsFromRedis</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisClient.getPermissions(userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// Redis 异常处理，尝试从本地缓存获取</span></span><br><span class="line">        <span class="keyword">return</span> permissionsCache.getIfPresent(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种，缓存服务正常但并发请求量超过了缓存服务的承载能力，这种情况下可以采用限流和降级措施。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试从缓存获取数据</span></span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 缓存服务异常，触发熔断</span></span><br><span class="line">        <span class="keyword">if</span> (circuitBreaker.shouldTrip()) &#123;</span><br><span class="line">            <span class="comment">// 直接从数据库获取，并进入降级模式</span></span><br><span class="line">            circuitBreaker.trip();</span><br><span class="line">            <span class="keyword">return</span> getFromDbDirectly(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getFromDbDirectly</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 实施限流保护</span></span><br><span class="line">    <span class="keyword">if</span> (!rateLimit.tryAcquire()) &#123;</span><br><span class="line">        <span class="comment">// 超过限流阈值，返回兜底数据或默认值</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultValue(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 限流通过，从数据库查询</span></span><br><span class="line">    <span class="keyword">return</span> db.query(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 22 暑期实习一面面试原题：缓存雪崩，如何解决</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手面经同学 7 Java 后端技术一面面试原题：说一下 缓存穿透、缓存击穿、缓存雪崩</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 7 Java 后端实习一面的原题：Redis 宕机会不会对权限系统有影响？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 7 Java 后端实习一面的原题：说一下 Redis 雪崩、穿透、击穿等场景的解决方案</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米同学 F 面试原题：缓存常见问题和解决方案（引申到多级缓存），多级缓存（redis，nginx，本地缓存）的实现思路</li>
</ol>
</blockquote>
<h3 id="30-🌟能说说布隆过滤器吗？"><a href="#30-🌟能说说布隆过滤器吗？" class="headerlink" title="30.🌟能说说布隆过滤器吗？"></a>30.🌟能说说布隆过滤器吗？</h3><p>布隆过滤器是一种空间效率极高的概率性数据结构，用于快速判断一个元素是否在一个集合中。它的特点是能够以极小的内存消耗，判断一个元素“一定不在集合中”或“可能在集合中”，常用来解决 Redis 缓存穿透的问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022105702.png" alt="20251022105702"><br>三分恶面渣逆袭：布隆过滤器</p>
<p>-—这部分面试中可以不背start—-</p>
<p>布隆过滤器的核心由一个很长的二进制向量和一系列哈希函数组成。</p>
<ul>
<li>初始化的时候，创建一个长度为 m 的位数组，初始值全为 0，同时选择 k 个不同的哈希函数</li>
<li>当添加一个元素时，用 k 个哈希函数计算出 k 个哈希值，然后对 m 取模，得到 k 个位置，将这些位置的二进制位都设为 1</li>
<li>当需要判断一个元素是否在集合中时，同样用 k 个哈希函数计算出 k 个位置，如果这些位置的二进制位有任何一个为 0，该元素一定不在集合中；如果全部为 1，则该元素可能在集合中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> BitSet bitSet;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bitSetSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numberOfHashFunctions;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">double</span> falsePositiveProbability, <span class="type">int</span> expectedNumberOfElements)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据预期元素数量和期望的误判率，计算最优的位数组大小和哈希函数个数</span></span><br><span class="line">        <span class="built_in">this</span>.bitSetSize = calculateOptimalBitSetSize(expectedNumberOfElements, falsePositiveProbability);</span><br><span class="line">        <span class="built_in">this</span>.numberOfHashFunctions = calculateOptimalNumberOfHashFunctions(expectedNumberOfElements, bitSetSize);</span><br><span class="line">        <span class="built_in">this</span>.bitSet = <span class="keyword">new</span> <span class="title class_">BitSet</span>(bitSetSize);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashes = createHashes(element);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> hash : hashes) &#123;</span><br><span class="line">            bitSet.set(Math.abs(hash % bitSetSize), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mightContain</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashes = createHashes(element);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> hash : hashes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bitSet.get(Math.abs(hash % bitSetSize))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果任何一位为0，元素一定不存在</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 所有位都为1，元素可能存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他辅助方法，如计算哈希值，计算最优参数等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-—这部分面试中可以不背end—-</p>
<h4 id="布隆过滤器存在误判吗？"><a href="#布隆过滤器存在误判吗？" class="headerlink" title="布隆过滤器存在误判吗？"></a>布隆过滤器存在误判吗？</h4><p>是的，布隆过滤器存在误判。它可能会错误地认为某个元素在集合中，而元素实际上并不在集合中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022105811.png" alt="20251022105811"><br>勇哥：布隆过滤器</p>
<p>但如果布隆过滤器认为某个元素不存在于集合中，那么它一定不存在。</p>
<p>误判产生的原因是因为哈希冲突。在布隆过滤器中，多个不同的元素可能映射到相同的位置。随着向布隆过滤器中添加的元素越来越多，位数组中的 1 也越来越多，发生哈希冲突的概率随之增加，误判率也就随之上升。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110143.png" alt="20251022110143"><br>勇哥：布隆过滤器的误判</p>
<p>误判率取决于以下 3 个因素：</p>
<ol>
<li>位数组的大小（m）：m 决定了可以存储的标志位数量。如果位数组过小，那么哈希碰撞的几率就会增加，从而导致更高的误判率。</li>
<li>哈希函数的数量（k）：k 决定了每个元素在位数组中标记的位数。哈希函数越多，碰撞的概率也会相应变化。如果哈希函数太少，过滤器很快会变得不精确；如果太多，误判率也会升高，效率下降。</li>
<li>存入的元素数量（n）：n 越多，哈希碰撞的几率越大，从而导致更高的误判率。</li>
</ol>
<p>要降低误判率，可以增加位数组的大小或者减少插入的元素数量。</p>
<p>要彻底解决布隆过滤器的误判问题，可以在布隆过滤器返回”可能存在”时，再通过数据库进行二次确认。</p>
<h4 id="布隆过滤器支持删除吗？"><a href="#布隆过滤器支持删除吗？" class="headerlink" title="布隆过滤器支持删除吗？"></a>布隆过滤器支持删除吗？</h4><p>布隆过滤器并不支持删除操作，这是它的一个重要限制。</p>
<p>当我们添加一个元素时，会将位数组中的 k 个位置设置为 1。由于多个不同元素可能共享相同的位，如果我们尝试删除一个元素，将其对应的 k 个位重置为 0，可能会错误地影响到其他元素的判断结果。</p>
<p>例如，元素 A 和元素 B 都将位置 5 设为 1，如果删除元素 A 时将位置 5 重置为 0，那么对元素 B 的查询就会产生错误的”不存在”结果，这违背了布隆过滤器的基本特性。</p>
<p>如果想要实现删除操作，可以使用计数布隆过滤器，它在每个位置上存储一个计数器而不是单一的位。这样可以通过减少计数器的值来实现删除操作，但会增加内存开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingBloomFilter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counters;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hashFunctions;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountingBloomFilter</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> hashFunctions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.hashFunctions = hashFunctions;</span><br><span class="line">        <span class="built_in">this</span>.counters = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] positions = getHashPositions(element);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> position : positions) &#123;</span><br><span class="line">            counters[position]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] positions = getHashPositions(element);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> position : positions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counters[position] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                counters[position]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mightContain</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] positions = getHashPositions(element);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> position : positions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counters[position] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getHashPositions(T element) &#123;</span><br><span class="line">        <span class="comment">// 计算哈希位置的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么不能用哈希表而是用布隆过滤器？"><a href="#为什么不能用哈希表而是用布隆过滤器？" class="headerlink" title="为什么不能用哈希表而是用布隆过滤器？"></a>为什么不能用哈希表而是用布隆过滤器？</h4><p>布隆过滤器最突出的优势是内存效率。</p>
<p>假如我们要判断 10 亿个用户 ID 是否曾经访问过特定页面，使用哈希表至少需要 10G 内存（每个 ID 至少需要8字节），而使用布隆过滤器只需要 1.2G 内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m ≈ -n*ln(p)/ln(2)² ≈ -10⁹*ln(0.01)/ln(2)² ≈ 9.6 billion bits ≈ 1.2GB</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 7 Java 后端实习一面的原题：有了解过布隆过滤器吗？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的TP联洲同学 5 Java 后端一面的原题：布隆过滤器原理，这种方式下5%的错误率可接受？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团同学 9 一面面试原题：布隆过滤器？布隆过滤器优点？为什么不能用哈希表要用布隆过滤器？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的理想汽车面经同学 2 一面面试原题：追问：说明一下布隆过滤器</li>
</ol>
</blockquote>
<h3 id="31-🌟如何保证缓存和数据库的数据⼀致性？"><a href="#31-🌟如何保证缓存和数据库的数据⼀致性？" class="headerlink" title="31.🌟如何保证缓存和数据库的数据⼀致性？"></a>31.🌟如何保证缓存和数据库的数据⼀致性？</h3><p>在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，对于文章标签这种允许短暂不一致的数据，我会采用 <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">Cache Aside</a> + TTL 过期机制来保证缓存和数据库的一致性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110356.png" alt="20251022110356"><br>技术派教程：MySQL 和 Redis 一致性</p>
<p>具体做法是读取时先查 Redis，未命中再查 MySQL，同时为缓存设置一个合理的过期时间；更新时先更新 MySQL，再删除 Redis。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取逻辑</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 先查缓存</span></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">user</span> <span class="operator">=</span> cache.get(<span class="string">&quot;user:&quot;</span> + userId);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存未命中，查数据库</span></span><br><span class="line">    user = database.selectUser(userId);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 放入缓存，设置合理的过期时间</span></span><br><span class="line">        cache.set(<span class="string">&quot;user:&quot;</span> + userId, user, <span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(UserInfo user)</span> &#123;</span><br><span class="line">    <span class="comment">// 先更新数据库</span></span><br><span class="line">    database.updateUser(user);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除缓存</span></span><br><span class="line">    cache.delete(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式简单有效，适用于读多写少的场景。TTL 过期时间也能够保证即使更新操作失败，未能及时删除缓存，过期时间也能确保数据最终一致。</p>
<h4 id="那再来说说为什么要删除缓存而不是更新缓存？"><a href="#那再来说说为什么要删除缓存而不是更新缓存？" class="headerlink" title="那再来说说为什么要删除缓存而不是更新缓存？"></a>那再来说说为什么要删除缓存而不是更新缓存？</h4><p>最初设计缓存策略时，我也考虑过直接更新缓存，但通过实践发现，删除缓存是更优的选择。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110609.png" alt="20251022110609"><br>技术派：更新 Redis 而不是删除 Redis</p>
<p>最主要的原因是在并发环境下，假设我们有两个并发的更新操作，如果采用更新缓存的策略，就可能出现这样的时序问题：</p>
<ul>
<li>操作 A 和操作 B 同时发生，A 先更新 MySQL 将值改为 10，B 后更新 MySQL 将值改为 11。但在缓存更新时，可能 B 先执行将缓存设为 11，然后 A 才执行将缓存设为10。这样就会造成 MySQL 是 11 但 Redis 是 10 的不一致状态。</li>
</ul>
<p>而采用删除策略，无论 A 和 B 谁先删除缓存，后续的读取操作都会从 MySQL 获取最新值。</p>
<p>另外，相对而言，删除缓存的速度比更新缓存的速度快得多。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110559.png" alt="20251022110559"><br>三分恶面渣逆袭：删除缓存和更新缓存</p>
<p>因为删除操作只是简单的 DEL 命令，而更新可能需要重新序列化整个对象再写入缓存。</p>
<h4 id="那再说说为什么要先更新数据库，再删除缓存？"><a href="#那再说说为什么要先更新数据库，再删除缓存？" class="headerlink" title="那再说说为什么要先更新数据库，再删除缓存？"></a>那再说说为什么要先更新数据库，再删除缓存？</h4><p>这个操作顺序的选择也是我在实际项目中踩过坑才深刻理解的。假设我们采用先删缓存再更新数据库的策略，在高并发场景下就可能出现这样的问题：</p>
<ul>
<li>线程 A 要更新用户信息，先删除了缓存</li>
<li>线程 B 恰好此时要读取该用户信息，发现缓存为空，于是查询数据库，此时还是旧值</li>
<li>线程 B 将查到的旧值重新放入缓存</li>
<li>线程 A 完成数据库更新</li>
</ul>
<p>结果就是数据库是新的值，但缓存中还是旧值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110834.png" alt="20251022110834"><br>技术派：先删 Redis 再更新 MySQL</p>
<p>而采用先更新数据库再删缓存的策略，即使出现类似的并发情况，最坏的情况也只是短暂地从缓存中读取到了旧值，但缓存删除后的请求会直接从数据库中获取最新值。</p>
<p>另外，如果先删缓存再更新数据库，当数据库更新失败时，缓存已经被删除了。这会导致短期内所有读请求都会穿透到数据库，对数据库造成额外的压力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110950.png" alt="20251022110950"><br>三分恶面渣逆袭：先更数据库还是先删缓存</p>
<p>而先更新数据库再删缓存，如果数据库更新失败，缓存保持原状，系统仍然能继续正常提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先更新数据库</span></span><br><span class="line">        database.updateUser(user);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再删除缓存</span></span><br><span class="line">        cache.delete(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DatabaseException e) &#123;</span><br><span class="line">        <span class="comment">// 数据库更新失败，缓存保持原状，系统仍可正常提供服务</span></span><br><span class="line">        log.error(<span class="string">&quot;Database update failed&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CacheException e) &#123;</span><br><span class="line">        <span class="comment">// 缓存删除失败，数据库已更新，数据会在TTL后自动一致</span></span><br><span class="line">        log.warn(<span class="string">&quot;Cache deletion failed, will be eventually consistent&quot;</span>, e);</span><br><span class="line">        <span class="comment">// 可以选择不抛异常，因为有TTL兜底</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="那假如对缓存数据库一致性要求很高，该怎么办呢？"><a href="#那假如对缓存数据库一致性要求很高，该怎么办呢？" class="headerlink" title="那假如对缓存数据库一致性要求很高，该怎么办呢？"></a>那假如对缓存数据库一致性要求很高，该怎么办呢？</h4><p>当业务对缓存与数据库的一致性要求很高时，比如支付系统、库存管理等场景，我会采用多种策略来保证强一致性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111101.png" alt="20251022111101"><br>二哥的 Java 进阶之路：缓存强一致性</p>
<p>第一种，引入消息队列来保证缓存最终被删除，比如说在数据库更新的事务中插入一条本地消息记录，事务提交后异步发送给 MQ 进行缓存删除。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111121.png" alt="20251022111121"><br>三分恶面渣逆袭：消息队列保证key被删除</p>
<p>即使缓存删除失败，消息队列的重试机制也能保证最终一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(UserInfo user)</span> &#123;</span><br><span class="line">    <span class="comment">// 在事务中更新数据库</span></span><br><span class="line">    database.updateUser(user);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在同一事务中记录需要删除的缓存信息</span></span><br><span class="line">    <span class="type">LocalMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalMessage</span>(<span class="string">&quot;CACHE_DELETE&quot;</span>, <span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">    database.insertLocalMessage(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式发布事件，供监听器捕获</span></span><br><span class="line">    eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">UserUpdateEvent</span>(<span class="built_in">this</span>, <span class="string">&quot;user:&quot;</span> + user.getId()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务提交后发送MQ消息</span></span><br><span class="line"><span class="meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendCacheDeleteMessage</span><span class="params">(UserUpdateEvent event)</span> &#123;</span><br><span class="line">    messageQueue.send(<span class="string">&quot;cache-delete-topic&quot;</span>, event.getCacheKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，使用 <a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">Canal</a> 监听 MySQL 的 binlog，在数据更新时，将数据变更记录到消息队列中，消费者消息监听到变更后去删除缓存。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111140.png" alt="20251022111140"><br>三分恶面渣逆袭：数据库订阅+消息队列保证key被删除</p>
<p>这种方案的优势是完全解耦了业务代码和缓存维护逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanalListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheUpdateListener</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@EventHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUserUpdate</span><span class="params">(UserUpdateEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 从binlog事件中提取变更信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> event.getUserId();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送缓存删除消息</span></span><br><span class="line">        <span class="type">CacheDeleteMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheDeleteMessage</span>();</span><br><span class="line">        message.setCacheKey(<span class="string">&quot;user:&quot;</span> + userId);</span><br><span class="line">        messageQueue.send(<span class="string">&quot;cache-delete-topic&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者监听消息队列</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &quot;cache-delete-topic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleCacheDeleteMessage</span><span class="params">(CacheDeleteMessage message)</span> &#123;</span><br><span class="line">    <span class="comment">// 删除缓存</span></span><br><span class="line">    cache.delete(message.getCacheKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，如果说业务比较简单，不需要上消息队列，可以通过延迟双删策略降低缓存和数据库不一致的时间窗口，在第一次删除缓存之后，过一段时间之后，再次尝试删除缓存。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111245.png" alt="20251022111245"><br>三分恶面渣逆袭：延时双删</p>
<p>这种方式主要针对缓存不存在，但写入了脏数据的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(UserInfo user)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次删除缓存，减少不一致时间窗口</span></span><br><span class="line">    cache.delete(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新数据库</span></span><br><span class="line">    database.updateUser(user);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 立即删除缓存</span></span><br><span class="line">    cache.delete(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 延时删除，应对可能的并发读取</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 延时时间根据主从同步延迟调整</span></span><br><span class="line">            cache.delete(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，无论采用哪种策略，最好为缓存设置一个合理的过期时间作为最后的保障。即使所有的主动删除机制都失败了，TTL 也能确保数据最终达到一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据数据的重要程度设置不同的TTL</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCache</span><span class="params">(String key, Object value, DataImportance importance)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ttl;</span><br><span class="line">    <span class="keyword">switch</span> (importance) &#123;</span><br><span class="line">        <span class="keyword">case</span> HIGH:      <span class="comment">// 关键数据，短TTL</span></span><br><span class="line">            ttl = <span class="number">300</span>;  <span class="comment">// 5分钟</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MEDIUM:    <span class="comment">// 一般数据</span></span><br><span class="line">            ttl = <span class="number">1800</span>; <span class="comment">// 30分钟</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LOW:       <span class="comment">// 不太重要的数据</span></span><br><span class="line">            ttl = <span class="number">3600</span>; <span class="comment">// 1小时</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cache.setWithTTL(key, value, ttl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式虽然简单，但能确保即使出现极端情况，数据不一致的影响也是可控的。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为面经同学 8 技术二面面试原题：怎样保证数据的最终一致性？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 23 QQ 后台技术一面面试原题：数据一致性问题</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的微众银行同学 1 Java 后端一面的原题：MySQL 和缓存一致性问题了解吗？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团面经同学 3 Java 后端技术一面面试原题：如何保证 redis 缓存与数据库的一致性，为什么这么设计</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的比亚迪面经同学 12 Java 技术面试原题：怎么解决redis和mysql的缓存一致性问题</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 17 后端技术面试原题：双写一致性怎么解决的</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 9 面试原题：redis的数据和缓存不一致应该处理</li>
</ol>
</blockquote>
<h3 id="40-🌟Redis有哪些内存淘汰策略？"><a href="#40-🌟Redis有哪些内存淘汰策略？" class="headerlink" title="40.🌟Redis有哪些内存淘汰策略？"></a>40.🌟Redis有哪些内存淘汰策略？</h3><p>当内存使用接近 maxmemory 限制时，Redis 会依据内存淘汰策略来决定删除哪些 key 以缓解内存压力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023112833.png" alt="20251023112833"><br>码哥字节：内存淘汰策略</p>
<p>常用的内存淘汰策略有八种，分别是默认的 <code>noeviction</code>，内存不足时不会删除任何 key，直接返回错误信息，生产环境下基本上不会使用。</p>
<p>然后是针对所有 key 的 <code>allkeys-lru</code>、<code>allkeys-lfu</code> 和 <code>allkeys-random</code>。lru 会删除最近最少使用的 key，在纯缓存场景中最常用，能自动保留热点数据；lfu 会删除访问频率最低的 key，更适合长期运行的系统；random 会随机删除一些 key，一般不推荐使用。</p>
<p>其次是针对设置了过期时间的 key，有 volatile-lru、volatile-lfu、volatile-ttl 和 volatile-random。</p>
<p>lru 在混合存储场景中经常使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HybridStorageService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重要数据不设置过期时间，临时数据设置过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">storeData</span><span class="params">(String key, Object data, DataImportance importance)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (importance == DataImportance.HIGH) &#123;</span><br><span class="line">            <span class="comment">// 重要数据不设置过期时间，在volatile-*策略下不会被淘汰</span></span><br><span class="line">            redisTemplate.opsForValue().set(key, data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 临时数据设置过期时间，可以被volatile-*策略淘汰</span></span><br><span class="line">            redisTemplate.opsForValue().set(key, data, Duration.ofHours(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lfu 适合需要保护某些重要数据不被淘汰的场景；ttl 优先删除即将过期的 key，在用户会话管理系统中推荐使用；random 仍然很少用。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米春招同学 K 一面面试原题：为什么 redis 快，淘汰策略 持久化</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的去哪儿面经同学 1 技术 2 面面试原题：redis 内存淘汰和过期策略</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的作业帮面经同学 1 Java 后端一面面试原题：redis内存淘汰策略</li>
</ol>
</blockquote>
<h3 id="45-🌟Redis支持事务吗？"><a href="#45-🌟Redis支持事务吗？" class="headerlink" title="45.🌟Redis支持事务吗？"></a>45.🌟Redis支持事务吗？</h3><p>是的，Redis 支持简单的事务，可以将 multi、exec、discard 和 watch 命令打包，然后一次性的按顺序执行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023160847.png" alt="20251023160847"><br>Redis设计与实现：事务</p>
<p>基本流程是用 multi 开启事务，然后执行一系列命令，最后用 exec 提交。这些命令会被放入队列，在 exec 时批量执行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023160907.png" alt="20251023160907"><br>二哥的 Java 进阶之路：Redis 事务</p>
<p>当客户端处于非事务状态时，所有发送给 Redis 服务的命令都会立即执行；但当客户端进入事务状态之后，这些命令会被放入一个事务队列中，然后立即返回 QUEUED，表示命令已入队。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023160922.png" alt="20251023160922"><br>Redis设计与实现：事务和非事务的区别</p>
<p>当 exec 命令执行时，Redis 会将事务队列中的所有命令按先进先出的顺序执行。当事务队列里的命令全部执行完毕后，Redis 会返回一个数组，包含每个命令的执行结果。</p>
<p>discard 命令用于取消一个事务，它会清空事务队列并退出事务状态。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023160930.png" alt="20251023160930"><br>二哥的 Java 进阶之路：discard</p>
<p>watch 命令用于监视一个或者多个 key，如果这个 key 在事务执行之前 被其他命令改动，那么事务将会被打断。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023160946.png" alt="20251023160946"><br>码哥字节：watch</p>
<p>但 Redis 的事务与 MySQL 的有很大不同，它并不支持回滚，也不支持隔离级别。</p>
<h4 id="说一下-Redis-事务的原理？"><a href="#说一下-Redis-事务的原理？" class="headerlink" title="说一下 Redis 事务的原理？"></a>说一下 Redis 事务的原理？</h4><p>Redis 事务的原理并不复杂，核心就是一个”先排队，后执行”的机制。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161016.png" alt="20251023161016"><br>小生凡一：Redis事务</p>
<p>当执行 MULTI 命令时，Redis 会给这个客户端打一个事务的标记，表示这个客户端后面发送的命令不会被立即执行，而是被放到一个队列里排队等着。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161037.png" alt="20251023161037"><br>小生凡一：MULTI</p>
<p>当 Redis 收到 EXEC 命令时，它会把队列里的命令一个个拿出来执行。因为 Redis 是单线程的，所以这个过程不会被其他命令打断，这就保证了Redis 事务的原子性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161053.png" alt="20251023161053"><br>小生凡一：WATCH</p>
<p>当执行 WATCH 命令时，Redis 会将 key 添加到全局监视字典中；只要这些 key 在 EXEC 前被其他客户端修改，Redis 就会给相关客户端打上脏标记，EXEC 时发现事务已被干扰就会直接取消整个事务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局监视字典</span></span><br><span class="line">dict *watched_keys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchedKey</span> &#123;</span></span><br><span class="line">    robj *key;</span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125; watchedKey;</span><br></pre></td></tr></table></figure>

<p>DISCARD 做的事情很简单直接，首先检查客户端是否真的在事务状态，如果不在就报错；如果在事务状态，就清空事务队列并退出事务状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">discardCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;DISCARD without MULTI&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redis-事务有哪些注意点？"><a href="#Redis-事务有哪些注意点？" class="headerlink" title="Redis 事务有哪些注意点？"></a>Redis 事务有哪些注意点？</h4><p>最重要的的一点是，Redis 事务不支持回滚，一旦 EXEC 命令被调用，所有命令都会被执行，即使有些命令可能执行失败。</p>
<h4 id="Redis事务为什么不支持回滚？"><a href="#Redis事务为什么不支持回滚？" class="headerlink" title="Redis事务为什么不支持回滚？"></a>Redis事务为什么不支持回滚？</h4><p>Redis 的核心设计理念是简单、高效，而不是完整的 ACID 特性。而实现回滚需要在执行过程中保存大量的状态信息，并在发生错误时逆向执行命令以恢复原始状态。这会增加 Redis 的复杂性和性能开销。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161146.png" alt="20251023161146"><br>redis.io：不支持事务回滚</p>
<h4 id="Redis事务满足原子性吗？要怎么改进？"><a href="#Redis事务满足原子性吗？要怎么改进？" class="headerlink" title="Redis事务满足原子性吗？要怎么改进？"></a>Redis事务满足原子性吗？要怎么改进？</h4><p>Redis 的事务不能满足标准的原子性，因为它不支持事务回滚，也就是说，假如某个命令执行失败，整个事务并不会自动回滚到初始状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个转账事务</span></span><br><span class="line">redisTemplate.multi();</span><br><span class="line">redisTemplate.opsForValue().decrement(<span class="string">&quot;user:1:balance&quot;</span>, <span class="number">100</span>); <span class="comment">// 成功</span></span><br><span class="line">redisTemplate.opsForList().leftPush(<span class="string">&quot;user:1:balance&quot;</span>, <span class="string">&quot;log&quot;</span>);  <span class="comment">// 类型错误，失败</span></span><br><span class="line">redisTemplate.opsForValue().increment(<span class="string">&quot;user:2:balance&quot;</span>, <span class="number">100</span>);  <span class="comment">// 还是会执行</span></span><br><span class="line">List&lt;Object&gt; results = redisTemplate.exec();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：用户1被扣了钱，用户2也收到了钱，但中间的日志操作失败了</span></span><br><span class="line"><span class="comment">// 这符合Redis的原子性定义，但不符合业务期望</span></span><br></pre></td></tr></table></figure>

<p>可以使用 Lua 脚本来替代事务，脚本运行期间，Redis 不会处理其他命令，并且我们可以在脚本中处理整个业务逻辑，包括条件检查和错误处理，保证要么执行成功，要么保持最初的状态，不会出现一个命令执行失败、其他命令执行成功的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImprovedTransactionService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">atomicTransfer</span><span class="params">(String fromUser, String toUser, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">luaScript</span> <span class="operator">=</span> </span><br><span class="line">            <span class="string">&quot;local from_key = KEYS[1] &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local to_key = KEYS[2] &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local amount = tonumber(ARGV[1]) &quot;</span> +</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查转出账户余额</span></span><br><span class="line">            <span class="string">&quot;local from_balance = redis.call(&#x27;GET&#x27;, from_key) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;if not from_balance then return -1 end &quot;</span> +</span><br><span class="line">            </span><br><span class="line">            <span class="string">&quot;from_balance = tonumber(from_balance) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;if from_balance &lt; amount then return -2 end &quot;</span> +</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查转入账户是否存在</span></span><br><span class="line">            <span class="string">&quot;if redis.call(&#x27;EXISTS&#x27;, to_key) == 0 then return -3 end &quot;</span> +</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 所有检查通过，执行转账</span></span><br><span class="line">            <span class="string">&quot;redis.call(&#x27;DECRBY&#x27;, from_key, amount) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;redis.call(&#x27;INCRBY&#x27;, to_key, amount) &quot;</span> +</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录转账日志</span></span><br><span class="line">            <span class="string">&quot;local log = from_key .. &#x27;:&#x27; .. to_key .. &#x27;:&#x27; .. amount &quot;</span> +</span><br><span class="line">            <span class="string">&quot;redis.call(&#x27;LPUSH&#x27;, &#x27;transfer:log&#x27;, log) &quot;</span> +</span><br><span class="line">            </span><br><span class="line">            <span class="string">&quot;return 1&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        DefaultRedisScript&lt;Long&gt; script = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        script.setScriptText(luaScript);</span><br><span class="line">        script.setResultType(Long.class);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(script, </span><br><span class="line">            Arrays.asList(<span class="string">&quot;user:&quot;</span> + fromUser + <span class="string">&quot;:balance&quot;</span>, <span class="string">&quot;user:&quot;</span> + toUser + <span class="string">&quot;:balance&quot;</span>),</span><br><span class="line">            amount);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result != <span class="literal">null</span> &amp;&amp; result == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redis-事务的-ACID-特性如何体现？"><a href="#Redis-事务的-ACID-特性如何体现？" class="headerlink" title="Redis 事务的 ACID 特性如何体现？"></a>Redis 事务的 ACID 特性如何体现？</h4><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务在执行过程中如果某个命令失败了，其他命令还是会继续执行，不会回滚。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161307.png" alt="20251023161307"><br>小生凡一：Redis 事务的原子性</p>
<p>一致性指的是，如果数据在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据也应该是一致的。但 Redis 事务并不保证一致性，因为如果事务中的某个命令失败了，其他命令仍然会执行，就会出现数据不一致的情况。</p>
<p>Redis 是单线程执行事务的，并且不会中断，直到执行完所有事务队列中的命令为止。因此，我认为 Redis 的事务具有隔离性的特征。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023161344.png" alt="20251023161344"><br>小生凡一：Redis 事务的隔离性</p>
<p>Redis 事务的持久性完全依赖于 Redis 本身的持久化机制，如果开启了 AOF，那么事务中的命令会作为一个整体记录到 AOF 文件中，当然也要看 AOF 的 fsync 策略。</p>
<p>如果只开启了 RDB，事务中的命令可能会在下次快照前丢失。如果两个都没有开启，肯定是不满足持久性的。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为一面原题：说下 Redis 事务</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">二哥编程星球</a>球友<a target="_blank" rel="noopener" href="https://t.zsxq.com/BaHOh">枕云眠美团 AI 面试原题</a>：什么是 redis 的事务，它的 ACID 属性如何体现</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：Redis事务满足原子性吗？要怎么改进？</li>
</ol>
</blockquote>
<h3 id="48-🌟Redis能实现分布式锁吗？"><a href="#48-🌟Redis能实现分布式锁吗？" class="headerlink" title="48.🌟Redis能实现分布式锁吗？"></a>48.🌟Redis能实现分布式锁吗？</h3><p>分布式锁是一种用于控制多个不同进程在分布式系统中访问共享资源的锁机制。它能确保在同一时刻，只有一个节点可以对资源进行访问，从而避免分布式场景下的并发问题。</p>
<p>可以使用 Redis 的 SETNX 命令实现简单的分布式锁。比如 <code>SET key value NX PX 3000</code> 就创建了一个锁名为 <code>key</code> 的分布式锁，锁的持有者为 <code>value</code>。NX 保证只有在 key 不存在时才能创建成功，EX 设置过期时间用以防止死锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162344.png" alt="20251023162344"><br>三分恶面渣逆袭：set原子命令</p>
<h4 id="Redis如何保证-SETNX-不会发生冲突？"><a href="#Redis如何保证-SETNX-不会发生冲突？" class="headerlink" title="Redis如何保证 SETNX 不会发生冲突？"></a>Redis如何保证 SETNX 不会发生冲突？</h4><p>当我们使用 <code>SET key value NX EX 30</code> 这个命令进行加锁时，Redis 会把整个操作当作一个原子指令来执行。因为 Redis 的命令处理是单线程的，所以在同一时刻只能有一个命令在执行。</p>
<p>比如说两个客户端 A 和 B 同时请求同一个锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端A: SET lock_key uuid_a NX EX 30</span><br><span class="line">客户端B: SET lock_key uuid_b NX EX 30</span><br></pre></td></tr></table></figure>

<p>虽然这两个请求可能几乎同时到达 Redis 服务器，但 Redis 会严格按照到达的先后顺序来处理。假设 A 的请求先到，Redis 会先执行 A 的 SET 命令，这时 lock_key 被设置为 uuid_a。</p>
<p>当处理 B 的请求时，因为 lock_key 已经存在了，NX 条件不满足，所以 B 的 SET 命令会失败，返回 NULL。这样就保证了只有 A 能获取到锁。</p>
<p>关键点在于 NX 的语义：<code>NOT EXISTS</code>，只有在 key 不存在的时候才会设置成功。Redis 在执行这个命令时，会先检查 key 是否存在，如果不存在才会设置值，这整个过程是原子的，不会被其他命令打断。</p>
<h4 id="SETNX有什么问题，如何解决？"><a href="#SETNX有什么问题，如何解决？" class="headerlink" title="SETNX有什么问题，如何解决？"></a>SETNX有什么问题，如何解决？</h4><p>使用 SETNX 创建分布式锁时，虽然可以通过设置过期时间来避免死锁，但会误删锁。比如线程 A 获取锁后，业务执行时间比较长，锁过期了。这时线程 B 获取到锁，但线程 A 执行完业务逻辑后，会尝试删除锁，这时候删掉的其实是线程 B 的锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162513.png" alt="20251023162513"><br>技术派：Redis 锁</p>
<p>可以通过锁的自动续期机制来解决锁过期的问题，比如 Redisson 的看门狗机制，在后台启动一个定时任务，每隔一段时间就检查锁是否还被当前线程持有，如果是就自动延长过期时间。这样既避免了死锁，又防止了锁被提前释放。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162536.png" alt="20251023162536"><br>技术派：redisson 看门狗</p>
<h4 id="Redisson了解多少？"><a href="#Redisson了解多少？" class="headerlink" title="Redisson了解多少？"></a>Redisson了解多少？</h4><p>Redisson 是一个基于 Redis 的 Java 客户端，它不只是对 Redis 的操作进行简单地封装，还提供了很多分布式的数据结构和服务，比如最常用的分布式锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redisson 的分布式锁比 SETNX 完善的得多，它的看门狗机制可以让我们在获取锁的时候省去手动设置过期时间的步骤，它在内部封装了一个定时任务，每隔 10 秒会检查一次，如果当前线程还持有锁就自动续期 30 秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 手动设置过期时间</span></span><br><span class="line">        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 启用看门狗机制，使用默认的30秒过期时间</span></span><br><span class="line">        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,</span><br><span class="line">                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理获取锁成功的情况</span></span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果获取锁成功且启用看门狗机制</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">                internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                scheduleExpirationRenewal(threadId); <span class="comment">// 启动看门狗</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，Redisson 还提供了分布式限流器 RRateLimiter，基于令牌桶算法实现，用于控制分布式环境下的访问频率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// API 接口限流</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; getData() &#123;</span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;api.data&quot;</span>);</span><br><span class="line">        limiter.trySetRate(RateType.OVERALL, <span class="number">100</span>, <span class="number">1</span>, RateIntervalUnit.MINUTES);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (limiter.tryAcquire()) &#123;</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok(processData());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 限流触发</span></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(<span class="number">429</span>).body(<span class="string">&quot;Rate limit exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="详细说说Redisson的看门狗机制？"><a href="#详细说说Redisson的看门狗机制？" class="headerlink" title="详细说说Redisson的看门狗机制？"></a>详细说说Redisson的看门狗机制？</h4><p>Redisson 的看门狗机制是一种自动续期机制，用于解决分布式锁的过期问题。</p>
<p>基本原理是这样的：当调用 <code>lock()</code> 方法加锁时，如果没有显式设置过期时间，Redisson 会默认给锁加一个 30 秒的过期时间，同时启用一个名为“看门狗”的定时任务，每隔 10 秒（默认是过期时间的 1&#x2F;3），去检查一次锁是否还被当前线程持有，如果是，就自动续期，将过期时间延长到 30 秒。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162648.png" alt="20251023162648"><br>郭慕荣博客园：看门狗</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码展示核心逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager()</span><br><span class="line">        .newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> &#123;</span><br><span class="line">                <span class="comment">// 用 Lua 脚本检查并续期</span></span><br><span class="line">                <span class="keyword">if</span> (redis.call(<span class="string">&quot;get&quot;</span>, lockKey) == currentThreadId) &#123;</span><br><span class="line">                    redis.call(<span class="string">&quot;expire&quot;</span>, lockKey, <span class="number">30</span>);</span><br><span class="line">                    <span class="comment">// 递归调用，继续下一次续期</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>续期的 Lua 脚本会检查锁的 value 是否匹配当前线程，如果匹配就延长过期时间。这样就能保证只有锁的真正持有者才能续期。</p>
<p>当调用 <code>unlock()</code> 方法时，看门狗任务会被取消。或者如果业务逻辑执行完但忘记 unlock 了，看门狗也会帮我们自动检查锁，如果锁已经不属于当前线程了，也会自动停止续期。</p>
<p>这样我们就不用担心业务执行时间过长导致锁被提前释放，也避免了手动估算过期时间的麻烦，同时也解决了分布式环境下的死锁问题。</p>
<h4 id="看门狗机制中的检查锁过程是原子操作吗？"><a href="#看门狗机制中的检查锁过程是原子操作吗？" class="headerlink" title="看门狗机制中的检查锁过程是原子操作吗？"></a>看门狗机制中的检查锁过程是原子操作吗？</h4><p>是的，Redisson 使用了 Lua 脚本来保证锁检查的原子性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162726.png" alt="20251023162726"><br>二哥的 Java 进阶之路：看门狗 lua 脚本检查锁</p>
<p>Redis 在执行 Lua 脚本时，会把整个脚本当作一个命令来处理，期间不会执行其他命令。所以 hexists 检查和 expire 续期是原子执行的。</p>
<h4 id="Redlock你了解多少？"><a href="#Redlock你了解多少？" class="headerlink" title="Redlock你了解多少？"></a>Redlock你了解多少？</h4><p>Redlock 是 Redis 作者 antirez 提出的一种分布式锁算法，用于解决单个 Redis 实例作为分布式锁时存在的单点故障问题。</p>
<p>Redlock 的核心思想是通过在多个完全独立的 Redis 实例上同时获取锁来实现容错。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023162805.png" alt="20251023162805"><br>二哥的 Java 进阶之路：RedissonRedLock</p>
<p>minLocksAmount 方法返回的 <code>locks.size()/2 + 1</code>，正是 Redlock 算法要求的少数服从多数原则。failedLocksLimit 方法会计算允许失败的锁数量，确保即使部分实例失败，只要成功的实例数量超过一半就认为获取锁成功。</p>
<p>红锁会尝试依次向所有 Redis 实例获取锁，并记录成功获取的锁数量，当数量达到 minLocksAmount 时就认为获取成功，否则释放已获取的锁并返回失败。</p>
<p>虽然 Redlock 存在一些争议，比如说时钟漂移问题、网络分区导致的脑裂问题，但它仍然是一个相对成熟的分布式锁解决方案。</p>
<h4 id="红锁能不能保证百分百上锁？"><a href="#红锁能不能保证百分百上锁？" class="headerlink" title="红锁能不能保证百分百上锁？"></a>红锁能不能保证百分百上锁？</h4><p>不能，Redlock 无法保证百分百上锁成功，这是由分布式系统的本质特性决定的。</p>
<p>当有网络分区时，客户端可能无法与足够数量的 Redis 实例通信。比如在 5 个 Redis 实例的部署中，如果网络分区导致客户端只能访问到 2 个实例，那么无论如何都无法满足红锁要求的少数服从多数原则，获取锁的时候必然失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="type">boolean</span> lockAcquired;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RedisResponseTimeoutException e) &#123;</span><br><span class="line">            lockAcquired = <span class="literal">false</span>; <span class="comment">// 网络超时导致失败</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            lockAcquired = <span class="literal">false</span>; <span class="comment">// 其他异常导致失败</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果剩余可尝试的实例数量不足以达到多数派，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (locks.size() - acquiredLocks.size() == failedLocksLimit()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否达到多数派要求</span></span><br><span class="line">    <span class="keyword">if</span> (acquiredLocks.size() &gt;= minLocksAmount(locks)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        unlockInner(acquiredLocks);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 未达到多数派，获取失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时钟漂移也会影响成功率。即使所有实例都可达，如果各个 Redis 实例之间存在明显的时钟漂移，或者客户端在获取锁的过程中耗时过长，比如网络延迟、GC 停顿等，都可能会导致锁在获取完成前就过期，从而获取失败。</p>
<p>在实际应用中，可以通过重试机制来提高锁的成功率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxRetries; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (redLock.tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(retryDelay);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h4 id="项目中有用到分布式锁吗？"><a href="#项目中有用到分布式锁吗？" class="headerlink" title="项目中有用到分布式锁吗？"></a>项目中有用到分布式锁吗？</h4><p>在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/pmhub.html">PmHub</a>项目中，我有使用 Redission 的分布式锁来确保流程状态的更新按顺序执行，且不被其他流程服务干扰。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023164922.png" alt="20251023164922"><br>PmHub：分布式锁保障流程状态更新</p>
<h3 id="49-🌟Redis都有哪些底层数据结构？"><a href="#49-🌟Redis都有哪些底层数据结构？" class="headerlink" title="49.🌟Redis都有哪些底层数据结构？"></a>49.🌟Redis都有哪些底层数据结构？</h3><p>Redis 之所以快，除了基于内存读写之外，还有很重要的一点就是它精心设计的底层数据结构。Redis 总共有 8 种核心的底层数据结构，我按照重要程度来说一下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023164947.png" alt="20251023164947"><br>三分恶面渣逆袭：Redis Object对应的映射</p>
<p>首先是 SDS，这是 Redis 自己实现的动态字符串，它保留了 C 语言原生的字符串长度，所以获取长度的时间复杂度是 <code>O(1)</code>，在此基础上还支持动态扩容，以及存储二进制数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165020.png" alt="20251023165020"><br>三分恶面渣逆袭：SDS</p>
<p>然后是字典，更底层是用数组+链表实现的哈希表。它的设计很巧妙，用了两个哈希表，平时用第一个，rehash 的时候用第二个，这样可以渐进式地进行扩容，不会阻塞太久。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165052.png" alt="20251023165052"><br>三分恶面渣逆袭：字典</p>
<p>接下来压缩列表 ziplist，这个设计很有意思。Redis 为了节省内存，设计了这种紧凑型的数据结构，把所有元素连续存储在一块内存里。但是它有个致命问题叫”连锁更新”，就是当我们修改一个元素的时候，可能会导致后面所有的元素都要重新编码，性能会急剧下降。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165136.png" alt="20251023165136"><br>Shubhi Jain：Ziplist</p>
<p>为了解决压缩列表的问题，Redis 后来设计了 quicklist。这个设计思路很聪明，它把 ziplist 拆分成小块，然后用双向链表把这些小块串起来。这样既保持了 ziplist 节省内存的优势，又避免了连锁更新的问题，因为每个小块的 ziplist 都不会太大。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165213.png" alt="20251023165213"><br>Mr.于博客园：quicklist</p>
<p>再后来，Redis 又设计了 listpack，这个可以说是 ziplist 的完美替代品。它最大的特点是每个元素只记录自己的长度，不记录前一个元素的长度，这样就彻底解决了连锁更新的问题。Redis 5.0 已经用 listpack 替换了 ziplist。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165228.png" alt="20251023165228"><br>baseoncpp：listpack</p>
<p>跳表skiplist 主要用在 ZSet 中。它的设计很巧妙，通过多层指针来实现快速查找，平均时间复杂度是 <code>O(log N)</code>。相比红黑树，跳表的实现更简单，而且支持范围查询，这对 Redis 的有序集合来说很重要。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165726.png" alt="20251023165726"><br>三分恶面渣逆袭：跳表</p>
<p>还有整数集合intset，当 Set 中都是整数且元素数量较少时使用，内部是一个有序数组，查找用的二分法。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165813.png" alt="20251023165813"><br>zhangtielei.com：intset</p>
<p>最后是双向链表LinkedList，早期版本的 Redis 会在 List 中用到，但 Redis 3.2 后就被 quicklist 替代了，因为纯链表的问题是内存不连续，影响 CPU 缓存性能。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165854.png" alt="20251023165854"><br>pdai：Redis 底层数据结构和数据类型关系</p>
<h4 id="简单介绍下链表？"><a href="#简单介绍下链表？" class="headerlink" title="简单介绍下链表？"></a>简单介绍下链表？</h4><p>Redis 的 linkedlist 是⼀个双向⽆环链表结构，和 Java 中的 <a target="_blank" rel="noopener" href="https://javabetter.cn/collection/linkedlist.html">LinkedList</a> 类似。</p>
<p>节点由 listNode 表示，每个节点都有指向其前置节点和后置节点的指针，头节点的前置和尾节点的后置均指向 null。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023165930.png" alt="20251023165930"><br>三分恶面渣逆袭：链表linkedlist</p>
<h4 id="关于整数集合，能再详细说说吗？"><a href="#关于整数集合，能再详细说说吗？" class="headerlink" title="关于整数集合，能再详细说说吗？"></a>关于整数集合，能再详细说说吗？</h4><p>整数集合是 Redis 中一个非常精巧的数据结构，当一个 Set 只包含整数元素，并且数量不多时，默认不超过 512 个，Redis 就会用 intset 来存储这些数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170000.png" alt="20251023170000"><br>三分恶面渣逆袭：整数集合intset</p>
<p>intset 最有意思的地方是类型升级机制。它有三种编码方式：16位、32位和 64位，会根据存储的整数大小动态调整。比如原来存的都是小整数，用 16 位编码就够了，但突然插入了一个很大的数，超出了 16 位的范围，这时整个数组会升级到 32 位编码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;   <span class="comment">// 编码方式：16位、32位或64位</span></span><br><span class="line">    <span class="type">uint32_t</span> length;     <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];   <span class="comment">// 保存元素的数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>当然了，这种升级是有代价的，因为需要重新分配内存并复制数据，并且是不可逆的，但它的好处是可以节省内存空间，特别是在存储大量小整数时。</p>
<p>另外，所有元素在数组中按照从小到大的顺序排列，这样就可以使用二分查找来定位元素，时间复杂度为 <code>O(log N)</code>。</p>
<h4 id="说一下zset-的底层原理？"><a href="#说一下zset-的底层原理？" class="headerlink" title="说一下zset 的底层原理？"></a>说一下zset 的底层原理？</h4><p>ZSet 是 Redis 最复杂的数据类型，它有两种底层实现方式：压缩列表和跳表。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170235.png" alt="20251023170235"><br>0xcafebabe：zset 的底层实现</p>
<p>当保存的元素数量少于 128 个，且保存的所有元素大小都小于 64 字节时，Redis 会采用压缩列表的编码方式；否则就用跳表。</p>
<p>当然，这两个条件都可以通过参数进行调整。</p>
<p>选择压缩列表作为底层实现时，每个元素会使用两个紧挨在一起的节点来保存：第一个节点保存元素的成员，第二个节点保存元素的分值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170247.png" alt="20251023170247"><br>0xcafebabe：zset 使用压缩列表</p>
<p>所有元素按分值从小到大有序排列，小的放在靠近表头的位置，大的放在靠近表尾的位置。</p>
<p>但跳表的缺点是查找只能按顺序进行，时间复杂度为 <code>O(N)</code>，而且在最坏的情况下，插入和删除操作还可能会引起连锁更新。</p>
<p>当元素数量较多或元素较大时，Redis 会使用 skiplist 的编码方式；这个设计非常的巧妙，同时使用了两种数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    zskiplist *zsl;  <span class="comment">// 跳跃表</span></span><br><span class="line">    dict *dict;      <span class="comment">// 字典</span></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>跳表按分数有序保存所有元素，且支持范围查询（如 <code>ZRANGE</code>、<code>ZRANGEBYSCORE</code>），平均时间复杂度为 <code>O(log N)</code>。而哈希表则用来存储成员和分值的映射关系，查找时间复杂度为 <code>O(1)</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170359.png" alt="20251023170359"><br>0xcafebabe：zset 使用跳表</p>
<p>虽然同时使用两种结构，但它们会通过指针来共享相同元素的成员和分值，因此不会浪费额外的内存。</p>
<h4 id="你知道为什么Redis-7-0要用listpack来替代ziplist吗？"><a href="#你知道为什么Redis-7-0要用listpack来替代ziplist吗？" class="headerlink" title="你知道为什么Redis 7.0要用listpack来替代ziplist吗？"></a>你知道为什么Redis 7.0要用listpack来替代ziplist吗？</h4><p>答：主要是为了解决压缩列表的一个核心问题——连锁更新。在压缩列表中，每个节点都需要记录前一个节点的长度信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170416.png" alt="20251023170416"><br>wenfh2020.com：redis ziplist</p>
<p>当插入或删除一个节点时，如果这个操作导致某个节点的长度发生了变化，那么后续的节点可能都需要更新它们存储的”前一个节点长度”字段。最坏的情况下，一次操作可能触发整个链表的更新，时间复杂度会从 <code>O(1)</code>退化到 <code>O(n²)</code>。</p>
<p>而 listpack 的设计理念完全不同。它让每个节点只记录自己的长度信息，不再依赖前一个节点的长度。这样就从根本上避免了连锁更新的问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170521.png" alt="20251023170521"><br>极客时间：listpack</p>
<p>listpack 中的节点不再保存其前一个节点的长度，而是保存当前节点的编码类型、数据和长度。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251023170535.png" alt="20251023170535"><br>极客时间：listpack 的元素</p>
<h4 id="连锁更新是怎么发生的？"><a href="#连锁更新是怎么发生的？" class="headerlink" title="连锁更新是怎么发生的？"></a>连锁更新是怎么发生的？</h4><p>比如说我们有一个压缩列表，其中有几个节点的长度都是 253 个字节。在 ziplist 的编码中，如果前一个节点的长度小于 254 字节，我们只需要 1 个字节来存储这个长度信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607100252.png" alt="Hello Jelly：连锁更新"></p>
<p>Hello Jelly：连锁更新</p>
<p>但如果在这些节点前面插入一个长度为 254 字节的节点，那么原来只需要 1 个字节存储长度的节点现在需要 5 个字节来存储长度信息。这就会导致后续所有节点的长度信息都需要更新。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动商业化一面的原题：说说 Redis 的 zset，什么是跳表，插入一个节点要构建几层索引</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动面经同学 9 飞书后端技术一面面试原题：Redis 的数据类型，ZSet 的实现</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米暑期实习同学 E 一面面试原题：你知道 Redis 的 zset 底层实现吗</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 23 QQ 后台技术一面面试原题：zset 的底层原理</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手面经同学 7 Java 后端技术一面面试原题：说一下 ZSet 底层结构</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团同学 9 一面面试原题：redis的数据结构底层原理？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 27 云后台技术一面面试原题：Zset的底层实现？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的得物面经同学 9 面试题目原题：Zset的底层如何实现？</li>
</ol>
</blockquote>
<h3 id="52-🌟你了解跳表吗？"><a href="#52-🌟你了解跳表吗？" class="headerlink" title="52.🌟你了解跳表吗？"></a>52.🌟你了解跳表吗？</h3><p>跳表是一种非常巧妙的数据结构，它在有序链表的基础上建立了多层索引，最底层包含所有数据，每往上一层，节点数量就减少一半。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024094421.png" alt="20251024094421"><br>metahub follower：skiplist</p>
<p>它的核心思想是”用空间换时间”，通过多层索引来跳过大量节点，从而提高查找效率。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024094451.png" alt="20251024094451"><br>三分恶面渣逆袭：跳表</p>
<p>每个节点有 50% 的概率只在第 1 层出现，25% 的概率在第 2 层出现，依此类推。查找的时候从最高层开始水平移动，当下一个节点值大于目标时，就向下跳一层，直到找到目标节点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024094551.png" alt="20251024094551"><br>Dylan Wang：Skiplist</p>
<h4 id="怎么往跳表插入节点呢？"><a href="#怎么往跳表插入节点呢？" class="headerlink" title="怎么往跳表插入节点呢？"></a>怎么往跳表插入节点呢？</h4><p>首先是找到插入位置，从最高层的头节点开始，在每一层都找到应该插入位置的前驱节点，用一个 update 数组把这些前驱节点记录下来。这个查找过程和普通查找一样，在每层向右移动直到下个节点的值大于要插入的值，然后下降到下一层。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录每层的插入位置</span></span><br><span class="line">zskiplistNode *update[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">zskiplistNode *x;</span><br><span class="line"><span class="type">int</span> i, level;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最高层开始查找</span></span><br><span class="line">x = zsl-&gt;header;</span><br><span class="line"><span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 在当前层水平移动，找到插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">           (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">             sdscmp(x-&gt;level[i].forward-&gt;ele, ele) &lt; <span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    update[i] = x;  <span class="comment">// 记录每层的前驱节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来随机生成新节点的层数。通常用一个循环，每次有 50% 的概率继续往上，直到随机失败或达到最大层数限制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis 中的随机层数生成</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zslRandomLevel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level &lt; ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成新节点的层数</span></span><br><span class="line">level = zslRandomLevel();</span><br></pre></td></tr></table></figure>

<p>创建新节点后，从底层开始到新节点的最高层，在每一层都进行标准的链表插入操作。这一步要利用之前记录的 update 数组，将新节点插入到正确位置，然后更新前后指针的连接关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新前进指针</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">    x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">    update[i]-&gt;level[i].forward = x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新跨度信息</span></span><br><span class="line">    x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">    update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新未涉及层的跨度</span></span><br><span class="line"><span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">    update[i]-&gt;level[i].span++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新后退指针</span></span><br><span class="line">x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">    x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    zsl-&gt;tail = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新跳表长度</span></span><br><span class="line">zsl-&gt;length++;</span><br></pre></td></tr></table></figure>

<p>我们来模拟一个跳表的插入过程，假设插入的数据依次是 22、19、7、3、37、11、26。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024095121.png" alt="20251024095121"><br>zhangtielei.com：跳表插入过程</p>
<p>那假如我们在一个已经分布了 1、14、27、31、44、56、63、70、80、91 的跳表中插入一个 67 的节点，插入过程是这样的：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024095130.png" alt="20251024095130"><br>Dylan Wang：插入节点</p>
<h4 id="zset为什么要使用跳表呢？"><a href="#zset为什么要使用跳表呢？" class="headerlink" title="zset为什么要使用跳表呢？"></a>zset为什么要使用跳表呢？</h4><p>第一，跳表天然就是有序的数据结构，查找、插入和删除都能保持 <code>O(log n)</code> 的时间复杂度。</p>
<p>第二，跳表支持范围查询，找到起始位置后可以直接沿着底层链表顺序遍历，满足 ZRANGE 按排名获取元素，或者 ZRANGEBYSCORE 按分值范围获取元素。</p>
<h4 id="跳表是如何定义的呢？"><a href="#跳表是如何定义的呢？" class="headerlink" title="跳表是如何定义的呢？"></a>跳表是如何定义的呢？</h4><p>跳表本质上是一个多层链表，底层是一个包含所有元素的有序链表，上一层作为索引层，包含了下一层的部分节点；层数通过随机算法确定，理论上可以无限高。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024095312.png" alt="20251024095312"><br>metahub follower：跳表</p>
<p>跳表节点包含分值 score、成员对象 obj、一个后退指针 backward，以及一个层级数组 level。每个层级包含 forward 前进指针和 span 跨度信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> score;                    <span class="comment">// 分值（用于排序）</span></span><br><span class="line">    robj *obj;                      <span class="comment">// 数据对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">backward</span>;</span>   <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;           <span class="comment">// 跨度（到下个节点的距离）</span></span><br><span class="line">    &#125; level[];                      <span class="comment">// 层级数组</span></span><br><span class="line">&#125; skiplistNode;</span><br></pre></td></tr></table></figure>

<p>跳表本身包含头尾节点指针、节点总数 length 和当前最大层数 level。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">skiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">// 头尾节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;               <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">int</span> level;                         <span class="comment">// 最大层数</span></span><br><span class="line">&#125; skiplist;</span><br></pre></td></tr></table></figure>

<h4 id="span-跨度有什么用？"><a href="#span-跨度有什么用？" class="headerlink" title="span 跨度有什么用？"></a>span 跨度有什么用？</h4><p>span 记录了当前节点到下一节点之间，底层到底跨越了几个节点，它的主要作用是快速找到 ZSet 中某个分值的排名。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024100031.png" alt="20251024100031"><br>Aparajita Pandey：span</p>
<p>比如说我们执行 <code>ZRANK</code> 命令时，如果没有 span，就需要从头节点开始遍历每个节点，直到找到目标分值，这样时间复杂度是 <code>O(n)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有span的排名查询 - O(n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRankWithoutSpan</span><span class="params">(skiplist *zsl, <span class="type">double</span> score, robj *obj)</span> &#123;</span><br><span class="line">    skiplistNode *x = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;score == score &amp;&amp; equalStringObjects(x-&gt;obj, obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank + <span class="number">1</span>;  <span class="comment">// 排名从1开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        rank++;</span><br><span class="line">        x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但有了 span，我们在从高层往低层搜索的时候，可以直接跳过一些节点，快速定位到目标分值所在的范围。这样就能把时间复杂度降到 <code>O(log n)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">skiplistGetRank</span><span class="params">(skiplist *zsl, <span class="type">double</span> score, robj *obj)</span> &#123;</span><br><span class="line">    skiplistNode *x = zsl-&gt;header;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从最高层开始查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = zsl-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">               (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                 compareStringObjects(x-&gt;level[i].forward-&gt;obj, obj) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">            </span><br><span class="line">            rank += x-&gt;level[i].span;  <span class="comment">// 累加跨度</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到目标节点</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">            equalStringObjects(x-&gt;level[i].forward-&gt;obj, obj)) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么跳表的范围查询效率比字典高？"><a href="#为什么跳表的范围查询效率比字典高？" class="headerlink" title="为什么跳表的范围查询效率比字典高？"></a>为什么跳表的范围查询效率比字典高？</h4><p>字典是通过哈希函数将键值对分散存储的，元素在内存中是无序分布的，没有任何顺序关系。而跳表本身就是有序的数据结构，所有元素按照分值从小到大排列。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024100154.png" alt="20251024100154"><br>WARRIOR：跳表</p>
<p>当需要进行范围查询时，字典必须遍历所有元素，逐个检查每个元素是否在指定范围内，时间复杂度是 <code>O(n)</code>。比如要找分值在 60 到 80 之间的所有元素，字典只能把整个哈希表扫描一遍，因为它无法知道符合条件的元素在哪里。</p>
<p>而跳表的范围查询就高效多了。首先用 <code>O(log n)</code> 时间找到范围的起始位置，然后沿着底层的有序链表顺序遍历，直到超出范围为止。总时间复杂度是 <code>O(log n + k)</code>，其中 k 是结果集的大小。这种效率差异在数据量大的时候非常明显。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024100219.png" alt="20251024100219"><br>晴天哥：zset 底层由字典和跳表组成</p>
<p>这也是为什么 Redis 的 zset 要用跳表而不是纯哈希表的重要原因，因为 zset 经常需要 ZRANGE、ZRANGEBYSCORE 这类范围操作。实际上 Redis 的 zset 是跳表和哈希表的组合：跳表保证有序性支持范围查询，哈希表保证 <code>O(1)</code> 的单点查找效率，两者互补。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米暑期实习同学 E 一面面试原题：为什么 hash 表范围查询效率比跳表低</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的得物面经同学 8 一面面试原题：跳表的结构</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团面经同学 4 一面面试原题：Redis 跳表</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里系面经同学 19 饿了么面试原题：跳表了解吗</li>
</ol>
</blockquote>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="4-🌟Spring用了哪些设计模式？"><a href="#4-🌟Spring用了哪些设计模式？" class="headerlink" title="4.🌟Spring用了哪些设计模式？"></a>4.🌟Spring用了哪些设计模式？</h3><p>Spring 框架里面确实用了很多设计模式，我从平时工作中能观察到的几个来说说。</p>
<p>首先是工厂模式，这个在 Spring 里用得非常多。BeanFactory 就是一个典型的工厂，它负责创建和管理所有的 Bean 对象。我们平时用的 ApplicationContext 其实也是 BeanFactory 的一个实现。当我们通过 <code>@Autowired</code> 获取一个 Bean 的时候，底层就是通过工厂模式来创建和获取对象的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022155254.png" alt="20251022155254"><br>三分恶面渣逆袭：Spring中用到的设计模式</p>
<p>单例模式也是 Spring 的默认行为。默认情况下，Spring 容器中的 Bean 都是单例的，整个应用中只会有一个实例。这样可以节省内存，提高性能。当然我们也可以通过 <code>@Scope</code> 注解来改变 Bean 的作用域，比如设置为 prototype 就是每次获取都创建新实例。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022155349.png" alt="20251022155349"><br>二哥的 Java 进阶之路：@Scope注解</p>
<p>代理模式在 AOP 中用得特别多。Spring AOP 的底层实现就是基于动态代理的，对于实现了接口的类用 JDK 动态代理，没有实现接口的类用 CGLIB 代理。比如我们用 <code>@Transactional</code> 注解的时候，Spring 会为我们的类创建一个代理对象，在方法执行前后添加事务处理逻辑。</p>
<p>模板方法模式在 Spring 里也很常见，比如 JdbcTemplate。它定义了数据库操作的基本流程：获取连接、执行 SQL、处理结果、关闭连接，但是具体的 SQL 语句和结果处理逻辑由我们来实现。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022155821.png" alt="20251022155821"><br>技术派源码：JdbcTemplate</p>
<p>观察者模式在 Spring 的事件机制中有所体现。我们可以通过 ApplicationEvent 和 ApplicationListener 来实现事件的发布和监听。比如用户注册成功后，我们可以发布一个用户注册事件，然后有多个监听器来处理后续的业务逻辑，比如发送邮件、记录日志等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022155845.png" alt="20251022155845"><br>技术派源码：ApplicationListener</p>
<p>这些设计模式的应用让 Spring 框架既灵活又强大，也让我在实际的开发中学到很多经典的设计思想。</p>
<h4 id="Spring如何实现单例模式？"><a href="#Spring如何实现单例模式？" class="headerlink" title="Spring如何实现单例模式？"></a>Spring如何实现单例模式？</h4><p>传统的单例模式是在类的内部控制只能创建一个实例，比如用 private 构造方法加 <code>static getInstance()</code> 这种方式。但是 Spring 的单例是容器级别的，同一个 Bean 在整个 Spring 容器中只会有一个实例。</p>
<p>具体的实现机制是这样的：Spring 在启动的时候会把所有的 Bean 定义信息加载进来，然后在 DefaultSingletonBeanRegistry 这个类里面维护了一个叫 singletonObjects 的 ConcurrentHashMap，这个 Map 就是用来存储单例 Bean 的。key 是 Bean 的名称，value 就是 Bean 的实例对象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022160045.png" alt="20251022160045"><br>二哥的 Java 进阶之路：DefaultSingletonBeanRegistry</p>
<p>当我们第一次获取某个 Bean 的时候，Spring 会先检查 singletonObjects 这个 Map 里面有没有这个 Bean，如果没有就会创建一个新的实例，然后放到 Map 里面。后面再获取同一个 Bean 的时候，直接从 Map 里面取就行了，这样就保证了单例。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022160058.png" alt="20251022160058"><br>二哥的 Java 进阶之路：registerSingleton</p>
<p>还有一个细节就是 Spring 为了解决循环依赖的问题，还用了三级缓存。除了 singletonObjects 这个一级缓存，还有 earlySingletonObjects 二级缓存和 singletonFactories 三级缓存。这样即使有循环依赖，Spring 也能正确处理。</p>
<p>而且 Spring 的单例是线程安全的，因为用的是 ConcurrentHashMap，多线程访问不会有问题。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的携程面经同学 10 Java 暑期实习一面面试原题：Spring IoC 的设计模式，AOP 的设计模式</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小公司面经合集同学 1 Java 后端面试原题：Spring 框架使用到的设计模式？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的同学 1 贝壳找房后端技术一面面试原题：Spring用了什么设计模式？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：Spring中使用了哪些设计模式，以其中一种模式举例说明？Spring如何实现单例模式？</li>
</ol>
</blockquote>
<h3 id="7-🌟能说一下Bean的生命周期吗？"><a href="#7-🌟能说一下Bean的生命周期吗？" class="headerlink" title="7.🌟能说一下Bean的生命周期吗？"></a>7.🌟能说一下Bean的生命周期吗？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zb6eA3Se0gQoqL8PylCPLw">三分恶：Spring Bean 生命周期，好像人的一生</a></p>
<p>好的。</p>
<p>Bean 的生命周期可以分为 5 个主要阶段，我按照实际的执行顺序来说一下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164805.png" alt="20251022164805"><br>三分恶面渣逆袭：Bean生命周期五个阶段</p>
<p>第一个阶段是实例化。Spring 容器会根据 BeanDefinition，通过反射调用 Bean 的构造方法创建对象实例。如果有多个构造方法，Spring 会根据依赖注入的规则选择合适的构造方法。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164814.png" alt="20251022164814"><br>三分恶面渣逆袭：Spring Bean生命周期</p>
<p>第二阶段是属性赋值。这个阶段 Spring 会给 Bean 的属性赋值，包括通过 <code>@Autowired</code>、<code>@Resource</code> 这些注解注入的依赖对象，以及通过 <code>@Value</code> 注入的配置值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164823.png" alt="20251022164823"><br>二哥的 Java 进阶之路：doCreateBean 方法源码</p>
<p>第三阶段是初始化。这个阶段会依次执行：</p>
<ul>
<li><code>@PostConstruct</code> 标注的方法</li>
<li>InitializingBean 接口的 afterPropertiesSet 方法</li>
<li>通过 <code>@Bean</code> 的 initMethod 指定的初始化方法</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164834.png" alt="20251022164834"><br>三分恶面渣逆袭：Bean生命周期源码追踪</p>
<p>我在项目中经常用 <code>@PostConstruct</code> 来做一些初始化工作，比如缓存预加载、DB 配置等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CategoryServiceImpl中的缓存初始化</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    categoryCaches = CacheBuilder.newBuilder().maximumSize(<span class="number">300</span>).build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;Long, CategoryDTO&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> CategoryDTO <span class="title function_">load</span><span class="params">(<span class="meta">@NotNull</span> Long categoryId)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">CategoryDO</span> <span class="variable">category</span> <span class="operator">=</span> categoryDao.getById(categoryId);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DynamicConfigContainer中的配置初始化</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    cache = Maps.newHashMap();</span><br><span class="line">    bindBeansFromLocalCache(<span class="string">&quot;dbConfig&quot;</span>, cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化后，Spring 还会调用所有注册的 BeanPostProcessor 后置处理方法。这个阶段经常用来创建代理对象，比如 AOP 代理。</p>
<p>第五阶段是使用 Bean。比如我们的 Controller 调用 Service，Service 调用 DAO。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserController中的使用示例</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserDTO <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.getUserById(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UserService中的使用示例</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="keyword">public</span> UserDTO <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userDao.getById(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UserDao中的使用示例</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"><span class="keyword">public</span> UserDTO <span class="title function_">getById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;id&#125;, <span class="keyword">new</span> <span class="title class_">UserRowMapper</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是销毁阶段。当容器关闭或者 Bean 被移除的时候，会依次执行：</p>
<ul>
<li><code>@PreDestroy</code> 标注的方法</li>
<li>DisposableBean 接口的 destroy 方法</li>
<li>通过 <code>@Bean</code> 的 destroyMethod 指定的销毁方法</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164849.png" alt="20251022164849"><br>二哥的 Java 进阶之路：close 源码</p>
<h4 id="Aware-类型的接口有什么作用？"><a href="#Aware-类型的接口有什么作用？" class="headerlink" title="Aware 类型的接口有什么作用？"></a>Aware 类型的接口有什么作用？</h4><p>Aware 接口在 Spring 中是一个很有意思的设计，它们的作用是让 Bean 能够感知到 Spring 容器的一些内部组件。</p>
<p>从设计理念来说，Aware 接口实现了一种“回调”机制。正常情况下，Bean 不应该直接依赖 Spring 容器，这样可以保持代码的独立性。但有些时候，Bean 确实需要获取容器的一些信息或者组件，Aware 接口就提供了这样一个能力。</p>
<p>我最常用的 Aware 接口是 ApplicationContextAware，它可以让 Bean 获取到 ApplicationContext 容器本身。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022164904.png" alt="20251022164904"><br>技术派源码：ApplicationContextAware</p>
<p>在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派项目</a>中，我就通过实现 ApplicationContextAware 和 EnvironmentAware 接口封装了一个 SpringUtil 工具类，通过 getBean 和 getProperty 方法来获取 Bean 和配置属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法获取Bean，方便在非Spring管理的类中使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> context.getBean(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> environment.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果配置了-init-method-和-destroy-method，Spring-会在什么时候调用其配置的方法？"><a href="#如果配置了-init-method-和-destroy-method，Spring-会在什么时候调用其配置的方法？" class="headerlink" title="如果配置了 init-method 和 destroy-method，Spring 会在什么时候调用其配置的方法？"></a>如果配置了 init-method 和 destroy-method，Spring 会在什么时候调用其配置的方法？</h4><p>init-method 指定的初始化方法会在 Bean 的初始化阶段被调用，具体的执行顺序是：</p>
<ul>
<li>先执行 <code>@PostConstruct</code> 标注的方法</li>
<li>然后执行 InitializingBean 接口的 <code>afterPropertiesSet()</code> 方法</li>
<li>最后再执行 init-method 指定的方法</li>
</ul>
<p>也就是说，init-method 是在所有其他初始化方法之后执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postConstruct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1. @PostConstruct执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customInit</span><span class="params">()</span> &#123;  <span class="comment">// 通过@Bean的initMethod指定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3. init-method执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;customInit&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>destroy-method 会在 Bean 销毁阶段被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1. @PreDestroy执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customDestroy</span><span class="params">()</span> &#123;  <span class="comment">// 通过@Bean的destroyMethod指定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3. destroy-method执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过在实际开发中，通常用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 就够了，它们更简洁。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米 25 届日常实习一面原题：说说 Bean 的生命周期</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：Spring中bean生命周期</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的8 后端开发秋招一面面试原题：讲一下Spring Bean的生命周期</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的同学 1 贝壳找房后端技术一面面试原题：bean生命周期</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：介绍下Bean的生命周期？Aware类型接口的作用？如果配置了init-method和destroy-method，Spring会在什么时候调用其配置的方法？</li>
</ol>
</blockquote>
<h3 id="14-🌟Spring怎么解决循环依赖呢？"><a href="#14-🌟Spring怎么解决循环依赖呢？" class="headerlink" title="14.🌟Spring怎么解决循环依赖呢？"></a>14.🌟Spring怎么解决循环依赖呢？</h3><p>Spring 通过三级缓存机制来解决循环依赖：</p>
<ol>
<li>一级缓存：存放完全初始化好的单例 Bean。</li>
<li>二级缓存：存放提前暴露的 Bean，实例化完成，但未初始化完成。</li>
<li>三级缓存：存放 Bean 工厂，用于生成提前暴露的 Bean。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165402.png" alt="20251022165402"><br>三分恶面渣逆袭：三级缓存</p>
<p>以 A、B 两个类发生循环依赖为例：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165409.png" alt="20251022165409"><br>三分恶面渣逆袭：循环依赖</p>
<p>第 1 步：开始创建 Bean A。</p>
<ul>
<li>Spring 调用 A 的构造方法，创建 A 的实例。此时 A 对象已存在，但 b属性还是 null。</li>
<li>将 A 的对象工厂放入三级缓存。</li>
<li>开始进行 A 的属性注入。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165417.png" alt="20251022165417"><br>三分恶面渣逆袭：A 对象工厂</p>
<p>第 2 步：A 需要注入 B，开始创建 Bean B。</p>
<ul>
<li>发现需要 B，但 B 还不存在，所以开始创建 B。</li>
<li>调用 B 的构造方法，创建 B 的实例。此时 B 对象已存在，但 a 属性还是 null。</li>
<li>将 B 的对象工厂放入三级缓存。</li>
<li>开始进行 B 的属性注入。</li>
</ul>
<p>第 3 步：B 需要注入 A，从缓存中获取 A。</p>
<ul>
<li>B 需要注入 A，先从一级缓存找 A，没找到。</li>
<li>再从二级缓存找 A，也没找到。</li>
<li>最后从三级缓存找 A，找到了 A 的对象工厂。</li>
<li>调用 A 的对象工厂得到 A 的实例。这时 A 已经实例化了，虽然还没完全初始化。</li>
<li>将 A 从三级缓存移到二级缓存。</li>
<li>B 拿到 A 的引用，完成属性注入。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165426.png" alt="20251022165426"><br>三分恶面渣逆袭：A 放入二级缓存，B 放入一级缓存</p>
<p>第 4 步：B 完成初始化。</p>
<ul>
<li>B 的属性注入完成，执行 <code>@PostConstruct</code> 等初始化逻辑。</li>
<li>B 完全创建完成，从三级缓存移除，放入一级缓存。</li>
</ul>
<p>第 5 步：A 完成初始化。</p>
<ul>
<li>回到 A 的创建过程，A 拿到完整的 B 实例，完成属性注入。</li>
<li>A 执行初始化逻辑，创建完成。</li>
<li>A 从二级缓存移除，放入一级缓存。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165435.png" alt="20251022165435"><br>三分恶面渣逆袭：AB 都好了</p>
<p>用代码来模拟这个过程，是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟Spring的解决过程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 三级缓存</span></span><br><span class="line">    Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, ObjectFactory&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 先从一级缓存获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) <span class="keyword">return</span> bean;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再从二级缓存获取</span></span><br><span class="line">        bean = earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) <span class="keyword">return</span> bean;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后从三级缓存获取</span></span><br><span class="line">        <span class="type">ObjectFactory</span> <span class="variable">factory</span> <span class="operator">=</span> singletonFactories.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">            bean = factory.getObject();</span><br><span class="line">            earlySingletonObjects.put(beanName, bean);  <span class="comment">// 移到二级缓存</span></span><br><span class="line">            singletonFactories.remove(beanName);        <span class="comment">// 从三级缓存移除</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哪些情况下Spring无法解决循环依赖？"><a href="#哪些情况下Spring无法解决循环依赖？" class="headerlink" title="哪些情况下Spring无法解决循环依赖？"></a>哪些情况下Spring无法解决循环依赖？</h4><p>Spring 虽然能解决大部分循环依赖问题，但确实有几种情况是无法处理的，我来详细说说。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165456.png" alt="20251022165456"><br>三分恶面渣逆袭：循环依赖的几种情形</p>
<p>第一种，构造方法的循环依赖，这种情况 Spring 会直接抛出 BeanCurrentlyInCreationException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;  <span class="comment">// 构造方法注入</span></span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;  <span class="comment">// 构造方法注入</span></span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为构造方法注入发生在实例化阶段，创建 A 的时候必须先有 B，但创建 B又必须先有 A，这时候两个对象都还没创建出来，无法提前暴露到缓存中。</p>
<p>第二种，prototype 作用域的循环依赖。prototype 作用域的 Bean 每次获取都会创建新实例，Spring 无法缓存这些实例，所以也无法解决循环依赖。</p>
<p>-—面试中可以不背，方便大家理解 start—-</p>
<p>我们来看一个实例，先是 PrototypeBeanA：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeBeanA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrototypeBeanB prototypeBeanB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrototypeBeanA</span><span class="params">(PrototypeBeanB prototypeBeanB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prototypeBeanB = prototypeBeanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是 PrototypeBeanB：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeBeanB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrototypeBeanA prototypeBeanA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrototypeBeanB</span><span class="params">(PrototypeBeanA prototypeBeanA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prototypeBeanA = prototypeBeanA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再然后是测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    CommandLineRunner <span class="title function_">commandLineRunner</span><span class="params">(ApplicationContext ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            <span class="comment">// 尝试获取PrototypeBeanA的实例</span></span><br><span class="line">            <span class="type">PrototypeBeanA</span> <span class="variable">beanA</span> <span class="operator">=</span> ctx.getBean(PrototypeBeanA.class);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165524.png" alt="20251022165524"><br>二哥的 Java 进阶之路：循环依赖</p>
<p>-—面试中可以不背，方便大家理解 end—-</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米 25 届日常实习一面原题：如何解决循环依赖？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：Spring如何解决循环依赖？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的得物面经同学 9 面试题目原题：Spring源码看过吗？Spring的三级缓存知道吗？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里云面经同学 22 面经：spring三级缓存解决循环依赖问题</li>
</ol>
</blockquote>
<h3 id="16-🌟说一说什么是IoC？"><a href="#16-🌟说一说什么是IoC？" class="headerlink" title="16.🌟说一说什么是IoC？"></a>16.🌟说一说什么是IoC？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/springboot/ioc.html">IoC 扫盲</a></p>
<p>IoC 的全称是 Inversion of Control，也就是控制反转。这里的“控制”指的是对象创建和依赖关系管理的控制权。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165715.png" alt="20251022165715"><br>图片来源于网络：IoC</p>
<p>以前我们写代码的时候，如果 A 类需要用到 B 类，我们就在 A 类里面直接 new 一个 B 对象出来，这样 A 类就控制了 B 类对象的创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式：对象主动创建依赖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 主动创建依赖对象</span></span><br><span class="line">        <span class="built_in">this</span>.userDao = <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了 IoC 之后，这个控制权就“反转”了，不再由 A 类来控制 B 对象的创建，而是交给外部的容器来管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用 Spring IoC 容器来管理 UserDao 的创建和注入</span></span><br><span class="line"><span class="comment"> * 技术派源码：https://github.com/itwanger/paicoding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不需要主动创建 UserDao，由 Spring 容器注入</span></span><br><span class="line">    <span class="keyword">public</span> BaseUserInfoDTO <span class="title function_">getAndUpdateUserIpInfoBySessionId</span><span class="params">(String session, String clientIp)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接使用注入的 userDao</span></span><br><span class="line">        <span class="keyword">return</span> userDao.getBySessionId(session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-—这部分面试中可以不背 start—-</p>
<p>没有 IoC 之前：</p>
<blockquote>
<p>我需要一个女朋友，刚好大街上突然看到了一个小姐姐，人很好看，于是我就自己主动上去搭讪，要她的微信号，找机会聊天关心她，然后约她出来吃饭，打听她的爱好，三观。。。</p>
</blockquote>
<p>有了 IoC 之后：</p>
<blockquote>
<p>我需要一个女朋友，于是我就去找婚介所，告诉婚介所，我需要一个长的像赵露思的，会打 Dota2 的，于是婚介所在它的人才库里开始找，找不到它就直接说没有，找到它就直接介绍给我。</p>
</blockquote>
<p>婚介所就相当于一个 IoC 容器，我就是一个对象，我需要的女朋友就是另一个对象，我不用关心女朋友是怎么来的，我只需要告诉婚介所我需要什么样的女朋友，婚介所就帮我去找。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165731.png" alt="20251022165731"><br>三分恶面渣逆袭：引入IoC之前和引入IoC之后</p>
<p>-—这部分面试中可以不背 end—-</p>
<h4 id="DI和IoC的区别了解吗？"><a href="#DI和IoC的区别了解吗？" class="headerlink" title="DI和IoC的区别了解吗？"></a>DI和IoC的区别了解吗？</h4><p>IoC 的思想是把对象创建和依赖关系的控制权由业务代码转移给 Spring 容器。这是一个比较抽象的概念，告诉我们应该怎么去设计系统架构。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165745.png" alt="20251022165745"><br>Martin Fowler’s Definition</p>
<p>而 DI，也就是依赖注入，它是实现 IoC 这种思想的具体技术手段。在 Spring 里，我们用 <code>@Autowired</code> 注解就是在使用 DI 的字段注入方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleReadServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ArticleReadService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleDao articleDao;  <span class="comment">// 字段注入</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从实现角度来看，DI 除了字段注入，还有构造方法注入和 Setter 方法注入等方式。在做<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派</a>项目的时候，我就尝试过构造方法注入的方式。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165756.png" alt="20251022165756"><br>技术派源码：构造方法的注入方式</p>
<p>当然了，DI 并不是实现 IoC 的唯一方式，还有 Service Locator 模式，可以通过实现 ApplicationContextAware 接口来获取 Spring 容器中的 Bean。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022165805.png" alt="20251022165805"><br>技术派源码：IoC 的Service Locator 模式</p>
<p>之所以 ID 后成为 IoC 的首选实现方式，是因为代码更清晰、可读性更高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IoC（控制反转）</span><br><span class="line">├── DI（依赖注入）          ← 主要实现方式</span><br><span class="line">│   ├── 构造器注入</span><br><span class="line">│   ├── 字段注入</span><br><span class="line">│   └── Setter注入</span><br><span class="line">├── 服务定位器模式</span><br><span class="line">├── 工厂模式</span><br><span class="line">└── 其他实现方式</span><br></pre></td></tr></table></figure>

<h4 id="为什么要使用-IoC-呢？"><a href="#为什么要使用-IoC-呢？" class="headerlink" title="为什么要使用 IoC 呢？"></a>为什么要使用 IoC 呢？</h4><p>在日常开发中，如果我们需要实现某一个功能，可能至少需要两个以上的对象来协助完成，在没有 Spring 之前，每个对象在需要它的合作对象时，需要自己 new 一个，比如说 A 要使用 B，A 就对 B 产生了依赖，也就是 A 和 B 之间存在了一种耦合关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式：对象自己创建依赖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>(); <span class="comment">// 硬编码依赖</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了 Spring 之后，创建 B 的工作交给了 Spring 来完成，Spring 创建好了 B 对象后就放到容器中，A 告诉 Spring 我需要 B，Spring 就从容器中取出 B 交给 A 来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IoC 方式：依赖由外部注入</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 依赖注入，不关心具体实现</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于 B 是怎么来的，A 就不再关心了，Spring 容器想通过 newnew 创建 B 还是 new 创建 B，无所谓。</p>
<p>这就是 IoC 的好处，它降低了对象之间的耦合度，让每个对象只关注自己的业务实现，不关心其他对象是怎么创建的。</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xdp-gacl/p/4249939.html">孤傲苍狼：谈谈对 Spring IOC 的理解</a></p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米 25 届日常实习一面原题：说说你对 AOP 和 IoC 的理解。</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小公司面经合集同学 1 Java 后端面试原题：介绍 Spring IoC 和 AOP?</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的招商银行面经同学 6 招银网络科技面试原题：SpringBoot框架的AOP、IOC&#x2F;DI？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 8 面试原题：IOC，AOP</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：解释下什么是IOC和AOP？分别解决了什么问题？IOC和DI的区别？</li>
</ol>
</blockquote>
<h3 id="19-🌟项目启动时Spring的IoC会做什么？"><a href="#19-🌟项目启动时Spring的IoC会做什么？" class="headerlink" title="19.🌟项目启动时Spring的IoC会做什么？"></a>19.🌟项目启动时Spring的IoC会做什么？</h3><p>第一件事是扫描和注册 Bean。IoC 容器会根据我们的配置，比如 <code>@ComponentScan</code> 指定的包路径，去扫描所有标注了 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code> 这些注解的类。然后把这些类的元信息包装成 BeanDefinition 对象，注册到容器的 BeanDefinitionRegistry 中。这个阶段只是收集信息，还没有真正创建对象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024162351.png" alt="20251024162351"><br>pdai.tech：IoC</p>
<p>第二件事是 Bean 的实例化和注入。这是最核心的过程，IoC 容器会按照依赖关系的顺序开始创建 Bean 实例。对于单例 Bean，容器会通过反射调用构造方法创建实例，然后进行属性注入，最后执行初始化回调方法。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024162423.png" alt="20251024162423"><br>Tom弹架构：Bean 的实例化和注入</p>
<p>在依赖注入时，容器会根据 <code>@Autowired</code>、<code>@Resource</code> 这些注解，把相应的依赖对象注入到目标 Bean 中。比如 UserService 需要 UserDao，容器就会把 UserDao 的实例注入到 UserService 中。</p>
<h4 id="说说Spring的Bean实例化方式？"><a href="#说说Spring的Bean实例化方式？" class="headerlink" title="说说Spring的Bean实例化方式？"></a>说说Spring的Bean实例化方式？</h4><p>Spring 提供了 4 种方式来实例化 Bean，以满足不同场景下的需求。</p>
<p>第一种是通过构造方法实例化，这是最常用的方式。当我们用 <code>@Component</code>、<code>@Service</code> 这些注解标注类的时候，Spring 默认通过无参构造器来创建实例的。如果类只有一个有参构造方法，Spring 会自动进行构造方法注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;  <span class="comment">// 构造方法注入</span></span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是通过静态工厂方法实例化。有时候对象的创建比较复杂，我们会写一个静态工厂方法来创建，然后用 <code>@Bean</code> 注解来标注这个方法。Spring 会调用这个静态方法来获取 Bean 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 复杂的DataSource创建逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种是通过实例工厂方法实例化。这种方式是先创建工厂对象，然后通过工厂对象的方法来创建Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ConnectionFactory <span class="title function_">connectionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">createConnection</span><span class="params">(ConnectionFactory factory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.createConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四种是通过 FactoryBean 接口实例化。这是 Spring 提供的一个特殊接口，当我们需要创建复杂对象的时候特别有用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;MyObject&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyObject <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 复杂的对象创建逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyObject.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际工作中，用得最多的还是构造方法实例化，因为简单直接。工厂方法一般用在需要复杂初始化逻辑的场景，比如数据库连接池、消息队列连接这些。FactoryBean 主要是在框架开发或者需要动态创建对象的时候使用。</p>
<p>Spring 在实例化的时候会根据 Bean 的定义自动选择合适的方式，我们作为开发者主要是通过注解和配置来告诉 Spring 应该怎么创建对象。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为面经同学 8 技术二面面试原题：说说 Spring 的 Bean 实例化方式</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团同学 2 优选物流调度技术 2 面面试原题：bean加工有哪些方法？</li>
</ol>
</blockquote>
<h3 id="20-🌟说说什么是-AOP？"><a href="#20-🌟说说什么是-AOP？" class="headerlink" title="20.🌟说说什么是 AOP？"></a>20.🌟说说什么是 AOP？</h3><p>AOP，也就是面向切面编程，简单点说，AOP 就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加清爽。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024163612.png" alt="20251024163612"><br>三分恶面渣逆袭：横向抽取</p>
<p>-—这部分面试中可以不背，方便大家理解 start—-</p>
<p>举个简单的例子，假设我们有很多个 Service 方法，每个方法都需要记录执行日志、检查权限、管理事务等等。如果没有 AOP 的话，我们可能需要在每个方法里都写这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;开始执行createUser方法&quot;</span>);</span><br><span class="line">    <span class="comment">// 权限检查</span></span><br><span class="line">    <span class="keyword">if</span> (!hasPermission()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;无权限&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    transactionManager.begin();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 真正的业务逻辑</span></span><br><span class="line">        userDao.save(user);</span><br><span class="line">        transactionManager.commit();</span><br><span class="line">        log.info(<span class="string">&quot;createUser方法执行成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        transactionManager.rollback();</span><br><span class="line">        log.error(<span class="string">&quot;createUser方法执行失败&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果每个方法都这样写，代码就会变得非常臃肿，AOP 就是为了解决这个问题，它可以让我们把这些横切关注点（如日志、权限、事务等）从业务代码中抽取出来。</p>
<p>这样，我们就可以定义一个切面，在切面中统一处理这些横切关注点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行方法: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterReturning</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;方法执行成功: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;,</span></span><br><span class="line"><span class="meta">                   throwing = &quot;ex&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;方法执行失败: &quot;</span> + joinPoint.getSignature().getName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，业务代码就变得非常干净了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="comment">// 只需要关注业务逻辑，不需要关心日志、权限、事务等</span></span><br><span class="line">    userDao.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-—面试中可以不背，方便大家理解 end—-</p>
<p>从技术实现上来说，AOP 主要是通过动态代理来实现的。如果目标类实现了接口，就用 JDK 动态代理；如果没有实现接口，就用 CGLIB 来创建子类代理。代理对象会在方法执行前后插入我们定义的切面逻辑。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024163711.png" alt="20251024163711"><br>stack overflow：JDK Proxy vs CGLIB Proxy</p>
<h4 id="Spring-AOP-有哪些核心概念？"><a href="#Spring-AOP-有哪些核心概念？" class="headerlink" title="Spring AOP 有哪些核心概念？"></a>Spring AOP 有哪些核心概念？</h4><p>Spring AOP 是 AOP 的一个具体实现，我按照在工作&#x2F;学习中理解的重要程度来说一下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024163740.png" alt="20251024163740"><br>DataFlair Team：AOP 核心概念</p>
<p>①、<strong>切面</strong>：我们定义的一个类，包含了要在什么时候、什么地方执行什么逻辑。比如我们定义一个日志切面，专门负责记录方法的执行情况。在 Spring 中，我们会用 <code>@Aspect</code> 注解来标识一个切面类。</p>
<p>②、<strong>切点</strong>：定义了在哪些地方应用切面逻辑。说白了就是告诉 Spring，我这个切面要在哪些方法上生效。比如我们可以定义一个切点表达式，让它匹配所有 Service 层的方法，或者匹配某个特定包下的所有方法。在 Spring 中用 <code>@Pointcut</code> 注解来定义，通常会写一些表达式，比如 <code>execution( com.example.service..*(..))</code> 这样的。</p>
<p>③、<strong>通知</strong>：是切面中具体要执行的代码逻辑。它有几种类型：<code>@Before</code> 是在方法执行前执行，<code>@After</code> 是在方法执行后执行，<code>@Around</code> 是环绕通知，可以在方法执行前后都执行，<code>@AfterReturning</code> 是在方法正常返回后执行，<code>@AfterThrowing</code> 是在方法抛出异常后执行。我一般用得最多的是 <code>@Around</code>，因为它最灵活，可以控制方法是否执行，也可以修改参数和返回值。</p>
<p>④、<strong>连接点</strong>：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中，连接点指的是被拦截到的方法，实际上连接点还可以是字段或者构造方法。</p>
<p>⑤、<strong>织入</strong>：是把切面逻辑应用到目标对象的过程。Spring AOP 是在运行时通过动态代理来实现织入的，当我们从 Spring 容器中获取 Bean 的时候，如果这个 Bean 需要被切面处理，Spring 就会返回一个代理对象给我们。</p>
<p>⑥、<strong>目标对象</strong>：被切面处理的对象，也就是我们平时写的 Service、Controller 等类。Spring AOP 会在目标对象上织入切面逻辑。</p>
<p>它们之间的逻辑关系图是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">切面（Aspect）</span><br><span class="line">    ├── 切入点（Pointcut）─── 定义在哪里执行</span><br><span class="line">    └── 通知（Advice）   ─── 定义何时执行什么</span><br><span class="line">            ├── @Before</span><br><span class="line">            ├── @After</span><br><span class="line">            ├── @AfterReturning</span><br><span class="line">            ├── @AfterThrowing</span><br><span class="line">            └── @Around</span><br><span class="line"></span><br><span class="line">目标对象（Target）──→ 代理对象（Proxy）──→ 织入（Weaving）</span><br><span class="line">     ↑                                    ↓</span><br><span class="line">连接点（Join Point）                    客户端调用</span><br></pre></td></tr></table></figure>

<h4 id="Spring-AOP-织入有哪几种方式？"><a href="#Spring-AOP-织入有哪几种方式？" class="headerlink" title="Spring AOP 织入有哪几种方式？"></a>Spring AOP 织入有哪几种方式？</h4><p>织入有三种主要方式，我按照它们的执行时机来说一下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024163839.png" alt="20251024163839"><br>AOP 织入方式</p>
<p>编译期织入是在编译 Java 源码的时候就把切面逻辑织入到目标类中。这种方式最典型的实现就是 AspectJ 编译器。它会在编译的时候直接修改字节码，把切面的逻辑插入到目标方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存用户: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样生成的 class 文件就已经包含了切面逻辑，运行时不需要额外的代理机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器自动生成的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 织入的切面代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前: saveUser&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 原始业务代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;保存用户: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译期织入的优点是性能最好，因为没有代理的开销，但缺点是需要使用特殊的编译器，而且比较复杂，在 Spring 项目中用得不多。</p>
<p>类加载期织入是在 JVM 加载 class 文件的时候进行织入。这种方式通过 Java 的 Instrumentation API 或者自定义的 ClassLoader 来实现，在类被加载到 JVM 之前修改字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeavingClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classBytes = loadClassBytes(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在这里进行字节码织入</span></span><br><span class="line">        <span class="type">byte</span>[] wovenBytes = weaveAspects(classBytes);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> defineClass(name, wovenBytes, <span class="number">0</span>, wovenBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] weaveAspects(<span class="type">byte</span>[] classBytes) &#123;</span><br><span class="line">        <span class="comment">// 使用 ASM 或其他字节码操作库进行织入</span></span><br><span class="line">        <span class="keyword">return</span> classBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AspectJ 的 Load-Time Weaving 就是这种方式的典型实现。它比编译期织入更灵活一些，但是配置相对复杂，需要在 JVM 启动参数中指定 Java agent，在 Spring 中也有支持，但用得不是特别多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># JVM 启动参数</span><br><span class="line">java -javaagent:aspectjweaver.jar -jar myapp.jar</span><br></pre></td></tr></table></figure>

<p>运行时织入是我们在 Spring 中最常见的方式，也就是通过动态代理来实现。Spring AOP 采用的就是这种方式。当 Spring 容器启动的时候，如果发现某个 Bean 需要被切面处理，就会为这个 Bean 创建一个代理对象。如果目标类实现了接口，Spring 会使用 JDK 的动态代理技术。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存用户: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring 自动创建的代理（伪代码）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Advisor&gt; advisors;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行前置通知</span></span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (advisor.getPointcut().matches(<span class="built_in">this</span>.getClass().getMethod(<span class="string">&quot;saveUser&quot;</span>, String.class))) &#123;</span><br><span class="line">                advisor.getAdvice().before();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        target.saveUser(username);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行后置通知</span></span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            advisor.getAdvice().after();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果目标类没有实现接口，就会使用 CGLIB 来创建一个子类作为代理。运行时织入的优点是实现简单，不需要特殊的编译器或 JVM 配置，缺点是有一定的性能开销，因为每次方法调用都要经过代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有接口的类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建订单: &quot;</span> + orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CGLIB 生成的代理子类（伪代码）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService$$EnhancerByCGLIB$$12345</span> <span class="keyword">extends</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor interceptor;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 MethodInterceptor 执行切面逻辑</span></span><br><span class="line">        interceptor.intercept(<span class="built_in">this</span>, getMethod(<span class="string">&quot;createOrder&quot;</span>), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;orderId&#125;, </span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">MethodProxy</span>() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> Object <span class="title function_">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> &#123;</span><br><span class="line">                                    <span class="keyword">return</span> OrderService.<span class="built_in">super</span>.createOrder((String) args[<span class="number">0</span>]);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring AOP 默认的织入方式就是运行时织入，使用起来非常简单，只需要加个 <code>@Aspect</code> 注解和相应的通知注解就可以了。虽然性能上不如编译期织入，但是对于大部分业务场景来说，这点性能开销是完全可以接受的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring AOP 的代理创建过程</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>  <span class="comment">// 启用 AOP 自动代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring 内部的代理创建逻辑（简化版）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">AopProxyFactory</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            <span class="comment">// 使用 CGLIB 代理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CglibAopProxy</span>(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 JDK 动态代理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AspectJ-是什么？"><a href="#AspectJ-是什么？" class="headerlink" title="AspectJ 是什么？"></a>AspectJ 是什么？</h4><p>AspectJ 是一个 AOP 框架，它可以做很多 Spring AOP 干不了的事情，比如说编译时、编译后和类加载时织入切面。并且提供了很多复杂的切点表达式和通知类型。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164017.png" alt="20251024164017"><br>AspectJ 官网</p>
<p>Spring AOP 只支持方法级别的拦截，而且只能拦截 Spring 容器管理的 Bean。但是 AspectJ 可以拦截任何 Java 对象的方法调用、字段访问、构造方法执行、异常处理等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring AOP 只能做到这些</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAopAspect</span> &#123;</span><br><span class="line">    <span class="comment">// ✅ 可以拦截：public 方法调用</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(public * com.example.service.*.*(..))&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundPublicMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ❌ 无法拦截：字段访问</span></span><br><span class="line">    <span class="comment">// ❌ 无法拦截：构造函数</span></span><br><span class="line">    <span class="comment">// ❌ 无法拦截：私有方法</span></span><br><span class="line">    <span class="comment">// ❌ 无法拦截：静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Spring-AOP-有哪些通知方式？"><a href="#Spring-AOP-有哪些通知方式？" class="headerlink" title="Spring AOP 有哪些通知方式？"></a>Spring AOP 有哪些通知方式？</h4><p>Spring AOP 提供了多种通知方式，允许我们在方法执行的不同阶段插入逻辑。常用的通知方式有：</p>
<ul>
<li>前置通知 (@Before)</li>
<li>返回通知 (@AfterReturning)</li>
<li>异常通知 (@AfterThrowing)</li>
<li>后置通知 (@After)</li>
<li>环绕通知 (@Around)</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164058.png" alt="20251024164058"><br>三分恶面渣逆袭：Spring AOP 通知方式</p>
<p>前置通知是在目标方法执行之前执行的通知。这种通知比较简单，主要用来做一些准备工作，比如参数校验、权限检查、记录方法开始执行的日志等等。前置通知无法阻止目标方法的执行，也无法修改方法的参数，它只能在方法执行前做一些额外的操作。我们在项目中经常用它来记录操作日志，比如记录谁在什么时候调用了什么方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印方法名和参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用方法: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;参数: &quot;</span> + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后置通知是在目标方法执行完成后执行的，不管方法是正常返回还是抛出异常都会执行。这种通知主要用来做一些清理工作，比如释放资源、记录方法执行完成的日志等等。需要注意的是，后置通知拿不到方法的返回值，也捕获不到异常信息，它就是纯粹的在方法执行后做一些收尾工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印方法执行完成的日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行完成: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回通知是在目标方法正常返回后执行的。这种通知可以获取到方法的返回值，我们可以在注解中指定 returning 参数来接收返回值。返回通知经常用来做一些基于返回结果的后续处理，比如缓存方法的返回结果、根据返回值发送通知等等。如果方法抛出异常的话，返回通知是不会执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印方法执行完成的日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行完成: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        <span class="comment">// 打印方法返回值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;返回值: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常通知是在目标方法抛出异常后执行的。我们可以在注解中指定 throwing 参数来接收异常对象。异常通知主要用来做异常处理和记录，比如记录错误日志、发送告警、异常统计等等。需要注意的是，异常通知不能处理异常，异常还是会继续向上抛出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;,</span></span><br><span class="line"><span class="meta">                     throwing = &quot;ex&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印方法名和异常信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行异常: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;异常信息: &quot;</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>环绕通知是最强大也是我们用得最多的一种通知。它可以在方法执行前后都执行逻辑，而且可以控制目标方法是否执行，还可以修改方法的参数和返回值。环绕通知的方法必须接收一个 ProceedingJoinPoint 参数，通过调用其 <code>proceed()</code> 方法来执行目标方法。</p>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派</a> 项目中就主要是通过环绕通知来实现切面。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164130.png" alt="20251024164130"><br>技术派源码：环绕通知</p>
<p>如果有多个切面，还可以通过 <code>@Order</code> 注解指定先后顺序，数字越小，优先级越高。代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebLogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">webLog</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 开始打印请求日志</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">        <span class="comment">// 打印请求相关参数</span></span><br><span class="line">        logger.info(<span class="string">&quot;========================================== Start ==========================================&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印请求 url</span></span><br><span class="line">        logger.info(<span class="string">&quot;URL            : &#123;&#125;&quot;</span>, request.getRequestURL().toString());</span><br><span class="line">        <span class="comment">// 打印 Http method</span></span><br><span class="line">        logger.info(<span class="string">&quot;HTTP Method    : &#123;&#125;&quot;</span>, request.getMethod());</span><br><span class="line">        <span class="comment">// 打印调用 controller 的全路径以及执行方法</span></span><br><span class="line">        logger.info(<span class="string">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());</span><br><span class="line">        <span class="comment">// 打印请求的 IP</span></span><br><span class="line">        logger.info(<span class="string">&quot;IP             : &#123;&#125;&quot;</span>, request.getRemoteAddr());</span><br><span class="line">        <span class="comment">// 打印请求入参</span></span><br><span class="line">        logger.info(<span class="string">&quot;Request Args   : &#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 结束后打个分隔线，方便查看</span></span><br><span class="line">        logger.info(<span class="string">&quot;=========================================== End ===========================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="comment">// 打印出参</span></span><br><span class="line">        logger.info(<span class="string">&quot;Response Args  : &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(result));</span><br><span class="line">        <span class="comment">// 执行耗时</span></span><br><span class="line">        logger.info(<span class="string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - startTime);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Spring-AOP-发生在什么时候？"><a href="#Spring-AOP-发生在什么时候？" class="headerlink" title="Spring AOP 发生在什么时候？"></a>Spring AOP 发生在什么时候？</h4><p>Spring AOP 是在 Bean 的初始化阶段发生的，具体来说是在 Bean 生命周期的后置处理阶段。</p>
<p>在 Bean 实例化完成、属性注入完成之后，Spring 会调用所有 BeanPostProcessor 的 postProcessAfterInitialization 方法，AOP 代理的创建就是在这个阶段完成的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164150.png" alt="20251024164150"><br>二哥的 Java 进阶之路：BeanPostProcessor</p>
<h4 id="简单总结一下-AOP"><a href="#简单总结一下-AOP" class="headerlink" title="简单总结一下 AOP"></a>简单总结一下 AOP</h4><p>AOP，也就是面向切面编程，是一种编程范式，旨在提高代码的模块化。比如说可以将日志记录、事务管理等分离出来，来提高代码的可重用性。</p>
<p>AOP 的核心概念包括切面、连接点、通知、切点和织入等。</p>
<p>① 像日志打印、事务管理等都可以抽离为切面，可以声明在类的方法上。像 <code>@Transactional</code> 注解，就是一个典型的 AOP 应用，它就是通过 AOP 来实现事务管理的。我们只需要在方法上添加 <code>@Transactional</code> 注解，Spring 就会在方法执行前后添加事务管理的逻辑。</p>
<p>② Spring AOP 是基于代理的，它默认使用 JDK 动态代理和 CGLIB 代理来实现 AOP。</p>
<p>③ Spring AOP 的织入方式是运行时织入，而 AspectJ 支持编译时织入、类加载时织入。</p>
<h4 id="AOP和-OOP-的关系？"><a href="#AOP和-OOP-的关系？" class="headerlink" title="AOP和 OOP 的关系？"></a>AOP和 OOP 的关系？</h4><p>AOP 和 OOP 是互补的编程思想：</p>
<ol>
<li>OOP 通过类和对象封装数据和行为，专注于核心业务逻辑。</li>
<li>AOP 提供了解决横切关注点（如日志、权限、事务等）的机制，将这些逻辑集中管理。</li>
</ol>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯 Java 后端实习一面原题：说说 AOP 的原理。</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米 25 届日常实习一面原题：说说你对 AOP 和 IoC 的理解。</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手面经同学 7 Java 后端技术一面面试原题：说一下 Spring AOP 的实现原理</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小公司面经合集同学 1 Java 后端面试原题：介绍 Spring IoC 和 AOP?</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的招商银行面经同学 6 招银网络科技面试原题：SpringBoot框架的AOP、IOC&#x2F;DI？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团面经同学 4 一面面试原题：Spring AOP发生在什么时候</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的理想汽车面经同学 2 一面面试原题：Spring AOP的概念了解吗？AOP和 OOP 的关系？</li>
</ol>
</blockquote>
<h3 id="21-🌟AOP的应用场景有哪些？"><a href="#21-🌟AOP的应用场景有哪些？" class="headerlink" title="21.🌟AOP的应用场景有哪些？"></a>21.🌟AOP的应用场景有哪些？</h3><p>答：AOP 在实际工作&#x2F;编码学习中有很多应用场景，我按照使用频率来说说几个主要的。</p>
<p>事务管理是用得最多的场景，基本上每个项目都会用到。只需要在 Service 方法上加个 <code>@Transactional</code> 注解，Spring 就会自动帮我们管理事务的开启、提交和回滚。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164321.png" alt="20251024164321"><br>技术派源码：@Transactional事务</p>
<p>日志记录也是一个很常见的应用。在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，就利用了 AOP 来打印接口的入参和出参日志、执行时间，方便后期 bug 溯源和性能调优。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164332.png" alt="20251024164332"><br>沉默王二：技术派教程</p>
<p>-—这部分面试可以不背，方便大家理解 start—-</p>
<p>第一步，定义 <code>@MdcDot</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MdcDot &#123;</span><br><span class="line">    String <span class="title function_">bizCode</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，配置 MdcAspect 切面，拦截带有 <code>@MdcDot</code> 注解的方法或类，在方法执行前后进行 MDC 操作，记录方法执行耗时。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164346.png" alt="20251024164346"><br>技术派项目：配置 AOP 切面</p>
<p>第三步，在需要的地方加上 <code>@MdcDot</code> 注解。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164358.png" alt="20251024164358"><br>技术派项目：使用注解</p>
<p>第四步，当接口被调用时，就可以看到对应的执行日志。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-06-16 11:06:13,008 [http-nio-8080-exec-3] INFO |00000000.1686884772947.468581113|101|c.g.p.forum.core.mdc.MdcAspect.handle(MdcAspect.java:47) - 方法执行耗时: com.github.paicoding.forum.web.front.article.rest.ArticleRestController#recommend = 47</span><br></pre></td></tr></table></figure>

<p>-—面试可以不背，方便大家理解 end—-</p>
<p>除此之外，还有权限控制、性能监控、缓存处理等场景。总的来说，任何需要在多个地方重复执行的通用逻辑，都可以考虑用 AOP 来实现。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 5 Java 后端技术一面面试原题：AOP应用场景</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的理想汽车面经同学 2 一面面试原题：AOP的使用场景有哪些？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 9 面试原题：项目中的AOP是怎么用到的</li>
</ol>
</blockquote>
<h3 id="24-🌟说说JDK动态代理和CGLIB代理的区别？"><a href="#24-🌟说说JDK动态代理和CGLIB代理的区别？" class="headerlink" title="24.🌟说说JDK动态代理和CGLIB代理的区别？"></a>24.🌟说说JDK动态代理和CGLIB代理的区别？</h3><p>JDK 动态代理和 CGLIB 代理是 Spring AOP 用来创建代理对象的两种方式。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164722.png" alt="20251024164722"><br>logbasex：JDK 动态代理和 CGLIB 代理</p>
<p>从使用条件来说，JDK 动态代理要求目标类必须实现至少一个接口，因为它是基于接口来创建代理的。而 CGLIB 代理不需要目标类实现接口，它是通过继承目标类来创建代理的。</p>
<p>这是两者最根本的区别。比如我们有一个 TransferService 接口和 TransferServiceImpl 实现类，如果用 JDK 动态代理，创建的代理对象会实现 TransferService 接口；</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024164917.png" alt="20251024164917"><br>logbasex：JDK 动态代理</p>
<p>如果用 CGLIB，代理对象会继承 TransferServiceImpl 类。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024165053.png" alt="20251024165053"><br>logbasex：CGLIB 代理</p>
<p>从实现原理来说，JDK 动态代理是 Java 原生支持的，它通过反射机制在运行时动态创建一个实现了指定接口的代理类。当我们调用代理对象的方法时，会被转发到 InvocationHandler 的 invoke 方法中，我们可以在这个方法里插入切面逻辑，然后再通过反射调用目标对象的真实方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            (proxy1, method, args1) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Before method: &quot;</span> + method.getName());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args1);</span><br><span class="line">                System.out.println(<span class="string">&quot;After method: &quot;</span> + method.getName());</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        proxy.findUser(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CGLIB 则是一个第三方的字节码生成库，它通过 ASM 字节码框架动态生成目标类的子类，然后重写父类的方法来插入切面逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserController.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Before method: &quot;</span> + method.getName());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;After method: &quot;</span> + method.getName());</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">UserController</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserController) enhancer.create();</span><br><span class="line">        proxy.getUser(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择-CGLIB-还是-JDK-动态代理？"><a href="#选择-CGLIB-还是-JDK-动态代理？" class="headerlink" title="选择 CGLIB 还是 JDK 动态代理？"></a>选择 CGLIB 还是 JDK 动态代理？</h4><p>如果目标对象没有实现任何接口，就只能使用 CGLIB 代理，就比如说 Controller 层的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有实现接口的Controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleController</span> &#123;</span><br><span class="line">    <span class="meta">@MdcDot(bizCode = &quot;article.create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> ArticleReq req)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果目标对象实现了接口，通常首选 JDK 动态代理，比如说 Service 层的类，一般都会先定义接口，再实现接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArticleService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveArticle</span><span class="params">(Article article)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ArticleService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveArticle</span><span class="params">(Article article)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Spring Boot 2.0 之后，Spring AOP 默认使用 CGLIB 代理。这是因为 Spring Boot 作为一个追求“约定优于配置”的框架，选择 CGLIB，可以简化开发者的心智负担，避免因为忘记实现接口而导致 AOP 不生效的问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024165224.png" alt="20251024165224"><br>技术派源码：AopAutoConfiguration</p>
<h4 id="你会用-JDK-动态代理吗？"><a href="#你会用-JDK-动态代理吗？" class="headerlink" title="你会用 JDK 动态代理吗？"></a>你会用 JDK 动态代理吗？</h4><p>会的。</p>
<p>假设我们有这样一个小场景，客服中转，解决用户问题：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024165235.png" alt="20251024165235"><br>三分恶面渣逆袭：用户向客服提问题</p>
<p>我们可以用 JDK 动态代理来实现这个场景。JDK 动态代理的核心是通过反射机制在运行时创建一个实现了指定接口的代理类。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024165247.png" alt="20251024165247"><br>三分恶面渣逆袭：JDK动态代理类图</p>
<p>第一步，创建接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISolver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，实现接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solver</span> <span class="keyword">implements</span> <span class="title class_">ISolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;疯狂掉头发解决问题……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，使用用反射生成目标对象的代理，这里用了一个匿名内部类方式重写 InvocationHandler 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为目标对象生成代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;请问有什么可以帮到您？&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 调用目标对象方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;问题已经解决啦！&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步，生成一个代理对象实例，通过代理对象调用目标对象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象:程序员</span></span><br><span class="line">        <span class="type">ISolver</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solver</span>();</span><br><span class="line">        <span class="comment">//代理：客服小姐姐</span></span><br><span class="line">        <span class="type">ISolver</span> <span class="variable">csProxy</span> <span class="operator">=</span> (ISolver) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(developer).getProxyInstance();</span><br><span class="line">        <span class="comment">//目标方法：解决问题</span></span><br><span class="line">        csProxy.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="你会用-CGLIB-动态代理吗？"><a href="#你会用-CGLIB-动态代理吗？" class="headerlink" title="你会用 CGLIB 动态代理吗？"></a>你会用 CGLIB 动态代理吗？</h4><p>会的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024165344.png" alt="20251024165344"><br>三分恶面渣逆袭：CGLIB动态代理类图</p>
<p>第一步：定义目标类 Solver，定义 solve 方法，模拟解决问题的行为。目标类不需要实现任何接口，这与 JDK 动态代理的要求不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;疯狂掉头发解决问题……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：创建代理工厂 ProxyFactory，使用 CGLIB 的 Enhancer 类来生成目标类的子类（代理对象）。CGLIB 允许我们在运行时动态创建一个继承自目标类的代理类，并重写目标方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为目标对象生成代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">en</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        en.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建子类对象代理</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请问有什么可以帮到您？&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行目标对象的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;问题已经解决啦！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：创建客户端 Client，获取代理对象并调用目标方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象:程序员</span></span><br><span class="line">        <span class="type">Solver</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solver</span>();</span><br><span class="line">        <span class="comment">//代理：客服小姐姐</span></span><br><span class="line">        <span class="type">Solver</span> <span class="variable">csProxy</span> <span class="operator">=</span> (Solver) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(developer).getProxyInstance();</span><br><span class="line">        <span class="comment">//目标方法：解决问题</span></span><br><span class="line">        csProxy.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的帆软同学 3 Java 后端一面的原题：cglib 的原理</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 22 暑期实习一面面试原题：Spring AOP 实现原理</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米面经同学 F 面试原题：两种动态代理的区别</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动面经同学 8 Java 后端实习一面面试原题：spring的aop是如何实现的</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯云智面经同学 20 二面面试原题：spring aop的底层原理是什么？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团面经同学 3 Java 后端技术一面面试原题：java的反射机制，反射的应用场景AOP的实现原理是什么，与动态代理和反射有什么区别</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的比亚迪面经同学 12 Java 技术面试原题：代理介绍一下，jdk和cglib的区别</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：Spring AOP的实现原理？JDK动态代理和CGLib动态代理的各自实现及其区别？现在需要统计方法的具体执行时间，说下如何使用AOP来实现？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的理想汽车面经同学 2 一面面试原题：了解AOP底层是怎么做的吗？</li>
</ol>
</blockquote>
<h3 id="25-🌟说说你对Spring事务的理解？"><a href="#25-🌟说说你对Spring事务的理解？" class="headerlink" title="25.🌟说说你对Spring事务的理解？"></a>25.🌟说说你对Spring事务的理解？</h3><p>Spring 提供了两种事务管理方式，编程式事务和声明式事务。编程式事务就是我们要手动调用事务的开始、提交、回滚这些操作，虽然灵活但是代码比较繁琐。声明式事务只需要在需要事务的方法上加上 <code>@Transactional</code> 注解就好了，Spring 会帮我们自动处理事务的整个生命周期。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024184234.png" alt="20251024184234"><br>Spring TransactionInterceptor</p>
<p>-—这部分可以不背，方便大家理解 start—-</p>
<p>编程式事务可以使用 TransactionTemplate 和 PlatformTransactionManager 来实现，允许我们在代码中直接控制事务的边界。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTransactionTemplate</span><span class="params">(TransactionTemplate transactionTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transactionTemplate = transactionTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="keyword">final</span> String out, <span class="keyword">final</span> String in, <span class="keyword">final</span> Double money)</span> &#123;</span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">                <span class="comment">// 转出</span></span><br><span class="line">                accountDao.outMoney(out, money);</span><br><span class="line">                <span class="comment">// 转入</span></span><br><span class="line">                accountDao.inMoney(in, money);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-—这部分可以不背，方便大家理解 end—-</p>
<p>Spring 事务的底层实现是通过 AOP 来完成的。当我们在方法上加 <code>@Transactional</code> 注解后，Spring 会为这个 Bean 创建代理对象，在方法执行前开启事务，方法正常返回时提交事务，如果方法抛出异常就回滚事务。</p>
<p>声明式事务的优点是不需要在业务逻辑代码中掺杂事务管理的代码，缺点是，最细粒度只能到方法级别，无法到代码块级别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double money)</span> &#123;</span><br><span class="line">        <span class="comment">// 转出</span></span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        <span class="comment">// 转入</span></span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东同学 10 后端实习一面的原题：Spring 事务怎么实现的</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的农业银行面经同学 7 Java 后端面试原题：Spring 如何保证事务</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的比亚迪面经同学 12 Java 技术面试原题：Spring的事务用过吗，在项目里面怎么使用的</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的虾皮面经同学 13 一面面试原题：spring事务</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里云面经同学 22 面经：如何使用spring实现事务</li>
</ol>
</blockquote>
<h3 id="29-🌟说说Spring的事务传播机制？"><a href="#29-🌟说说Spring的事务传播机制？" class="headerlink" title="29.🌟说说Spring的事务传播机制？"></a>29.🌟说说Spring的事务传播机制？</h3><p>简单来说，当一个事务方法 A 调用另一个事务方法 B 时，方法 B 的事务应该如何运行？是加入方法 A 的现有事务，还是开启一个新事务，或者以非事务方式运行？这就是事务传播机制要解决的问题。</p>
<p>Spring 定义了七种事务传播行为，其中 REQUIRED 是默认的传播行为，表示如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024184604.png" alt="20251024184604"><br>三分恶面渣逆袭：事务传播机制</p>
<p>比如说在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，一个用户解锁付费文章的操作，会涉及到创建支付订单、更新订单状态等好几个数据库操作。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024184803.png" alt="20251024184803"><br>技术派源码：Spring事务传播机制</p>
<p>这些不同操作的方法就可以放在一个 <code>@Transactional</code> 注解的方法里，它们就自动在同一个事务里了，要么一起成功，要么一起失败。</p>
<p>当然，还有一些特殊情况。比如，我们希望记录一些操作日志，但不想因为主业务失败导致日志回滚。这时候 REQUIRES_NEW 就派上用场了。它不管当前有没有事务，都重新开启一个全新的、独立的事务来执行。这样，日志保存的事务和主业务的事务就互不干扰，即使主业务失败回滚，日志也能妥妥地保存下来。</p>
<p>另外，还有像 SUPPORTS、 NOT_SUPPORTED 这些。SUPPORTS 比较佛系，有事务就用，没事务就不用，适合一些不重要的更新操作。而 NOT_SUPPORTED 则更干脆，它会把当前的事务挂起，以非事务的方式去执行。比如说我们的事务里需要调用一个第三方的、响应很慢的接口，如果这个调用也包含在事务里，就会长时间占用数据库连接。把它用 NOT_SUPPORTED 包起来，就可以避免这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callExternalApi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用第三方接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后还有一个比较特殊的 NESTED，嵌套事务。它有点像 REQUIRES_NEW，但又不完全一样。NESTED 是父事务的一个子事务，父事务回滚，它肯定也得回滚。但它自己回滚，却不会影响到父事务。这个特性在处理一些批量操作，希望能部分回滚的场景下特别有用。不过它需要数据库支持 Savepoint 功能，MySQL 就支持。</p>
<h4 id="事务能在新线程中传播吗？"><a href="#事务能在新线程中传播吗？" class="headerlink" title="事务能在新线程中传播吗？"></a>事务能在新线程中传播吗？</h4><p>事务传播机制是通过 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ThreadLocal.html">ThreadLocal</a> 实现的，所以，如果调用的方法是在新线程中，事务传播就会失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parentMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; childMethod()).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的操作将不会在 parentMethod 的事务范围内执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="protected-和-private-方法加事务会生效吗？"><a href="#protected-和-private-方法加事务会生效吗？" class="headerlink" title="protected 和 private 方法加事务会生效吗？"></a>protected 和 private 方法加事务会生效吗？</h4><p>我的理解是：在 private 方法上加事务是肯定不会生效的，而 protected 方法在特定的代理模式下是可能生效的，但这两种用法都应该避免，不是推荐的使用方式。</p>
<p>这背后涉及到 Spring AOP 的代理机制。</p>
<p>我先说一下 JDK 动态代理，它要求目标类必须实现一个或者多个接口。也就意味着代理只能拦截接口中声明的方法，而 protected 和 private 方法并不能在接口中声明，因此在 JDK 动态代理下，这些方法的事务注解是会被直接忽略的。</p>
<p>那 Spring Boot 2.0 之后，Spring AOP 默认使用的是 CGLIB 代理。CGLIB 代理是通过继承目标类来创建代理对象的。</p>
<p>那对于 private 方法来说，由于无法被子类重写，所以 CGLIB 代理也无法拦截，事务也就无法生效。对于 protected 方法来说，因为它可以被子类重写，所以理论上事务是生效的。</p>
<p>-—这部分可以不背，方便大家理解 start—-</p>
<p>我们创建一个 protected 方法，名为 <code>protectedTransactionalMethod</code> ，它被 <code>@Transactional</code> 注解标记。这个方法会先向数据库中插入一条记录（一个 TestEntity 实例）。紧接着，它会立即抛出一个 RuntimeException 。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185126.png" alt="20251024185126"><br>派聪明源码：测试 protected 方法的事务是否生效</p>
<ul>
<li>如果事务生效：当 RuntimeException 抛出时，Spring 的事务管理器会捕获它，并触发事务回滚。这意味着，之前插入数据库的那条记录会被撤销。最终，数据库里不会留下这条记录。</li>
<li>如果事务失效：即使 RuntimeException 被抛出，由于没有事务管理，已经执行的数据库插入操作不会被撤销。最终，数据库里会留下这条记录。</li>
</ul>
<p>我们创建了一个 public 方法 <code>testProtectedTransaction</code> ，它通过 <code>this.protectedTransactionalMethod()</code> 的方式直接调用了那个 protected 方法。接着我们访问 <code>/api/v1/test/transaction/protected</code> 来触发这个调用。</p>
<p>结果：数据库中会留下一条名为 ‘test-protected’ 的记录。这证明了由于是内部调用，绕过了 Spring AOP 代理，<code>@Transactional</code> 注解没有生效。</p>
<p>我们创建了另一个 public 方法 <code>testProtectedTransactionWithSelfProxy</code>。在这个方法里，我们通过一个“自注入”的代理对象 self 来调用 <code>self.protectedTransactionalMethod()</code>。接着我们通过访问 <code>/api/v1/test/transaction/protected/proxy</code> 来触发这个调用。</p>
<p>结果：数据库中不会留下名为 ‘test-protected-proxy’ 的记录。这证明通过代理对象的调用，Spring AOP 成功拦截并开启了事务，最终在异常发生时正确地回滚了事务。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/spring-20250714171739.png" alt="派聪明源码：protected 方法的事务生效结果"></p>
<p>派聪明源码：protected 方法的事务生效结果</p>
<p>-—这部分可以不背，方便大家理解 end—-</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东同学 10 后端实习一面的原题：事务的传播机制</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米春招同学 K 一面面试原题：事务传播，protected 和 private 加事务会生效吗,还有那些不生效的情况</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为面经同学 8 技术二面面试原题：Spring 中的事务的隔离级别，事务的传播行为？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的oppo 面经同学 8 后端开发秋招一面面试原题：讲一下Spring事务传播机制</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里云面经同学 22 面经：介绍事务传播模型</li>
</ol>
</blockquote>
<h3 id="31-🌟Spring-MVC-的工作流程了解吗？"><a href="#31-🌟Spring-MVC-的工作流程了解吗？" class="headerlink" title="31.🌟Spring MVC 的工作流程了解吗？"></a>31.🌟Spring MVC 的工作流程了解吗？</h3><p>简单来说，Spring MVC 是一个基于 Servlet 的请求处理框架，核心流程可以概括为：请求接收 → 路由分发 → 控制器处理 → 视图解析。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185306.png" alt="20251024185306"><br>三分恶面渣逆袭：Spring MVC的工作流程</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185314.png" alt="20251024185314"><br>图片来源于网络：SpringMVC工作流程图</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185323.png" alt="20251024185323"><br>_未来可期：SpringMVC工作流程图</p>
<p>用户发起的 HTTP 请求，首先会被 DispatcherServlet 捕获，这是 Spring MVC 的“前端控制器”，负责拦截所有请求，起到统一入口的作用。</p>
<p>DispatcherServlet 接收到请求后，会根据 URL、请求方法等信息，交给 HandlerMapping 进行路由匹配，查找对应的处理器，也就是 Controller 中的具体方法。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185332.png" alt="20251024185332"><br>技术派源码：Controller</p>
<p>找到对应 Controller 方法后，DispatcherServlet 会委托给处理器适配器 HandlerAdapter 进行调用。处理器适配器负责执行方法本身，并处理参数绑定、数据类型转换等。在注解驱动开发中，常用的是 RequestMappingHandlerAdapter。这一层会把请求参数自动注入到方法形参中，并调用 Controller 执行实际的业务逻辑。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024185702.png" alt="20251024185702"><br>技术派源码：RequestMappingHandlerAdapter</p>
<p>Controller 方法最终会返回结果，比如视图名称、ModelAndView 或直接返回 JSON 数据。</p>
<p>当 Controller 方法返回视图名时，DispatcherServlet 会调用 ViewResolver 将其解析为实际的 View 对象，比如 Thymeleaf 页面。在前后端分离的接口项目中，这一步则通常是返回 JSON 数据。</p>
<p>最后，由 View 对象完成渲染，或者将 JSON 结果直接通过 DispatcherServlet 返回给客户端。</p>
<h4 id="为什么还需要-HandlerAdapter？"><a href="#为什么还需要-HandlerAdapter？" class="headerlink" title="为什么还需要 HandlerAdapter？"></a>为什么还需要 HandlerAdapter？</h4><p>Spring MVC 支持多种风格的处理器，比如基于 <code>@Controller</code> 注解的处理器、实现了 Controller 接口的处理器等。如果没有处理器适配器，DispatcherServlet 就需要硬编码每种处理器的调用方式，框架就会变得非常僵硬——新增一种 Controller 类型，就必须改 DispatcherServlet 的代码。</p>
<p>因此，Spring 引入了 HandlerAdapter 作为适配器，屏蔽不同控制器的差异，给 DispatcherServlet 提供一个统一的调用入口。</p>
<p>比如说，如果是实现了 Controller 接口的处理器，DispatcherServlet 会使用 SimpleControllerHandlerAdapter 来适配它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略一个无关方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是使用 <code>@RequestMapping</code> 注解的处理器，DispatcherServlet 则会使用 RequestMappingHandlerAdapter 来适配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">        <span class="comment">// 执行方法并返回 ModelAndView      </span></span><br><span class="line">        <span class="keyword">return</span> invokeHandlerMethod(handlerMethod, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯 Java 后端实习一面原题：说说前端发起请求到 SpringMVC 的整个处理流程。</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的国企面试原题：说说 SpringMVC 的流程吧</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小公司面经同学 5 Java 后端面试原题：springMVC 工作流程 我大概就是按面渣逆袭里答的，答到一半打断我：然后会有个 Handler，这个 Handler 是什么东西啊。前面 Handler 不是已经知道 controller 了吗，我直接执行不就行了，为什么还要 Adapter 呢。</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 8 面试原题：SpringMVC框架</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 17 后端技术面试原题：springmvc执行流程</li>
</ol>
</blockquote>
<h3 id="33-🌟介绍一下-SpringBoot？"><a href="#33-🌟介绍一下-SpringBoot？" class="headerlink" title="33.🌟介绍一下 SpringBoot？"></a>33.🌟介绍一下 SpringBoot？</h3><p>Spring Boot 可以说是 Spring 生态的一个重大突破，它极大地简化了 Spring 应用的开发和部署过程。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190129.png" alt="20251024190129"><br>SpringBoot图标</p>
<p>以前我们用 Spring 开发项目的时候，需要配置一大堆 XML 文件，包括 Bean 的定义、数据源配置、事务配置等等，非常繁琐。而且还要手动管理各种 jar 包的依赖关系，很容易出现版本冲突的问题。部署的时候还要单独搭建 Tomcat 服务器，整个过程很复杂。Spring Boot 就是为了解决这些痛点而生的。</p>
<p>“约定大于配置”是 Spring Boot 最核心的理念。它预设了很多默认配置，比如默认使用内嵌的 Tomcat 服务器，默认的日志框架是 Logback 等等。这样，我们开发者就只需要关注业务逻辑，不用再纠结于各种配置细节。</p>
<p>自动装配也是 Spring Boot 的一大特色，它会根据项目中引入的依赖自动配置合适的 Bean。比如说，我们引入了 Spring Data JPA，Spring Boot 就会自动配置数据源；比如说，我们引入了 Spring Security，Spring Boot 就会自动配置安全相关的 Bean。</p>
<p>Spring Boot 还提供了很多开箱即用的功能，比如 Actuator 监控、DevTools 开发工具、Spring Boot Starter 等等。Actuator 可以让我们轻松监控应用的健康状态、性能指标等；DevTools 可以加快开发效率，比如自动重启、热部署等；Spring Boot Starter 则是一些预配置好的依赖集合，让我们可以快速引入某些常用的功能。</p>
<h4 id="Spring-Boot常用注解有哪些？"><a href="#Spring-Boot常用注解有哪些？" class="headerlink" title="Spring Boot常用注解有哪些？"></a>Spring Boot常用注解有哪些？</h4><p>Spring Boot 的注解很多，我就挑两个说一下吧。</p>
<ul>
<li><code>@SpringBootApplication</code>：这是 Spring Boot 的核心注解，它是一个组合注解，包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。它标志着一个 Spring Boot 应用的入口。</li>
<li><code>@SpringBootTest</code>：用于测试 Spring Boot 应用的注解，它会加载整个 Spring 上下文，适合集成测试。</li>
</ul>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为 OD 面经中出现过该题：讲讲 Spring Boot 的特性。</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：SpringBoot基本原理</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的国企零碎面经同学 9 面试原题：Springboot基于Spring的配置有哪几种</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里云面经同学 22 面经：springboot常用注解</li>
</ol>
</blockquote>
<h3 id="34-🌟Spring-Boot的自动装配原理了解吗？"><a href="#34-🌟Spring-Boot的自动装配原理了解吗？" class="headerlink" title="34.🌟Spring Boot的自动装配原理了解吗？"></a>34.🌟Spring Boot的自动装配原理了解吗？</h3><p>在 Spring Boot 中，开启自动装配的注解是<code>@EnableAutoConfiguration</code>。这个注解会告诉 Spring 去扫描所有可用的自动配置类。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190137.png" alt="20251024190137"><br>二哥的 Java 进阶之路：@EnableAutoConfiguration 源码</p>
<p>Spring Boot 为了进一步简化，把这个注解包含到了 <code>@SpringBootApplication</code> 注解中。也就是说，当我们在主类上使用 <code>@SpringBootApplication</code> 注解时，实际上就已经开启了自动装配。</p>
<p>当 main 方法运行的时候，Spring 会去类路径下找 <code>spring.factories</code> 这个文件，读取里面配置的自动配置类列表。比如在我们的<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派项目</a>中，paicoding-core 和 paicoding-service 模块里都有 spring.factories，分别注册了 ForumCoreAutoConfig 和 ServiceAutoConfig，这两个配置类就会在项目启动的时候被自动加载。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190147.png" alt="20251024190147"><br>技术派源码：spring.factories</p>
<p>然后每个自动配置类内部，通常会有一个 <code>@Configuration</code> 注解，同时结合各种 <code>@Conditional</code> 注解来做条件控制。像<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派</a>的 RabbitMqAutoConfig 类，就用了 <code>@ConditionalOnProperty</code> 注解来判断配置文件里有没有开启 rabbitmq.switchFlag，来决定是否初始化 RabbitMQ 消费线程。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190156.png" alt="20251024190156"><br>技术派源码：RabbitMqAutoConfig</p>
<p>另外一个常见的场景是自动注入 Bean，比如<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派</a>的 ServiceAutoConfig 中就用了 <code>@ComponentScan</code> 来扫描 service 包，<code>@MapperScan</code> 扫描 MyBatis 的 mapper 接口，实现业务层和 DAO 层的自动装配。</p>
<p>具体的执行过程可以总结为：Spring Boot 项目在启动时加载所有的自动配置类，然后逐个检查它们的生效条件，当条件满足时就实例化并创建相应的 Bean。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190207.png" alt="20251024190207"><br>三分恶面渣逆袭：Spring Boot的自动装配原理</p>
<p>自动装配的执行时机是在 Spring 容器启动的时候。具体来说是在 ConfigurationClassPostProcessor 这个 BeanPostProcessor 中处理的，它会解析 <code>@Configuration</code> 类，包括通过 <code>@Import</code> 导入的自动配置类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查自动配置是否启用。如果@ConditionalOnClass等条件注解使得自动配置不适用于当前环境，则返回一个空的配置条目。</span></span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取启动类上的@EnableAutoConfiguration注解的属性，这可能包括对特定自动配置类的排除。</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从spring.factories中获取所有候选的自动配置类。这是通过加载META-INF/spring.factories文件中对应的条目来实现的。</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除配置列表中的重复项，确保每个自动配置类只被考虑一次。</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据注解属性解析出需要排除的自动配置类。</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查排除的类是否存在于候选配置中，如果存在，则抛出异常。</span></span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从候选配置中移除排除的类。</span></span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用过滤器进一步筛选自动配置类。过滤器可能基于条件注解如@ConditionalOnBean等来排除特定的配置类。</span></span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发自动配置导入事件，允许监听器对自动配置过程进行干预。</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并返回一个包含最终确定的自动配置类和排除的配置类的AutoConfigurationEntry对象。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的滴滴同学 2 技术二面的原题：SpringBoot 启动时为什么能够自动装配</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 22 暑期实习一面面试原题：Spring Boot 如何做到启动的时候注入一些 bean</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的比亚迪面经同学 3 Java 技术一面面试原题：说一下 Spring Boot 的自动装配原理</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的农业银行同学 1 面试原题：spring boot 的自动装配</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：SpringBoot如何实现自动装配</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的 OPPO 面经同学 1 面试原题：自动配置怎么实现的？</li>
</ol>
</blockquote>
<h3 id="35-🌟如何自定义一个-SpringBoot-Starter"><a href="#35-🌟如何自定义一个-SpringBoot-Starter" class="headerlink" title="35.🌟如何自定义一个 SpringBoot Starter?"></a>35.🌟如何自定义一个 SpringBoot Starter?</h3><p>第一步，SpringBoot 官方建议第三方 starter 的命名格式是 xxx-spring-boot-starter，所以我们可以创建一个名为 <code>my-spring-boot-starter</code> 的项目，一共包括两个模块，一个是 autoconfigure 模块，包含自动配置逻辑；一个是 starter 模块，只包含依赖声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring.boot.version&gt;<span class="number">2.3</span><span class="number">.1</span>.RELEASE&lt;/spring.boot.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>第二步，创建一个自动配置类，通常在 autoconfigure 包下，该类的作用是根据配置文件中的属性来创建和配置 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyStarterProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">(MyStarterProperties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>(properties.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，创建一个配置属性类，用于读取配置文件中的属性。通常使用 <code>@ConfigurationProperties</code> 注解来标记这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mystarter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStarterProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;二哥的 Java 进阶之路不错啊!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步，创建一个简单的服务类，用于提供业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五步，在 <code>src/main/resources/META-INF</code> 目录下创建一个名为 spring.factories 文件，告诉 SpringBoot 在启动时要加载我们的自动配置类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.itwanger.mystarter.autoconfigure.MyServiceAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>第六步，使用 Maven 打包这个项目。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>

<p>第七步，在其他的 Spring Boot 项目中，通过 Maven 来添加这个自定义的 Starter 依赖，并通过 application.properties 配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mystarter.message=javabetter.cn</span><br></pre></td></tr></table></figure>

<p>然后就可以在 Spring Boot 项目中注入 MyStarterProperties 来使用它。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190258.png" alt="20251024190258"><br>MyStarterProperties 注入示例</p>
<p>启动项目，然后在浏览器中输入 <code>localhost:8081/hello</code>，就可以看到返回的内容是 <code>javabetter.cn</code>，说明我们的自定义 Starter 已经成功工作了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190310.png" alt="20251024190310"><br>二哥的 Java 进阶之路：自定义 Spring Boot Stater</p>
<h4 id="Spring-Boot-Starter-的原理了解吗？"><a href="#Spring-Boot-Starter-的原理了解吗？" class="headerlink" title="Spring Boot Starter 的原理了解吗？"></a>Spring Boot Starter 的原理了解吗？</h4><p>Starter 的核心思想是把相关的依赖打包在一起，让开发者只需要引入一个 starter 依赖，就能获得完整的功能模块。</p>
<p>当我们在 pom.xml 中引入一个 starter 时，Maven 就会自动解析这个 starter 的依赖树，把所有需要的 jar 包都下载下来。</p>
<p>每个 starter 都会包含对应的自动配置类，这些配置类通过条件注解来判断是否应该生效。比如当我们引入了 <code>spring-boot-starter-web</code>，它会自动配置 Spring MVC、内嵌的 Tomcat 服务器等。</p>
<p>spring.factories 文件是 Spring Boot 自动装配的核心，它位于每个 starter 的 <code>META-INF</code> 目录下。这个文件列出了所有的自动配置类，Spring Boot 在启动时会读取这个文件，加载对应的配置类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.example.demo.autoconfigure.DemoAutoConfiguration,\</span><br><span class="line">com.example.demo.autoconfigure.AnotherAutoConfiguration</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动面经同学 1 Java 后端技术一面面试原题：你封装过 springboot starter 吗？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯云智面经同学 20 二面面试原题：Spring Boot Starter 的原理了解吗？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：为什么使用SpringBoot？SpringBoot自动装配的原理及流程？@Import的作用？如果想让SpringBoot对自定义的jar包进行自动配置的话，需要怎么做？</li>
</ol>
</blockquote>
<h3 id="36-🌟Spring-Boot-启动原理了解吗？"><a href="#36-🌟Spring-Boot-启动原理了解吗？" class="headerlink" title="36.🌟Spring Boot 启动原理了解吗？"></a>36.🌟Spring Boot 启动原理了解吗？</h3><p>Spring Boot 的启动主要围绕两个核心展开，一个是 <code>@SpringBootApplication</code> 注解，一个是 <code>SpringApplication.run()</code> 方法。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190348.png" alt="20251024190348"><br>SpringBoot 启动大致流程-图片来源网络</p>
<p>我先说一下 <code>@SpringBootApplication</code> 注解，它是一个组合注解，包含了 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>，这三个注解的作用分别是：</p>
<ul>
<li><code>@SpringBootConfiguration</code>：标记这个类是一个 Spring Boot 配置类，相当于一个 Spring 配置文件。</li>
<li><code>@EnableAutoConfiguration</code>：告诉 Spring Boot 可以进行自动配置。比如说，项目引入了 Spring MVC 的依赖，那么 Spring Boot 就会自动配置 DispatcherServlet、HandlerMapping 等组件。</li>
<li><code>@ComponentScan</code>：扫描当前包及其子包下的组件，注册为 Bean。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190356.png" alt="20251024190356"><br>派聪明源码：启动类</p>
<p>好，接下来我再说一下 <code>SpringApplication.run()</code> 方法，它是 Spring Boot 项目的启动入口，内部流程大致可以分为 5 个步骤：</p>
<p>①、创建 SpringApplication 实例，并识别应用类型，比如说是标准的 Servlet Web 还是响应式的 WebFlux，然后准备监听器和初始化监听容器。</p>
<p>②、创建并准备 ApplicationContext，将主类作为配置源进行加载。</p>
<p>③、刷新 Spring 上下文，触发 Bean 的实例化，比如说扫描并注册 <code>@ComponentScan</code> 指定路径下的 Bean。</p>
<p>④、触发自动配置，在 Spring Boot 2.7 及之前是通过 spring.factories 加载的，3.x 是通过读取 <code>AutoConfiguration.imports</code>，并结合 <code>@ConditionalOn</code> 系列注解依据条件注册 Bean。</p>
<p>⑤、如果引入了 Web 相关依赖，会创建并启动 Tomcat 容器，完成 HTTP 端口监听。</p>
<p>关键的代码逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建启动时的监听器并触发启动事件</span></span><br><span class="line">    <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 准备运行环境</span></span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners);</span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建上下文</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> createApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 准备上下文</span></span><br><span class="line">        prepareContext(context, environment, listeners, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 刷新上下文，完成 Bean 初始化和装配</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 调用运行器</span></span><br><span class="line">        afterRefresh(context, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 触发启动完成事件</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, listeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="要在启动阶段自定义逻辑该怎么做？"><a href="#要在启动阶段自定义逻辑该怎么做？" class="headerlink" title="要在启动阶段自定义逻辑该怎么做？"></a>要在启动阶段自定义逻辑该怎么做？</h4><p>可以通过实现 <code>ApplicationRunner</code> 接口来完成启动后的自定义逻辑。</p>
<p>比如说在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派项目</a>中，我们就在 run 方法中追加了：JSON 类型转换配置和动态设置应用访问地址等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190407.png" alt="20251024190407"><br>技术派源码：启动后添加自定义逻辑</p>
<h4 id="为什么-Spring-Boot-在启动的时候能够找到-main-方法上的-SpringBootApplication-注解？"><a href="#为什么-Spring-Boot-在启动的时候能够找到-main-方法上的-SpringBootApplication-注解？" class="headerlink" title="为什么 Spring Boot 在启动的时候能够找到 main 方法上的@SpringBootApplication 注解？"></a>为什么 Spring Boot 在启动的时候能够找到 main 方法上的@SpringBootApplication 注解？</h4><p>其实 Spring Boot 并不是自己找到 <code>@SpringBootApplication</code> 注解的，而是我们通过程序告诉它的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把 <code>Application.class</code> 作为参数传给了 run 方法。这个 Application 类标注了 <code>@SpringBootApplication</code> 注解，用来告诉 Spring Boot：请用这个类作为配置类来启动。</p>
<p>然后，SpringApplication 在运行时就会把这个类注册到 Spring 容器中。</p>
<h4 id="Spring-Boot-默认的包扫描路径是什么？"><a href="#Spring-Boot-默认的包扫描路径是什么？" class="headerlink" title="Spring Boot 默认的包扫描路径是什么？"></a>Spring Boot 默认的包扫描路径是什么？</h4><p>Spring Boot 默认的包扫描路径是主类所在的包及其子包。</p>
<p>比如说在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，启动类<code>QuickForumApplication</code>所在的包是<code>com.github.paicoding.forum.web</code>，那么 Spring Boot 默认会扫描<code>com.github.paicoding.forum.web</code>包及其子包下的所有组件。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251024190421.png" alt="20251024190421"><br>沉默王二：技术派项目截图</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的滴滴同学 2 技术二面的原题：为什么 Spring Boot 启动时能找到 Main 类上面的注解</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 22 暑期实习一面面试原题：Spring Boot 默认的包扫描路径？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的微众银行同学 1 Java 后端一面的原题：@SpringBootApplication 注解了解吗？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的国企零碎面经同学 9 面试原题：Springboot的工作原理？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 5 Java 后端技术一面面试原题：SpringBoot启动流程（忘了）</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的哔哩哔哩同学 1 二面面试原题：springBoot启动机制，启动之后做了哪些步骤</li>
</ol>
</blockquote>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>详见操作系统学习笔记</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="🌟18-说说-HTTP-与-HTTPS-有哪些区别？"><a href="#🌟18-说说-HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="🌟18.说说 HTTP 与 HTTPS 有哪些区别？"></a>🌟18.说说 HTTP 与 HTTPS 有哪些区别？</h3><p><code>HTTPS</code> 是 <code>HTTP</code> 的增强版，在 <code>HTTP</code> 的基础上加入了 <code>SSL/TLS</code> 协议，<strong>确保数据在传输过程中是加密的</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025143412.png" alt="20251025143412"></p>
<p><code>HTTP</code> 的默认端⼝号是 <code>80</code>，<code>URL</code> 以<code>http://</code>开头；<br><code>HTTPS</code> 的默认端⼝号是 <code>443</code>，<code>URL</code> 以<code>https://</code>开头。</p>
<h3 id="🌟25-TCP-握手为什么是三次，为什么不能是两次？不能是四次？"><a href="#🌟25-TCP-握手为什么是三次，为什么不能是两次？不能是四次？" class="headerlink" title="🌟25.TCP 握手为什么是三次，为什么不能是两次？不能是四次？"></a>🌟25.TCP 握手为什么是三次，为什么不能是两次？不能是四次？</h3><p>使用<strong>三次握手可以建立一个可靠的连接</strong>。这一过程的目的是确保双方都知道对方已准备好进行通信，并同步双方的序列号，从而保持数据包的顺序和完整性。</p>
<h4 id="为什么-TCP-握手不能是两次？"><a href="#为什么-TCP-握手不能是两次？" class="headerlink" title="为什么 TCP 握手不能是两次？"></a>为什么 TCP 握手不能是两次？</h4><ul>
<li>为了<strong>防止服务器一直等，等到黄花菜都凉了</strong>。</li>
<li>为了<strong>防止客户端已经失效的连接请求突然又传送到了服务器</strong>。</li>
</ul>
<p>要知道，网络传输是有延时的（要通过网络光纤、WIFI、卫星信号传输等）。</p>
<p>假如说客户端发起了 SYN&#x3D;1 的第一次握手。服务器也及时回复了 SYN&#x3D;2 和 ACK&#x3D;1 的第二次握手，但是这个 ACK&#x3D;1 的确认报文段因为某些原因在传输过程中丢失了。</p>
<p>如果没有第三次握手告诉服务器，客户端收到了服务器的回应，那服务器是不知道客户端有没有接收到的。</p>
<p>于是服务器就一直干巴巴地开着端口在等着客户端发消息呢，但其实客户端并没有收到服务器的回应，心灰意冷地跑了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025143839.png" alt="20251025143839"></p>
<p>还有一种情况是，一个旧的、延迟的连接请求（SYN&#x3D;1）被服务器接受，导致服务器错误地开启一个不再需要的连接。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715112359.png" alt="20250715112359"></p>
<p>举个例子：假设你（客户端）给你的朋友（服务器）发送了一个邮件（连接请求）。因为某些原因，这封邮件迟迟没有到达朋友那里，可能是因为邮局的延误。于是你决定再发一封新的邮件。朋友收到了第二封邮件，你们成功地建立了连接并开始通信。</p>
<p>但是，过了很久，那封延误的旧邮件突然也到了你朋友那里。如果没有一种机制来识别和处理这种延误的邮件，你的朋友可能会以为这是一个新的连接请求，并尝试响应它，但其实你已经重新发了请求，原来的不需要了。这就导致了不必要的混乱和资源浪费。</p>
<p>所以我们需要“三次握手”来确认这个过程：</p>
<p>第一次握手：客户端发送 SYN 包（连接请求）给服务器，如果这个包延迟了，客户端不会一直等待，它<strong>可能会重试并发送一个新的连接请求</strong>。<br>第二次握手：服务器收到 SYN 包后，发送一个 SYN-ACK 包（确认接收到连接请求）回客户端。<br>第三次握手：客户端收到 SYN-ACK 包后，再发送一个 ACK 包给服务器，确认收到了服务器的响应。</p>
<h4 id="为什么不是四次？"><a href="#为什么不是四次？" class="headerlink" title="为什么不是四次？"></a>为什么不是四次？</h4><p>三次握手已经足够创建可靠的连接了，没有必要再多一次握手。</p>
<h4 id="什么是泛洪攻击？"><a href="#什么是泛洪攻击？" class="headerlink" title="什么是泛洪攻击？"></a>什么是泛洪攻击？</h4><p>泛洪攻击（SYN Flood Attack）是一种常见的 DoS（拒绝服务）攻击，攻击者会发送大量的伪造的 TCP 连接请求，导致服务器资源耗尽，无法处理正常的连接请求。</p>
<p>半连接服务拒绝，也称为 SYN 洪泛攻击或 SYN Flood。</p>
<p>所谓的半连接就是指在 TCP 的三次握手过程中，当服务器接收到来自客户端的第一个 SYN 包后，它会回复一个 SYN-ACK 包，此时连接处于“半开”状态，因为连接的建立还需要客户端发送最后一个 ACK 包。</p>
<p>在收到最后的 ACK 包之前，服务器会为这个尚未完成的连接分配一定的资源，并在它的队列中保留这个连接的位置。</p>
<h4 id="如果让你重新设计，怎么设计？"><a href="#如果让你重新设计，怎么设计？" class="headerlink" title="如果让你重新设计，怎么设计？"></a>如果让你重新设计，怎么设计？</h4><p>如果重新设计 TCP 的连接建立过程，可以考虑引入 <code>SYN cookies</code>，这种技术通过在 <code>SYN-ACK</code> 响应中编码连接信息，从而在不占用大量资源的情况下验证客户端。</p>
<h3 id="🌟30-说说-TCP-四次挥手的过程？"><a href="#🌟30-说说-TCP-四次挥手的过程？" class="headerlink" title="🌟30.说说 TCP 四次挥手的过程？"></a>🌟30.说说 TCP 四次挥手的过程？</h3><p>TCP 连接的断开过程被形象地概括为<strong>四次挥手</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251025144223.png" alt="20251025144223"></p>
<p><strong>第一次挥手</strong>：客户端向服务器发送一个 <code>FIN</code> 结束报文，表示客户端没有数据要发送了，但仍然可以接收数据。客户端进入 <code>FIN-WAIT-1</code> 状态。</p>
<p><strong>第二次挥手</strong>：服务器接收到 <code>FIN</code> 报文后，向客户端发送一个 <code>ACK</code> 报文，确认已接收到客户端的 <code>FIN</code> 请求。服务器进入 <code>CLOSE-WAIT</code> 状态，客户端进入 <code>FIN-WAIT-2</code> 状态。</p>
<p><strong>第三次挥手</strong>：服务器向客户端发送一个 <code>FIN</code> 报文，表示服务器也没有数据要发送了。服务器进入 <code>LAST-ACK </code>状态。</p>
<p><strong>第四次挥手</strong>：客户端接收到 <code>FIN</code> 报文后，向服务器发送一个 <code>ACK</code> 报文，确认已接收到服务器的 <code>FIN</code> 请求。客户端进入 <code>TIME-WAIT</code> 状态，等待一段时间以确保服务器接收到 <code>ACK</code> 报文。服务器接收到 <code>ACK</code> 报文后进入 <code>CLOSED</code> 状态。客户端在等待一段时间后也进入 <code>CLOSED</code> 状态。</p>
<h3 id="🌟31-TCP-挥手为什么需要四次呢？"><a href="#🌟31-TCP-挥手为什么需要四次呢？" class="headerlink" title="🌟31.TCP 挥手为什么需要四次呢？"></a>🌟31.TCP 挥手为什么需要四次呢？</h3><p>因为 <strong>TCP 是全双工通信协议</strong>，数据的发送和接收需要两次一来一回，也就是四次，来确保双方都能正确关闭连接。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716110915.png" alt="20250716110915"></p>
<ol>
<li>第一次挥手：客户端表示数据发送完成了，准备关闭，你确认一下。</li>
<li>第二次挥手：服务端回话说 ok，我马上处理完数据，稍等。</li>
<li>第三次挥手：服务端表示处理完了，可以关闭了。</li>
<li>第四次挥手：客户端说好，进入 TIME_WAIT 状态，确保服务端关闭连接后，自己再关闭连接。</li>
</ol>

<div class="article-footer slide-up fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap slide-up" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/10/24/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.24%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.10.24学习日记</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/10/23/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.23%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.10.23学习日记</a></div></section></div>







<footer class="page-footer slide-up footnote"><hr><div class="text"><p>本站由 <a href="/">JakicDong</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0">Stellar 1.30.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper slide-up toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaSE"><span class="toc-text">JavaSE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%F0%9F%8C%9F%E4%BB%80%E4%B9%88%E6%98%AF-Java%EF%BC%9F"><span class="toc-text">1.🌟什么是 Java？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E8%AF%AD%E8%A8%80%E5%92%8C-C-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 语言和 C 语言有哪些区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%F0%9F%8C%9FJava-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">7.🌟Java 有哪些数据类型？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean-%E7%B1%BB%E5%9E%8B%E5%AE%9E%E9%99%85%E5%8D%A0%E7%94%A8%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-text">boolean 类型实际占用几个字节？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99Integer%E6%9C%80%E5%A4%A7%E5%80%BC-1%EF%BC%8C%E6%98%AF%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="toc-text">给Integer最大值+1，是什么结果？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%F0%9F%8C%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">18.🌟面向对象编程有哪些特性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">封装是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">继承是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="toc-text">什么是多态？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Java%E9%87%8C%E9%9D%A2%E8%A6%81%E5%A4%9A%E7%BB%84%E5%90%88%E5%B0%91%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-text">为什么Java里面要多组合少继承？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%F0%9F%8C%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">23.🌟抽象类和接口有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-text">抽象类可以定义构造方法吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-text">接口可以定义构造方法吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F"><span class="toc-text">Java支持多继承吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F"><span class="toc-text">接口可以多继承吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">继承和抽象的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%99%AE%E9%80%9A%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">抽象类和普通类的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%F0%9F%8C%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E2%BD%85%E6%B3%95%EF%BC%9F"><span class="toc-text">29.🌟为什么重写 equals 时必须重写 hashCode ⽅法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">什么是 hashCode 方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">为什么要有 hashCode 方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84-hashcode-%E5%80%BC%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%9F%E4%B8%8D%E2%BC%80%E5%AE%9A%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">为什么两个对象有相同的 hashcode 值，它们也不⼀定相等？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashCode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">hashCode 和 equals 方法的关系？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%F0%9F%8C%9FString-%E5%92%8C-StringBuilder%E3%80%81StringBuffer-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">34.🌟String 和 StringBuilder、StringBuffer 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-String-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">请说说 String 的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-StringBuilder-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">请说说 StringBuilder 的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-StringBuffer-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">请说说 StringBuffer 的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">请总结一下使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%F0%9F%8C%9FJava-%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BD%93%E7%B3%BB"><span class="toc-text">41.🌟Java 中异常处理体系?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%F0%9F%8C%9FBIO%E3%80%81NIO%E3%80%81AIO-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">46.🌟BIO、NIO、AIO 之间的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B-BIO%EF%BC%9F"><span class="toc-text">简单说一下 BIO？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B-NIO%EF%BC%9F"><span class="toc-text">简单说下 NIO？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B-AIO%EF%BC%9F"><span class="toc-text">简单说下 AIO？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%F0%9F%8C%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F%E5%BA%94%E7%94%A8%EF%BC%9F%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">52.🌟什么是反射？应用？原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">反射有哪些应用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">反射的原理是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-text">Java集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-text">1.🌟说说有哪些常见的集合框架？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9F"><span class="toc-text">集合框架有哪几个常用工具类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%98%9F%E5%88%97"><span class="toc-text">简单介绍一下队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BC%98%E5%8A%A3%EF%BC%9F"><span class="toc-text">用过哪些集合类，它们的优劣？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">队列和栈的区别了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-text">哪些是线程安全的容器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection-%E7%BB%A7%E6%89%BF%E4%BA%86%E5%93%AA%E4%BA%9B%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-text">Collection 继承了哪些接口？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%F0%9F%8C%9FArrayList-%E5%92%8C-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2.🌟ArrayList 和 LinkedList 有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E7%94%A8%E9%80%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">ArrayList 和 LinkedList 的用途有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%EF%BC%9F"><span class="toc-text">ArrayList 和 LinkedList 是否支持随机访问？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">ArrayList 和 LinkedList 内存占用有何不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">ArrayList 和 LinkedList 的使用场景有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">链表和数组有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%F0%9F%8C%9F%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B-HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%97%EF%BC%9F"><span class="toc-text">8.🌟能说一下 HashMap 的底层数据结构吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%F0%9F%8C%9FHashMap-%E7%9A%84-put-%E6%B5%81%E7%A8%8B%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-text">11.🌟HashMap 的 put 流程知道吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E9%87%8D%E5%86%99%E5%85%83%E7%B4%A0%E7%9A%84-equals-%E6%96%B9%E6%B3%95%E6%B2%A1%E9%87%8D%E5%86%99-hashCode%EF%BC%8Cput-%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text">只重写元素的 equals 方法没重写 hashCode，put 的时候会发生什么?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%F0%9F%8C%9FHashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">21.🌟HashMap的扩容机制了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-7-%E6%89%A9%E5%AE%B9%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">JDK 7 扩容的时候有什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8-%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-text">JDK 8 是怎么解决这个问题的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E7%9A%84%E6%97%B6%E5%80%99%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E9%83%BD%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%97%EF%BC%9F"><span class="toc-text">扩容的时候每个节点都要进行位运算吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%F0%9F%8C%9FHashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">24.🌟HashMap 是线程安全的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%F0%9F%8C%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-HashMap-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-text">25.🌟怎么解决 HashMap 线程不安全的问题呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">Java并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2.🌟说说进程和线程的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="toc-text">如何理解协程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">线程间是如何进行通信的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">3.🌟说说线程有几种创建方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA-8G-%E5%86%85%E5%AD%98%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9C%80%E5%A4%9A%E8%83%BD%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-text">一个 8G 内存的系统最多能创建多少个线程?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA-Java-%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4%E9%87%8C%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">启动一个 Java 程序，你能说说里面有哪些线程吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%F0%9F%8C%9F%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E9%82%A3%E6%80%8E%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">4.🌟调用 start 方法时会执行 run 方法，那怎么不直接调用 run方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%F0%9F%8C%9F%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">6.🌟线程有几种状态？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BC%BA%E5%88%B6%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">如何强制终止线程？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%F0%9F%8C%9F%E8%AF%B7%E8%AF%B4%E8%AF%B4-sleep-%E5%92%8C-wait-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">10.🌟请说说 sleep 和 wait 的区别？（补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%F0%9F%8C%9F%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">11.🌟怎么保证线程安全？（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%B8%AAint%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%BA0%EF%BC%8C%E5%8D%81%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BD%AE%E6%B5%81%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C-%E6%93%8D%E4%BD%9C%EF%BC%88%E5%BE%AA%E7%8E%AF10000%E6%AC%A1%EF%BC%89%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A4%A7%E4%BA%8E10-%E4%B8%87%E8%BF%98%E6%98%AF%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E10%E4%B8%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">有个int的变量为0，十个线程轮流对其进行++操作（循环10000次），结果大于10 万还是小于等于10万，为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-%E6%9C%89%E4%B8%80%E4%B8%AA-key-%E5%AF%B9%E5%BA%94%E7%9A%84-value-%E6%98%AF%E4%B8%80%E4%B8%AAjson-%E7%BB%93%E6%9E%84%EF%BC%8Cjson-%E5%BD%93%E4%B8%AD%E6%9C%89%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%AD%90%E4%BB%BB%E5%8A%A1%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%AD%90%E4%BB%BB%E5%8A%A1%E5%A6%82%E6%9E%9C%E5%AF%B9-key-%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">场景:有一个 key 对应的 value 是一个json 结构，json 当中有好几个子任务，这些子任务如果对 key 进行修改的话，会不会存在线程安全的问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">说一个线程安全的使用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B-Hashtable-%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%97%EF%BC%9F"><span class="toc-text">能说一下 Hashtable 的底层数据结构吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%F0%9F%8C%9FThreadLocal-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">12.🌟ThreadLocal 是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">ThreadLocal 有哪些优点？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%F0%9F%8C%9FThreadLocal-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">14.🌟ThreadLocal 怎么实现的呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-text">什么是弱引用，什么是强引用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%F0%9F%8C%9FThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F"><span class="toc-text">15.🌟ThreadLocal 内存泄露是怎么回事？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-text">那怎么解决内存泄漏问题呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88-key-%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-text">那为什么 key 要设计成弱引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B-ThreadLocal-%E7%9A%84%E6%94%B9%E8%BF%9B%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">你了解哪些 ThreadLocal 的改进方案？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%F0%9F%8C%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">20.🌟说一下你对 Java 内存模型的理解？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E8%A6%81%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-text">为什么线程要用自己的内存？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%F0%9F%8C%9Fvolatile-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">25.🌟volatile 了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">volatile 怎么保证可见性的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">volatile 怎么保证有序性的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%92%8C-synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">volatile 和 synchronized 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%8A%A0%E5%9C%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">volatile 加在基本类型和对象上的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%F0%9F%8C%9Fsynchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">29.🌟synchronized 锁升级了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-synchronized-%E5%9B%9B%E7%A7%8D%E9%94%81%E7%8A%B6%E6%80%81%E5%90%97%EF%BC%9F"><span class="toc-text">了解 synchronized 四种锁状态吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">synchronized 做了哪些优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">请详细说说锁升级的过程？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%F0%9F%8C%9Fsynchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">30.🌟synchronized 和 ReentrantLock 的区别了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%87%8F%E5%A4%A7%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BD%BF%E7%94%A8-synchronized-%E8%BF%98%E6%98%AF-ReentrantLock%EF%BC%9F"><span class="toc-text">并发量大的情况下，使用 synchronized 还是 ReentrantLock？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">Lock 了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock-%E7%9A%84-lock-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">ReentrantLock 的 lock() 方法实现逻辑了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4-ReentrantLock-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">32.🌟说说 ReentrantLock 的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%F0%9F%8C%9FCAS-%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">34.🌟CAS 了解多少？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81-CAS-%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-text">怎么保证 CAS 的原子性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%F0%9F%8C%9FCAS-%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">35.🌟CAS 有什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ABA-%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">什么是 ABA 问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E5%BC%80%E9%94%80%E5%A4%A7%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">自旋开销大怎么解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%90%8C%E6%97%B6%E6%9B%B4%E6%96%B0%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">涉及到多个变量同时更新怎么办？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%F0%9F%8C%9F%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%E5%91%A2%EF%BC%9F"><span class="toc-text">40.🌟死锁问题怎么排查呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%F0%9F%8C%9F%E8%81%8A%E8%81%8A%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">42.🌟聊聊悲观锁和乐观锁？（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%8F%91%E7%8E%B0%E6%9C%89%E7%BA%BF%E7%A8%8B%E8%BF%87%E6%9D%A5%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">乐观锁发现有线程过来修改数据，怎么办？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%F0%9F%8C%9F%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B-ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">48.🌟能说一下 ConcurrentHashMap 的实现吗？（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JDK-7-%E4%B8%AD-ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">说一下 JDK 7 中 ConcurrentHashMap 的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JDK-7-%E4%B8%AD-ConcurrentHashMap-%E7%9A%84-put-%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">说一下 JDK 7 中 ConcurrentHashMap 的 put 流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JDK-7-%E4%B8%AD-ConcurrentHashMap-%E7%9A%84-get-%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">说一下 JDK 7 中 ConcurrentHashMap 的 get 流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JDK-8-%E4%B8%AD-ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">说一下 JDK 8 中 ConcurrentHashMap 的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JDK-8-%E4%B8%AD-ConcurrentHashMap-%E7%9A%84-put-%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">说一下 JDK 8 中 ConcurrentHashMap 的 put 流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JDK-8-%E4%B8%AD-ConcurrentHashMap-%E7%9A%84-get-%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">说一下 JDK 8 中 ConcurrentHashMap 的 get 流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-HashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">说一下 HashMap 和 ConcurrentHashMap 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-ConcurrentHashMap-%E7%9A%84%EF%BC%9F"><span class="toc-text">你项目中怎么使用 ConcurrentHashMap 的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-ConcurrentHashMap-%E5%AF%B9-HashMap-%E7%9A%84%E6%94%B9%E8%BF%9B%EF%BC%9F"><span class="toc-text">说一下 ConcurrentHashMap 对 HashMap 的改进？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E5%9C%A8-JDK-1-7-%E4%B8%AD%E8%A6%81%E7%94%A8-ReentrantLock%EF%BC%8C%E8%80%8C%E5%9C%A8-JDK-1-8-%E8%A6%81%E7%94%A8-synchronized"><span class="toc-text">为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%F0%9F%8C%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">53.🌟什么是线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%F0%9F%8C%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">55.🌟说一下线程池的工作流程？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E7%94%A8%E4%B8%80%E4%B8%AA%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E%E4%B8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">能用一个生活中的例子说明下吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%F0%9F%8C%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">56.🌟线程池的主要参数有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8F%82%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%90%97%EF%BC%9F"><span class="toc-text">能简单说一下参数之间的关系吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8D%E5%A4%9F%E4%BC%9A%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">核心线程数不够会怎么进行处理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%BF%99%E4%BA%9B%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-text">举个例子说一下这些参数的变化？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%F0%9F%8C%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">57.🌟线程池的拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-%F0%9F%8C%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E4%BC%98%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">67.🌟线程池调优了解吗？（补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-%F0%9F%8C%9F%E4%BD%A0%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%97%EF%BC%9F"><span class="toc-text">69.🌟你能设计实现一个线程池吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F"><span class="toc-text">手写一个数据库连接池，可以吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%F0%9F%8C%9F%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%90%97%EF%BC%9F"><span class="toc-text">3.🌟能说一下 JVM 的内存区域吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F"><span class="toc-text">介绍一下程序计数器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%9F"><span class="toc-text">介绍一下 Java 虚拟机栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E6%9C%89%E7%9A%84%E7%A9%BA%E6%96%B9%E6%B3%95%EF%BC%8C%E7%A9%BA%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%B2%A1%E6%9C%89%EF%BC%8C%E9%82%A3%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E9%87%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-text">一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%9F"><span class="toc-text">介绍一下本地方法栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E7%9A%84%E8%BF%90%E8%A1%8C%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">介绍一下本地方法栈的运行场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#native-%E6%96%B9%E6%B3%95%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-text">native 方法解释一下？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-Java-%E5%A0%86%EF%BC%9F"><span class="toc-text">介绍一下 Java 堆？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">堆和栈的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F"><span class="toc-text">介绍一下方法区？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AD%98%E5%9C%A8%E5%A0%86%E6%A0%88%E7%9A%84%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-text">变量存在堆栈的什么位置？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%F0%9F%8C%9F%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">6.🌟对象创建的过程了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81%E8%BF%87%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">对象的销毁过程了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%F0%9F%8C%9F%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-text">14.🌟对象什么时候会进入老年代？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%EF%BC%9F"><span class="toc-text">长期存活的对象如何判断？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%EF%BC%9F"><span class="toc-text">大对象如何判断？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">动态年龄判定了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%F0%9F%8C%9F%E8%AE%B2%E8%AE%B2-JVM-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">23.🌟讲讲 JVM 的垃圾回收机制（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">垃圾回收的过程是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%F0%9F%8C%9F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%BB%8D%E7%84%B6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-text">24.🌟如何判断对象仍然存活？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%EF%BC%9F"><span class="toc-text">什么是引用计数法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E5%89%8D%E7%BD%AE%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-text">做可达性分析的时候，应该有哪些前置性的操作？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%F0%9F%8C%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">27.🌟垃圾收集算法了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">说说标记-清除算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">说说标记-复制算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">说说标记-整理算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">说说分代收集算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么要用分代收集呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B%E5%92%8C%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%81%9C%E9%A1%BF%EF%BC%9F"><span class="toc-text">标记复制的标记过程和复制过程会不会停顿？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%F0%9F%8C%9F%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">31.🌟知道哪些垃圾收集器？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Serial-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 Serial 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-ParNew-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 ParNew 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 Parallel Scavenge 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 Serial Old 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 Parallel Old 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-CMS-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 CMS 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-G1-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 G1 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-ZGC-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 ZGC 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">垃圾回收器的作用是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%F0%9F%8C%9F%E8%83%BD%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B-CMS-%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">32.🌟能详细说一下 CMS 的垃圾收集过程吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E6%8F%90%E5%88%B0%E4%BA%86remark%EF%BC%8C%E9%82%A3%E5%AE%83remark%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%9F"><span class="toc-text">你提到了remark，那它remark具体是怎么执行的？三色标记法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%9F"><span class="toc-text">什么是三色标记法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%F0%9F%8C%9FG1-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">33.🌟G1 垃圾收集器了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%F0%9F%8C%9F%E4%BA%86%E8%A7%A3%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">45.🌟了解类的加载机制吗？（补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%F0%9F%8C%9F%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-text">48.🌟类装载的过程知道吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BD%E5%85%A5%E8%BF%87%E7%A8%8B-JVM-%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">载入过程 JVM 会做什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%F0%9F%8C%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">49.🌟什么是双亲委派模型？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL"><span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F0-%E4%BB%80%E4%B9%88%E6%98%AFMYSQL"><span class="toc-text">🌟0.什么是MYSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-%E5%88%9B%E5%BB%BA%E4%B8%80%E5%BC%A0%E8%A1%A8"><span class="toc-text">删除&#x2F;创建一张表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E5%8D%87%E5%BA%8F-%E9%99%8D%E5%BA%8F%E7%9A%84SQL%E8%AF%AD%E5%8F%A5"><span class="toc-text">写一个升序&#x2F;降序的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MYSQL%E5%87%BA%E7%8E%B0%E6%80%A7%E8%83%BD%E5%B7%AE%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">MYSQL出现性能差的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%F0%9F%8C%9F%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8emoji"><span class="toc-text">9.🌟如何存储emoji?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%F0%9F%8C%9F%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5SELECT%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="toc-text">21.🌟一条查询语句SELECT是如何执行的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%F0%9F%8C%9FMySQL-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="toc-text">24.🌟MySQL 有哪些常见存储引擎？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%F0%9F%8C%9FMySQL-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">28.🌟MySQL 日志文件有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E9%87%8D%E7%82%B9%E8%AF%B4%E8%AF%B4-binlog%EF%BC%9F"><span class="toc-text">请重点说说 binlog？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog-%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E9%83%BD%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">binlog 的配置参数都了解哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%BA%86binlog%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81undolog-redolog%EF%BC%9F"><span class="toc-text">有了binlog为什么还要undolog redolog？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%8E%A2%E7%A9%B6%E4%B8%80%E4%B8%8Bbinlog-%E9%95%BF%E6%96%87%E8%AD%A6%E5%91%8A%E2%9A%A0%EF%B8%8F"><span class="toc-text">详细探究一下binlog(长文警告⚠️):</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Binlog-%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E6%9C%89%E4%B8%A4%E4%B8%AA%EF%BC%9A"><span class="toc-text">Binlog 的主要作用有两个：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Binlog-%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-text">Binlog 日志格式:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-mysqlbinlog-%E5%91%BD%E4%BB%A4%E6%89%8B%E5%8A%A8%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-text">如何通过 mysqlbinlog 命令手动恢复数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-redo-log-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">说说 redo log 的工作机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">redo log 文件的大小是固定的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4WAL"><span class="toc-text">说一说WAL?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%F0%9F%8C%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">30.🌟为什么要两阶段提交?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-2PC-%E8%83%BD%E4%BF%9D%E8%AF%81-redo-log-%E5%92%8C-binlog-%E7%9A%84%E5%BC%BA%E2%BC%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-text">为什么 2PC 能保证 redo log 和 binlog 的强⼀致性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XID-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">XID 了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%F0%9F%8C%9Fredo-log-%E7%9A%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">31.🌟redo log 的写入过程了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BC%9A%E8%A7%A6%E5%8F%91-redo-log-%E7%9A%84%E5%88%B7%E7%9B%98%E5%8A%A8%E4%BD%9C%EF%BC%9F"><span class="toc-text">哪些场景会触发 redo log 的刷盘动作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#innodb-flush-log-at-trx-commit-%E5%8F%82%E6%95%B0%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">innodb_flush_log_at_trx_commit 参数你了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1%E7%9A%84-redo-log%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%88%B7%E7%9B%98%EF%BC%9F"><span class="toc-text">一个没有提交事务的 redo log，会不会刷盘？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redo-Log-Buffer-%E6%98%AF%E9%A1%BA%E5%BA%8F%E5%86%99%E8%BF%98%E6%98%AF%E9%9A%8F%E6%9C%BA%E5%86%99%EF%BC%9F"><span class="toc-text">Redo Log Buffer 是顺序写还是随机写？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#buf-next-to-write-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">buf_next_to_write 了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-MTR-%E5%90%97%EF%BC%9F"><span class="toc-text">了解 MTR 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redo-Log-Block-%E7%9A%84%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">Redo Log Block 的结构了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redo-Log-Block-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%88%90-512-%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-text">Redo Log Block 为什么设计成 512 字节？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LSN-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">LSN 了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Checkpoint-%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">Checkpoint 了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Eredo-log-%E7%9A%84%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">关于redo log 的调优参数了解多少？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F32-%E4%BB%80%E4%B9%88%E6%98%AF%E6%85%A2-SQL%EF%BC%9F"><span class="toc-text">🌟32.什么是慢 SQL？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">SQL 的执行过程了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%85%A2SQL"><span class="toc-text">如何优化慢SQL?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2sql%E6%97%A5%E5%BF%97%E6%80%8E%E4%B9%88%E5%BC%80%E5%90%AF%EF%BC%9F"><span class="toc-text">慢sql日志怎么开启？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F33-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E6%9D%A5%E4%BC%98%E5%8C%96-SQL%EF%BC%9F"><span class="toc-text">🌟33.你知道哪些方法来优化 SQL？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">如何利用覆盖索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">如何正确使用联合索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">如何进行分页优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E9%A1%B5%E4%BC%9A%E5%8F%98%E6%85%A2%EF%BC%9F"><span class="toc-text">为什么分页会变慢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JOIN-%E4%BB%A3%E6%9B%BF%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">JOIN 代替子查询有什么好处？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JOIN%E6%93%8D%E4%BD%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%8F%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%A4%A7%E8%A1%A8%EF%BC%9F"><span class="toc-text">JOIN操作为什么要小表驱动大表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-JOIN-%E5%85%B3%E8%81%94%E5%A4%AA%E5%A4%9A%E7%9A%84%E8%A1%A8%EF%BC%9F"><span class="toc-text">为什么要避免使用 JOIN 关联太多的表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">如何进行排序优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-filesort%EF%BC%9F"><span class="toc-text">什么是 filesort？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F%E5%92%8C-rowid-%E6%8E%92%E5%BA%8F%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">全字段排序和 rowid 排序了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9-Sort-merge-passes-%E5%8F%82%E6%95%B0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">你对 Sort_merge_passes 参数了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%8E%A8%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">条件下推你了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-select-%EF%BC%9F"><span class="toc-text">为什么要尽量避免使用 select *？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%BF%98%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B-SQL-%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">你还知道哪些 SQL 优化方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%F0%9F%8C%9Fexplain%E5%B9%B3%E5%B8%B8%E6%9C%89%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">34.🌟explain平常有用过吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#explain-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89%E7%90%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">explain 输出结果中常见的字段含义理解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%AD%89%E7%BA%A7%EF%BC%8C%E8%BE%BE%E5%88%B0%E4%BB%80%E4%B9%88%E7%BA%A7%E5%88%AB%E6%AF%94%E8%BE%83%E5%90%88%E9%80%82%EF%BC%9F"><span class="toc-text">type的执行效率等级，达到什么级别比较合适？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%F0%9F%8C%9F%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98MySQL%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-text">35.🌟索引为什么能提高MySQL查询效率？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%F0%9F%8C%9F%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E5%90%97%EF%BC%9F"><span class="toc-text">36.🌟能简单说一下索引的分类吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">你对主键索引了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">唯一索引和主键索引有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-key-%E5%92%8C-unique-index-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">unique key 和 unique index 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">普通索引和唯一索引有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">你对全文索引了解多少？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%F0%9F%8C%9F%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F"><span class="toc-text">37.🌟创建索引有哪些注意点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%F0%9F%8C%9F%E7%B4%A2%E5%BC%95%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%A4%B1%E6%95%88%E5%91%A2%EF%BC%9F"><span class="toc-text">38.🌟索引哪些情况下会失效呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">什么情况下模糊查询不走索引？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%F0%9F%8C%9F%E4%B8%BA%E4%BB%80%E4%B9%88-InnoDB-%E8%A6%81%E4%BD%BF%E7%94%A8-B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">41.🌟为什么 InnoDB 要使用 B+树作为索引？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%98%AF%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E8%BF%98%E6%98%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%BB%8E%E5%A4%A7%E5%80%BC%E5%90%91%E5%B0%8F%E5%80%BC%E6%A3%80%E7%B4%A2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-text">B+树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-MongoDB-%E7%9A%84%E7%B4%A2%E5%BC%95%E7%94%A8-B%E6%A0%91%EF%BC%8C%E8%80%8C-MySQL-%E7%94%A8-B-%E6%A0%91%EF%BC%9F"><span class="toc-text">为什么 MongoDB 的索引用 B树，而 MySQL 用 B+ 树？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%F0%9F%8C%9F%E4%B8%80%E6%A3%B5B-%E6%A0%91%E8%83%BD%E5%AD%98%E5%82%A8%E5%A4%9A%E5%B0%91%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%91%A2%EF%BC%9F"><span class="toc-text">42.🌟一棵B+树能存储多少条数据呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">每个叶子节点能存放多少条数据？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%F0%9F%8C%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-B-%E6%A0%91%E8%80%8C%E4%B8%8D%E7%94%A8-B-%E6%A0%91%E5%91%A2%EF%BC%9F"><span class="toc-text">44.🌟为什么用 B+ 树而不用 B 树呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">B+树的时间复杂度是多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-B-%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么用 B+树不用跳表呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-text">B+树的范围查找怎么做的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%BF%AB%E6%8E%92%E5%90%97"><span class="toc-text">了解快排吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%F0%9F%8C%9F%E8%81%9A%E6%97%8F%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E6%97%8F%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">46.🌟聚族索引和非聚族索引有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%F0%9F%8C%9F%E5%9B%9E%E8%A1%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">47.🌟回表了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E7%9A%84%E4%BB%A3%E4%BB%B7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">回表的代价是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-MRR-%E5%90%97%EF%BC%9F"><span class="toc-text">了解 MRR 吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%F0%9F%8C%9F%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">48.🌟联合索引了解吗？（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">联合索引底层的存储结构是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E5%86%85%E5%AE%B9"><span class="toc-text">联合索引的叶子节点存的什么内容?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49-%F0%9F%8C%9F%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">49.🌟覆盖索引了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%F0%9F%8C%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-text">50.🌟什么是最左前缀原则？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E5%88%97%E8%BF%98%E8%83%BD%E7%94%A8%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%9F"><span class="toc-text">范围查询后的列还能用索引吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BB%8E%E6%9C%80%E5%B7%A6%E5%BC%80%E5%A7%8B%E6%9F%A5%EF%BC%8C%E5%B0%B1%E6%97%A0%E6%B3%95%E5%8C%B9%E9%85%8D%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么不从最左开始查，就无法匹配呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-a-b-%EF%BC%8Cwhere-a-1-%E5%92%8C-where-b-1%EF%BC%8C%E6%95%88%E6%9E%9C%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%E5%90%97"><span class="toc-text">联合索引 (a, b)，where a &#x3D; 1 和 where b &#x3D; 1，效果是一样的吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E5%A6%82%E6%9C%89%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-abc%EF%BC%8C%E4%B8%8B%E9%9D%A2%E7%9A%84-sql-%E6%80%8E%E4%B9%88%E8%B5%B0%E7%9A%84%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">假如有联合索引 abc，下面的 sql 怎么走的联合索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#A-B-C-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-select-from-tbn-where-a-and-b-in-and-c-%E4%BC%9A%E8%B5%B0%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%9F"><span class="toc-text">(A,B,C) 联合索引 select * from tbn where a&#x3D;? and b in (?,?) and c&gt;? 会走索引吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9C%BA%E6%99%AF%E9%A2%98%EF%BC%9A-a-b-c-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%8C-b-c-%E6%98%AF%E5%90%A6%E4%BC%9A%E8%B5%B0%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%9F"><span class="toc-text">联合索引的一个场景题：(a,b,c)联合索引，(b,c)是否会走索引吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-a-b-c-%EF%BC%8Cwhere-c-5-%E6%98%AF%E5%90%A6%E4%BC%9A%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">建立联合索引(a,b,c)，where c &#x3D; 5 是否会用到索引？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sql%E4%B8%AD%E4%BD%BF%E7%94%A8like%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%81%B5%E5%BE%AA%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E5%AE%9A%E4%BC%9A%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%F0%9F%8C%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%9F"><span class="toc-text">51.🌟什么是索引下推？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%F0%9F%8C%9FMySQL-%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="toc-text">53.🌟MySQL 中有哪几种锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4-MySQL-%E7%9A%84%E8%A1%8C%E9%94%81%EF%BC%9F"><span class="toc-text">55.🌟说说 MySQL 的行锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select-for-update-%E6%9C%89%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%EF%BC%9F"><span class="toc-text">select for update 有什么需要注意的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E8%AE%B0%E5%BD%95%E9%94%81%E5%90%A7%EF%BC%9F"><span class="toc-text">说说记录锁吧？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">间隙锁了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%E4%BC%9A%E5%8A%A0%E4%B8%8A%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%9F"><span class="toc-text">执行什么命令会加上间隙锁？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%F0%9F%8C%9FMySQL%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">58.🌟MySQL的乐观锁和悲观锁了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">如何通过悲观锁和乐观锁解决库存超卖问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%F0%9F%8C%9FMySQL%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-text">60.🌟MySQL事务的四大特性说一下？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-text">详细说一下原子性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-text">详细说一下一致性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%9F"><span class="toc-text">详细说一下隔离性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9F"><span class="toc-text">详细说一下持久性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%F0%9F%8C%9F%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">62.🌟事务的隔离级别有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%EF%BC%9F"><span class="toc-text">详细说说读未提交？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%EF%BC%9F"><span class="toc-text">什么是读已提交？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9F"><span class="toc-text">什么是可重复读？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%EF%BC%9F"><span class="toc-text">什么是串行化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E4%BA%8B%E5%8A%A1%E6%9C%AA%E6%8F%90%E4%BA%A4%EF%BC%8CB-%E4%BA%8B%E5%8A%A1%E4%B8%8A%E6%9F%A5%E8%AF%A2%E5%88%B0%E7%9A%84%E6%98%AF%E6%97%A7%E5%80%BC%E8%BF%98%E6%98%AF%E6%96%B0%E5%80%BC%EF%BC%9F"><span class="toc-text">A 事务未提交，B 事务上查询到的是旧值还是新值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%9B%B4%E6%94%B9%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="toc-text">怎么更改事务的隔离级别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%F0%9F%8C%9F%E8%AF%B7%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E5%B9%BB%E8%AF%BB%E5%91%A2%EF%BC%9F"><span class="toc-text">64.🌟请详细说说幻读呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-text">如何避免幻读？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%93%E5%89%8D%E8%AF%BB%E5%91%A2%EF%BC%9F"><span class="toc-text">什么是当前读呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-UPDATE-%E5%92%8C-DELETE-%E4%B9%9F%E5%B1%9E%E4%BA%8E%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%9F"><span class="toc-text">为什么 UPDATE 和 DELETE 也属于当前读？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%91%A2%EF%BC%9F"><span class="toc-text">什么是快照读呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-%F0%9F%8C%9FMVCC-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">65.🌟MVCC 了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E7%89%88%E6%9C%AC%E9%93%BE%EF%BC%9F"><span class="toc-text">请详细说说什么是版本链？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AFReadView%EF%BC%9F"><span class="toc-text">请详细说说什么是ReadView？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReadView-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%88%E6%9C%AC%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A7%81%E7%9A%84%EF%BC%9F"><span class="toc-text">ReadView 是如何判断记录的某个版本是否可见的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%9C%A8-ReadView-%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">可重复读和读已提交在 ReadView 上的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA-AB-%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%EF%BC%8C%E9%82%A3%E4%B9%88-A-%E8%AF%BB%E5%88%B0%E7%9A%84%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90%E3%80%82"><span class="toc-text">如果两个 AB 事务并发修改一个变量，那么 A 读到的值是什么，怎么分析。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%F0%9F%8C%9F%E4%BD%A0%E4%BB%AC%E4%B8%80%E8%88%AC%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E5%BA%93%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">70.🌟你们一般是怎么分库的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-%F0%9F%8C%9F%E9%82%A3%E4%BD%A0%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E8%A1%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">71.🌟那你们是怎么分表的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF-Redis"><span class="toc-text">1.🌟说说什么是 Redis?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%92%8C-MySQL-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Redis 和 MySQL 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TecHub%E9%A1%B9%E7%9B%AE%E9%87%8C%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86-Redis%EF%BC%9F"><span class="toc-text">TecHub项目里哪里用到了 Redis？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E8%BF%87-Redis-%E5%90%97%EF%BC%9F"><span class="toc-text">部署过 Redis 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E6%9C%89%E9%83%A8%E7%BD%B2%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">Redis 的高可用方案有部署过吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%F0%9F%8C%9FRedis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">3.🌟Redis有哪些数据类型？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="toc-text">详细介绍下字符串？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8B%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="toc-text">详细介绍下列表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8B%E5%93%88%E5%B8%8C%EF%BC%9F"><span class="toc-text">详细介绍下哈希？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8B%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-text">详细介绍下集合？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-text">详细介绍下有序集合？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8BBitmap%EF%BC%9F"><span class="toc-text">详细介绍下Bitmap？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8BHyperLogLog%EF%BC%9F"><span class="toc-text">详细介绍下HyperLogLog？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8BGEO%EF%BC%9F"><span class="toc-text">详细介绍下GEO？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-hash-%E7%B1%BB%E5%9E%8B%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8-string-%E7%B1%BB%E5%9E%8B%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-text">为什么使用 hash 类型而不使用 string 类型序列化存储？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%F0%9F%8C%9FRedis-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%E5%91%A2%EF%BC%9F"><span class="toc-text">4.🌟Redis 为什么快呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%F0%9F%8C%9FRedis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">10.🌟Redis的持久化方式有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B-RDB%EF%BC%9F"><span class="toc-text">详细说一下 RDB？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91-RDB-%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-text">什么情况下会自动触发 RDB 持久化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B-AOF%EF%BC%9F"><span class="toc-text">详细说一下 AOF？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E7%9A%84%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">AOF 的刷盘策略了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4AOF%E7%9A%84%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">说说AOF的重写机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E9%87%8D%E5%86%99%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">AOF 重写的具体过程是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">AOF 文件存储的是什么类型的数据？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E9%87%8D%E5%86%99%E6%9C%9F%E9%97%B4%E5%91%BD%E4%BB%A4%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%86%99%E5%85%A5%E4%B8%A4%E6%AC%A1%EF%BC%8C%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">AOF重写期间命令可能会写入两次，会造成什么影响？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%F0%9F%8C%9FRedis-4-0-%E7%9A%84%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">14.🌟Redis 4.0 的混合持久化了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">如何设置持久化模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE-RDB-%E5%92%8C-AOF-%E7%9A%84%EF%BC%9F"><span class="toc-text">你在开发中是怎么配置 RDB 和 AOF 的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%F0%9F%8C%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F"><span class="toc-text">29.🌟什么是缓存击穿？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F"><span class="toc-text">什么是缓存穿透？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F"><span class="toc-text">什么是缓存雪崩？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%F0%9F%8C%9F%E8%83%BD%E8%AF%B4%E8%AF%B4%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%97%EF%BC%9F"><span class="toc-text">30.🌟能说说布隆过滤器吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AD%98%E5%9C%A8%E8%AF%AF%E5%88%A4%E5%90%97%EF%BC%9F"><span class="toc-text">布隆过滤器存在误判吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%94%AF%E6%8C%81%E5%88%A0%E9%99%A4%E5%90%97%EF%BC%9F"><span class="toc-text">布隆过滤器支持删除吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E8%80%8C%E6%98%AF%E7%94%A8%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9F"><span class="toc-text">为什么不能用哈希表而是用布隆过滤器？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%F0%9F%8C%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E2%BC%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-text">31.🌟如何保证缓存和数据库的数据⼀致性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E5%86%8D%E6%9D%A5%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-text">那再来说说为什么要删除缓存而不是更新缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E5%86%8D%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-text">那再说说为什么要先更新数据库，再删除缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E5%81%87%E5%A6%82%E5%AF%B9%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E8%A6%81%E6%B1%82%E5%BE%88%E9%AB%98%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%E5%91%A2%EF%BC%9F"><span class="toc-text">那假如对缓存数据库一致性要求很高，该怎么办呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%F0%9F%8C%9FRedis%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">40.🌟Redis有哪些内存淘汰策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%F0%9F%8C%9FRedis%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%90%97%EF%BC%9F"><span class="toc-text">45.🌟Redis支持事务吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-Redis-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">说一下 Redis 事务的原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F"><span class="toc-text">Redis 事务有哪些注意点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A%EF%BC%9F"><span class="toc-text">Redis事务为什么不支持回滚？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E6%BB%A1%E8%B6%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%9F%E8%A6%81%E6%80%8E%E4%B9%88%E6%94%B9%E8%BF%9B%EF%BC%9F"><span class="toc-text">Redis事务满足原子性吗？要怎么改进？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E7%9A%84-ACID-%E7%89%B9%E6%80%A7%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%EF%BC%9F"><span class="toc-text">Redis 事务的 ACID 特性如何体现？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%F0%9F%8C%9FRedis%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-text">48.🌟Redis能实现分布式锁吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-SETNX-%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-text">Redis如何保证 SETNX 不会发生冲突？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SETNX%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">SETNX有什么问题，如何解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">Redisson了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4Redisson%E7%9A%84%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">详细说说Redisson的看门狗机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E6%A3%80%E6%9F%A5%E9%94%81%E8%BF%87%E7%A8%8B%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%90%97%EF%BC%9F"><span class="toc-text">看门狗机制中的检查锁过程是原子操作吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redlock%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">Redlock你了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%94%81%E8%83%BD%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E7%99%BE%E5%88%86%E7%99%BE%E4%B8%8A%E9%94%81%EF%BC%9F"><span class="toc-text">红锁能不能保证百分百上锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E7%94%A8%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-text">项目中有用到分布式锁吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%F0%9F%8C%9FRedis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">49.🌟Redis都有哪些底层数据结构？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8B%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="toc-text">简单介绍下链表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%EF%BC%8C%E8%83%BD%E5%86%8D%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E5%90%97%EF%BC%9F"><span class="toc-text">关于整数集合，能再详细说说吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bzset-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">说一下zset 的底层原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E4%B8%BA%E4%BB%80%E4%B9%88Redis-7-0%E8%A6%81%E7%94%A8listpack%E6%9D%A5%E6%9B%BF%E4%BB%A3ziplist%E5%90%97%EF%BC%9F"><span class="toc-text">你知道为什么Redis 7.0要用listpack来替代ziplist吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-text">连锁更新是怎么发生的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%F0%9F%8C%9F%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%B7%B3%E8%A1%A8%E5%90%97%EF%BC%9F"><span class="toc-text">52.🌟你了解跳表吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%BE%80%E8%B7%B3%E8%A1%A8%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E5%91%A2%EF%BC%9F"><span class="toc-text">怎么往跳表插入节点呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zset%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E5%91%A2%EF%BC%9F"><span class="toc-text">zset为什么要使用跳表呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">跳表是如何定义的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#span-%E8%B7%A8%E5%BA%A6%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">span 跨度有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B7%B3%E8%A1%A8%E7%9A%84%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%AF%94%E5%AD%97%E5%85%B8%E9%AB%98%EF%BC%9F"><span class="toc-text">为什么跳表的范围查询效率比字典高？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%F0%9F%8C%9FSpring%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">4.🌟Spring用了哪些设计模式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">Spring如何实现单例模式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%F0%9F%8C%9F%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="toc-text">7.🌟能说一下Bean的生命周期吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Aware-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">Aware 类型的接口有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%85%8D%E7%BD%AE%E4%BA%86-init-method-%E5%92%8C-destroy-method%EF%BC%8CSpring-%E4%BC%9A%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%B0%83%E7%94%A8%E5%85%B6%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">如果配置了 init-method 和 destroy-method，Spring 会在什么时候调用其配置的方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%F0%9F%8C%9FSpring%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%91%A2%EF%BC%9F"><span class="toc-text">14.🌟Spring怎么解决循环依赖呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8BSpring%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="toc-text">哪些情况下Spring无法解决循环依赖？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%F0%9F%8C%9F%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AFIoC%EF%BC%9F"><span class="toc-text">16.🌟说一说什么是IoC？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DI%E5%92%8CIoC%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">DI和IoC的区别了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-IoC-%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么要使用 IoC 呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%F0%9F%8C%9F%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6Spring%E7%9A%84IoC%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">19.🌟项目启动时Spring的IoC会做什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Spring%E7%9A%84Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">说说Spring的Bean实例化方式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF-AOP%EF%BC%9F"><span class="toc-text">20.🌟说说什么是 AOP？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-AOP-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="toc-text">Spring AOP 有哪些核心概念？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-AOP-%E7%BB%87%E5%85%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">Spring AOP 织入有哪几种方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AspectJ-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">AspectJ 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-AOP-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">Spring AOP 有哪些通知方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-AOP-%E5%8F%91%E7%94%9F%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%EF%BC%9F"><span class="toc-text">Spring AOP 发生在什么时候？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B-AOP"><span class="toc-text">简单总结一下 AOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E5%92%8C-OOP-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">AOP和 OOP 的关系？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%F0%9F%8C%9FAOP%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">21.🌟AOP的应用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">24.🌟说说JDK动态代理和CGLIB代理的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-CGLIB-%E8%BF%98%E6%98%AF-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">选择 CGLIB 还是 JDK 动态代理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BC%9A%E7%94%A8-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">你会用 JDK 动态代理吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BC%9A%E7%94%A8-CGLIB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">你会用 CGLIB 动态代理吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">25.🌟说说你对Spring事务的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">29.🌟说说Spring的事务传播机制？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E8%83%BD%E5%9C%A8%E6%96%B0%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%BC%A0%E6%92%AD%E5%90%97%EF%BC%9F"><span class="toc-text">事务能在新线程中传播吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protected-%E5%92%8C-private-%E6%96%B9%E6%B3%95%E5%8A%A0%E4%BA%8B%E5%8A%A1%E4%BC%9A%E7%94%9F%E6%95%88%E5%90%97%EF%BC%9F"><span class="toc-text">protected 和 private 方法加事务会生效吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%F0%9F%8C%9FSpring-MVC-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">31.🌟Spring MVC 的工作流程了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81-HandlerAdapter%EF%BC%9F"><span class="toc-text">为什么还需要 HandlerAdapter？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%F0%9F%8C%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-SpringBoot%EF%BC%9F"><span class="toc-text">33.🌟介绍一下 SpringBoot？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Boot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Spring Boot常用注解有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%F0%9F%8C%9FSpring-Boot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">34.🌟Spring Boot的自动装配原理了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%F0%9F%8C%9F%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-SpringBoot-Starter"><span class="toc-text">35.🌟如何自定义一个 SpringBoot Starter?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Boot-Starter-%E7%9A%84%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">Spring Boot Starter 的原理了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%F0%9F%8C%9FSpring-Boot-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">36.🌟Spring Boot 启动原理了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E5%9C%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%BB%E8%BE%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">要在启动阶段自定义逻辑该怎么做？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Spring-Boot-%E5%9C%A8%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%83%BD%E5%A4%9F%E6%89%BE%E5%88%B0-main-%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84-SpringBootApplication-%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-text">为什么 Spring Boot 在启动的时候能够找到 main 方法上的@SpringBootApplication 注解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Boot-%E9%BB%98%E8%AE%A4%E7%9A%84%E5%8C%85%E6%89%AB%E6%8F%8F%E8%B7%AF%E5%BE%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Spring Boot 默认的包扫描路径是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F18-%E8%AF%B4%E8%AF%B4-HTTP-%E4%B8%8E-HTTPS-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">🌟18.说说 HTTP 与 HTTPS 有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F25-TCP-%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F%E4%B8%8D%E8%83%BD%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-text">🌟25.TCP 握手为什么是三次，为什么不能是两次？不能是四次？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E6%8F%A1%E6%89%8B%E4%B8%8D%E8%83%BD%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F"><span class="toc-text">为什么 TCP 握手不能是两次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-text">为什么不是四次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">什么是泛洪攻击？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-text">如果让你重新设计，怎么设计？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F30-%E8%AF%B4%E8%AF%B4-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">🌟30.说说 TCP 四次挥手的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F31-TCP-%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E5%91%A2%EF%BC%9F"><span class="toc-text">🌟31.TCP 挥手为什么需要四次呢？</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function (response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function (data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function (error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.30.0" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script defer src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const slideUp = {
      distance: `16px`,
      duration: `800`,
      interval: `100`,
      scale: `1`,
      opacity: 0,
      easing: "ease-out"
    };
    ScrollReveal().reveal('.l_left .slide-up', slideUp);
    ScrollReveal().reveal('.l_main .slide-up', slideUp);
    ScrollReveal().reveal('.l_right .slide-up', slideUp);
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script><script src="/js/check-in.js"></script></div></body></html>
