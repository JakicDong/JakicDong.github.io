
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0" theme-name="Stellar" theme-version="1.30.0">
  
  <meta name="generator" content="Hexo 7.0.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>JVM学习笔记-窥内存洞天观玄机,调GC轮回掌生死 - Jakic's Blog</title>

  
    <meta name="description" content="类加载器为接引童子，垃圾回收是判官笔——施主可要修习这「虚拟机造化经」？">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记-窥内存洞天观玄机,调GC轮回掌生死">
<meta property="og:url" content="https://jakicdong.github.io/2025/10/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Jakic&#39;s Blog">
<meta property="og:description" content="类加载器为接引童子，垃圾回收是判官笔——施主可要修习这「虚拟机造化经」？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010142854.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010144035.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010144138.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010144803.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150406.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150604.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150844.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150900.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151152.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151210.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151832.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151924.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010152555.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010152927.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010152935.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010153321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010153455.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010153713.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010154018.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010154052.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010154125.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010154253.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/jvm-20250111112843.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010155515.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010155845.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010160224.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010160439.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010160504.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010160817.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010160909.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010161037.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010161525.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010161558.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010161658.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010161923.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162035.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162108.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162712.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162802.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162812.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162907.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010163747.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010163811.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010163927.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164013.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164344.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164502.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164524.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164651.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164706.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164834.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164854.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164919.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164933.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010165007.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010165039.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010165059.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010165118.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010165610.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095331.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095524.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095558.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095647.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011101355.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102656.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102820.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102844.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102906.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103059.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103201.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103352.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103544.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104114.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104247.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104304.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104352.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104424.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105011.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105137.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105431.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105556.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105859.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110129.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110227.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110342.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110418.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110439.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110455.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110603.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110714.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110725.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110806.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110923.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111056.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111442.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111643.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111737.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111848.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011112052.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011112408.png">
<meta property="article:published_time" content="2025-10-09T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-23T02:50:50.806Z">
<meta property="article:author" content="JakicDong">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010142854.png">
  
  
  
  <meta name="keywords" content="基础,Java">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.30.0">


  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/logo.png">
  

  

  
<!-- hexo injector head_end start --><script src="./func.js"></script><!-- hexo injector head_end end --></head>
<link rel="stylesheet" href="/css/check-in.css"><body><div class="sitebg"><div class="siteblur"></div></div>

<div class="l_body content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://avatars.githubusercontent.com/u/130200522?v=4" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Jakic's Blog</div><div class="sub normal cap">学习生活记录</div><div class="sub hover cap" style="opacity:0"> 踏上取经路,比抵达灵山更重要</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客首页" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="打卡墙" href="/check-in" style="color:#1976D2"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="github" target="_blank" rel="noopener" href="https://github.com/JakicDong/" style="color:#1BCDFC"><svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle"> <path fill="#cccccc" d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path> </svg></a><a class="nav-item" title="力扣" target="_blank" rel="noopener" href="https://leetcode.cn/u/dong7/" style="color:#3DC550"><svg width="59" height="22" viewBox="0 0 59 22" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-full w-auto max-w-none"> <path fill-rule="evenodd" clip-rule="evenodd" d="M27.8226 17.4752C28.3202 16.1443 28.7218 14.5458 28.9859 12.6607C29.1277 11.6491 29.2845 10.1658 29.4568 8.20813H35.2561C35.2637 8.20813 35.2713 8.20828 35.2789 8.20857C35.6071 8.22119 35.8628 8.49743 35.8502 8.82558L35.4996 17.9427C35.4873 18.262 35.2249 18.5144 34.9054 18.5144H33.2974C32.8595 18.5144 32.5046 18.8694 32.5046 19.3072C32.5046 19.7451 32.8595 20.1 33.2974 20.1H35.4776C36.3533 20.1 37.0631 19.3901 37.0631 18.5144L37.4595 8.20813C37.4595 7.33244 36.7497 6.62254 35.874 6.62254H29.5913C29.671 5.65054 29.7537 4.58575 29.8394 3.42794C29.8718 2.99129 29.544 2.61109 29.1074 2.57874C28.6707 2.54639 28.2905 2.87414 28.2582 3.3108C28.1689 4.51669 28.0829 5.62069 28.0004 6.62254H25.3695C24.9316 6.62254 24.5767 6.97749 24.5767 7.41534C24.5767 7.85318 24.9316 8.20813 25.3695 8.20813H27.8651C27.7 10.07 27.5501 11.4816 27.4157 12.4407C27.1674 14.2124 26.7941 15.6986 26.3374 16.9199C26.0981 17.5599 25.8527 18.0822 25.6163 18.4944C25.5366 18.6333 25.4649 18.7474 25.4029 18.8378C25.3703 18.8853 25.3512 18.9109 25.3475 18.9155C25.0722 19.256 25.1252 19.7552 25.4657 20.0305C25.8062 20.3057 26.3054 20.2528 26.5806 19.9123C26.6737 19.7971 26.8159 19.5898 26.9917 19.2833C27.271 18.7963 27.5531 18.1959 27.8226 17.4752ZM48.5586 17.3184V7.72969H55.6831C56.3474 7.72969 56.883 8.26047 56.883 8.9117V16.4576C56.883 17.1088 56.3474 17.6396 55.6831 17.6396H53.3916C52.7274 17.6396 52.1918 17.1088 52.1918 16.4576V10.1081C52.1918 9.67022 51.8369 9.31528 51.399 9.31528C50.9612 9.31528 50.6062 9.67022 50.6062 10.1081V16.4576C50.6062 17.9877 51.8548 19.2252 53.3916 19.2252H55.6831C57.2199 19.2252 58.4686 17.9877 58.4686 16.4576V8.9117C58.4686 7.38157 57.2199 6.14411 55.6831 6.14411H48.5586V3.76573C48.5586 3.32788 48.2037 2.97294 47.7658 2.97294C47.328 2.97294 46.9731 3.32788 46.9731 3.76573V6.14411H44.1983C43.7604 6.14411 43.4055 6.49905 43.4055 6.9369C43.4055 7.37475 43.7604 7.72969 44.1983 7.72969H46.9731V12.465L44.3002 13.5341C43.8937 13.6968 43.696 14.1581 43.8586 14.5647C44.0212 14.9712 44.4826 15.1689 44.8891 15.0063L46.9731 14.1727V17.3184C46.9731 18.3666 46.0906 19.2252 44.9911 19.2252C44.5532 19.2252 44.1983 19.5801 44.1983 20.018C44.1983 20.4558 44.5532 20.8108 44.9911 20.8108C46.9567 20.8108 48.5586 19.2522 48.5586 17.3184Z" fill="white"></path> <path d="M13.3797 16.4636C13.874 15.9701 14.674 15.9714 15.1667 16.4665C15.6593 16.9616 15.6581 17.7631 15.1638 18.2566L12.9691 20.4481C10.9443 22.4699 7.64261 22.4992 5.58369 20.5162C5.57179 20.5048 4.655 19.6058 1.63058 16.6402C-0.381491 14.6673 -0.581941 11.5104 1.31147 9.4831L4.84172 5.7031C6.7209 3.69085 10.1849 3.47093 12.3335 5.20847L15.5398 7.80152C16.0828 8.24065 16.1676 9.03757 15.7292 9.58151C15.2909 10.1254 14.4953 10.2104 13.9523 9.77127L10.746 7.17824C9.62238 6.26954 7.65677 6.39434 6.68718 7.43259L3.15688 11.2126C2.23512 12.1996 2.33607 13.7895 3.39833 14.8311C5.61922 17.0088 7.33084 18.6871 7.33282 18.689C8.40324 19.72 10.134 19.7046 11.185 18.6551L13.3797 16.4636Z" fill="#FFA116"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M8.04824 14.2706C7.35039 14.2706 6.78467 13.7039 6.78467 13.0048C6.78467 12.3057 7.35039 11.739 8.04824 11.739H17.3671C18.0649 11.739 18.6306 12.3057 18.6306 13.0048C18.6306 13.7039 18.0649 14.2706 17.3671 14.2706H8.04824Z" fill="#B3B3B3"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M9.79343 0.401024C10.2702 -0.109469 11.0698 -0.136141 11.5794 0.34145C12.089 0.819042 12.1156 1.62004 11.6389 2.13054L3.15692 11.2126C2.23513 12.1995 2.33608 13.7894 3.39827 14.831L7.31536 18.6721C7.81405 19.1611 7.82258 19.9625 7.33442 20.4621C6.84626 20.9616 6.04626 20.9702 5.54757 20.4812L1.63046 16.6401C-0.381492 14.6671 -0.581942 11.5102 1.31155 9.48305L9.79343 0.401024Z" fill="white"></path> </svg></a><a class="nav-item" title="知识星球" target="_blank" rel="noopener" href="https://wx.zsxq.com/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="语雀" target="_blank" rel="noopener" href="https://www.yuque.com/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="sidebar-check-in">
    <div id="sidebar-check-in-calendar"></div>
</div>
<div class="widgets">
<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">专栏：学习博客</span></div><div class="widget-body"><a class="item" href="/2025/10/23/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">场景设计学习笔记-闯架构天宫演诸法,降需求心魔定禅心</span></a><a class="item" href="/2025/10/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%AC%AC%E4%BA%8C%E7%89%88)/"><span class="title">Spring学习笔记(第二版)-炼金丹炉铸Bean山 布注解阵控轮回盘</span></a><a class="item" href="/2025/10/18/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/MYDB%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">MYDB项目笔记</span></a><a class="item" href="/2025/10/17/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RAG%E7%9F%A5%E8%AF%86%E5%BA%93%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">RAG知识库项目笔记</span></a><a class="item" href="/2025/10/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">SQL刷题笔记-执SQL咒扫乾坤表,祭联合影擒数据妖</span></a><a class="item active" href="/2025/10/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记-窥内存洞天观玄机,调GC轮回掌生死</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">操作系统学习笔记-掌轮回内核定纲常,渡进程内存化阴阳</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">设计模式学习笔记-布天罡阵降需求妖,演变化术破代码劫</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">微服务学习笔记-化整为零散作星,聚沙成塔架云台</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">分布式学习笔记-架天网布分布式,炼金丹渡一致劫</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">RocketMQ学习笔记-架消息桥通三界路 施持久咒定乾坤轮</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">MyBatis学习笔记-架映射桥通人神境 写SQL咒调数据兵</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Linux学习笔记-踏终端登灵霄殿,执符咒驭众生器</span></a><a class="item" href="/2025/09/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%AE%80%E5%8E%86%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="title">简历对应知识点</span></a><a class="item" href="/2025/09/09/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Elasticsearch(ES)%E4%B8%8B%E8%BD%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><span class="title">Elasticsearch(ES)下载使用指南</span></a><a class="item" href="/2025/08/30/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/git%E7%A7%98%E9%92%A5%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86/"><span class="title">Redis学习笔记</span></a><a class="item" href="/2025/08/08/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java并发编程学习笔记-布天罗网锁线程妖,设八卦阵伏竞态魔</span></a><a class="item" href="/2025/08/06/3DGS/SSH%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"><span class="title">SSH远程调用开发环境</span></a><a class="item" href="/2025/08/05/3DGS/Ubuntu20%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%ACCUDA/"><span class="title">Ubuntu20使用多个版本CUDA</span></a><a class="item" href="/2025/08/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Thymeleaf%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"><span class="title">Thymeleaf模版引擎</span></a><a class="item" href="/2025/08/01/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架学习笔记-开乾坤袋纳百川 布玲珑局定山河</span></a><a class="item" href="/2025/07/30/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Natapp/"><span class="title">Natapp内网穿透使用</span></a><a class="item" href="/2025/07/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"><span class="title">微信扫码登录</span></a><a class="item" href="/2025/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%81%B5%E8%8C%B6%E5%B1%B1%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">灵茶山算法基础笔记</span></a><a class="item" href="/2025/07/25/Go%E5%9F%BA%E7%A1%80/Go%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">Go基础笔记</span></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄</span></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JavaSE学习笔记-筑基篇开修行路,炼气层破语法障</span></a><a class="item" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/"><span class="title">程序员养生指南-调阴阳戒久坐劫 通经脉战代码妖</span></a><a class="item" href="/2025/07/14/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">计算机网络学习笔记-布协议栈通三界,架路由桥渡万维</span></a><a class="item" href="/2025/07/12/3DGS/%E4%BD%BF%E7%94%A8Postshot%E8%AE%AD%E7%BB%833DGS%E6%B5%81%E7%A8%8B/"><span class="title">使用Postshot训练3DGS模型流程</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/%E8%B7%A8%E5%9F%9F%E6%94%AF%E6%8C%81%E7%AC%94%E8%AE%B0/"><span class="title">跨域支持笔记</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/MybatisPlus%E7%AC%94%E8%AE%B0/"><span class="title">MybatisPlus笔记</span></a><a class="item" href="/2025/06/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/TecHub%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">TecHub项目笔记</span></a><a class="item" href="/2025/06/24/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"><span class="title">技术派项目环境问题</span></a><a class="item" href="/2025/06/24/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"><span class="title">Unity游戏开发笔记</span></a><a class="item" href="/2025/06/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82B%E6%A0%91/"><span class="title">一次性搞懂B树</span></a><a class="item" href="/2025/06/12/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Spring学习笔记-开IOC瓶纳百川水 织AOP网覆三界尘</span></a><a class="item" href="/2025/06/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/nvm%E6%9B%B4%E6%94%B9node%E7%89%88%E6%9C%AC/"><span class="title">nvm更改node版本</span></a><a class="item" href="/2025/06/11/3DGS/3DGS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">3DGS学习笔记-撒神经点布星云阵 炼辐射场塑造化身</span></a><a class="item" href="/2025/06/11/3DGS/3DGS-Ubuntu%E7%8E%AF%E5%A2%83/"><span class="title">3DGS-Ubuntu环境.md</span></a><a class="item" href="/2025/06/10/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架笔记</span></a><a class="item" href="/2025/06/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Mysql学习笔记-布B+树阵锁苍龙 写SQL真言召天兵</span></a><a class="item" href="/2025/06/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记</span></a><a class="item" href="/2025/06/07/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%AF%87/"><span class="title">Java并发篇</span></a><a class="item" href="/2025/06/06/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E9%94%AE%E8%AE%B0%E5%BD%95/"><span class="title">常用组合键记录-结印诀腾挪三界,弹指间呼风唤雨</span></a><a class="item" href="/2025/06/06/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/java30%E5%A4%A9%E7%AC%94%E8%AE%B0/"><span class="title">java30天学习笔记</span></a><a class="item" href="/2025/06/05/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/hello-world/"><span class="title">Hello World</span></a><a class="item" href="/2025/06/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">技术派项目笔记</span></a><a class="item" href="/2025/06/02/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"><span class="title">个人博客搭建指南-架祥云自建菩提境,点慧灯独照博客天</span></a><a class="item" href="/2025/06/01/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RabbitMQ%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/"><span class="title">RabbitMQ项目使用</span></a><a class="item" href="/2025/06/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">数据结构算法学习笔记-布天罡阵伏算法妖 炼金石破数据结构</span></a></div></widget>

<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/10/24/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.24%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.24学习日记</span></a><a class="item title" href="/2025/10/23/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.23%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.23学习日记</span></a><a class="item title" href="/2025/10/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">SQL刷题笔记-执SQL咒扫乾坤表,祭联合影擒数据妖</span></a><a class="item title" href="/2025/07/14/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">计算机网络学习笔记-布协议栈通三界,架路由桥渡万维</span></a><a class="item title" href="/2025/06/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">数据结构算法学习笔记-布天罡阵伏算法妖 炼金石破数据结构</span></a><a class="item title" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄</span></a><a class="item title" href="/2025/10/23/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">场景设计学习笔记-闯架构天宫演诸法,降需求心魔定禅心</span></a><a class="item title" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/"><span class="title">程序员养生指南-调阴阳戒久坐劫 通经脉战代码妖</span></a><a class="item title" href="/2025/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%81%B5%E8%8C%B6%E5%B1%B1%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">灵茶山算法基础笔记</span></a><a class="item title" href="/2025/06/11/3DGS/3DGS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">3DGS学习笔记-撒神经点布星云阵 炼辐射场塑造化身</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/10/23/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习博客</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-10-09T16:00:00.000Z">2025-10-10</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-10-23T02:50:50.806Z">2025-10-23</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>JVM学习笔记-窥内存洞天观玄机,调GC轮回掌生死</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content slide-up"><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-什么是-JVM"><a href="#1-什么是-JVM" class="headerlink" title="1.什么是 JVM?"></a>1.什么是 JVM?</h3><p>JVM，也就是 Java 虚拟机，它是 Java 实现跨平台的基石。</p>
<p>程序运行之前，需要先通过编译器将 Java 源代码文件编译成 Java 字节码文件；</p>
<p>程序运行时，JVM 会对字节码文件进行逐行解释，翻译成机器码指令，并交给对应的操作系统去执行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010142854.png" alt="20251010142854"><br>三分恶面渣逆袭：Java语言编译运行</p>
<p>这样就实现了 Java 一次编译，处处运行的特性。</p>
<h4 id="说说-JVM-的其他特性？"><a href="#说说-JVM-的其他特性？" class="headerlink" title="说说 JVM 的其他特性？"></a>说说 JVM 的其他特性？</h4><p>①、JVM 可以自动管理内存，通过垃圾回收器回收不再使用的对象并释放内存空间。</p>
<p>②、JVM 包含一个即时编译器 JIT，它可以在运行时将热点代码缓存到 codeCache 中，下次执行的时候不用再一行一行的解释，而是直接执行缓存后的机器码，执行效率会大幅提高。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010144035.png" alt="20251010144035"><br>截图来自美团技术</p>
<p>③、任何可以通过 Java 编译的语言，比如说 Groovy、Kotlin、Scala 等，都可以在 JVM 上运行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010144138.png" alt="20251010144138"><br>三分恶面渣逆袭：JVM跨语言</p>
<h4 id="为什么要学习-JVM？"><a href="#为什么要学习-JVM？" class="headerlink" title="为什么要学习 JVM？"></a>为什么要学习 JVM？</h4><p>学习 JVM 可以帮助我们开发者更好地优化程序性能、避免内存问题。</p>
<p>比如说了解 JVM 的内存模型和垃圾回收机制，可以帮助我们更合理地配置内存、减少 GC 停顿。</p>
<p>比如说掌握 JVM 的类加载机制可以帮助我们排查类加载冲突或异常。</p>
<p>再比如说，JVM 还提供了很多调试和监控工具，可以帮助我们分析内存和线程的使用情况，从而解决内存溢出内存泄露等问题。</p>
<h3 id="2-说说-JVM-的组织架构（补充）"><a href="#2-说说-JVM-的组织架构（补充）" class="headerlink" title="2.说说 JVM 的组织架构（补充）"></a>2.说说 JVM 的组织架构（补充）</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/what-is-jvm.html">大白话带你认识 JVM</a></p>
<p>JVM 大致可以划分为三个部分：类加载器、运行时数据区和执行引擎。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010144803.png" alt="20251010144803"><br>截图来源于网络</p>
<p>① 类加载器，负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。</p>
<p>② 运行时数据区，JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域按照 Java 虚拟机规范可以划分为方法区、堆、虚拟机栈、程序计数器和本地方法栈。</p>
<p>③ 执行引擎，也是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器、即时编译器 JIT 和垃圾回收器。</p>
<h2 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h2><h3 id="3-🌟能说一下-JVM-的内存区域吗？"><a href="#3-🌟能说一下-JVM-的内存区域吗？" class="headerlink" title="3.🌟能说一下 JVM 的内存区域吗？"></a>3.🌟能说一下 JVM 的内存区域吗？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/neicun-jiegou.html">深入理解 JVM 的运行时数据区</a></p>
<p>按照 Java 虚拟机规范，JVM 的内存区域可以细分为<code>程序计数器</code>、<code>虚拟机栈</code>、<code>本地方法栈</code>、<code>堆</code>和<code>方法区</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150406.png" alt="20251010150406"><br>三分恶面渣逆袭：Java虚拟机运行时数据区</p>
<p>其中<code>方法区</code>和<code>堆</code>是线程共享的，<code>虚拟机栈</code>、<code>本地方法栈</code>和<code>程序计数器</code>是线程私有的。</p>
<h4 id="介绍一下程序计数器？"><a href="#介绍一下程序计数器？" class="headerlink" title="介绍一下程序计数器？"></a>介绍一下程序计数器？</h4><p>程序计数器也被称为 PC 寄存器，是一块较小的内存空间。它可以看作是当前线程所执行的字节码行号指示器。</p>
<h4 id="介绍一下-Java-虚拟机栈？"><a href="#介绍一下-Java-虚拟机栈？" class="headerlink" title="介绍一下 Java 虚拟机栈？"></a>介绍一下 Java 虚拟机栈？</h4><p>Java 虚拟机栈的生命周期与线程相同。</p>
<p>当线程执行一个方法时，会创建一个对应的<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/stack-frame.html">栈帧</a>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，然后栈帧会被压入虚拟机栈中。当方法执行完毕后，栈帧会从虚拟机栈中移除。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150604.png" alt="20251010150604"><br>三分恶面渣逆袭：Java虚拟机栈</p>
<h4 id="一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？"><a href="#一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？" class="headerlink" title="一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？"></a>一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？</h4><p>对于<a target="_blank" rel="noopener" href="https://javabetter.cn/oo/static.html">静态方法</a>，由于不需要访问实例对象 this，因此在局部变量表中不会有任何变量。</p>
<p>对于非静态方法，即使是一个完全空的方法，局部变量表中也会有一个用于存储 this 引用的变量。this 引用指向当前实例对象，在方法调用时被隐式传入。</p>
<p>详细解释一下：</p>
<p>比如说有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">emptyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 什么都没有</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticEmptyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 什么都没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>javap -v VarDemo1</code> 命令查看编译后的字节码，就可以在 emptyMethod 中看到这样的内容：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150844.png" alt="20251010150844"><br>二哥的 Java 进阶之路：javap emptyMethod</p>
<p>这里的 <code>locals=1</code> 表示局部变量表有一个变量，即 this，Slot 0 位置存储了 this 引用。</p>
<p>而在静态方法 staticEmptyMethod 中，你会看到这样的内容：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010150900.png" alt="20251010150900"><br>二哥的 Java 进阶之路：javap staticEmptyMethod</p>
<p>这里的 locals&#x3D;0 表示局部变量表为空，因为静态方法属于类级别方法，不需要 this 引用，也就没有局部变量。</p>
<h4 id="介绍一下本地方法栈？"><a href="#介绍一下本地方法栈？" class="headerlink" title="介绍一下本地方法栈？"></a>介绍一下本地方法栈？</h4><p>本地方法栈与虚拟机栈相似，区别在于虚拟机栈是为 JVM 执行 Java 编写的方法服务的，而本地方法栈是为 Java 调用<a target="_blank" rel="noopener" href="https://javabetter.cn/oo/native-method.html">本地 native 方法</a>服务的，通常由 C&#x2F;C++ 编写。</p>
<p>在本地方法栈中，主要存放了 native 方法的局部变量、动态链接和方法出口等信息。当一个 Java 程序调用一个 native 方法时，JVM 会切换到本地方法栈来执行这个方法。</p>
<h4 id="介绍一下本地方法栈的运行场景？"><a href="#介绍一下本地方法栈的运行场景？" class="headerlink" title="介绍一下本地方法栈的运行场景？"></a>介绍一下本地方法栈的运行场景？</h4><p>当 Java 应用需要与操作系统底层或硬件交互时，通常会用到本地方法栈。</p>
<p>比如调用操作系统的特定功能，如内存管理、文件操作、系统时间、系统调用等。</p>
<p>详细说明一下：</p>
<p>比如说获取系统时间的 <code>System.currentTimeMillis()</code> 方法就是调用本地方法，来获取操作系统当前时间的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151152.png" alt="20251010151152"><br>二哥的Java 进阶之路：currentTimeMillis方法源码</p>
<p>再比如 JVM 自身的一些底层功能也需要通过本地方法来实现。像 Object 类中的 <code>hashCode()</code> 方法、<code>clone()</code> 方法等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151210.png" alt="20251010151210"><br>二哥的Java 进阶之路：hashCode方法源码</p>
<h4 id="native-方法解释一下？"><a href="#native-方法解释一下？" class="headerlink" title="native 方法解释一下？"></a>native 方法解释一下？</h4><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/oo/native-method.html">手把手教你用 C语言实现 Java native 本地方法</a></p>
<p>native 方法是在 Java 中通过 <a target="_blank" rel="noopener" href="https://javabetter.cn/basic-extra-meal/48-keywords.html">native 关键字</a>声明的，用于调用非 Java 语言，如 C&#x2F;C++ 编写的代码。Java 可以通过 JNI，也就是 Java Native Interface 与底层系统、硬件设备、或者本地库进行交互。</p>
<h4 id="介绍一下-Java-堆？"><a href="#介绍一下-Java-堆？" class="headerlink" title="介绍一下 Java 堆？"></a>介绍一下 Java 堆？</h4><p>堆是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储 new 出来的对象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151832.png" alt="20251010151832"><br>二哥的 Java 进阶之路：堆</p>
<p>Java 中“几乎”所有的对象都会在堆中分配，堆也是<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/gc-collector.html">垃圾收集器</a>管理的目标区域。</p>
<p>从内存回收的角度来看，由于垃圾收集器大部分都是基于分代收集理论设计的，所以堆又被细分为<code>新生代</code>、<code>老年代</code>、<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010151924.png" alt="20251010151924"><br>三分恶面渣逆袭：Java 堆内存结构</p>
<p>随着 <a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/jit.html">JIT 编译器</a>的发展和逃逸技术的逐渐成熟，“所有的对象都会分配到堆上”就不再那么绝对了。</p>
<p>从 JDK 7 开始，JVM 默认开启了逃逸分析，意味着如果某些方法中的对象引用没有被返回或者没有在方法体外使用，也就是未逃逸出去，那么对象可以直接在栈上分配内存。</p>
<h4 id="堆和栈的区别是什么？"><a href="#堆和栈的区别是什么？" class="headerlink" title="堆和栈的区别是什么？"></a>堆和栈的区别是什么？</h4><p>堆属于线程共享的内存区域，几乎所有 new 出来的对象都会堆上分配，生命周期不由单个方法调用所决定，可以在方法调用结束后继续存在，直到不再被任何变量引用，最后被垃圾收集器回收。</p>
<p>栈属于线程私有的内存区域，主要存储局部变量、方法参数、对象引用等，通常随着方法调用的结束而自动释放，不需要垃圾收集器处理。</p>
<h4 id="介绍一下方法区？"><a href="#介绍一下方法区？" class="headerlink" title="介绍一下方法区？"></a>介绍一下方法区？</h4><p>方法区并不真实存在，属于 Java 虚拟机规范中的一个逻辑概念，用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p>在 HotSpot 虚拟机中，方法区的实现称为永久代 PermGen，但在 Java 8 及之后的版本中，已经被元空间 Metaspace 所替代。</p>
<h4 id="变量存在堆栈的什么位置？"><a href="#变量存在堆栈的什么位置？" class="headerlink" title="变量存在堆栈的什么位置？"></a>变量存在堆栈的什么位置？</h4><p>对于局部变量，它存储在当前方法栈帧中的局部变量表中。当方法执行完毕，栈帧被回收，局部变量也会被释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">100</span>;  <span class="comment">// 局部变量，存储在栈帧中的局部变量表里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于静态变量来说，它存储在 Java 虚拟机规范中的方法区中，在 Java 7 中是永久代，在 Java8 及以后 是元空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticVarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">100</span>;  <span class="comment">// 静态变量，存储在方法区中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-说一下-JDK-1-6、1-7、1-8-内存区域的变化？"><a href="#4-说一下-JDK-1-6、1-7、1-8-内存区域的变化？" class="headerlink" title="4.说一下 JDK 1.6、1.7、1.8 内存区域的变化？"></a>4.说一下 JDK 1.6、1.7、1.8 内存区域的变化？</h3><p>JDK 1.6 使用永久代来实现方法区：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010152555.png" alt="20251010152555"><br>三分恶面渣逆袭：JDK 1.6内存区域</p>
<p>JDK 1.7 时仍然是永久代，但发生了一些细微变化，比如将字符串常量池、静态变量存放到了堆上。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010152927.png" alt="20251010152927"><br>三分恶面渣逆袭：JDK 1.7内存区域</p>
<p>在 JDK 1.8 时，直接在内存中划出了一块区域，叫<strong>元空间</strong>，来取代之前放在 JVM 内存中的永久代，并将运行时常量池、类常量池都移动到了元空间。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010152935.png" alt="20251010152935"><br>三分恶面渣逆袭：JDK 1.8内存区域</p>
<h3 id="5-为什么使用元空间替代永久代？"><a href="#5-为什么使用元空间替代永久代？" class="headerlink" title="5.为什么使用元空间替代永久代？"></a>5.为什么使用元空间替代永久代？</h3><p>客观上，永久代会导致 Java 应用程序更容易出现内存溢出的问题，因为它要受到 JVM 内存大小的限制。</p>
<p>HotSpot 虚拟机的永久代大小可以通过 <code>-XX：MaxPermSize</code> 参数来设置，32 位机器默认的大小为 64M，64 位的机器则为 85M。</p>
<p>而 J9 和 JRockit 虚拟机就不存在这种限制，只要没有触碰到进程可用的内存上限，例如 32 位系统中的 4GB 限制，就不会出问题。</p>
<p>主观上，当 Oracle 收购 BEA 获得了 JRockit 的所有权后，就准备把 JRockit 中的优秀功能移植到 HotSpot 中。</p>
<p>如 Java Mission Control 管理工具。</p>
<p>但因为两个虚拟机对方法区实现有差异，导致这项工作遇到了很多阻力。</p>
<p>考虑到 HotSpot 虚拟机未来的发展，JDK 6 的时候，开发团队就打算放弃永久代了。</p>
<p>JDK 7 的时候，前进了一小步，把原本放在永久代的字符串常量池、静态变量等移动到了堆中。</p>
<p>JDK 8 就终于完成了这项移出工作，这样的好处就是，元空间的大小不再受到 JVM 内存的限制，而是可以像 J9 和 JRockit 那样，只要系统内存足够，就可以一直用。</p>
<h3 id="6-🌟对象创建的过程了解吗？"><a href="#6-🌟对象创建的过程了解吗？" class="headerlink" title="6.🌟对象创建的过程了解吗？"></a>6.🌟对象创建的过程了解吗？</h3><p>当我们使用 new 关键字创建一个对象时，JVM 首先会检查 new 指令的参数是否能在常量池中定位到类的符号引用，然后检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，就先执行类加载。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010153321.png" alt="20251010153321"><br>二哥的 Java 进阶之路：对象的创建过程</p>
<p>如果已经加载，JVM 会为对象分配内存完成初始化，比如数值类型的成员变量初始值是 0，布尔类型是 false，对象类型是 null。</p>
<p>接下来会设置对象头，里面包含了对象是哪个类的实例、对象的哈希码、对象的 GC 分代年龄等信息。</p>
<p>最后，JVM 会执行构造方法 <code>&lt;init&gt;</code> 完成赋值操作，将成员变量赋值为预期的值，比如 <code>int age = 18</code>，这样一个对象就创建完成了。</p>
<h4 id="对象的销毁过程了解吗？"><a href="#对象的销毁过程了解吗？" class="headerlink" title="对象的销毁过程了解吗？"></a>对象的销毁过程了解吗？</h4><p>当对象不再被任何引用指向时，就会变成垃圾。垃圾收集器会通过可达性分析算法判断对象是否存活，如果对象不可达，就会被回收。</p>
<p>垃圾收集器通过标记清除、标记复制、标记整理等算法来回收内存，将对象占用的内存空间释放出来。</p>
<p>可以通过 <code>java -XX:+PrintCommandLineFlags -version</code> 和 <code>java -XX:+PrintGCDetails -version</code> 命令查看 JVM 的 GC 收集器。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010153455.png" alt="20251010153455"><br>二哥的 Java 进阶之路：JVM 使用的垃圾收集器</p>
<p>可以看到，我本机安装的 JDK 8 默认使用的是 <code>Parallel Scavenge + Parallel Old</code>。</p>
<p>不同参数代表对应的垃圾收集器表单：</p>
<table>
<thead>
<tr>
<th>新生代</th>
<th>老年代</th>
<th>JVM参数</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>Serial</td>
<td>-XX:+UseSerialGC</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>Serial</td>
<td>-XX:+UseParallelGC -XX:-UseParallelOldGC</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>Parallel Old</td>
<td>-XX:+UseParallelGC -XX:+UseParallelOldGC</td>
</tr>
<tr>
<td>Parallel New</td>
<td>CMS</td>
<td>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</td>
</tr>
<tr>
<td>G1</td>
<td></td>
<td>-XX:+UseG1GC</td>
</tr>
</tbody></table>
<h3 id="7-堆内存是如何分配的？"><a href="#7-堆内存是如何分配的？" class="headerlink" title="7.堆内存是如何分配的？"></a>7.堆内存是如何分配的？</h3><p>在堆中为对象分配内存时，主要使用两种策略：指针碰撞和空闲列表。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010153713.png" alt="20251010153713"><br>三分恶面渣逆袭：指针碰撞和空闲列表</p>
<p>指针碰撞适用于管理简单、碎片化较少的内存区域，如年轻代；而空闲列表适用于内存碎片化较严重或对象大小差异较大的场景如老年代。</p>
<h4 id="什么是指针碰撞？"><a href="#什么是指针碰撞？" class="headerlink" title="什么是指针碰撞？"></a>什么是指针碰撞？</h4><p>假设堆内存是一个连续的空间，分为两个部分，一部分是已经被使用的内存，另一部分是未被使用的内存。</p>
<p>在分配内存时，Java 虚拟机会维护一个指针，指向下一个可用的内存地址，每次分配内存时，只需要将指针向后移动一段距离，如果没有发生碰撞，就将这段内存分配给对象实例。</p>
<h4 id="什么是空闲列表？"><a href="#什么是空闲列表？" class="headerlink" title="什么是空闲列表？"></a>什么是空闲列表？</h4><p>JVM 维护一个列表，记录堆中所有未占用的内存块，每个内存块都记录有大小和地址信息。</p>
<p>当有新的对象请求内存时，JVM 会遍历空闲列表，寻找足够大的空间来存放新对象。</p>
<p>分配后，如果选中的内存块未被完全利用，剩余的部分会作为一个新的内存块加入到空闲列表中。</p>
<h3 id="8-new-对象时，堆会发生抢占吗？"><a href="#8-new-对象时，堆会发生抢占吗？" class="headerlink" title="8.new 对象时，堆会发生抢占吗？"></a>8.new 对象时，堆会发生抢占吗？</h3><p>会。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010154018.png" alt="20251010154018"><br>Baeldung：堆抢占</p>
<p>new 对象时，指针会向右移动一个对象大小的距离，假如一个线程 A 正在给字符串对象 s 分配内存，另外一个线程 B 同时为 ArrayList 对象 l 分配内存，两个线程就发生了抢占。</p>
<h4 id="JVM-怎么解决堆内存分配的竞争问题？"><a href="#JVM-怎么解决堆内存分配的竞争问题？" class="headerlink" title="JVM 怎么解决堆内存分配的竞争问题？"></a>JVM 怎么解决堆内存分配的竞争问题？</h4><p>为了解决堆内存分配的竞争问题，JVM 为每个线程保留了一小块内存空间，被称为 TLAB，也就是线程本地分配缓冲区，用于存放该线程分配的对象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010154052.png" alt="20251010154052"><br>Baeldung：TLAB</p>
<p>当线程需要分配对象时，直接从 TLAB 中分配。只有当 TLAB 用尽或对象太大需要直接在堆中分配时，才会使用全局分配指针。</p>
<p>这里简单测试一下 TLAB。</p>
<p>可以通过 <code>java -XX:+PrintFlagsFinal -version | grep TLAB</code> 命令查看当前 JVM 是否开启了 TLAB。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010154125.png" alt="20251010154125"><br>二哥的 Java 进阶之路：查看 TLAB</p>
<p>如果开启了 TLAB，会看到类似以下的输出，其中 bool UseTLAB 的值为 true。</p>
<p>我们编写一个简单的测试类，创建大量对象并强制触发垃圾回收，查看 TLAB 的使用情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TLABDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10_000_000</span>; i++) &#123;</span><br><span class="line">            allocate(); <span class="comment">// 创建大量对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.gc(); <span class="comment">// 强制触发垃圾回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">allocate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小对象分配，通常会使用 TLAB</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">64</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 VM 参数中添加 <code>-XX:+UseTLAB -XX:+PrintTLAB -XX:+PrintGCDetails -XX:+PrintGCDateStamps</code>，运行后可以看到这样的内容：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010154253.png" alt="20251010154253"><br>二哥的 Java 进阶之路：测试 TLAB</p>
<ul>
<li>waste：未使用的 TLAB 空间。</li>
<li>alloc：分配到 TLAB 的空间。</li>
<li>refills：TLAB 被重新填充的次数。</li>
</ul>
<p>可以看到，当前线程的 TLAB 目标大小为 10,496 KB（<code>desired_size: 10496KB</code>）；未发生慢分配（<code>slow allocs: 0</code>）；分配效率直接拉满（<code>alloc: 1.00000 52494KB</code>）。</p>
<p>当使用 <code>-XX:-UseTLAB -XX:+PrintGCDetails</code> 关闭 TLAB 时，会看到类似以下的输出：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/jvm-20250111112843.png" alt="二哥的 Java 进阶之路：关闭 TLAB"></p>
<p>二哥的 Java 进阶之路：关闭 TLAB</p>
<p>直接出现了两次 GC，因为没有 TLAB，Eden 区更快被填满，导致年轻代 GC。年轻代 GC 频繁触发，一部分长生命周期对象被晋升到老年代，间接导致老年代 GC 触发。</p>
<h3 id="9-能说一下对象的内存布局吗？"><a href="#9-能说一下对象的内存布局吗？" class="headerlink" title="9.能说一下对象的内存布局吗？"></a>9.能说一下对象的内存布局吗？</h3><p>好的。</p>
<p>对象的内存布局是由 Java 虚拟机规范定义的，但具体的实现细节各有不同，如 HotSpot 和 OpenJ9 就不一样。</p>
<p>就拿我们常用的 HotSpot 来说吧。</p>
<p>对象在内存中包括三部分：对象头、实例数据和对齐填充。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010155515.png" alt="20251010155515"><br>三分恶面渣逆袭：对象的存储布局</p>
<h4 id="说说对象头的作用？"><a href="#说说对象头的作用？" class="headerlink" title="说说对象头的作用？"></a>说说对象头的作用？</h4><p>对象头是对象存储在内存中的元信息，包含了Mark Word、类型指针等信息。</p>
<p>Mark Word 存储了对象的运行时状态信息，包括锁、哈希值、GC 标记等。在 64 位操作系统下占 8 个字节，32 位操作系统下占 4 个字节。</p>
<p>类型指针指向对象所属类的元数据，也就是 Class 对象，用来支持多态、方法调用等功能。</p>
<p>除此之外，如果对象是数组类型，还会有一个额外的数组长度字段。占 4 个字节。</p>
<h4 id="类型指针会被压缩吗？"><a href="#类型指针会被压缩吗？" class="headerlink" title="类型指针会被压缩吗？"></a>类型指针会被压缩吗？</h4><p>类型指针可能会被压缩，以节省内存空间。比如说在开启压缩指针的情况下占 4 个字节，否则占 8 个字节。在 JDK 8 中，压缩指针默认是开启的。</p>
<p>可以通过 <code>java -XX:+PrintFlagsFinal -version | grep UseCompressedOops</code> 命令来查看 JVM 是否开启了压缩指针。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010155845.png" alt="20251010155845"><br>二哥的 Java 进阶之路：查看 JVM 是否开启压缩指针</p>
<p>如果压缩指针开启，输出结果中的 bool UseCompressedOops 值为 true。</p>
<h4 id="实例数据了解吗？"><a href="#实例数据了解吗？" class="headerlink" title="实例数据了解吗？"></a>实例数据了解吗？</h4><p>了解一些。</p>
<p>实例数据是对象实际的字段值，也就是成员变量的值，按照字段在类中声明的顺序存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectDemo</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 会对这些数据进行对齐&#x2F;重排，以提高内存访问速度。</p>
<h4 id="对齐填充了解吗？"><a href="#对齐填充了解吗？" class="headerlink" title="对齐填充了解吗？"></a>对齐填充了解吗？</h4><p>由于 JVM 的内存模型要求对象的起始地址是 8 字节对齐（64 位 JVM 中），因此对象的总大小必须是 8 字节的倍数。</p>
<p>如果对象头和实例数据的总长度不是 8 的倍数，JVM 会通过填充额外的字节来对齐。</p>
<p>比如说，如果对象头 + 实例数据 &#x3D; 14 字节，则需要填充 2 个字节，使总长度变为 16 字节。</p>
<h4 id="为什么非要进行-8-字节对齐呢？"><a href="#为什么非要进行-8-字节对齐呢？" class="headerlink" title="为什么非要进行 8 字节对齐呢？"></a>为什么非要进行 8 字节对齐呢？</h4><p>因为 CPU 进行内存访问时，一次寻址的指针大小是 8 字节，正好是 L1 缓存行的大小。如果不进行内存对齐，则可能出现跨缓存行访问，导致额外的缓存行加载，CPU 的访问效率就会降低。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010160224.png" alt="20251010160224"><br>rickiyang：缓存行污染</p>
<p>比如说上图中 obj1 占 6 个字节，由于没有对齐，导致这一行缓存中多了 2 个字节 obj2 的数据，当 CPU 访问 obj2 的时候，就会导致缓存行刷新。</p>
<p>也就说，8 字节对齐，是为了效率的提高，以空间换时间的一种方案。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010160439.png" alt="20251010160439"><br>rickiyang：000 结尾</p>
<h4 id="new-Object-对象的内存大小是多少？"><a href="#new-Object-对象的内存大小是多少？" class="headerlink" title="new Object() 对象的内存大小是多少？"></a>new Object() 对象的内存大小是多少？</h4><p>推荐阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rickiyang/p/14206724.html">高端面试必备：一个 Java 对象占用多大内存</a></p>
<p>一般来说，目前的操作系统都是 64 位的，并且 JDK 8 中的压缩指针是默认开启的，因此在 64 位的 JVM 上，<code>new Object()</code>的大小是 16 字节（12 字节的对象头 + 4 字节的对齐填充）。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010160504.png" alt="20251010160504"><br>rickiyang：Java 对象模型</p>
<p>对象头的大小是固定的，在 32 位 JVM 上是 8 字节，在 64 位 JVM 上是 16 字节；如果开启了压缩指针，就是 12 字节。</p>
<p>实例数据的大小取决于对象的成员变量和它们的类型。对于<code>new Object()</code>来说，由于默认没有成员变量，因此我们可以认为此时的实例数据大小是 0。</p>
<p>假如 MyObject 对象有三个成员变量，分别是 int、long 和 byte 类型，那么它们占用的内存大小分别是 4 字节、8 字节和 1 字节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;        <span class="comment">// 4 字节</span></span><br><span class="line">    <span class="type">long</span> b;       <span class="comment">// 8 字节</span></span><br><span class="line">    <span class="type">byte</span> c;       <span class="comment">// 1 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到对齐填充，MyObject 对象的总大小为 12（对象头） + 4（a） + 8（b） + 1（c） + 7（填充） &#x3D; 32 字节。</p>
<h4 id="用过-JOL-查看对象的内存布局吗？"><a href="#用过-JOL-查看对象的内存布局吗？" class="headerlink" title="用过 JOL 查看对象的内存布局吗？"></a>用过 JOL 查看对象的内存布局吗？</h4><p>用过。</p>
<p><a target="_blank" rel="noopener" href="https://openjdk.org/projects/code-tools/jol/">JOL</a> 是一款分析 JVM 对象布局的工具。</p>
<p>第一步，在 pom.xml 中引入 JOL 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步，使用 JOL 编写代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLSample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印JVM详细信息（可选）</span></span><br><span class="line">        System.out.println(VM.current().details());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Object实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印Object实例的内存布局</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">layout</span> <span class="operator">=</span> ClassLayout.parseInstance(obj).toPrintable();</span><br><span class="line">        System.out.println(layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，运行代码，查看输出结果：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010160817.png" alt="20251010160817"><br>二哥的 Java 进阶之路：JOL 运行结果</p>
<p>可以看到有 OFFSET、SIZE、TYPE DESCRIPTION、VALUE 这几个信息。</p>
<ul>
<li>OFFSET：偏移地址，单位字节；</li>
<li>SIZE：占用的内存大小，单位字节；</li>
<li>TYPE DESCRIPTION：类型描述，其中 object header 为对象头；</li>
<li>VALUE：对应内存中当前存储的值，二进制 32 位；</li>
</ul>
<p>从上面的结果能看到，对象头是 12 个字节，还有 4 个字节的 padding，<code>new Object()</code> 一共 16 个字节。</p>
<h4 id="对象的引用大小了解吗？"><a href="#对象的引用大小了解吗？" class="headerlink" title="对象的引用大小了解吗？"></a>对象的引用大小了解吗？</h4><p>推荐阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dijia478/p/14677243.html">Object o &#x3D; new Object()占多少个字节？</a></p>
<p>在 64 位 JVM 上，未开启压缩指针时，对象引用占用 8 字节；开启压缩指针时，对象引用会被压缩到 4 字节。HotSpot 虚拟机默认是开启压缩指针的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010160909.png" alt="20251010160909"><br>dijia478：对象头</p>
<p>我们来验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReferenceSizeExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReferenceHolder</span> &#123;</span><br><span class="line">        Object reference;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(VM.current().details());</span><br><span class="line">        System.out.println(ClassLayout.parseClass(ReferenceHolder.class).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，查看输出结果：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010161037.png" alt="20251010161037"><br>二哥的 Java 进阶之路：对象的引用有多大？</p>
<p>ReferenceHolder.reference 的大小为 4 字节。</p>
<h3 id="10-JVM-怎么访问对象的？"><a href="#10-JVM-怎么访问对象的？" class="headerlink" title="10.JVM 怎么访问对象的？"></a>10.JVM 怎么访问对象的？</h3><p>主流的方式有两种：句柄和直接指针。</p>
<p>两种方式的区别在于，句柄是通过一个中间的句柄表来定位对象的，而直接指针则是通过引用直接指向对象的内存地址。</p>
<p>优点是，对象被移动时只需要修改句柄表中的指针，而不需要修改对象引用本身。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010161525.png" alt="20251010161525"><br>三分恶面渣逆袭：通过句柄访问对象</p>
<p>在直接指针访问中，引用直接存储对象的内存地址；对象的实例数据和类型信息都存储在堆中固定的内存区域。</p>
<p>优点是访问速度更快，因为少了一次句柄的寻址操作。缺点是如果对象在内存中移动，引用需要更新为新的地址。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010161558.png" alt="20251010161558"><br>三分恶面渣逆袭：通过直接指针访问对象</p>
<p>HotSpot 虚拟机主要使用直接指针来进行对象访问。</p>
<h3 id="11-说一下对象有哪几种引用？"><a href="#11-说一下对象有哪几种引用？" class="headerlink" title="11.说一下对象有哪几种引用？"></a>11.说一下对象有哪几种引用？</h3><p>四种，分别是强引用、软引用、弱引用和虚引用。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010161658.png" alt="20251010161658"><br>三分恶面渣逆袭：四种引用总结</p>
<p>强引用是 Java 中最常见的引用类型。使用 new 关键字赋值的引用就是强引用，只要强引用关联着对象，垃圾收集器就不会回收这部分对象，即使内存不足。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// str 就是一个强引用</span><br><span class="line">String str = new String(&quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>

<p>软引用于描述一些非必须对象，通过 SoftReference 类实现。软引用的对象在内存不足时会被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// softRef 就是一个软引用</span><br><span class="line">SoftReference&lt;String&gt; softRef = new SoftReference&lt;&gt;(new String(&quot;沉默王二&quot;));</span><br></pre></td></tr></table></figure>

<p>弱引用用于描述一些短生命周期的非必须对象，如 ThreadLocal 中的 Entry，就是通过 WeakReference 类实现的。弱引用的对象会在下一次垃圾回收时会被回收，不论内存是否充足。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点类</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">//key赋值</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        <span class="comment">//value赋值</span></span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚引用主要用来跟踪对象被垃圾回收的过程，通过 PhantomReference 类实现。虚引用的对象在任何时候都可能被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// phantomRef 就是一个虚引用</span></span><br><span class="line">PhantomReference&lt;String&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;沉默王二&quot;</span>), <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>

<h3 id="12-Java-堆的内存分区了解吗？"><a href="#12-Java-堆的内存分区了解吗？" class="headerlink" title="12.Java 堆的内存分区了解吗？"></a>12.Java 堆的内存分区了解吗？</h3><p>了解。Java 堆被划分为<strong>新生代</strong>和<strong>老年代</strong>两个区域。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010161923.png" alt="20251010161923"><br>三分恶面渣逆袭：Java堆内存划分</p>
<p>新生代又被划分为 Eden 空间和两个 Survivor 空间（From 和 To）。</p>
<p>新创建的对象会被分配到 Eden 空间。当 Eden 区填满时，会触发一次 Minor GC，清除不再使用的对象。存活下来的对象会从 Eden 区移动到 Survivor 区。</p>
<p>对象在新生代中经历多次 GC 后，如果仍然存活，会被移动到老年代。当老年代内存不足时，会触发 Major GC，对整个堆进行垃圾回收。</p>
<h3 id="13-说一下新生代的区域划分？"><a href="#13-说一下新生代的区域划分？" class="headerlink" title="13.说一下新生代的区域划分？"></a>13.说一下新生代的区域划分？</h3><p>新生代的垃圾收集主要采用标记-复制算法，因为新生代的存活对象比较少，每次复制少量的存活对象效率比较高。</p>
<p>基于这种算法，虚拟机将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。默认 Eden 和 Survivor 的大小比例是 8∶1。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162035.png" alt="20251010162035"><br>三分恶面渣逆袭：新生代内存划分</p>
<h3 id="14-🌟对象什么时候会进入老年代？"><a href="#14-🌟对象什么时候会进入老年代？" class="headerlink" title="14.🌟对象什么时候会进入老年代？"></a>14.🌟对象什么时候会进入老年代？</h3><p>对象通常会在年轻代中分配，随着时间的推移和垃圾收集的进程，某些满足条件的对象会进入到老年代中，如长期存活的对象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162108.png" alt="20251010162108"><br>二哥的 Java 进阶之路：对象进入老年代</p>
<h4 id="长期存活的对象如何判断？"><a href="#长期存活的对象如何判断？" class="headerlink" title="长期存活的对象如何判断？"></a>长期存活的对象如何判断？</h4><p>JVM 会为对象维护一个“年龄”计数器，记录对象在新生代中经历 Minor GC 的次数。每次 GC 未被回收的对象，其年龄会加 1。</p>
<p>当超过一个特定阈值，默认值是 15，就会被认为老对象了，需要重点关照。这个年龄阈值可以通过 JVM 参数<code>-XX:MaxTenuringThreshold</code>来设置。</p>
<p>可以通过 <code>jinfo -flag MaxTenuringThreshold $(jps | grep -i nacos | awk &#39;&#123;print $1&#125;&#39;)</code> 来查看当前 JVM 的年龄阈值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162712.png" alt="20251010162712"><br>二哥的 Java 进阶之路：年龄阈值</p>
<ol>
<li>如果应用中的对象存活时间较短，可以适当调大这个值，让对象在新生代多待一会儿</li>
<li>如果对象存活时间较长，可以适当调小这个值，让对象更快进入老年代，减少在新生代的复制次数</li>
</ol>
<h4 id="大对象如何判断？"><a href="#大对象如何判断？" class="headerlink" title="大对象如何判断？"></a>大对象如何判断？</h4><p>大对象是指占用内存较大的对象，如大数组、长字符串等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1000000</span>]);</span><br></pre></td></tr></table></figure>

<p>其大小由 JVM 参数 <code>-XX:PretenureSizeThreshold</code> 控制，但在 JDK 8 中，默认值为 0，也就是说默认情况下，对象仅根据 GC 存活的次数来判断是否进入老年代。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162802.png" alt="20251010162802"><br>二哥的 Java 进阶之路：PretenureSizeThreshold</p>
<p>G1 垃圾收集器中，大对象会直接分配到 HUMONGOUS 区域。当对象大小超过一个 Region 容量的 50% 时，会被认为是大对象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162812.png" alt="20251010162812"><br>有梦想的肥宅：G1</p>
<p>Region 的大小可以通过 JVM 参数 <code>-XX:G1HeapRegionSize</code> 来设置，默认情况下从 1MB 到 32MB 不等，会根据堆内存大小动态调整。</p>
<p>可以通过 <code>java -XX:+UseG1GC -XX:+PrintGCDetails -version</code> 查看 G1 垃圾收集器的相关信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010162907.png" alt="20251010162907"><br>二哥的 Java 进阶之路：UseG1GC</p>
<p>从结果上来看，我本机上 G1 的堆大小为 2GB，Region 的大小为 4MB。</p>
<h4 id="动态年龄判定了解吗？"><a href="#动态年龄判定了解吗？" class="headerlink" title="动态年龄判定了解吗？"></a>动态年龄判定了解吗？</h4><p>如果 Survivor 区中所有对象的总大小超过了一定比例，通常是 Survivor 区的一半，那么年龄较小的对象也可能会被提前晋升到老年代。</p>
<p>这是因为如果年龄较小的对象在 Survivor 区中占用了较大的空间，会导致 Survivor 区中的对象复制次数增多，影响垃圾回收的效率。</p>
<h3 id="15-STW-了解吗？"><a href="#15-STW-了解吗？" class="headerlink" title="15.STW 了解吗？"></a>15.STW 了解吗？</h3><p>了解。</p>
<p>JVM 进行垃圾回收的过程中，会涉及到对象的移动，为了保证对象引用在移动过程中不被修改，必须暂停所有的用户线程，像这样的停顿，我们称之为<code>Stop The World</code>。简称 STW。</p>
<h4 id="如何暂停线程呢？"><a href="#如何暂停线程呢？" class="headerlink" title="如何暂停线程呢？"></a>如何暂停线程呢？</h4><p>JVM 会使用一个名为安全点（Safe Point）的机制来确保线程能够被安全地暂停，其过程包括四个步骤：</p>
<ul>
<li>JVM 发出暂停信号；</li>
<li>线程执行到安全点后，挂起自身并等待垃圾收集完成；</li>
<li>垃圾回收器完成 GC 操作；</li>
<li>线程恢复执行。</li>
</ul>
<h4 id="什么是安全点？"><a href="#什么是安全点？" class="headerlink" title="什么是安全点？"></a>什么是安全点？</h4><p>安全点是 JVM 的一种机制，常用于垃圾回收的 STW 操作，用于让线程在执行到某些特定位置时，可以被安全地暂停。</p>
<p>通常位于方法调用、循环跳转、异常处理等位置，以保证线程暂停时数据的一致性。</p>
<p>用个通俗的比喻，老王去拉车，车上的东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡时休息，只能在平地上停下来擦擦汗，喝口水。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010163747.png" alt="20251010163747"><br>三分恶面渣逆袭：老王拉车只能在平路休息</p>
<p>推荐大家看看这个<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=JkbWPPNc4SI">HotSpot JVM Deep Dive - Safepoint</a>，对 safe point 有一个比较深入地解释。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010163811.png" alt="20251010163811"></p>
<h3 id="16-对象一定分配在堆中吗？"><a href="#16-对象一定分配在堆中吗？" class="headerlink" title="16.对象一定分配在堆中吗？"></a>16.对象一定分配在堆中吗？</h3><p>不一定。</p>
<p>默认情况下，Java 对象是在堆中分配的，但 JVM 会进行逃逸分析，来判断对象的生命周期是否只在方法内部，如果是的话，这个对象可以在栈上分配。</p>
<p>举例来说，下面的代码中，对象 <code>new Person()</code> 的生命周期只在 <code>testStackAllocation</code> 方法内部，因此 JVM 会将这个对象分配在栈上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStackAllocation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">// 对象可能分配在栈上</span></span><br><span class="line">    p.name = <span class="string">&quot;沉默王二是只狗&quot;</span>;</span><br><span class="line">    p.age = <span class="number">18</span>;</span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么是逃逸分析？"><a href="#什么是逃逸分析？" class="headerlink" title="什么是逃逸分析？"></a>什么是逃逸分析？</h4><p>逃逸分析是一种 JVM 优化技术，用来分析对象的作用域和生命周期，判断对象是否逃逸出方法或线程。</p>
<p>可以通过分析对象的引用流向，判断对象是否被方法返回、赋值到全局变量、传递到其他线程等，来确定对象是否逃逸。</p>
<p>如果对象没有逃逸，就可以进行栈上分配、同步消除、标量替换等优化，以提高程序的性能。</p>
<p>可以通过 <code>java -XX:+PrintFlagsFinal -version | grep DoEscapeAnalysis</code> 来确认 JVM 是否开启了逃逸分析。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010163927.png" alt="20251010163927"><br>二哥的 Java 进阶之路：JVM 开启了逃逸分析</p>
<h4 id="逃逸具体是指什么？"><a href="#逃逸具体是指什么？" class="headerlink" title="逃逸具体是指什么？"></a>逃逸具体是指什么？</h4><p>根据对象逃逸的范围，可以分为方法逃逸和线程逃逸。</p>
<p>当对象被方法外部的代码引用，生命周期超出了方法的范围，那么对象就必须分配在堆中，由垃圾收集器管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Person <span class="title function_">createPerson</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 对象逃逸出方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说 <code>new Person()</code> 创建的对象被返回，那么这个对象就逃逸出当前方法了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164013.png" alt="20251010164013"><br>三分恶面渣逆袭：方法逃逸</p>
<p>再比如说，对象被另外一个线程引用，生命周期超出了当前线程，那么对象就必须分配在堆中，并且线程之间需要同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadEscapeExample</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 对象逃逸到另一个线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象 <code>new Person()</code> 被另外一个线程引用了，发生了线程逃逸。</p>
<h4 id="逃逸分析会带来什么好处？"><a href="#逃逸分析会带来什么好处？" class="headerlink" title="逃逸分析会带来什么好处？"></a>逃逸分析会带来什么好处？</h4><p>主要有三个。</p>
<p>第一，如果确定一个对象不会逃逸，那么就可以考虑栈上分配，对象占用的内存随着栈帧出栈后销毁，这样一来，垃圾收集的压力就降低很多。</p>
<p>第二，线程同步需要加锁，加锁就要占用系统资源，如果逃逸分析能够确定一个对象不会逃逸出线程，那么这个对象就不用加锁，从而减少线程同步的开销。</p>
<p>第三，如果对象的字段在方法中独立使用，JVM 可以将对象分解为标量变量，避免对象分配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scalarReplacementExample</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(p.getX() + p.getY());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Point 对象未逃逸，JVM 可以优化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">System.out.println(x + y);</span><br></pre></td></tr></table></figure>

<h3 id="17-内存溢出和内存泄漏了解吗？"><a href="#17-内存溢出和内存泄漏了解吗？" class="headerlink" title="17.内存溢出和内存泄漏了解吗？"></a>17.内存溢出和内存泄漏了解吗？</h3><p>内存溢出，俗称 OOM，是指当程序请求分配内存时，由于没有足够的内存空间，从而抛出 OutOfMemoryError。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    list.add(<span class="string">&quot;OutOfMemory&quot;</span>.repeat(<span class="number">1000</span>)); <span class="comment">// 无限增加内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能是因为堆、元空间、栈或直接内存不足导致的。可以通过优化内存配置、减少对象分配来解决。</p>
<p>内存泄漏是指程序在使用完内存后，未能及时释放，导致占用的内存无法再被使用。随着时间的推移，内存泄漏会导致可用内存逐渐减少，最终导致内存溢出。</p>
<p>内存泄漏通常是因为长期存活的对象持有短期存活对象的引用，又没有及时释放，从而导致短期存活对象无法被回收而导致的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryLeakExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; staticList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObject</span><span class="params">()</span> &#123;</span><br><span class="line">        staticList.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 对象不会被回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一个比较有味道的比喻来形容就是，内存溢出是排队去蹲坑，发现没坑了；内存泄漏，就是有人占着茅坑不拉屎，导致坑位不够用。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164344.png" alt="20251010164344"><br>三分恶面渣逆袭：内存泄漏、内存溢出</p>
<h3 id="18-能手写内存溢出的例子吗？"><a href="#18-能手写内存溢出的例子吗？" class="headerlink" title="18.能手写内存溢出的例子吗？"></a>18.能手写内存溢出的例子吗？</h3><p>可以。</p>
<p>我就拿最常见的堆内存溢出来完成吧，堆内存溢出通常是因为创建了大量的对象，且长时间无法被垃圾收集器回收，导致的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapSpaceErrorGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一步，创建一个大的容器</span></span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; bigObjects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第二步，循环写入数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 第三步，创建一个大对象，一个大约 10M 的数组</span></span><br><span class="line">                <span class="type">byte</span>[] bigObject = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">                <span class="comment">// 第四步，将大对象添加到容器中</span></span><br><span class="line">                bigObjects.add(bigObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;OutOfMemoryError 发生在 &quot;</span> + bigObjects.size() + <span class="string">&quot; 对象后&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很快就会发生内存溢出。</p>
<p>这就相当于一个房子里，不断堆积不能被回收的杂物，那么房子很快就会被堆满了。</p>
<p>也可以通过 VM 参数设置堆内存大小为 <code>-Xmx128M</code>，然后运行程序，出现的内存溢出的时间会更快。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164502.png" alt="20251010164502"><br>二哥的 Java 进阶之路：添加 -Xmx128M VM 参数</p>
<p>可以看到，堆内存溢出发生在 11 个对象后。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164524.png" alt="20251010164524"><br>二哥的 Java 进阶之路：堆内存溢出</p>
<h3 id="19-内存泄漏可能由哪些原因导致呢？"><a href="#19-内存泄漏可能由哪些原因导致呢？" class="headerlink" title="19.内存泄漏可能由哪些原因导致呢？"></a>19.内存泄漏可能由哪些原因导致呢？</h3><p>比如说：</p>
<p>①、静态的集合中添加的对象越来越多，但却没有及时清理；静态变量的生命周期与应用程序相同，如果静态变量持有对象的引用，这些对象将无法被 GC 回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OOM</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTests</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   list.add(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②、单例模式下对象持有的外部引用无法及时释放；单例对象在整个应用程序的生命周期中存活，如果单例对象持有其他对象的引用，这些对象将无法被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③、数据库、IO、Socket 等连接资源没有及时关闭；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//不关闭连接</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>④、 ThreadLocal 的引用未被清理，线程退出后仍然持有对象引用；在线程执行完后，要调用 ThreadLocal 的 remove 方法进行清理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">threadLocal.set(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 未清理</span></span><br></pre></td></tr></table></figure>

<h3 id="20-有没有处理过内存泄漏问题？"><a href="#20-有没有处理过内存泄漏问题？" class="headerlink" title="20.有没有处理过内存泄漏问题？"></a>20.有没有处理过内存泄漏问题？</h3><p>推荐阅读：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/oom.html">一次内存溢出的排查优化实战</a></li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/console-tools.html#jstack-%E8%B7%9F%E8%B8%AAjava%E5%A0%86%E6%A0%88">JVM 性能监控工具之命令行篇</a></li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/view-tools.html">JVM 性能监控工具之可视化篇</a></li>
</ol>
<p>有。</p>
<p>当时在做<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派</a>项目的时候，由于 ThreadLocal 没有及时清理导致出现了内存泄漏问题。</p>
<p>我用可视化的监控工具 VisualVM，配合 JDK 自带的 jstack 等命令行工具进行了排查。</p>
<p>大致的过程我回想了一下，主要有 7 个步骤：</p>
<p>第一步，使用 <code>jps -l</code> 查看运行的 Java 进程 ID。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164651.png" alt="20251010164651"><br>二哥的 Java 进阶之路：jps 查看技术派的进程 ID</p>
<p>第二步，使用<code>top -p [pid]</code> 查看进程使用 CPU 和内存占用情况。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164706.png" alt="20251010164706"><br>二哥的 Java 进阶之路：top -p</p>
<p>第三步，使用 <code>top -Hp [pid]</code> 查看进程下的所有线程占用 CPU 和内存情况。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164834.png" alt="20251010164834"><br>二哥的 Java 进阶之路：top -Hp</p>
<p>第四步，抓取线程栈：<code>jstack -F 29452 &gt; 29452.txt</code>，可以多抓几次做个对比。</p>
<blockquote>
<p>29452 为 pid，顺带作为文件名。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164854.png" alt="20251010164854"><br>二哥的 Java 进阶之路：jstack</p>
<p>看看有没有线程死锁、死循环或长时间等待这些问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164919.png" alt="20251010164919"><br>二哥的 Java 进阶之路：另外一组线程 id 的堆栈</p>
<p>第五步，可以使用<code>jstat -gcutil [pid] 5000 10</code> 每隔 5 秒输出 GC 信息，输出 10 次，查看 <strong>YGC</strong> 和 <strong>Full GC</strong> 次数。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010164933.png" alt="20251010164933"><br>二哥的 Java 进阶之路：jstat</p>
<p>通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。</p>
<p>或使用 <code>jstat -gccause [pid] 5000</code> 输出 GC 摘要信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010165007.png" alt="20251010165007"><br>二哥的 Java 进阶之路：jstat</p>
<p>或使用 <code>jmap -heap [pid]</code> 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010165039.png" alt="20251010165039"><br>二哥的 Java 进阶之路：jmap</p>
<p>如果发现 <code>Full GC</code> 次数太多，就很大概率存在内存泄漏了。</p>
<p>第六步，生成 <code>dump</code> 文件，然后借助可视化工具分析哪个对象非常多，基本就能定位到问题根源了。</p>
<p>执行命令 <code>jmap -dump:format=b,file=heap.hprof 10025</code> 会输出进程 10025 的堆快照信息，保存到文件 heap.hprof 中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010165059.png" alt="20251010165059"><br>二哥的 Java 进阶之路：jmap</p>
<p>第七步，使用图形化工具分析，如 JDK 自带的 <strong>VisualVM</strong>，从菜单 &gt; 文件 &gt; 装入 dump 文件。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010165118.png" alt="20251010165118"><br>VisualVM</p>
<p>然后在结果观察内存占用最多的对象，找到内存泄漏的源头。</p>
<h3 id="21-有没有处理过内存溢出问题？"><a href="#21-有没有处理过内存溢出问题？" class="headerlink" title="21.有没有处理过内存溢出问题？"></a>21.有没有处理过内存溢出问题？</h3><p>有。</p>
<p>当时在做<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派</a>的时候，由于上传的文件过大，没有正确处理，导致一下子撑爆了内存，程序直接崩溃了。</p>
<p>我记得是通过导出堆转储文件进行分析发现的。</p>
<p>第一步，使用 jmap 命令手动生成 Heap Dump 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>然后使用 MAT、JProfiler 等工具进行分析，查看内存中的对象占用情况。</p>
<p>一般来说：</p>
<p>如果生产环境的内存还有很多空余，可以适当增大堆内存大小来解决，例如 <code>-Xmx4g</code> 参数。</p>
<p>或者检查代码中是否存在内存泄漏，如未关闭的资源、长生命周期的对象等。</p>
<p>之后，在本地进行压力测试，模拟高负载情况下的内存表现，确保修改有效，且没有引入新的问题。</p>
<h3 id="22-什么情况下会发生栈溢出？（补充）"><a href="#22-什么情况下会发生栈溢出？（补充）" class="headerlink" title="22.什么情况下会发生栈溢出？（补充）"></a>22.什么情况下会发生栈溢出？（补充）</h3><p>栈溢出发生在程序调用栈的深度超过 JVM 允许的最大深度时。</p>
<p>栈溢出的本质是因为线程的栈空间不足，导致无法再为新的栈帧分配内存。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251010165610.png" alt="20251010165610"><br>二哥的Java进阶之路：栈帧</p>
<p>当一个方法被调用时，JVM 会在栈中分配一个栈帧，用于存储该方法的执行信息。如果方法调用嵌套太深，栈帧不断压入栈中，最终会导致栈空间耗尽，抛出 StackOverflowError。</p>
<p>最常见的栈溢出场景就是递归调用，尤其是没有正确的终止条件下，会导致递归无限进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOverflowExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 没有终止条件的递归调用</span></span><br><span class="line">        recursiveMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        recursiveMethod();  <span class="comment">// 导致栈溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，如果方法中定义了特别大的局部变量，栈帧会变得很大，导致栈空间更容易耗尽。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargeLocalVariables</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] largeArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000000</span>];  <span class="comment">// 大量局部变量</span></span><br><span class="line">        method();  <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method();  <span class="comment">// 导致栈溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、垃圾收集"><a href="#三、垃圾收集" class="headerlink" title="三、垃圾收集"></a>三、垃圾收集</h2><h3 id="23-🌟讲讲-JVM-的垃圾回收机制（补充）"><a href="#23-🌟讲讲-JVM-的垃圾回收机制（补充）" class="headerlink" title="23.🌟讲讲 JVM 的垃圾回收机制（补充）"></a>23.🌟讲讲 JVM 的垃圾回收机制（补充）</h3><blockquote>
<p>本题是增补的内容 参照：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/gc.html">深入理解 JVM 的垃圾回收机制</a></p>
</blockquote>
<p>垃圾回收就是对内存堆中已经死亡的或者长时间没有使用的对象进行清除或回收。</p>
<p>JVM 在做 GC 之前，会先搞清楚什么是垃圾，什么不是垃圾，通常会通过可达性分析算法来判断对象是否存活。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095331.png" alt="20251011095331"><br>二哥的 Java 进阶之路：可达性分析</p>
<p>在确定了哪些垃圾可以被回收后，垃圾收集器（如 CMS、G1、ZGC）要做的事情就是进行垃圾回收，可以采用标记清除算法、复制算法、标记整理算法、分代收集算法等。</p>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派</a>项目使用的 JDK 8，采用的是 CMS 垃圾收集器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseConcMarkSweepGC \</span><br><span class="line">     -XX:+UseParNewGC \</span><br><span class="line">     -XX:CMSInitiatingOccupancyFraction=<span class="number">75</span> \</span><br><span class="line">     -XX:+UseCMSInitiatingOccupancyOnly \</span><br><span class="line">     -jar your-application.jar</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收的过程是什么？"><a href="#垃圾回收的过程是什么？" class="headerlink" title="垃圾回收的过程是什么？"></a>垃圾回收的过程是什么？</h4><p>Java 的垃圾回收过程主要分为标记存活对象、清除无用对象、以及内存压缩&#x2F;整理三个阶段。不同的垃圾回收器在执行这些步骤时会采用不同的策略和算法。</p>
<h3 id="24-🌟如何判断对象仍然存活？"><a href="#24-🌟如何判断对象仍然存活？" class="headerlink" title="24.🌟如何判断对象仍然存活？"></a>24.🌟如何判断对象仍然存活？</h3><p>Java 通过可达性分析算法来判断一个对象是否还存活。</p>
<p>通过一组名为 “GC Roots” 的根对象，进行递归扫描，无法从根对象到达的对象就是“垃圾”，可以被回收。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095524.png" alt="20251011095524"><br>三分恶面渣逆袭：GC Root</p>
<p>这也是 G1、CMS 等主流垃圾收集器使用的主要算法。</p>
<h4 id="什么是引用计数法？"><a href="#什么是引用计数法？" class="headerlink" title="什么是引用计数法？"></a>什么是引用计数法？</h4><p>每个对象有一个引用计数器，记录引用它的次数。当计数器为零时，对象可以被回收。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095558.png" alt="20251011095558"><br>三分恶面渣逆袭：引用计数法</p>
<p>引用计数法无法解决循环引用的问题。例如，两个对象互相引用，但不再被其他对象引用，它们的引用计数都不为零，因此不会被回收。</p>
<h4 id="做可达性分析的时候，应该有哪些前置性的操作？"><a href="#做可达性分析的时候，应该有哪些前置性的操作？" class="headerlink" title="做可达性分析的时候，应该有哪些前置性的操作？"></a>做可达性分析的时候，应该有哪些前置性的操作？</h4><p>在进行垃圾回收之前，JVM 会暂停所有正在执行的应用线程。</p>
<p>这是因为可达性分析过程必须确保在执行分析时，内存中的对象关系不会被应用线程修改。如果不暂停应用线程，可能会出现对象引用的改变，导致垃圾回收过程中判断对象是否可达的结果不一致，从而引发严重的内存错误或数据丢失。</p>
<h3 id="25-Java-中可作为-GC-Roots-的引用有哪几种？"><a href="#25-Java-中可作为-GC-Roots-的引用有哪几种？" class="headerlink" title="25.Java 中可作为 GC Roots 的引用有哪几种？"></a>25.Java 中可作为 GC Roots 的引用有哪几种？</h3><ol>
<li>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/gc.html">深入理解垃圾回收机制</a></li>
<li>推荐阅读：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53613423/answer/135743258">R 大的所谓“GC roots”</a></li>
</ol>
<p>所谓的 GC Roots，就是一组必须活跃的引用，它们是程序运行时的起点，是一切引用链的源头。在 Java 中，GC Roots 包括以下几种：</p>
<ul>
<li>虚拟机栈中的引用（方法的参数、局部变量等）</li>
<li>本地方法栈中 JNI 的引用</li>
<li>类静态变量</li>
<li>运行时常量池中的常量（String 或 Class 类型）</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011095647.png" alt="20251011095647"><br>二哥的 java 进阶之路：GC Roots</p>
<h4 id="说说虚拟机栈中的引用？"><a href="#说说虚拟机栈中的引用？" class="headerlink" title="说说虚拟机栈中的引用？"></a>说说虚拟机栈中的引用？</h4><p>来看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 这里的 localVar 是一个局部变量，存在于虚拟机栈中</span></span><br><span class="line">        System.out.println(localVar.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StackReference</span>().greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 greet 方法中，localVar 是一个局部变量，存在于虚拟机栈中，可以被认为是 GC Roots。</p>
<p>在 greet 方法执行期间，localVar 引用的对象是活跃的，因为它是从 GC Roots 可达的。</p>
<p>当 greet 方法执行完毕后，localVar 的作用域结束，localVar 引用的 Object 对象不再由任何 GC Roots 引用（假设没有其他引用指向这个对象），因此它将有资格作为垃圾被回收掉 😁。</p>
<h4 id="说说本地方法栈中-JNI-的引用？"><a href="#说说本地方法栈中-JNI-的引用？" class="headerlink" title="说说本地方法栈中 JNI 的引用？"></a>说说本地方法栈中 JNI 的引用？</h4><p>Java 通过 JNI 提供了一种机制，允许 Java 代码调用本地代码（通常是 C 或 C++ 编写的代码）。</p>
<p>当调用 Java 方法时，虚拟机会创建一个栈帧并压入虚拟机栈，而当它调用本地方法时，虚拟机会通过动态链接直接调用指定的本地方法。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011101355.png" alt="20251011101355"><br>pecuyu：动态链接</p>
<p>JNI 引用是在 Java 本地接口代码中创建的引用，这些引用可以指向 Java 堆中的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设的JNI方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设在C/C++中实现的本地方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     NativeExample</span></span><br><span class="line"><span class="comment"> * Method:    nativeMethod</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_NativeExample_nativeMethod</span><span class="params">(JNIEnv *env, jobject thisObj)</span> &#123;</span><br><span class="line">    <span class="type">jobject</span> <span class="variable">localRef</span> <span class="operator">=</span> (*env)-&gt;NewObject(env, ...); <span class="comment">// 在本地方法栈中创建JNI引用</span></span><br><span class="line">    <span class="comment">// localRef 引用的Java对象在本地方法执行期间是活跃的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本地代码中，localRef 是对 Java 对象的一个 JNI 引用，它在本地方法执行期间保持 Java 对象活跃，可以被认为是 GC Roots。</p>
<p>一旦 JNI 方法执行完毕，除非这个引用是全局的，否则它指向的对象将会被作为垃圾回收掉（假设没有其他地方再引用这个对象）。</p>
<h4 id="说说类静态变量？"><a href="#说说类静态变量？" class="headerlink" title="说说类静态变量？"></a>说说类静态变量？</h4><p>来看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldReference</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 类静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(staticVar.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StaticFieldReference 类中的 staticVar 引用了一个 Object 对象，这个引用存储在元空间，可以被认为是 GC Roots。</p>
<p>只要 StaticFieldReference 类未被卸载，staticVar 引用的对象都不会被垃圾回收。如果 StaticFieldReference 类被卸载（这通常发生在其类加载器被垃圾回收时），那么 staticVar 引用的对象也将有资格被垃圾回收（如果没有其他引用指向这个对象）。</p>
<h4 id="说说运行时常量池中的常量？"><a href="#说说运行时常量池中的常量？" class="headerlink" title="说说运行时常量池中的常量？"></a>说说运行时常量池中的常量？</h4><p>来看这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstantPoolReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONSTANT_STRING</span> <span class="operator">=</span> <span class="string">&quot;Hello, World&quot;</span>; <span class="comment">// 常量，存在于运行时常量池中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt; CONSTANT_CLASS = Object.class; <span class="comment">// 类类型常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(CONSTANT_STRING);</span><br><span class="line">        System.out.println(CONSTANT_CLASS.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ConstantPoolReference 中，CONSTANT_STRING 和 CONSTANT_CLASS 作为常量存储在运行时常量池。它们可以用来作为 GC Roots。</p>
<p>这些常量引用的对象（字符串”Hello, World”和 Object.class 类对象）在常量池中，只要包含这些常量的 ConstantPoolReference 类未被卸载，这些对象就不会被垃圾回收。</p>
<h3 id="26-finalize-方法了解吗？"><a href="#26-finalize-方法了解吗？" class="headerlink" title="26.finalize()方法了解吗？"></a>26.finalize()方法了解吗？</h3><p>垃圾回收就是古代的秋后问斩，<code>finalize()</code> 就是刀下留人，在人犯被处决之前，还要做最后一次审计，青天大老爷会看看有没有什么冤情，需不需要刀下留人。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102656.png" alt="20251011102656"><br>三分恶面渣逆袭：刀下留人</p>
<p>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选。</p>
<p>筛选的条件是对象是否有必要执行 <code>finalize()</code>方法。</p>
<p>如果对象在 <code>finalize()</code> 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可。</p>
<p>譬如把自己 （this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。</p>
<h3 id="27-🌟垃圾收集算法了解吗？"><a href="#27-🌟垃圾收集算法了解吗？" class="headerlink" title="27.🌟垃圾收集算法了解吗？"></a>27.🌟垃圾收集算法了解吗？</h3><p>垃圾收集算法主要有三种，分别是标记-清除算法、标记-复制算法和标记-整理算法。</p>
<h4 id="说说标记-清除算法？"><a href="#说说标记-清除算法？" class="headerlink" title="说说标记-清除算法？"></a>说说标记-清除算法？</h4><p><code>标记-清除</code>算法分为两个阶段：</p>
<ul>
<li><strong>标记</strong>：标记所有需要回收的对象</li>
<li><strong>清除</strong>：回收所有被标记的对象</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102820.png" alt="20251011102820"><br>三分恶面渣逆袭：标记-清除算法</p>
<p>优点是实现简单，缺点是回收过程中会产生内存碎片。</p>
<h4 id="说说标记-复制算法？"><a href="#说说标记-复制算法？" class="headerlink" title="说说标记-复制算法？"></a>说说标记-复制算法？</h4><p><code>标记-复制</code>算法可以解决标记-清除算法的内存碎片问题，因为它将内存空间划分为两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后清理掉这一块。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102844.png" alt="20251011102844"><br>三分恶面渣逆袭：标记-复制算法</p>
<p>缺点是浪费了一半的内存空间。</p>
<h4 id="说说标记-整理算法？"><a href="#说说标记-整理算法？" class="headerlink" title="说说标记-整理算法？"></a>说说标记-整理算法？</h4><p><code>标记-整理</code>算法是标记-清除复制算法的升级版，它不再划分内存空间，而是将存活的对象向内存的一端移动，然后清理边界以外的内存。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011102906.png" alt="20251011102906"><br>标记-整理算法</p>
<p>缺点是移动对象的成本比较高。</p>
<h4 id="说说分代收集算法？"><a href="#说说分代收集算法？" class="headerlink" title="说说分代收集算法？"></a>说说分代收集算法？</h4><p><code>分代收集</code>算法是目前主流的垃圾收集算法，它根据对象存活周期的不同将内存划分为几块，一般分为新生代和老年代。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103059.png" alt="20251011103059"><br>二哥的 Java 进阶之路：Java 堆划分</p>
<p>新生代用复制算法，因为大部分对象生命周期短。老年代用标记-整理算法，因为对象存活率较高。</p>
<h4 id="为什么要用分代收集呢？"><a href="#为什么要用分代收集呢？" class="headerlink" title="为什么要用分代收集呢？"></a>为什么要用分代收集呢？</h4><p>分代收集算法的核心思想是根据对象的生命周期优化垃圾回收。</p>
<p>新生代的对象生命周期短，使用复制算法可以快速回收。老年代的对象生命周期长，使用标记-整理算法可以减少移动对象的成本。</p>
<h4 id="标记复制的标记过程和复制过程会不会停顿？"><a href="#标记复制的标记过程和复制过程会不会停顿？" class="headerlink" title="标记复制的标记过程和复制过程会不会停顿？"></a>标记复制的标记过程和复制过程会不会停顿？</h4><p>在标记-复制算法 中，标记阶段和复制阶段都会触发STW。</p>
<ul>
<li>标记阶段停顿是为了保证对象的引用关系不被修改。</li>
<li>复制阶段停顿是防止对象在复制过程中被修改。</li>
</ul>
<h3 id="28-Minor-GC、Major-GC、Mixed-GC、Full-GC-都是什么意思？"><a href="#28-Minor-GC、Major-GC、Mixed-GC、Full-GC-都是什么意思？" class="headerlink" title="28.Minor GC、Major GC、Mixed GC、Full GC 都是什么意思？"></a>28.Minor GC、Major GC、Mixed GC、Full GC 都是什么意思？</h3><p>Minor GC 也称为 Young GC，是指发生在年轻代的垃圾收集。年轻代包含 Eden 区以及两个 Survivor 区。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103201.png" alt="20251011103201"><br>二哥的 Java 进阶之路：Java 堆划分</p>
<p>Major GC 也称为 Old GC，主要指的是发生在老年代的垃圾收集。是 CMS 的特有行为。</p>
<p>Mixed GC 是 G1 垃圾收集器特有的一种 GC 类型，它在一次 GC 中同时清理年轻代和部分老年代。</p>
<p>Full GC 是最彻底的垃圾收集，涉及整个 Java 堆和方法区。它是最耗时的 GC，通常在 JVM 压力很大时发生。</p>
<h4 id="FULL-gc怎么去清理的？"><a href="#FULL-gc怎么去清理的？" class="headerlink" title="FULL gc怎么去清理的？"></a>FULL gc怎么去清理的？</h4><p>Full GC 会从 GC Root 出发，标记所有可达对象。新生代使用复制算法，清空 Eden 区。老年代使用标记-整理算法，回收对象并消除碎片。</p>
<p>停顿时间较长，会影响系统响应性能。</p>
<h3 id="29-Young-GC-什么时候触发？"><a href="#29-Young-GC-什么时候触发？" class="headerlink" title="29.Young GC 什么时候触发？"></a>29.Young GC 什么时候触发？</h3><p>如果 Eden 区没有足够的空间时，就会触发 Young GC 来清理新生代。</p>
<h3 id="30-什么时候会触发-Full-GC？"><a href="#30-什么时候会触发-Full-GC？" class="headerlink" title="30.什么时候会触发 Full GC？"></a>30.什么时候会触发 Full GC？</h3><p>在进行 Young GC 的时候，如果发现<code>老年代可用的连续内存空间</code> &lt; <code>新生代历次 Young GC 后升入老年代的对象总和的平均大小</code>，说明本次 Young GC 后升入老年代的对象大小，可能超过了老年代当前可用的内存空间，就会触发 Full GC。</p>
<p>执行 Young GC 后老年代没有足够的内存空间存放转入的对象，会立即触发一次 Full GC。</p>
<p><code>System.gc()</code>、<code>jmap -dump</code> 等命令会触发 full gc。</p>
<h4 id="空间分配担保是什么？"><a href="#空间分配担保是什么？" class="headerlink" title="空间分配担保是什么？"></a>空间分配担保是什么？</h4><p>空间分配担保是指在进行 Minor GC 前，JVM 会确保老年代有足够的空间存放从新生代晋升的对象。如果老年代空间不足，可能会触发 Full GC。</p>
<h3 id="31-🌟知道哪些垃圾收集器？"><a href="#31-🌟知道哪些垃圾收集器？" class="headerlink" title="31.🌟知道哪些垃圾收集器？"></a>31.🌟知道哪些垃圾收集器？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/gc-collector.html">深入理解 JVM 的垃圾收集器：CMS、G1、ZGC</a></p>
<p>JVM 的垃圾收集器主要分为两大类：分代收集器和分区收集器，分代收集器的代表是 CMS，分区收集器的代表是 G1 和 ZGC。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103352.png" alt="20251011103352"><br>三分恶面渣逆袭：HotSpot虚拟机垃圾收集器</p>
<p>CMS 是第一个关注 GC 停顿时间的垃圾收集器，JDK 1.5 时引入，JDK9 被标记弃用，JDK14 被移除。</p>
<p>G1 在 JDK 1.7 时引入，在 JDK 9 时取代 CMS 成为了默认的垃圾收集器。</p>
<p>ZGC 是 JDK11 推出的一款低延迟垃圾收集器，适用于大内存低延迟服务的内存管理和回收，在 128G 的大堆下，最大停顿时间才 1.68 ms，性能远胜于 G1 和 CMS。</p>
<h4 id="说说-Serial-收集器？"><a href="#说说-Serial-收集器？" class="headerlink" title="说说 Serial 收集器？"></a>说说 Serial 收集器？</h4><p>Serial 收集器是最基础、历史最悠久的收集器。</p>
<p>如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。</p>
<p>Serial&#x2F;Serial Old 收集器的运行过程如图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011103544.png" alt="20251011103544"><br>三分恶面渣逆袭：Serial&#x2F;Serial Old收集器运行示意图</p>
<h4 id="说说-ParNew-收集器？"><a href="#说说-ParNew-收集器？" class="headerlink" title="说说 ParNew 收集器？"></a>说说 ParNew 收集器？</h4><p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本，使用多条线程进行垃圾收集。</p>
<p>ParNew&#x2F;Serial Old 收集器运行示意图如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104114.png" alt="20251011104114"><br>三分恶面渣逆袭：ParNew&#x2F;Serial Old收集器运行示意图</p>
<h4 id="说说-Parallel-Scavenge-收集器？"><a href="#说说-Parallel-Scavenge-收集器？" class="headerlink" title="说说 Parallel Scavenge 收集器？"></a>说说 Parallel Scavenge 收集器？</h4><p>Parallel Scavenge 收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU 用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104156.png" alt="20251011104156"><br>三分恶面渣逆袭：吞吐量</p>
<p>根据对象存活周期的不同会将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<h4 id="说说-Serial-Old-收集器？"><a href="#说说-Serial-Old-收集器？" class="headerlink" title="说说 Serial Old 收集器？"></a>说说 Serial Old 收集器？</h4><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>
<h4 id="说说-Parallel-Old-收集器？"><a href="#说说-Parallel-Old-收集器？" class="headerlink" title="说说 Parallel Old 收集器？"></a>说说 Parallel Old 收集器？</h4><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，基于标记-整理算法实现，使用多条 GC 线程在 STW 期间同时进行垃圾回收。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104247.png" alt="20251011104247"><br>三分恶面渣逆袭：Parallel Old收集器</p>
<h4 id="说说-CMS-收集器？"><a href="#说说-CMS-收集器？" class="headerlink" title="说说 CMS 收集器？"></a>说说 CMS 收集器？</h4><p>CMS 在 JDK 1.5 时引入，JDK 9 时被标记弃用，JDK 14 时被移除。</p>
<p>CMS 是一种低延迟的垃圾收集器，采用标记-清除算法，分为初始标记、并发标记、重新标记和并发清除四个阶段，优点是垃圾回收线程和应用线程同时运行，停顿时间短，适合延迟敏感的应用，但容易产生内存碎片，可能触发 Full GC。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104304.png" alt="20251011104304"><br>小潘：CMS</p>
<h4 id="说说-G1-收集器？"><a href="#说说-G1-收集器？" class="headerlink" title="说说 G1 收集器？"></a>说说 G1 收集器？</h4><p>G1 在 JDK 1.7 时引入，在 JDK 9 时取代 CMS 成为默认的垃圾收集器。</p>
<p>G1 是一种面向大内存、高吞吐场景的垃圾收集器，它将堆划分为多个小的 Region，通过标记-整理算法，避免了内存碎片问题。优点是停顿时间可控，适合大堆场景，但调优较复杂。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104352.png" alt="20251011104352"><br>有梦想的肥宅：G1</p>
<h4 id="说说-ZGC-收集器？"><a href="#说说-ZGC-收集器？" class="headerlink" title="说说 ZGC 收集器？"></a>说说 ZGC 收集器？</h4><p>ZGC 是 JDK 11 时引入的一款低延迟的垃圾收集器，最大特点是将垃圾收集的停顿时间控制在 10ms 以内，即使在 TB 级别的堆内存下也能保持较低的停顿时间。</p>
<p>它通过并发标记和重定位来避免大部分 Stop-The-World 停顿，主要依赖指针染色来管理对象状态。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011104424.png" alt="20251011104424"><br>得物技术：指针染色</p>
<ul>
<li><strong>标记对象的可达性</strong>：通过在指针上增加标记位，不需要额外的标记位即可判断对象的存活状态。</li>
<li><strong>重定位状态</strong>：在对象被移动时，可以通过指针染色来更新对象的引用，而不需要等待全局同步。</li>
</ul>
<p>适用于需要超低延迟的场景，比如金融交易系统、电商平台。</p>
<h4 id="垃圾回收器的作用是什么？"><a href="#垃圾回收器的作用是什么？" class="headerlink" title="垃圾回收器的作用是什么？"></a>垃圾回收器的作用是什么？</h4><p>垃圾回收器的核心作用是自动管理 Java 应用程序的运行时内存。它负责识别哪些内存是不再被应用程序使用的，并释放这些内存以便重新使用。</p>
<p>这一过程减少了程序员手动管理内存的负担，降低了内存泄漏和溢出错误的风险。</p>
<h3 id="32-🌟能详细说一下-CMS-的垃圾收集过程吗？"><a href="#32-🌟能详细说一下-CMS-的垃圾收集过程吗？" class="headerlink" title="32.🌟能详细说一下 CMS 的垃圾收集过程吗？"></a>32.🌟能详细说一下 CMS 的垃圾收集过程吗？</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105011.png" alt="20251011105011"><br>三分恶面渣逆袭：Concurrent Mark Sweep收集器运行示意图</p>
<p>CMS 使用<strong>标记-清除</strong>算法进行垃圾收集，分 4 大步：</p>
<ul>
<li><strong>初始标记</strong>：标记所有从 GC Roots 直接可达的对象，这个阶段需要 STW，但速度很快。</li>
<li><strong>并发标记</strong>：从初始标记的对象出发，遍历所有对象，标记所有可达的对象。这个阶段是并发进行的。</li>
<li><strong>重新标记</strong>：完成剩余的标记工作，包括处理并发阶段遗留下来的少量变动，这个阶段通常需要短暂的 STW 停顿。</li>
<li><strong>并发清除</strong>：清除未被标记的对象，回收它们占用的内存空间。</li>
</ul>
<h4 id="你提到了remark，那它remark具体是怎么执行的？三色标记法？"><a href="#你提到了remark，那它remark具体是怎么执行的？三色标记法？" class="headerlink" title="你提到了remark，那它remark具体是怎么执行的？三色标记法？"></a>你提到了remark，那它remark具体是怎么执行的？三色标记法？</h4><p>是的，remark 阶段通常会结合三色标记法来执行，确保在并发标记期间所有存活对象都被正确标记。目的是修正并发标记阶段中可能遗漏的对象引用变化。</p>
<p>在 remark 阶段，垃圾收集器会停止应用线程，以确保在这个阶段不会有引用关系的进一步变化。这种暂停通常很短暂。remark 阶段主要包括以下操作：</p>
<ol>
<li>处理写屏障记录的引用变化：在并发标记阶段，应用程序可能会更新对象的引用（比如一个黑色对象新增了对一个白色对象的引用），这些变化通过写屏障记录下来。在 remark 阶段，GC 会处理这些记录，确保所有可达对象都正确地标记为灰色或黑色。</li>
<li>扫描灰色对象：再次遍历灰色对象，处理它们的所有引用，确保引用的对象正确标记为灰色或黑色。</li>
<li>清理：确保所有引用关系正确处理后，灰色对象标记为黑色，白色对象保持不变。这一步完成后，所有存活对象都应当是黑色的。</li>
</ol>
<h4 id="什么是三色标记法？"><a href="#什么是三色标记法？" class="headerlink" title="什么是三色标记法？"></a>什么是三色标记法？</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105137.png" alt="20251011105137"><br>Java全栈架构师：三色标记法</p>
<p>三色标记法用于标记对象的存活状态，它将对象分为三类：</p>
<ol>
<li>白色（White）：尚未访问的对象。垃圾回收结束后，仍然为白色的对象会被认为是不可达的对象，可以回收。</li>
<li>灰色（Gray）：已经访问到但未标记完其引用的对象。灰色对象是需要进一步处理的。</li>
<li>黑色（Black）：已经访问到并且其所有引用对象都已经标记过。黑色对象是完全处理过的，不需要再处理。</li>
</ol>
<p>三色标记法的工作流程：</p>
<p>①、初始标记（Initial Marking）：从 GC Roots 开始，标记所有直接可达的对象为灰色。</p>
<p>②、并发标记（Concurrent Marking）：在此阶段，标记所有灰色对象引用的对象为灰色，然后将灰色对象自身标记为黑色。这个过程是并发的，和应用线程同时进行。</p>
<p>此阶段的一个问题是，应用线程可能在并发标记期间修改对象的引用关系，导致一些对象的标记状态不准确。</p>
<p>③、重新标记（Remarking）：重新标记阶段的目标是处理并发标记阶段遗漏的引用变化。为了确保所有存活对象都被正确标记，remark 需要在 STW 暂停期间执行。</p>
<p>④、使用写屏障（Write Barrier）来捕捉并发标记阶段应用线程对对象引用的更新。通过遍历这些更新的引用来修正标记状态，确保遗漏的对象不会被错误地回收。</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaodaoge_it/article/details/121890145">小道哥的三色标记</a></p>
<h3 id="33-🌟G1-垃圾收集器了解吗？"><a href="#33-🌟G1-垃圾收集器了解吗？" class="headerlink" title="33.🌟G1 垃圾收集器了解吗？"></a>33.🌟G1 垃圾收集器了解吗？</h3><p>G1 在 JDK 1.7 时引入，在 JDK 9 时取代 CMS 成为默认的垃圾收集器。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105431.png" alt="20251011105431"><br>有梦想的肥宅：G1 收集器</p>
<p>G1 把 Java 堆划分为多个大小相等的独立区域Region，每个区域都可以扮演新生代或老年代的角色。</p>
<p>同时，G1 还有一个专门为大对象设计的 Region，叫 Humongous 区。</p>
<blockquote>
<p>大对象的判定规则是，如果一个大对象超过了一个 Region 大小的 50%，比如每个 Region 是 2M，只要一个对象超过了 1M，就会被放入 Humongous 中。</p>
</blockquote>
<p>这种区域化管理使得 G1 可以更灵活地进行垃圾收集，只回收部分区域而不是整个新生代或老年代。</p>
<p>G1 收集器的运行过程大致可划分为这几个步骤：</p>
<p>①、<strong>并发标记</strong>，G1 通过并发标记的方式找出堆中的垃圾对象。并发标记阶段与应用线程同时执行，不会导致应用线程暂停。</p>
<p>②、<strong>混合收集</strong>，在并发标记完成后，G1 会计算出哪些区域的回收价值最高（也就是包含最多垃圾的区域），然后优先回收这些区域。这种回收方式包括了部分新生代区域和老年代区域。</p>
<p>选择回收成本低而收益高的区域进行回收，可以提高回收效率和减少停顿时间。</p>
<p>③、<strong>可预测的停顿</strong>，G1 在垃圾回收期间仍然需要「Stop the World」。不过，G1 在停顿时间上添加了预测机制，用户可以 JVM 启动时指定期望停顿时间，G1 会尽可能地在这个时间内完成垃圾回收。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105556.png" alt="20251011105556"><br>三分恶面渣逆袭：G1收集器运行示意图</p>
<h3 id="34-有了-CMS，为什么还要引入-G1？"><a href="#34-有了-CMS，为什么还要引入-G1？" class="headerlink" title="34.有了 CMS，为什么还要引入 G1？"></a>34.有了 CMS，为什么还要引入 G1？</h3><table>
<thead>
<tr>
<th>特性</th>
<th>CMS</th>
<th>G1</th>
</tr>
</thead>
<tbody><tr>
<td>设计目标</td>
<td>低停顿时间</td>
<td>可预测的停顿时间</td>
</tr>
<tr>
<td>并发性</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>内存碎片</td>
<td>是，容易产生碎片</td>
<td>否，通过区域划分和压缩减少碎片</td>
</tr>
<tr>
<td>收集代数</td>
<td>年轻代和老年代</td>
<td>整个堆，但区分年轻代和老年代</td>
</tr>
<tr>
<td>并发阶段</td>
<td>并发标记、并发清理</td>
<td>并发标记、并发清理、并发回收</td>
</tr>
<tr>
<td>停顿时间预测</td>
<td>较难预测</td>
<td>可配置停顿时间目标</td>
</tr>
<tr>
<td>容易出现的问题</td>
<td>内存碎片、Concurrent Mode Failure</td>
<td>较少出现长时间停顿</td>
</tr>
</tbody></table>
<p>CMS 适用于对延迟敏感的应用场景，主要目标是减少停顿时间，但容易产生内存碎片。</p>
<p>G1 则提供了更好的停顿时间预测和内存压缩能力，适用于大内存和多核处理器环境。</p>
<h3 id="35-你们线上用的什么垃圾收集器？"><a href="#35-你们线上用的什么垃圾收集器？" class="headerlink" title="35.你们线上用的什么垃圾收集器？"></a>35.你们线上用的什么垃圾收集器？</h3><p>我们生产环境中采用了设计比较优秀的 G1 垃圾收集器，因为它不仅能满足低停顿的要求，而且解决了 CMS 的浮动垃圾问题、内存碎片问题。</p>
<p>G1 非常适合大内存、多核处理器的环境。</p>
<p>可以通过以下命令查看当前 JVM 的垃圾收集器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011105859.png" alt="20251011105859"><br>二哥的 Java 进阶之路：JDK 默认垃圾收集器</p>
<p><code>UseParallelGC</code> &#x3D; <code>Parallel Scavenge + Parallel Old</code>，表示新生代用<code>Parallel Scavenge</code>收集器，老年代使用<code>Parallel Old</code> 收集器。</p>
<p>因此你也可以这样回答：</p>
<p>我们系统的业务相对复杂，但并发量并不是特别高，所以我们选择了适用于多核处理器、能够并行处理垃圾回收任务，且能提供高吞吐量的<code>Parallel GC</code>。</p>
<p>但这个说法不讨喜，你也可以回答：</p>
<p>我们系统采用的是 CMS 收集器，能够最大限度减少应用暂停时间。</p>
<h4 id="工作中项目使用的什么垃圾回收算法？"><a href="#工作中项目使用的什么垃圾回收算法？" class="headerlink" title="工作中项目使用的什么垃圾回收算法？"></a>工作中项目使用的什么垃圾回收算法？</h4><p>我们生产环境中采用了设计比较优秀的 G1 垃圾收集器，G1 采用的是分区式标记-整理算法，将堆划分为多个区域，按需回收，适用于大内存和多核环境，能够同时考虑吞吐量和暂停时间。</p>
<p>或者：</p>
<p>我们系统采用的是 CMS 收集器，CMS 采用的是标记-清除算法，能够并发标记和清除垃圾，减少暂停时间，适用于对延迟敏感的应用。</p>
<p>再或者：</p>
<p>我们系统采用的是 Parallel 收集器，Parallel 采用的是年轻代使用复制算法，老年代使用标记-整理算法，适用于高吞吐量要求的应用。</p>
<h3 id="36-垃圾收集器应该如何选择？"><a href="#36-垃圾收集器应该如何选择？" class="headerlink" title="36.垃圾收集器应该如何选择？"></a>36.垃圾收集器应该如何选择？</h3><p>如果应用程序只需要一个很小的内存空间（大约 100 MB），或者对停顿时间没有特殊的要求，可以选择 Serial 收集器。</p>
<p>如果优先考虑应用程序的峰值性能，并且没有时间要求，或者可以接受 1 秒或更长的停顿时间，可以选择 Parallel 收集器。</p>
<p>如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约 1 秒以内，可以选择 CMS&#x2F; G1 收集器。</p>
<p>如果响应时间是高优先级的，或者堆空间比较大，可以选择 ZGC 收集器。</p>
<h2 id="四、JVM-调优"><a href="#四、JVM-调优" class="headerlink" title="四、JVM 调优"></a>四、JVM 调优</h2><h3 id="37-用过哪些性能监控的命令行工具？"><a href="#37-用过哪些性能监控的命令行工具？" class="headerlink" title="37.用过哪些性能监控的命令行工具？"></a>37.用过哪些性能监控的命令行工具？</h3><p>操作系统层面，我用过 top、vmstat、iostat、netstat 等命令，可以监控系统整体的资源使用情况，比如说内存、CPU、IO 使用情况、网络使用情况。</p>
<p>JDK 自带的命令行工具层面，我用过 jps、jstat、jinfo、jmap、jhat、jstack、jcmd 等，可以查看 JVM 运行时信息、内存使用情况、堆栈信息等。</p>
<h4 id="你一般都怎么用jmap？"><a href="#你一般都怎么用jmap？" class="headerlink" title="你一般都怎么用jmap？"></a>你一般都怎么用jmap？</h4><p>①、我一般会使用 <code>jmap -heap &lt;pid&gt;</code> 查看堆内存摘要，包括新生代、老年代、元空间等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110129.png" alt="20251011110129"><br>二哥的Java 进阶之路：jmap -heap</p>
<p>②、或者使用 <code>jmap -histo &lt;pid&gt;</code> 查看对象分布。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110227.png" alt="20251011110227"><br>二哥的Java 进阶之路：jmap -histo</p>
<p>③、还有生成堆转储文件：<code>jmap -dump:format=b,file=&lt;path&gt; &lt;pid&gt;</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110342.png" alt="20251011110342"><br>二哥的Java 进阶之路：jmap -dump</p>
<h3 id="38-了解哪些可视化的性能监控工具？"><a href="#38-了解哪些可视化的性能监控工具？" class="headerlink" title="38.了解哪些可视化的性能监控工具？"></a>38.了解哪些可视化的性能监控工具？</h3><p>我自己用过的可视化工具主要有：</p>
<p>①、JConsole：JDK 自带的监控工具，可以用来监视 Java 应用程序的运行状态，包括内存使用、线程状态、类加载、GC 等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110418.png" alt="20251011110418"><br>三分恶面渣逆袭：JConsole概览</p>
<p>②、VisualVM：一个基于 NetBeans 的可视化工具，在很长一段时间内，VisualVM 都是 Oracle 官方主推的故障处理工具。集成了多个 JDK 命令行工具的功能，非常友好。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110439.png" alt="20251011110439"><br>三分恶面渣逆袭：VisualVM安装插件</p>
<p>③、Java Mission Control：JMC 最初是 JRockit VM 中的诊断工具，但在 Oracle JDK7 Update 40 以后，就绑定到了 HotSpot VM 中。不过后来又被 Oracle 开源出来作为了一个单独的产品。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110455.png" alt="20251011110455"><br>三分恶面渣逆袭：JMC主要界面</p>
<h4 id="用过哪些第三方的工具？"><a href="#用过哪些第三方的工具？" class="headerlink" title="用过哪些第三方的工具？"></a>用过哪些第三方的工具？</h4><p>①、<strong>MAT</strong>：一个 Java 堆内存分析工具，主要用于分析和查找 Java 堆中的内存泄漏和内存消耗问题；可以从 Java 堆转储文件中分析内存使用情况，并提供丰富的报告，如内存泄漏疑点、最大对象和 GC 根信息；支持通过图形界面查询对象，以及检查对象间的引用关系。</p>
<p>②、<strong>GChisto</strong>：GC 日志分析工具，可以帮助我们优化垃圾收集行为和调整 GC 性能。</p>
<p>③、<strong>JProfiler</strong>：一个全功能的商业化 Java 性能分析工具，提供 CPU、 内存和线程的实时分析。</p>
<p>④、<strong>arthas</strong>：阿里巴巴开源的 Java 诊断工具，主要用于线上的应用诊断；支持在不停机的情况下进行诊断；可以提供包括 JVM 信息查看、监控、Trace 命令、反编译等功能。</p>
<p>⑤、<strong>async-profiler</strong>：一个低开销的性能分析工具，支持生成火焰图，适用于复杂性能问题的分析。</p>
<h3 id="39-JVM-的常见参数配置知道哪些？"><a href="#39-JVM-的常见参数配置知道哪些？" class="headerlink" title="39.JVM 的常见参数配置知道哪些？"></a>39.JVM 的常见参数配置知道哪些？</h3><h4 id="配置堆内存大小的参数有哪些？"><a href="#配置堆内存大小的参数有哪些？" class="headerlink" title="配置堆内存大小的参数有哪些？"></a>配置堆内存大小的参数有哪些？</h4><ul>
<li><code>-Xms</code>：初始堆大小</li>
<li><code>-Xmx</code>：最大堆大小</li>
<li><code>-XX:NewSize=n</code>：设置年轻代大小</li>
<li><code>-XX:NewRatio=n</code>：设置年轻代和年老代的比值。如：n 为 3 表示年轻代和年老代比值为 1：3，年轻代占总和的 1&#x2F;4</li>
<li><code>-XX:SurvivorRatio=n</code>：年轻代中 Eden 区与两个 Survivor 区的比值。如 n&#x3D;3 表示 Eden 占 3 Survivor 占 2，一个 Survivor 区占整个年轻代的 1&#x2F;5</li>
</ul>
<h4 id="配置-GC-收集器的参数有哪些？"><a href="#配置-GC-收集器的参数有哪些？" class="headerlink" title="配置 GC 收集器的参数有哪些？"></a>配置 GC 收集器的参数有哪些？</h4><ul>
<li><code>-XX:+UseSerialGC</code>：设置串行收集器</li>
<li><code>-XX:+UseParallelGC</code>：设置并行收集器</li>
<li><code>-XX:+UseParalledlOldGC</code>：设置并行老年代收集器</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：设置并发收集器</li>
</ul>
<h4 id="配置并行收集的参数有哪些？"><a href="#配置并行收集的参数有哪些？" class="headerlink" title="配置并行收集的参数有哪些？"></a>配置并行收集的参数有哪些？</h4><ul>
<li><code>-XX:MaxGCPauseMillis=n</code>：设置最大垃圾回收停顿时间</li>
<li><code>-XX:GCTimeRatio=n</code>：设置垃圾回收时间占程序运行时间的比例</li>
<li><code>-XX:+CMSIncrementalMode</code>：设置增量模式，适合单 CPU 环境</li>
<li><code>-XX:ParallelGCThreads=n</code>：设置并行收集器的线程数</li>
</ul>
<h4 id="打印-GC-回收的过程日志信息的参数有哪些？"><a href="#打印-GC-回收的过程日志信息的参数有哪些？" class="headerlink" title="打印 GC 回收的过程日志信息的参数有哪些？"></a>打印 GC 回收的过程日志信息的参数有哪些？</h4><ul>
<li><code>-XX:+PrintGC</code>：输出 GC 日志</li>
<li><code>-XX:+PrintGCDetails</code>：输出 GC 详细日志</li>
<li><code>-XX:+PrintGCTimeStamps</code>：输出 GC 的时间戳（以基准时间的形式）</li>
<li><code>-Xloggc:filename</code>：日志文件的输出路径</li>
</ul>
<h3 id="40-做过-JVM-调优吗？"><a href="#40-做过-JVM-调优吗？" class="headerlink" title="40.做过 JVM 调优吗？"></a>40.做过 JVM 调优吗？</h3><p>做过。</p>
<p>JVM 调优是一个复杂的过程，调优的对象包括堆内存、垃圾收集器和 JVM 运行时参数等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110603.png" alt="20251011110603"><br>二哥的 Java 进阶之路：JVM 调优</p>
<p>如果堆内存设置过小，可能会导致频繁的垃圾回收。所以在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，启动 JVM 的时候配置了 <code>-Xms</code> 和 <code>-Xmx</code> 参数，让堆内存最大可用内存为 2G（我用的丐版服务器）。</p>
<p>在项目运行期间，我会使用 JVisualVM 定期观察和分析 GC 日志，如果发现频繁的 Full GC，我会特意关注一下老年代的使用情况。</p>
<p>接着，通过分析 Heap dump 寻找内存泄漏的源头，看看是否有未关闭的资源，长生命周期的大对象等。</p>
<p>之后进行代码优化，比如说减少大对象的创建、优化数据结构的使用方式、减少不必要的对象持有等。</p>
<h3 id="41-CPU-占用过高怎么排查？"><a href="#41-CPU-占用过高怎么排查？" class="headerlink" title="41.CPU 占用过高怎么排查？"></a>41.CPU 占用过高怎么排查？</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110714.png" alt="20251011110714"><br>三分恶面渣逆袭：CPU飙高</p>
<p>首先，使用 top 命令查看 CPU 占用情况，找到占用 CPU 较高的进程 ID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110725.png" alt="20251011110725"><br>haikuotiankongdong：top 命令结果</p>
<p>接着，使用 jstack 命令查看对应进程的线程堆栈信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l &lt;pid&gt; &gt; thread-dump.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面 👆🏻 这个命令会将所有线程的堆栈信息输出到 thread-dump.txt 文件中。</p>
</blockquote>
<p>然后再使用 top 命令查看进程中线程的占用情况，找到占用 CPU 较高的线程 ID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -H -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110806.png" alt="20251011110806"><br>haikuotiankongdong：Java 进程中的线程情况</p>
<blockquote>
<p>注意，top 命令显示的线程 ID 是十进制的，而 jstack 输出的是十六进制的，所以需要将线程 ID 转换为十六进制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf <span class="string">&quot;%x\n&quot;</span> PID</span><br></pre></td></tr></table></figure>

<p>接着在 jstack 的输出中搜索这个十六进制的线程 ID，找到对应的堆栈信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Thread-5&quot;</span> #<span class="number">21</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f812c018800</span> nid=<span class="number">0x1a85</span> runnable [<span class="number">0x00007f811c000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at com.example.MyClass.myMethod(MyClass.java:<span class="number">123</span>)</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p>最后，根据堆栈信息定位到具体的业务方法，查看是否有死循环、频繁的垃圾回收、资源竞争导致的上下文频繁切换等问题。</p>
<h3 id="42-内存飙高问题怎么排查？"><a href="#42-内存飙高问题怎么排查？" class="headerlink" title="42.内存飙高问题怎么排查？"></a>42.内存飙高问题怎么排查？</h3><p>内存飚高一般是因为创建了大量的 Java 对象导致的，如果持续飙高则说明垃圾回收跟不上对象创建的速度，或者内存泄漏导致对象无法回收。</p>
<p>排查的方法主要分为以下几步：</p>
<p>第一，先观察垃圾回收的情况，可以通过 <code>jstat -gc PID 1000</code> 查看 GC 次数和时间。</p>
<p>或者使用 <code>jmap -histo PID | head -20</code> 查看堆内存占用空间最大的前 20 个对象类型。</p>
<p>第二步，通过 jmap 命令 dump 出堆内存信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011110923.png" alt="20251011110923"><br>二哥的 Java 进阶之路：dump</p>
<p>第三步，使用可视化工具分析 dump 文件，比如说 VisualVM，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111056.png" alt="20251011111056"><br>二哥的 Java 进阶之路：分析</p>
<h3 id="43-频繁-minor-gc-怎么办？"><a href="#43-频繁-minor-gc-怎么办？" class="headerlink" title="43.频繁 minor gc 怎么办？"></a>43.频繁 minor gc 怎么办？</h3><p>频繁的 Minor GC 通常意味着新生代中的对象频繁地被垃圾回收，可能是因为新生代空间设置的过小，或者是因为程序中存在大量的短生命周期对象（如临时变量）。</p>
<p>可以使用 GC 日志进行分析，查看 GC 的频率和耗时，找到频繁 GC 的原因。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -Xloggc:gc.log</span><br></pre></td></tr></table></figure>

<p>或者使用监控工具查看堆内存的使用情况，特别是新生代（Eden 和 Survivor 区）的使用情况。</p>
<p>如果是因为新生代空间不足，可以通过 <code>-Xmn</code> 增加新生代的大小，减缓新生代的填满速度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmn256m your-app.jar</span><br></pre></td></tr></table></figure>

<p>如果对象需要长期存活，但频繁从 Survivor 区晋升到老年代，可以通过 <code>-XX:SurvivorRatio</code> 参数调整 Eden 和 Survivor 的比例。默认比例是 8:1，表示 8 个空间用于 Eden，1 个空间用于 Survivor 区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio=<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>调整为 6 的话，会减少 Eden 区的大小，增加 Survivor 区的大小，以确保对象在 Survivor 区中存活的时间足够长，避免过早晋升到老年代。</p>
<h3 id="44-频繁-Full-GC-怎么办？"><a href="#44-频繁-Full-GC-怎么办？" class="headerlink" title="44.频繁 Full GC 怎么办？"></a>44.频繁 Full GC 怎么办？</h3><p>频繁的 Full GC 通常意味着老年代中的对象频繁地被垃圾回收，可能是因为老年代空间设置的过小，或者是因为程序中存在大量的长生命周期对象。</p>
<h4 id="该怎么排查-Full-GC-频繁问题？"><a href="#该怎么排查-Full-GC-频繁问题？" class="headerlink" title="该怎么排查 Full GC 频繁问题？"></a>该怎么排查 Full GC 频繁问题？</h4><p>我厂会通过专门的性能监控系统，查看 GC 的频率和堆内存的使用情况，然后根据监控数据分析 GC 的原因。</p>
<p>如果是小厂，可以这么回复。</p>
<p>我一般会使用 JDK 的自带工具，包括 jmap、jstat 等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看堆内存各区域的使用率以及GC情况</span><br><span class="line">jstat -gcutil -h20 pid <span class="number">1000</span></span><br><span class="line"># 查看堆内存中的存活对象，并按空间排序</span><br><span class="line">jmap -histo pid | head -n20</span><br><span class="line"># dump堆内存文件</span><br><span class="line">jmap -dump:format=b,file=heap pid</span><br></pre></td></tr></table></figure>

<p>或者使用一些可视化的工具，比如 VisualVM、JConsole 等，查看堆内存的使用情况。</p>
<p>假如是因为大对象直接分配到老年代导致的 Full GC 频繁，可以通过 <code>-XX:PretenureSizeThreshold</code> 参数设置大对象直接进入老年代的阈值。</p>
<p>或者将大对象拆分成小对象，减少大对象的创建。比如说分页。</p>
<p>假如是因为内存泄漏导致的频繁 Full GC，可以通过分析堆内存 dump 文件找到内存泄漏的对象，再找到内存泄漏的代码位置。</p>
<p>假如是因为长生命周期的对象进入到了老年代，要及时释放资源，比如说 ThreadLocal、数据库连接、IO 资源等。</p>
<p>假如是因为 GC 参数配置不合理导致的频繁 Full GC，可以通过调整 GC 参数来优化 GC 行为。或者直接更换更适合的 GC 收集器，如 G1、ZGC 等。</p>
<h2 id="五、类加载机制"><a href="#五、类加载机制" class="headerlink" title="五、类加载机制"></a>五、类加载机制</h2><h3 id="45-🌟了解类的加载机制吗？（补充）"><a href="#45-🌟了解类的加载机制吗？（补充）" class="headerlink" title="45.🌟了解类的加载机制吗？（补充）"></a>45.🌟了解类的加载机制吗？（补充）</h3><p>了解。</p>
<p>JVM 的操作对象是 Class 文件，JVM 把 Class 文件中描述类的数据结构加载到内存中，并对数据进行校验、解析和初始化，最终转化成可以被 JVM 直接使用的类型，这个过程被称为类加载机制。</p>
<p>其中最重要的三个概念就是：类加载器、类加载过程和双亲委派模型。</p>
<ul>
<li><strong>类加载器</strong>：负责加载类文件，将类文件加载到内存中，生成 Class 对象。</li>
<li><strong>类加载过程</strong>：包括加载、验证、准备、解析和初始化等步骤。</li>
<li><strong>双亲委派模型</strong>：当一个类加载器接收到类加载请求时，它会把请求委派给父——类加载器去完成，依次递归，直到最顶层的类加载器，如果父——类加载器无法完成加载请求，子类加载器才会尝试自己去加载。</li>
</ul>
<h3 id="46-类加载器有哪些？"><a href="#46-类加载器有哪些？" class="headerlink" title="46.类加载器有哪些？"></a>46.类加载器有哪些？</h3><p>主要有四种：</p>
<p>①、<strong>启动类加载器</strong>，负责加载 JVM 的核心类库，如 rt.jar 和其他核心库位于<code>JAVA_HOME/jre/lib</code>目录下的类。</p>
<p>②、<strong>扩展类加载器</strong>，负责加载<code>JAVA_HOME/jre/lib/ext</code>目录下，或者由系统属性<code>java.ext.dirs</code>指定位置的类库，由<code>sun.misc.Launcher$ExtClassLoader</code> 实现。</p>
<p>③、<strong>应用程序类加载器</strong>，负责加载 classpath 的类库，由<code>sun.misc.Launcher$AppClassLoader</code>实现。</p>
<p>我们编写的任何类都是由应用程序类加载器加载的，除非显式使用自定义类加载器。</p>
<p>④、<strong>用户自定义类加载器</strong>，通常用于加载网络上的类、执行热部署（动态加载和替换应用程序的组件），或者为了安全考虑，从不同的源加载类。</p>
<p>通过继承<code>java.lang.ClassLoader</code>类来实现。</p>
<h3 id="47-能说一下类的生命周期吗？"><a href="#47-能说一下类的生命周期吗？" class="headerlink" title="47.能说一下类的生命周期吗？"></a>47.能说一下类的生命周期吗？</h3><p>一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 、验证、准备、解析、初始化、使用和卸载。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111442.png" alt="20251011111442"><br>三分恶面渣逆袭：类的生命周期</p>
<h3 id="48-🌟类装载的过程知道吗？"><a href="#48-🌟类装载的过程知道吗？" class="headerlink" title="48.🌟类装载的过程知道吗？"></a>48.🌟类装载的过程知道吗？</h3><blockquote>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/class-load.html">一文彻底搞懂 Java 类加载机制</a></p>
</blockquote>
<p>知道。</p>
<p>类装载过程包括三个阶段：载入、链接和初始化。</p>
<p>①、载入：将类的二进制字节码加载到内存中。</p>
<p>②、链接可以细分为三个小的阶段：</p>
<ul>
<li>验证：检查类文件格式是否符合 JVM 规范</li>
<li>准备：为类的静态变量分配内存并设置默认值。</li>
<li>解析：将符号引用替换为直接引用。</li>
</ul>
<p>③、初始化：执行静态代码块和静态变量初始化。</p>
<p>在准备阶段，静态变量已经被赋过默认初始值了，在初始化阶段，静态变量将被赋值为代码期望赋的值。比如说 <code>static int a = 1;</code>，在准备阶段，<code>a</code> 的值为 0，在初始化阶段，<code>a</code> 的值为 1。</p>
<p>换句话说，初始化阶段是在执行类的构造方法，也就是 <a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/bytecode.html">javap</a> 中看到的 <code>&lt;clinit&gt;()</code>。</p>
<h4 id="载入过程-JVM-会做什么？"><a href="#载入过程-JVM-会做什么？" class="headerlink" title="载入过程 JVM 会做什么？"></a>载入过程 JVM 会做什么？</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111643.png" alt="20251011111643"><br>三分恶面渣逆袭：载入</p>
<ul>
<li>1）通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>3）在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为这个类的访问入口。</li>
</ul>
<h3 id="49-🌟什么是双亲委派模型？"><a href="#49-🌟什么是双亲委派模型？" class="headerlink" title="49.🌟什么是双亲委派模型？"></a>49.🌟什么是双亲委派模型？</h3><p>双亲委派模型要求类加载器在加载类时，先委托父加载器尝试加载，只有父加载器无法加载时，子加载器才会加载。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111737.png" alt="20251011111737"><br>三分恶面渣逆袭：双亲委派模型</p>
<p>这个过程会一直向上递归，也就是说，从子加载器到父加载器，再到更上层的加载器，一直到最顶层的启动类加载器。</p>
<p>启动类加载器会尝试加载这个类。如果它能够加载这个类，就直接返回；如果它不能加载这个类，就会将加载任务返回给委托它的子加载器。</p>
<p>子加载器尝试加载这个类。如果子加载器也无法加载这个类，它就会继续向下传递这个加载任务，依此类推。</p>
<p>直到某个加载器能够加载这个类，或者所有加载器都无法加载这个类，最终抛出 ClassNotFoundException。</p>
<h3 id="49-为什么要用双亲委派模型？"><a href="#49-为什么要用双亲委派模型？" class="headerlink" title="49.为什么要用双亲委派模型？"></a>49.为什么要用双亲委派模型？</h3><p><strong>①、避免类的重复加载</strong>：父加载器加载的类，子加载器无需重复加载。</p>
<p><strong>②、保证核心类库的安全性</strong>：如 <code>java.lang.*</code> 只能由 Bootstrap ClassLoader 加载，防止被篡改。</p>
<h3 id="50-如何破坏双亲委派机制？"><a href="#50-如何破坏双亲委派机制？" class="headerlink" title="50.如何破坏双亲委派机制？"></a>50.如何破坏双亲委派机制？</h3><p>重写 ClassLoader 的 <code>loadClass()</code> 方法。</p>
<p>如果不想打破双亲委派模型，就重写 ClassLoader 类中的 <code>findClass()</code> 方法，那些无法被父类加载器加载的类最终会通过这个方法被加载。</p>
<h3 id="51-有哪些破坏双亲委派模型的典型例子？"><a href="#51-有哪些破坏双亲委派模型的典型例子？" class="headerlink" title="51.有哪些破坏双亲委派模型的典型例子？"></a>51.有哪些破坏双亲委派模型的典型例子？</h3><p>我了解的有两种：</p>
<ul>
<li>第一种：SPI 机制加载 JDBC 驱动。</li>
<li>第二种：热部署框架。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011111848.png" alt="20251011111848"><br>三分恶面渣逆袭：双亲委派模型的三次破坏</p>
<h4 id="说说SPI-机制？"><a href="#说说SPI-机制？" class="headerlink" title="说说SPI 机制？"></a>说说SPI 机制？</h4><p>SPI 是 Java 的一种扩展机制，用于加载和注册第三方类库，常见于 JDBC、JNDI 等框架。</p>
<p>双亲委派模型会优先让父类加载器加载类，而 SPI 需要动态加载子类加载器中的实现。</p>
<p>根据双亲委派模型，<code>java.sql.Driver</code> 类应该由父加载器加载，但父类加载器无法加载由子类加载器定义的驱动类，如 MySQL 的 <code>com.mysql.cj.jdbc.Driver</code>。</p>
<p>那么只能使用 SPI 机制通过 <code>META-INF/services</code> 文件指定服务提供者的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">Enumeration&lt;Driver&gt; drivers = ServiceLoader.load(Driver.class, cl).iterator();</span><br></pre></td></tr></table></figure>

<p>DriverManager 使用了线程上下文类加载器来加载 SPI 的实现类，从而允许子类加载器加载具体的 JDBC 驱动。</p>
<h4 id="说说热部署？"><a href="#说说热部署？" class="headerlink" title="说说热部署？"></a>说说热部署？</h4><p>热部署是指在不重启服务器的情况下更新应用程序代码，需要替换旧版本的类，但旧版本的类可能由父加载器加载。</p>
<p>如 Spring Boot 的 DevTools 通常会自定义类加载器，优先加载新的类版本。</p>
<h3 id="52-Tomcat-的类加载机制了解吗？"><a href="#52-Tomcat-的类加载机制了解吗？" class="headerlink" title="52.Tomcat 的类加载机制了解吗？"></a>52.Tomcat 的类加载机制了解吗？</h3><p>了解。</p>
<p>Tomcat 基于双亲委派模型进行了一些扩展，主要的类加载器有：</p>
<ul>
<li>Bootstrap ClassLoader：加载 Java 的核心类库；</li>
<li>Catalina ClassLoader：加载 Tomcat 的核心类库；</li>
<li>Shared ClassLoader：加载共享类库，允许多个 Web 应用共享某些类库；</li>
<li>WebApp ClassLoader：加载 Web 应用程序的类库，支持多应用隔离和优先加载应用自定义的类库（破坏了双亲委派模型）。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011112052.png" alt="20251011112052"><br>Tomcat类加载器</p>
<h3 id="53-你觉得应该怎么实现一个热部署功能？"><a href="#53-你觉得应该怎么实现一个热部署功能？" class="headerlink" title="53.你觉得应该怎么实现一个热部署功能？"></a>53.你觉得应该怎么实现一个热部署功能？</h3><p>热部署是指在不重启服务器的情况下，动态加载、更新或卸载应用程序的组件，比如类、配置文件等。</p>
<p>需要在类加载器的基础上，实现类的重新加载。</p>
<p>我的思路是：</p>
<p>第一步，使用文件监控机制，如 Java NIO 的 WatchService 来监控类文件或配置文件的变化。当监控到文件变更时，触发热部署流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileWatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">watchDirectoryPath</span><span class="params">(Path path)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查路径是否是有效目录</span></span><br><span class="line">        <span class="keyword">if</span> (!isDirectory(path)) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Provided path is not a directory: &quot;</span> + path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Starting to watch path: &quot;</span> + path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件系统的 WatchService</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">WatchService</span> <span class="variable">watchService</span> <span class="operator">=</span> path.getFileSystem().newWatchService()) &#123;</span><br><span class="line">            <span class="comment">// 注册目录监听服务，监听创建、修改和删除事件</span></span><br><span class="line">            path.register(watchService, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                WatchKey key;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞直到有事件发生</span></span><br><span class="line">                    key = watchService.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;WatchService interrupted, stopping directory watch.&quot;</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理事件</span></span><br><span class="line">                <span class="keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;</span><br><span class="line">                    processEvent(event);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重置 key，如果失败则退出</span></span><br><span class="line">                <span class="keyword">if</span> (!key.reset()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;WatchKey no longer valid. Exiting watch loop.&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;An error occurred while setting up the WatchService: &quot;</span> + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">(Path path)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processEvent</span><span class="params">(WatchEvent&lt;?&gt; event)</span> &#123;</span><br><span class="line">        WatchEvent.Kind&lt;?&gt; kind = event.kind();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理事件类型</span></span><br><span class="line">        <span class="keyword">if</span> (kind == OVERFLOW) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Event overflow occurred. Some events might have been lost.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">fileName</span> <span class="operator">=</span> ((WatchEvent&lt;Path&gt;) event).context();</span><br><span class="line">        System.out.println(<span class="string">&quot;Event: &quot;</span> + kind.name() + <span class="string">&quot;, File affected: &quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置监控路径为当前目录</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">pathToWatch</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        watchDirectoryPath(pathToWatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，创建一个自定义类加载器，继承<code>java.lang.ClassLoader</code>，并重写<code>findClass()</code>方法，用来加载新的类文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HotSwapClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotSwapClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(ClassLoader.getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 加载指定路径下的类文件字节码</span></span><br><span class="line">        <span class="type">byte</span>[] classBytes = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classBytes == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用defineClass将字节码转换为Class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        <span class="comment">// 实现从文件系统或其他来源加载类文件的字节码</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友情提示：Intellij IDEA 提供了热部署功能，当我们修改了代码后，IDEA 会自动保存并编译，如果是 Web 项目，还可以在 Chrome 浏览器中装一个 LiveReload 插件，一旦编译完成，页面就会自动刷新看到最新的效果。对于测试或者调试来说，非常方便。</p>
<h3 id="54-说说解释执行和编译执行的区别（补充）"><a href="#54-说说解释执行和编译执行的区别（补充）" class="headerlink" title="54.说说解释执行和编译执行的区别（补充）"></a>54.说说解释执行和编译执行的区别（补充）</h3><p>先说解释和编译的区别：</p>
<ul>
<li>解释：将源代码逐行转换为机器码。</li>
<li>编译：将源代码一次性转换为机器码。</li>
</ul>
<p>一个是逐行，一个是一次性，再来说说解释执行和编译执行的区别：</p>
<ul>
<li>解释执行：程序运行时，将源代码逐行转换为机器码，然后执行。</li>
<li>编译执行：程序运行前，将源代码一次性转换为机器码，然后执行。</li>
</ul>
<p>Java 一般被称为“解释型语言”，因为 Java 代码在执行前，需要先将源代码编译成字节码，然后在运行时，再由 JVM 的解释器“逐行”将字节码转换为机器码，然后执行。</p>
<p>这也是 Java 被诟病“慢”的主要原因。</p>
<p>但 JIT 的出现打破了这种刻板印象，JVM 会将热点代码（即运行频率高的代码）编译后放入 CodeCache，当下次执行再遇到这段代码时，会从 CodeCache 中直接读取机器码，然后执行。</p>
<p>因此，Java 的执行效率得到了大幅提升。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251011112408.png" alt="20251011112408"><br>图片来源于美团技术博客</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯 Java 后端实习一面原题：说说 Java 解释执行的流程。</li>
</ol>
</blockquote>

<div class="article-footer slide-up fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap slide-up" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/10/11/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.10.11学习日记</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/10/10/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.10%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.10.10学习日记</a></div></section></div>







<footer class="page-footer slide-up footnote"><hr><div class="text"><p>本站由 <a href="/">JakicDong</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0">Stellar 1.30.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper slide-up toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80"><span class="toc-text">一、引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-JVM"><span class="toc-text">1.什么是 JVM?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-JVM-%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">说说 JVM 的其他特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0-JVM%EF%BC%9F"><span class="toc-text">为什么要学习 JVM？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4-JVM-%E7%9A%84%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">2.说说 JVM 的组织架构（补充）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">二、内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%F0%9F%8C%9F%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%90%97%EF%BC%9F"><span class="toc-text">3.🌟能说一下 JVM 的内存区域吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F"><span class="toc-text">介绍一下程序计数器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%9F"><span class="toc-text">介绍一下 Java 虚拟机栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E6%9C%89%E7%9A%84%E7%A9%BA%E6%96%B9%E6%B3%95%EF%BC%8C%E7%A9%BA%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%B2%A1%E6%9C%89%EF%BC%8C%E9%82%A3%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E9%87%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-text">一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%9F"><span class="toc-text">介绍一下本地方法栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E7%9A%84%E8%BF%90%E8%A1%8C%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">介绍一下本地方法栈的运行场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#native-%E6%96%B9%E6%B3%95%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-text">native 方法解释一下？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-Java-%E5%A0%86%EF%BC%9F"><span class="toc-text">介绍一下 Java 堆？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">堆和栈的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F"><span class="toc-text">介绍一下方法区？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AD%98%E5%9C%A8%E5%A0%86%E6%A0%88%E7%9A%84%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-text">变量存在堆栈的什么位置？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B4%E4%B8%80%E4%B8%8B-JDK-1-6%E3%80%811-7%E3%80%811-8-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-text">4.说一下 JDK 1.6、1.7、1.8 内存区域的变化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%85%83%E7%A9%BA%E9%97%B4%E6%9B%BF%E4%BB%A3%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%9F"><span class="toc-text">5.为什么使用元空间替代永久代？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%F0%9F%8C%9F%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">6.🌟对象创建的过程了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81%E8%BF%87%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">对象的销毁过程了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A0%86%E5%86%85%E5%AD%98%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E7%9A%84%EF%BC%9F"><span class="toc-text">7.堆内存是如何分配的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%EF%BC%9F"><span class="toc-text">什么是指针碰撞？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="toc-text">什么是空闲列表？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-new-%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%A0%86%E4%BC%9A%E5%8F%91%E7%94%9F%E6%8A%A2%E5%8D%A0%E5%90%97%EF%BC%9F"><span class="toc-text">8.new 对象时，堆会发生抢占吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">JVM 怎么解决堆内存分配的竞争问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%90%97%EF%BC%9F"><span class="toc-text">9.能说一下对象的内存布局吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">说说对象头的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88%E4%BC%9A%E8%A2%AB%E5%8E%8B%E7%BC%A9%E5%90%97%EF%BC%9F"><span class="toc-text">类型指针会被压缩吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">实例数据了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">对齐填充了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E8%A6%81%E8%BF%9B%E8%A1%8C-8-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么非要进行 8 字节对齐呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-Object-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">new Object() 对象的内存大小是多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E8%BF%87-JOL-%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%90%97%EF%BC%9F"><span class="toc-text">用过 JOL 查看对象的内存布局吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%A4%A7%E5%B0%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">对象的引用大小了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-JVM-%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">10.JVM 怎么访问对象的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-text">11.说一下对象有哪几种引用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Java-%E5%A0%86%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">12.Java 堆的内存分区了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%EF%BC%9F"><span class="toc-text">13.说一下新生代的区域划分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%F0%9F%8C%9F%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-text">14.🌟对象什么时候会进入老年代？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%EF%BC%9F"><span class="toc-text">长期存活的对象如何判断？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%EF%BC%9F"><span class="toc-text">大对象如何判断？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">动态年龄判定了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-STW-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">15.STW 了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9A%82%E5%81%9C%E7%BA%BF%E7%A8%8B%E5%91%A2%EF%BC%9F"><span class="toc-text">如何暂停线程呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%9F"><span class="toc-text">什么是安全点？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E5%88%86%E9%85%8D%E5%9C%A8%E5%A0%86%E4%B8%AD%E5%90%97%EF%BC%9F"><span class="toc-text">16.对象一定分配在堆中吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-text">什么是逃逸分析？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%85%B7%E4%BD%93%E6%98%AF%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">逃逸具体是指什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">逃逸分析会带来什么好处？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">17.内存溢出和内存泄漏了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%83%BD%E6%89%8B%E5%86%99%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E4%BE%8B%E5%AD%90%E5%90%97%EF%BC%9F"><span class="toc-text">18.能手写内存溢出的例子吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8F%AF%E8%83%BD%E7%94%B1%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0%E5%AF%BC%E8%87%B4%E5%91%A2%EF%BC%9F"><span class="toc-text">19.内存泄漏可能由哪些原因导致呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%9C%89%E6%B2%A1%E6%9C%89%E5%A4%84%E7%90%86%E8%BF%87%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">20.有没有处理过内存泄漏问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%9C%89%E6%B2%A1%E6%9C%89%E5%A4%84%E7%90%86%E8%BF%87%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">21.有没有处理过内存溢出问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">22.什么情况下会发生栈溢出？（补充）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-text">三、垃圾收集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%F0%9F%8C%9F%E8%AE%B2%E8%AE%B2-JVM-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">23.🌟讲讲 JVM 的垃圾回收机制（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">垃圾回收的过程是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%F0%9F%8C%9F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%BB%8D%E7%84%B6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-text">24.🌟如何判断对象仍然存活？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%EF%BC%9F"><span class="toc-text">什么是引用计数法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E5%89%8D%E7%BD%AE%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-text">做可达性分析的时候，应该有哪些前置性的操作？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-Java-%E4%B8%AD%E5%8F%AF%E4%BD%9C%E4%B8%BA-GC-Roots-%E7%9A%84%E5%BC%95%E7%94%A8%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">25.Java 中可作为 GC Roots 的引用有哪几种？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-text">说说虚拟机栈中的引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%AD-JNI-%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-text">说说本地方法栈中 JNI 的引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%B1%BB%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-text">说说类静态变量？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%EF%BC%9F"><span class="toc-text">说说运行时常量池中的常量？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-finalize-%E6%96%B9%E6%B3%95%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">26.finalize()方法了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%F0%9F%8C%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">27.🌟垃圾收集算法了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">说说标记-清除算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">说说标记-复制算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">说说标记-整理算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">说说分代收集算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么要用分代收集呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B%E5%92%8C%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%81%9C%E9%A1%BF%EF%BC%9F"><span class="toc-text">标记复制的标记过程和复制过程会不会停顿？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-Minor-GC%E3%80%81Major-GC%E3%80%81Mixed-GC%E3%80%81Full-GC-%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">28.Minor GC、Major GC、Mixed GC、Full GC 都是什么意思？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FULL-gc%E6%80%8E%E4%B9%88%E5%8E%BB%E6%B8%85%E7%90%86%E7%9A%84%EF%BC%9F"><span class="toc-text">FULL gc怎么去清理的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-Young-GC-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="toc-text">29.Young GC 什么时候触发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91-Full-GC%EF%BC%9F"><span class="toc-text">30.什么时候会触发 Full GC？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">空间分配担保是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%F0%9F%8C%9F%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">31.🌟知道哪些垃圾收集器？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Serial-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 Serial 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-ParNew-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 ParNew 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 Parallel Scavenge 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 Serial Old 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 Parallel Old 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-CMS-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 CMS 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-G1-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 G1 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-ZGC-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">说说 ZGC 收集器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">垃圾回收器的作用是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%F0%9F%8C%9F%E8%83%BD%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B-CMS-%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">32.🌟能详细说一下 CMS 的垃圾收集过程吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E6%8F%90%E5%88%B0%E4%BA%86remark%EF%BC%8C%E9%82%A3%E5%AE%83remark%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%9F"><span class="toc-text">你提到了remark，那它remark具体是怎么执行的？三色标记法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%9F"><span class="toc-text">什么是三色标记法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%F0%9F%8C%9FG1-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">33.🌟G1 垃圾收集器了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E6%9C%89%E4%BA%86-CMS%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%BC%95%E5%85%A5-G1%EF%BC%9F"><span class="toc-text">34.有了 CMS，为什么还要引入 G1？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E4%BD%A0%E4%BB%AC%E7%BA%BF%E4%B8%8A%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">35.你们线上用的什么垃圾收集器？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">工作中项目使用的什么垃圾回收算法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">36.垃圾收集器应该如何选择？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81JVM-%E8%B0%83%E4%BC%98"><span class="toc-text">四、JVM 调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-text">37.用过哪些性能监控的命令行工具？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%B8%80%E8%88%AC%E9%83%BD%E6%80%8E%E4%B9%88%E7%94%A8jmap%EF%BC%9F"><span class="toc-text">你一般都怎么用jmap？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-text">38.了解哪些可视化的性能监控工具？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-text">用过哪些第三方的工具？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-JVM-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">39.JVM 的常见参数配置知道哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">配置堆内存大小的参数有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-GC-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">配置 GC 收集器的参数有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%B9%B6%E8%A1%8C%E6%94%B6%E9%9B%86%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">配置并行收集的参数有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0-GC-%E5%9B%9E%E6%94%B6%E7%9A%84%E8%BF%87%E7%A8%8B%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">打印 GC 回收的过程日志信息的参数有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E5%81%9A%E8%BF%87-JVM-%E8%B0%83%E4%BC%98%E5%90%97%EF%BC%9F"><span class="toc-text">40.做过 JVM 调优吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-CPU-%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-text">41.CPU 占用过高怎么排查？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E5%86%85%E5%AD%98%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-text">42.内存飙高问题怎么排查？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E9%A2%91%E7%B9%81-minor-gc-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">43.频繁 minor gc 怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E9%A2%91%E7%B9%81-Full-GC-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">44.频繁 Full GC 怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A5%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5-Full-GC-%E9%A2%91%E7%B9%81%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">该怎么排查 Full GC 频繁问题？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">五、类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%F0%9F%8C%9F%E4%BA%86%E8%A7%A3%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">45.🌟了解类的加载机制吗？（补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">46.类加载器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="toc-text">47.能说一下类的生命周期吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%F0%9F%8C%9F%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-text">48.🌟类装载的过程知道吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BD%E5%85%A5%E8%BF%87%E7%A8%8B-JVM-%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">载入过程 JVM 会做什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%F0%9F%8C%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">49.🌟什么是双亲委派模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">49.为什么要用双亲委派模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E5%A6%82%E4%BD%95%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">50.如何破坏双亲委派机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BE%8B%E5%AD%90%EF%BC%9F"><span class="toc-text">51.有哪些破坏双亲委派模型的典型例子？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4SPI-%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">说说SPI 机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%83%AD%E9%83%A8%E7%BD%B2%EF%BC%9F"><span class="toc-text">说说热部署？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-Tomcat-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">52.Tomcat 的类加载机制了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E4%BD%A0%E8%A7%89%E5%BE%97%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%83%AD%E9%83%A8%E7%BD%B2%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">53.你觉得应该怎么实现一个热部署功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E8%AF%B4%E8%AF%B4%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">54.说说解释执行和编译执行的区别（补充）</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function (response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function (data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function (error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.30.0" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script defer src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const slideUp = {
      distance: `16px`,
      duration: `800`,
      interval: `100`,
      scale: `1`,
      opacity: 0,
      easing: "ease-out"
    };
    ScrollReveal().reveal('.l_left .slide-up', slideUp);
    ScrollReveal().reveal('.l_main .slide-up', slideUp);
    ScrollReveal().reveal('.l_right .slide-up', slideUp);
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script><script src="/js/check-in.js"></script></div></body></html>
