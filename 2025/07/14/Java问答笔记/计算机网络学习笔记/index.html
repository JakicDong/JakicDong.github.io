
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0" theme-name="Stellar" theme-version="1.30.0">
  
  <meta name="generator" content="Hexo 7.0.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>计算机网络学习笔记 - Jakic's Blog</title>

  
    <meta name="description" content="基础1.计算机网络体系的结构计算机网络体系结构通过将复杂的网络通信分解成不同的层次，来标准化交互的过程。常见的模型包括 OSI 七层模型、TCP&#x2F;IP 四层模型和五层体系结构。  OSI 是理论上的网络通信模型，TCP&#x2F;IP 是实际应用层面上的网络通信模型，五层结构是为了方便理解和记忆。 说说 OSI 七层模型？OSI（Open System Interconnection）七层参考模型">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络学习笔记">
<meta property="og:url" content="https://jakicdong.github.io/2025/07/14/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Jakic&#39;s Blog">
<meta property="og:description" content="基础1.计算机网络体系的结构计算机网络体系结构通过将复杂的网络通信分解成不同的层次，来标准化交互的过程。常见的模型包括 OSI 七层模型、TCP&#x2F;IP 四层模型和五层体系结构。  OSI 是理论上的网络通信模型，TCP&#x2F;IP 是实际应用层面上的网络通信模型，五层结构是为了方便理解和记忆。 说说 OSI 七层模型？OSI（Open System Interconnection）七层参考模型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714102442.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714103206.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714103951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104012.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104213.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104653.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104751.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104925.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104947.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714105341.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714105809.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714110047.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714110428.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714111209.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714111527.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714111725.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714112439.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715095105.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715100451.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715101143.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715101851.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715102040.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715102941.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715103149.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715103246.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715104158.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715104419.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715105420.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715105708.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715105908.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715110041.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715110431.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715112316.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715112359.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716103538.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716103635.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716105715.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716105801.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716110915.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716112349.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717092859.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717093709.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095429.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095450.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095514.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095532.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717100157.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717101303.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717101631.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717101740.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717102823.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717102916.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103327.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103500.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103608.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103856.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104021.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104143.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104352.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104711.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104804.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104919.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718095307.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718100733.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718103720.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718104718.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718105151.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718105938.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718110409.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719105300.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719110943.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719111207.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719111233.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719111300.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719111323.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719111341.png">
<meta property="article:published_time" content="2025-07-13T16:00:00.000Z">
<meta property="article:modified_time" content="2025-07-22T01:46:06.712Z">
<meta property="article:author" content="JakicDong">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714102442.png">
  
  
  
  <meta name="keywords" content="基础,计算机网络">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.30.0">


  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/logo.png">
  

  

  
<!-- hexo injector head_end start --><script src="./func.js"></script><!-- hexo injector head_end end --></head>
<link rel="stylesheet" href="/css/check-in.css"><body><div class="sitebg"><div class="siteblur"></div></div>

<div class="l_body content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://avatars.githubusercontent.com/u/130200522?v=4" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Jakic's Blog</div><div class="sub normal cap">学习生活记录</div><div class="sub hover cap" style="opacity:0"> 踏上取经路,比抵达灵山更重要</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客首页" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="打卡墙" href="/check-in" style="color:#9c27b0"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="github" target="_blank" rel="noopener" href="https://github.com/JakicDong/" style="color:#1BCDFC"><svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle"> <path fill="#cccccc" d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path> </svg></a><a class="nav-item" title="力扣" target="_blank" rel="noopener" href="https://leetcode.cn/u/dong7/" style="color:#3DC550"><svg width="59" height="22" viewBox="0 0 59 22" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-full w-auto max-w-none"> <path fill-rule="evenodd" clip-rule="evenodd" d="M27.8226 17.4752C28.3202 16.1443 28.7218 14.5458 28.9859 12.6607C29.1277 11.6491 29.2845 10.1658 29.4568 8.20813H35.2561C35.2637 8.20813 35.2713 8.20828 35.2789 8.20857C35.6071 8.22119 35.8628 8.49743 35.8502 8.82558L35.4996 17.9427C35.4873 18.262 35.2249 18.5144 34.9054 18.5144H33.2974C32.8595 18.5144 32.5046 18.8694 32.5046 19.3072C32.5046 19.7451 32.8595 20.1 33.2974 20.1H35.4776C36.3533 20.1 37.0631 19.3901 37.0631 18.5144L37.4595 8.20813C37.4595 7.33244 36.7497 6.62254 35.874 6.62254H29.5913C29.671 5.65054 29.7537 4.58575 29.8394 3.42794C29.8718 2.99129 29.544 2.61109 29.1074 2.57874C28.6707 2.54639 28.2905 2.87414 28.2582 3.3108C28.1689 4.51669 28.0829 5.62069 28.0004 6.62254H25.3695C24.9316 6.62254 24.5767 6.97749 24.5767 7.41534C24.5767 7.85318 24.9316 8.20813 25.3695 8.20813H27.8651C27.7 10.07 27.5501 11.4816 27.4157 12.4407C27.1674 14.2124 26.7941 15.6986 26.3374 16.9199C26.0981 17.5599 25.8527 18.0822 25.6163 18.4944C25.5366 18.6333 25.4649 18.7474 25.4029 18.8378C25.3703 18.8853 25.3512 18.9109 25.3475 18.9155C25.0722 19.256 25.1252 19.7552 25.4657 20.0305C25.8062 20.3057 26.3054 20.2528 26.5806 19.9123C26.6737 19.7971 26.8159 19.5898 26.9917 19.2833C27.271 18.7963 27.5531 18.1959 27.8226 17.4752ZM48.5586 17.3184V7.72969H55.6831C56.3474 7.72969 56.883 8.26047 56.883 8.9117V16.4576C56.883 17.1088 56.3474 17.6396 55.6831 17.6396H53.3916C52.7274 17.6396 52.1918 17.1088 52.1918 16.4576V10.1081C52.1918 9.67022 51.8369 9.31528 51.399 9.31528C50.9612 9.31528 50.6062 9.67022 50.6062 10.1081V16.4576C50.6062 17.9877 51.8548 19.2252 53.3916 19.2252H55.6831C57.2199 19.2252 58.4686 17.9877 58.4686 16.4576V8.9117C58.4686 7.38157 57.2199 6.14411 55.6831 6.14411H48.5586V3.76573C48.5586 3.32788 48.2037 2.97294 47.7658 2.97294C47.328 2.97294 46.9731 3.32788 46.9731 3.76573V6.14411H44.1983C43.7604 6.14411 43.4055 6.49905 43.4055 6.9369C43.4055 7.37475 43.7604 7.72969 44.1983 7.72969H46.9731V12.465L44.3002 13.5341C43.8937 13.6968 43.696 14.1581 43.8586 14.5647C44.0212 14.9712 44.4826 15.1689 44.8891 15.0063L46.9731 14.1727V17.3184C46.9731 18.3666 46.0906 19.2252 44.9911 19.2252C44.5532 19.2252 44.1983 19.5801 44.1983 20.018C44.1983 20.4558 44.5532 20.8108 44.9911 20.8108C46.9567 20.8108 48.5586 19.2522 48.5586 17.3184Z" fill="white"></path> <path d="M13.3797 16.4636C13.874 15.9701 14.674 15.9714 15.1667 16.4665C15.6593 16.9616 15.6581 17.7631 15.1638 18.2566L12.9691 20.4481C10.9443 22.4699 7.64261 22.4992 5.58369 20.5162C5.57179 20.5048 4.655 19.6058 1.63058 16.6402C-0.381491 14.6673 -0.581941 11.5104 1.31147 9.4831L4.84172 5.7031C6.7209 3.69085 10.1849 3.47093 12.3335 5.20847L15.5398 7.80152C16.0828 8.24065 16.1676 9.03757 15.7292 9.58151C15.2909 10.1254 14.4953 10.2104 13.9523 9.77127L10.746 7.17824C9.62238 6.26954 7.65677 6.39434 6.68718 7.43259L3.15688 11.2126C2.23512 12.1996 2.33607 13.7895 3.39833 14.8311C5.61922 17.0088 7.33084 18.6871 7.33282 18.689C8.40324 19.72 10.134 19.7046 11.185 18.6551L13.3797 16.4636Z" fill="#FFA116"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M8.04824 14.2706C7.35039 14.2706 6.78467 13.7039 6.78467 13.0048C6.78467 12.3057 7.35039 11.739 8.04824 11.739H17.3671C18.0649 11.739 18.6306 12.3057 18.6306 13.0048C18.6306 13.7039 18.0649 14.2706 17.3671 14.2706H8.04824Z" fill="#B3B3B3"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M9.79343 0.401024C10.2702 -0.109469 11.0698 -0.136141 11.5794 0.34145C12.089 0.819042 12.1156 1.62004 11.6389 2.13054L3.15692 11.2126C2.23513 12.1995 2.33608 13.7894 3.39827 14.831L7.31536 18.6721C7.81405 19.1611 7.82258 19.9625 7.33442 20.4621C6.84626 20.9616 6.04626 20.9702 5.54757 20.4812L1.63046 16.6401C-0.381492 14.6671 -0.581942 11.5102 1.31155 9.48305L9.79343 0.401024Z" fill="white"></path> </svg></a><a class="nav-item" title="知识星球" target="_blank" rel="noopener" href="https://wx.zsxq.com/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="语雀" target="_blank" rel="noopener" href="https://www.yuque.com/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="sidebar-check-in">
    <div id="sidebar-check-in-calendar"></div>
</div>
<div class="widgets">
<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">专栏：学习博客</span></div><div class="widget-body"><a class="item" href="/2025/10/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">SQL刷题笔记</span></a><a class="item" href="/2025/10/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">微服务学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">操作系统学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">设计模式学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">分布式学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">RocketMQ学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">MyBatis学习笔记</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Linux学习笔记</span></a><a class="item" href="/2025/09/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%AE%80%E5%8E%86%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="title">简历对应的一些知识点</span></a><a class="item" href="/2025/09/09/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Elasticsearch(ES)%E4%B8%8B%E8%BD%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><span class="title">Elasticsearch(ES)下载使用指南</span></a><a class="item" href="/2025/09/09/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%AE%80%E5%8E%86%E5%AD%98%E6%A1%A3/"><span class="title">简历存档</span></a><a class="item" href="/2025/08/30/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/git%E7%A7%98%E9%92%A5%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86/"><span class="title">Redis学习笔记</span></a><a class="item" href="/2025/08/08/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java并发编程学习笔记</span></a><a class="item" href="/2025/08/06/3DGS/SSH%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"><span class="title">SSH远程调用开发环境</span></a><a class="item" href="/2025/08/05/3DGS/Ubuntu20%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%ACCUDA/"><span class="title">Ubuntu20使用多个版本CUDA</span></a><a class="item" href="/2025/08/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Thymeleaf%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"><span class="title">Thymeleaf模版引擎</span></a><a class="item" href="/2025/08/01/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架学习笔记</span></a><a class="item" href="/2025/07/30/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Natapp/"><span class="title">Natapp内网穿透使用</span></a><a class="item" href="/2025/07/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"><span class="title">微信扫码登录</span></a><a class="item" href="/2025/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%81%B5%E8%8C%B6%E5%B1%B1%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">灵茶山算法基础笔记</span></a><a class="item" href="/2025/07/25/Go%E5%9F%BA%E7%A1%80/Go%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">Go基础笔记</span></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Redis学习笔记</span></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JavaSE学习笔记</span></a><a class="item" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/"><span class="title">程序员养生指南</span></a><a class="item active" href="/2025/07/14/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">计算机网络学习笔记</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item" href="/2025/07/12/3DGS/%E4%BD%BF%E7%94%A8Postshot%E8%AE%AD%E7%BB%833DGS%E6%B5%81%E7%A8%8B/"><span class="title">使用Postshot训练3DGS模型流程</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/MybatisPlus%E7%AC%94%E8%AE%B0/"><span class="title">MybatisPlus笔记</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/%E8%B7%A8%E5%9F%9F%E6%94%AF%E6%8C%81%E7%AC%94%E8%AE%B0/"><span class="title">跨域支持笔记</span></a><a class="item" href="/2025/06/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/TecHub%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">TecHub项目笔记</span></a><a class="item" href="/2025/06/24/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"><span class="title">技术派项目环境问题</span></a><a class="item" href="/2025/06/24/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-2D%E8%B6%B3%E7%90%83Demo/"><span class="title">游戏开发-2D足球Demo</span></a><a class="item" href="/2025/06/24/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unitu%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"><span class="title">Unity游戏开发笔记</span></a><a class="item" href="/2025/06/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82B%E6%A0%91/"><span class="title">一次性搞懂B树</span></a><a class="item" href="/2025/06/12/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Spring学习笔记</span></a><a class="item" href="/2025/06/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/nvm%E6%9B%B4%E6%94%B9node%E7%89%88%E6%9C%AC/"><span class="title">nvm更改node版本</span></a><a class="item" href="/2025/06/11/3DGS/3DGS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">3DGS学习笔记</span></a><a class="item" href="/2025/06/11/3DGS/3DGS-Ubuntu%E7%8E%AF%E5%A2%83/"><span class="title">3DGS-Ubuntu环境.md</span></a><a class="item" href="/2025/06/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Mysql学习笔记</span></a><a class="item" href="/2025/06/10/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架笔记</span></a><a class="item" href="/2025/06/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记</span></a><a class="item" href="/2025/06/07/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%AF%87/"><span class="title">Java并发篇</span></a><a class="item" href="/2025/06/06/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%88%96%E6%93%8D%E4%BD%9C/"><span class="title">好用的快捷键和操作</span></a><a class="item" href="/2025/06/06/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/java30%E5%A4%A9%E7%AC%94%E8%AE%B0/"><span class="title">java30天学习笔记</span></a><a class="item" href="/2025/06/05/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/hello-world/"><span class="title">Hello World</span></a><a class="item" href="/2025/06/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">技术派项目笔记</span></a><a class="item" href="/2025/06/02/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span class="title">个人博客搭建</span></a><a class="item" href="/2025/06/01/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RabbitMQ%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/"><span class="title">RabbitMQ项目使用</span></a><a class="item" href="/2025/06/01/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%A8%A1%E7%89%88/"><span class="title">博客模板</span></a><a class="item" href="/2025/06/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">算法学习笔记</span></a></div></widget>

<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/10/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">SQL刷题笔记</span></a><a class="item title" href="/2025/10/13/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.13%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.13学习日记</span></a><a class="item title" href="/2025/06/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">算法学习笔记</span></a><a class="item title" href="/2025/06/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Mysql学习笔记</span></a><a class="item title" href="/2025/10/12/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.12%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.12学习日记</span></a><a class="item title" href="/2025/10/11/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.11学习日记</span></a><a class="item title" href="/2025/10/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记</span></a><a class="item title" href="/2025/10/10/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.10%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.10学习日记</span></a><a class="item title" href="/2025/08/08/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java并发编程学习笔记</span></a><a class="item title" href="/2025/10/09/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B410%E6%9C%88/2025.10.9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">2025.10.9学习日记</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/10/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">学习博客</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-07-13T16:00:00.000Z">2025-07-14</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-07-22T01:46:06.712Z">2025-07-22</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>计算机网络学习笔记</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content slide-up"><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="1-计算机网络体系的结构"><a href="#1-计算机网络体系的结构" class="headerlink" title="1.计算机网络体系的结构"></a>1.计算机网络体系的结构</h3><p>计算机网络体系结构通过将复杂的网络通信分解成不同的层次，来标准化交互的过程。常见的模型包括 <code>OSI 七层模型</code>、<code>TCP/IP 四层模型</code>和<code>五层体系结构</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714102442.png" alt="20250714102442"></p>
<p>OSI 是理论上的网络通信模型，TCP&#x2F;IP 是实际应用层面上的网络通信模型，五层结构是为了方便理解和记忆。</p>
<h4 id="说说-OSI-七层模型？"><a href="#说说-OSI-七层模型？" class="headerlink" title="说说 OSI 七层模型？"></a>说说 OSI 七层模型？</h4><p>OSI（Open System Interconnection）七层参考模型是一个网络架构模型，由国际标准化组织（ISO）提出，用于描述和标准化各种计算机网络的功能和过程。这七层从高到低分别是：</p>
<ul>
<li><strong>应用层</strong>：最靠近用户的层，负责处理特定的应用程序细节。这一层提供了网络服务与用户应用软件之间的接口。  例如，Web 浏览器、FTP 客户端和服务器、电子邮件客户端等。</li>
<li><strong>表示层</strong>：确保从一个系统发送的信息可以被另一个系统的应用层读取。它负责数据的转换、压缩和加密。   例如，确保数据从一种编码格式转换为另一种，如 ASCII 到 EBCDIC。</li>
<li><strong>会话层</strong>：管理用户的会话，控制网络上两节点间的对话和数据交换的管理。它负责建立、维护和终止会话。  例如，建立一个会话令牌，以便在网络上的两个节点之间传递。</li>
<li><strong>传输层</strong>：提供端到端的通信服务，保证数据的完整性和正确顺序。这一层包括 <code>TCP</code> 和 <code>UDP</code> 等。</li>
<li><strong>网络层</strong>：负责在多个网络之间进行数据传输，确保数据能够在复杂的网络结构中找到从源到目的地的最佳路径。这层使用的是 <code>IP（Internet Protocol）协议</code>。</li>
<li><strong>数据链路层</strong>：在物理连接中提供可靠的传输，负责建立和维护两个相邻节点间的链路。包括帧同步、MAC（媒体访问控制）。</li>
<li><strong>物理层</strong>：负责在物理媒介上实现原始的数据传输，比如电缆、光纤和无线信号传输。涉及的内容包括电压、接口、针脚、电缆的规格和传输速率等。</li>
</ul>
<h4 id="说说-TCP-IP-四层模型？"><a href="#说说-TCP-IP-四层模型？" class="headerlink" title="说说 TCP&#x2F;IP 四层模型？"></a>说说 TCP&#x2F;IP 四层模型？</h4><p>TCP&#x2F;IP 四层模型是互联网通信的核心，定义了一系列协议和标准，确保设备间可以可靠地进行数据传输。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714103206.png" alt="20250714103206"></p>
<p>①、<strong>应用层（Application Layer）</strong>：直接面向用户和应用程序，提供各种网络服务。它包含了用于特定应用的协议和服务，如 HTTP（HyperText Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。</p>
<p>示例：当在浏览器中输入一个 URL 并访问一个网页时，浏览器使用 HTTP 协议从 Web 服务器请求页面内容。</p>
<p>②、<strong>传输层（Transport Layer）</strong>：提供端到端的通信服务，确保数据可靠传输。它负责分段数据、流量控制、错误检测和纠正。常见的传输层协议有 <code>TCP</code> 和 <code>UDP</code>。</p>
<p>示例：当发送一封电子邮件时，TCP 协议确保邮件从你的客户端可靠地传输到邮件服务器。</p>
<p>③、<strong>网际层</strong>：或者叫网络层（Internet Layer），负责在不同网络之间路由数据包，提供逻辑地址（IP 地址）和网络寻址功能。用于处理数据包的分组、转发和路由选择，确保数据可以从源端传输到目标端。</p>
<p>常见协议：<code>IPv4</code>、<code>IPv6</code>、<code>ICMP（Internet Control Message Protocol）</code>。</p>
<p>示例：当访问一个网站时，网络层协议（如 IPv4）将你的请求从你的计算机通过多个路由器传输到目标服务器。</p>
<p>④、<strong>网络接口层（Network Access Layer）</strong>：或者叫链路层（Link Layer），负责将数字信号在物理通道（网线）中准确传输，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。</p>
<p>常见协议：以太网（Ethernet）、Wi-Fi。</p>
<p>示例：在一个局域网（LAN）中，计算机通过以太网连接交换机，链路层协议负责数据帧在网络设备间的传输。</p>
<h4 id="说说五层体系结构？"><a href="#说说五层体系结构？" class="headerlink" title="说说五层体系结构？"></a>说说五层体系结构？</h4><p>是对 OSI 和 TCP&#x2F;IP 的折衷，它保留了 TCP&#x2F;IP 的实用性，同时提供了比四层模型更细致的分层，便于教学和理解网络的各个方面。</p>
<ul>
<li>应用层：作为网络服务和最终用户之间的接口。它提供了一系列供应用程序使用的协议，如 HTTP（网页）、FTP（文件传输）、SMTP（邮件传输）等。使用户的应用程序可以访问网络服务。</li>
<li>传输层：提供进程到进程的通信管理，这一层确保数据按顺序、无错误地传输。主要协议包括 TCP 和 UDP。</li>
<li>网络层：负责数据包从源到目的地的传输和路由选择，包括跨越多个网络（即互联网）。它使用逻辑地址（如 IP 地址）来唯一标识设备。路由器是网络层设备。</li>
<li>数据链路层：确保从一个节点到另一个节点的可靠、有效的数据传输。交换机、网桥是数据链路层设备。</li>
<li>物理层：电缆、光纤、无线电频谱、网络适配器等。</li>
</ul>
<h4 id="TCP三次握手四次挥手工作在哪一层？"><a href="#TCP三次握手四次挥手工作在哪一层？" class="headerlink" title="TCP三次握手四次挥手工作在哪一层？"></a>TCP三次握手四次挥手工作在哪一层？</h4><p>三次握手和四次挥手都是工作在<strong>传输层</strong>。<code>传输层（Transport Layer）</code>是 OSI 模型的第四层，负责提供端到端的通信服务，包括数据传输的建立、维护和终止。</p>
<p><code>TCP</code> 作为一种面向连接的协议，通过<strong>三次握手建立连接</strong>，通过<strong>四次挥手终止连接</strong>，确保数据传输的可靠性和完整性。</p>
<h4 id="讲一下计算机网络？"><a href="#讲一下计算机网络？" class="headerlink" title="讲一下计算机网络？"></a>讲一下计算机网络？</h4><p>计算机网络是指将多台计算机通过通信设备互联起来，实现资源共享和信息传递的系统。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714103951.png" alt="20250714103951"></p>
<h3 id="2-说一下每一层对应的网络协议有哪些？"><a href="#2-说一下每一层对应的网络协议有哪些？" class="headerlink" title="2.说一下每一层对应的网络协议有哪些？"></a>2.说一下每一层对应的网络协议有哪些？</h3><p>一张表格总结常见网络协议：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104012.png" alt="20250714104012"></p>
<h3 id="3-那么数据在各层之间是怎么传输的呢？"><a href="#3-那么数据在各层之间是怎么传输的呢？" class="headerlink" title="3.那么数据在各层之间是怎么传输的呢？"></a>3.那么数据在各层之间是怎么传输的呢？</h3><p>对于发送方而言，从<strong>上层到下层层层包装</strong>，对于接收方而言，从<strong>下层到上层，层层解开包装</strong>。</p>
<ul>
<li>发送方的应用进程向接收方的应用进程传送数据</li>
<li>AP 先将数据交给本主机的应用层，应用层加上本层的控制信息 H5 就变成了下一层的数据单元</li>
<li>传输层收到这个数据单元后，加上本层的控制信息 H4，再交给网络层，成为网络层的数据单元</li>
<li>到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）</li>
<li>最后的物理层，进行比特流的传输</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104213.png" alt="20250714104213"></p>
<p>这个过程类似写信，写一封信，每到一层，就加一个信封，写一些地址的信息。到了目的地之后，又一层层解封，传向下一个目的地。</p>
<h2 id="网络综合"><a href="#网络综合" class="headerlink" title="网络综合"></a>网络综合</h2><h3 id="4-从浏览器地址栏输入-url-到显示网页的过程了解吗？"><a href="#4-从浏览器地址栏输入-url-到显示网页的过程了解吗？" class="headerlink" title="4.从浏览器地址栏输入 url 到显示网页的过程了解吗？"></a>4.从浏览器地址栏输入 url 到显示网页的过程了解吗？</h3><p>这个过程包括多个步骤，涵盖了 <code>DNS 解析</code>、<code>TCP 连接</code>、<code>发送 HTTP 请求</code>、<code>服务器处理请求并返回 HTTP 响应</code>、<code>浏览器处理响应并渲染页面</code>等多个环节。</p>
<ol>
<li><strong>DNS 解析</strong>：浏览器会发起一个 DNS 请求到 DNS 服务器，将域名解析为服务器的 IP 地址。</li>
<li><strong>TCP 连接</strong>：浏览器通过解析得到的 IP 地址与服务器建立 TCP 连接。这一步涉及到 TCP 的三次握手，用于确保双方都已经准备好进行数据传输了。</li>
<li><strong>发送 HTTP 请求</strong>：浏览器构建 HTTP 请求，包括请求行、请求头和请求体；然后将请求发送到服务器。</li>
<li><strong>服务器处理请求</strong>：服务器接收到 HTTP 请求后，根据请求的资源路径，经过后端处理，生成 HTTP 响应消息；响应消息包括状态行、响应头和响应体。</li>
<li><strong>浏览器接收 HTTP 响应</strong>：浏览器接收到服务器返回的 HTTP 响应数据后，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。</li>
<li><strong>断开连接</strong>：TCP 四次挥手，连接结束。</li>
</ol>
<p>我们以输入 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 为例：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104653.png" alt="20250714104653"></p>
<h4 id="各个过程都使用了哪些协议？"><a href="#各个过程都使用了哪些协议？" class="headerlink" title="各个过程都使用了哪些协议？"></a>各个过程都使用了哪些协议？</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104751.png" alt="20250714104751"></p>
<h3 id="5-说说-DNS-的解析过程？"><a href="#5-说说-DNS-的解析过程？" class="headerlink" title="5.说说 DNS 的解析过程？"></a>5.说说 DNS 的解析过程？</h3><p><code>DNS</code> 的全称是 Domain Name System，也就是<code>域名解析系统</code>，它可以将域名映射到对应的 IP 地址上，比如说我们访问 <a target="_blank" rel="noopener" href="http://www.javabetter.cn,实际上访问的是我在阿里云上一台丐版服务器,它的/">www.javabetter.cn，实际上访问的是我在阿里云上一台丐版服务器，它的</a> IP 地址是 xxx.xxx.xxx.xxx。</p>
<p>当然了，也可以通过 IP 地址直接访问服务器，但不方便记忆，所以就有了域名系统。一个好的域名可以卖好多好多钱，像 javabetter.cn 这个域名，一年需要 39 块钱。</p>
<p>域名到 IP 之间的映射，就需要 DNS 来完成。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104925.png" alt="20250714104925"></p>
<p>我来说说 DNS 的解析过程吧：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104947.png" alt="20250714104947"></p>
<p>假设我们在浏览器地址栏里键入了 paicoding.com：</p>
<p>浏览器会首先检查<strong>自己的缓存中是否有这个域名对应的 IP 地址</strong>，如果有，直接返回；如果没有，进入下一步。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714105341.png" alt="20250714105341"></p>
<p>检查<strong>本地 DNS 缓存是否有该域名的记录</strong>。如果没有，向根域名服务器发送请求，根域名服务器将请求指向更具体的服务，如 com 顶级域名服务器。</p>
<p>顶级域名服务器再将请求指向权限域名服务器，通常由域名注册机构直接管理，paicoding.com是在阿里云上注册的，所以阿里云会提供对应的 DNS 解析服务，将域名和阿里云服务器绑定起来。</p>
<p>最终，浏览器使用获得的 IP 地址发起一个 HTTP 请求到目标服务器，然后该服务器返回所请求的网页内容。</p>
<h3 id="6-说说-WebSocket-与-Socket-的区别？"><a href="#6-说说-WebSocket-与-Socket-的区别？" class="headerlink" title="6.说说 WebSocket 与 Socket 的区别？"></a>6.说说 WebSocket 与 Socket 的区别？</h3><ul>
<li>Socket 其实就是等于 <strong>IP 地址 + 端口 + 协议</strong>。</li>
</ul>
<blockquote>
<p>具体来说，Socket 是一套标准，它完成了对 TCP&#x2F;IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。</p>
</blockquote>
<ul>
<li><code>WebSocket</code> 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决 <strong>http 不支持持久化连接</strong>的问题。</li>
<li><code>Socket</code> 一个是<strong>网编编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</li>
</ul>
<h3 id="7-说一下你了解的端口及对应的服务？"><a href="#7-说一下你了解的端口及对应的服务？" class="headerlink" title="7.说一下你了解的端口及对应的服务？"></a>7.说一下你了解的端口及对应的服务？</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714105809.png" alt="20250714105809"></p>
<h3 id="8-平常有抓包吗（补充）？"><a href="#8-平常有抓包吗（补充）？" class="headerlink" title="8.平常有抓包吗（补充）？"></a>8.平常有抓包吗（补充）？</h3><p>我平常使用最多的就是 chrome 浏览器自带的 network 面板了，可以看到<code>请求的时间</code>、<code>请求的信息</code>，以及<code>响应信息</code>。</p>
<p>更专业的还有 <code>fidder</code>、<code>wireshark</code> 等工具。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="8-说说-HTTP-常用的状态码及其含义？"><a href="#8-说说-HTTP-常用的状态码及其含义？" class="headerlink" title="8.说说 HTTP 常用的状态码及其含义？"></a>8.说说 HTTP 常用的状态码及其含义？</h3><p>HTTP 状态码用于表示服务器对<code>请求的处理结果</code>，可以分为 5 种：</p>
<ul>
<li><code>1xx</code> 服务器收到请求，需要进一步操作，例如 100 Continue。</li>
<li><code>2xx</code> 请求成功处理，例如 200 OK。</li>
<li><code>3xx</code> 重定向：需要进一步操作以完成请求；例如 304 Not Modified 表示资源未修改，客户端可以使用缓存。</li>
<li><code>4xx</code> 客户端错误：请求有问题，例如 404 Not Found 表示资源不存在。</li>
<li><code>5xx</code> 服务器错误，例如500 Internal Server Error 表示服务器内部错误。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714110047.png" alt="20250714110047"></p>
<h4 id="说一下-301-和-302-的区别？"><a href="#说一下-301-和-302-的区别？" class="headerlink" title="说一下 301 和 302 的区别？"></a>说一下 301 和 302 的区别？</h4><ul>
<li>301：永久性移动，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址。</li>
<li>302：临时性性移动，服务器从另外的地址响应资源，但是客户端还应该使用这个地址。</li>
</ul>
<p>用一个比喻，301 就是嫁人的新垣结衣，302 就是有男朋友的长泽雅美。</p>
<h3 id="9-HTTP-有哪些请求方式？"><a href="#9-HTTP-有哪些请求方式？" class="headerlink" title="9.HTTP 有哪些请求方式？"></a>9.HTTP 有哪些请求方式？</h3><p>HTTP 协议定义了多种请求方式，用以指示请求的目的。常见的请求方式有 <code>GET</code>、<code>POST</code>、<code>DELETE</code>、<code>PUT</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714110428.png" alt="20250714110428"></p>
<ul>
<li><code>GET</code>：请求检索指定的资源。应该只用于获取数据，并且是<strong>幂等的</strong>，即多次执行相同的 GET 请求应该返回相同的结果，并且<strong>不会改变资源的状态</strong>。</li>
<li><code>POST</code>：向指定资源提交数据，请求服务器进行处理（如提交表单或上传文件）。数据被包含在请求体中。<strong>可能会创建新的资源或修改现有资源</strong>。</li>
<li><code>DELETE</code>：<strong>删除</strong>指定的资源。</li>
<li><code>PUT</code>：用于替换指定的资源。如果指定的资源不存在，创建一个新资源。</li>
<li><code>HEAD</code>：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。可以用于检查资源是否存在，验证资源的更新时间等。</li>
<li><code>OPTIONS</code>：用于获取服务器支持的 HTTP 请求方法。通常用于跨域请求中的预检请求（CORS）。</li>
<li><code>TRACE</code>：<strong>回显服务器收到的请求</strong>，主要用于测试或诊断。但由于安全风险（可能暴露敏感信息），很多服务器会禁用 TRACE 请求。</li>
<li><code>CONNECT</code>：建立一个到目标资源的隧道（通常用于 SSL&#x2F;TLS 代理），用于在客户端和服务器之间进行加密的隧道传输。</li>
</ul>
<h4 id="HTTP-的-GET-方法可以实现写操作吗"><a href="#HTTP-的-GET-方法可以实现写操作吗" class="headerlink" title="HTTP 的 GET 方法可以实现写操作吗?"></a>HTTP 的 GET 方法可以实现写操作吗?</h4><p>可以是可以，但是不推荐。</p>
<p>使用 GET 执行写操作可能导致严重的安全问题，如跨站请求伪造（CSRF）。<br>实际开发中，也应该<strong>杜绝使用 GET 方法执行写操作</strong>。<br>通过在项目接口上明确指出需要的请求方式.<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714111209.png" alt="20250714111209"></p>
<p>客户端一旦使用错误❎，将会收到一个 <code>405 Method Not Allowed</code> 的响应。</p>
<h4 id="什么是幂等？幂等方法了解哪些？"><a href="#什么是幂等？幂等方法了解哪些？" class="headerlink" title="什么是幂等？幂等方法了解哪些？"></a>什么是幂等？幂等方法了解哪些？</h4><p><code>幂等（Idempotence）</code>是一个数学概念，用于描述某些操作的特性，<strong>即无论操作执行多少次，结果都是相同的</strong>。换句话说，幂等操作可以重复执行而不会改变系统状态。</p>
<p>如果一个操作是幂等的，那么对同一资源执行该操作一次和执行多次的效果相同。</p>
<p>在正确实现的条件下，<code>GET</code>、<code>HEAD</code>、<code>PUT</code>和 <code>DELETE</code> 等方法都是幂等的，而 <code>POST</code> 方法不是。</p>
<p>例如，<code>GET /pageX HTTP/1.1</code> 幂等的。连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br></pre></td></tr></table></figure>

<p><code>DELETE /idX/delete HTTP/1.1</code> 是幂等的，<strong>即便是不同请求之间接收到的状态码不一样</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure>

<h3 id="10-说⼀下-GET-和-POST-的区别？"><a href="#10-说⼀下-GET-和-POST-的区别？" class="headerlink" title="10.说⼀下 GET 和 POST 的区别？"></a>10.说⼀下 GET 和 POST 的区别？</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714111527.png" alt="20250714111527"></p>
<p><code>GET</code> 请求主要用于<strong>获取数据</strong>，<strong>参数附加在 URL 中</strong>，存在<strong>长度限制</strong>，且容易被浏览器缓存，有安全风险；<br><code>POST</code> 请求用于提交数据，<strong>参数放在请求体中</strong>，适合提交大量或敏感的数据。</p>
<p>另外，GET 请求是<strong>幂等的</strong>，多次请求不会改变服务器状态；而 POST 请求<strong>不是幂等的</strong>，可能对服务器数据有影响。</p>
<h3 id="11-GET-的长度限制是多少？"><a href="#11-GET-的长度限制是多少？" class="headerlink" title="11.GET 的长度限制是多少？"></a>11.GET 的长度限制是多少？</h3><p>HTTP 中的 <code>GET</code> 方法是通过 URL 传递数据的，但是 URL 本身其实并没有对数据的长度进行限制，真正限制 <code>GET</code> 长度的是<strong>浏览器</strong>。</p>
<p>例如 IE 浏览器对 URL 的最大限制是 2000 多个字符，大概 2kb 左右，像 Chrome、Firefox 等浏览器支持的 URL 字符数更多，其中 FireFox 中 URL 的最大长度限制是 65536 个字符，Chrome 则是 8182 个字符。</p>
<p>这个长度限制也不是针对数据部分，<strong>而是针对整个 URL</strong>。</p>
<h3 id="12-HTTP-请求的过程与原理？"><a href="#12-HTTP-请求的过程与原理？" class="headerlink" title="12.HTTP 请求的过程与原理？"></a>12.HTTP 请求的过程与原理？</h3><p>HTTP 是基于 <code>TCP/IP</code> 协议的<strong>应用层协议</strong>，它使用 <code>TCP</code> 作为传输层协议，通过建立 <code>TCP</code> 连接来传输数据。<br>HTTP 遵循标准的<strong>客户端-服务器模型</strong>，客户端打开连接发出请求，然后等待服务器返回的响应。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714111725.png" alt="20250714111725"></p>
<ul>
<li>在浏览器输入 URL 后，浏览器首先会通过 DNS 解析获取到服务器的 IP 地址，然后与服务器建立 TCP 连接。</li>
<li>TCP 连接建立后，浏览器会向服务器发送 HTTP 请求。</li>
<li>服务器收到请求后，会根据请求的信息处理请求。</li>
<li>处理完请求后，服务器会返回一个 HTTP 响应给浏览器。</li>
<li>浏览器收到响应后，会根据响应的信息渲染页面。然后，浏览器和服务器断开 TCP 连接。</li>
</ul>
<p>客户端发送一个请求到服务器，服务器处理请求并返回一个响应。这个过程是同步的，也就是说，客户端在发送请求后必须等待服务器的响应。在等待响应的过程中，客户端不会发送其他请求。</p>
<h4 id="怎么利用多线程来下载一个数据呢？"><a href="#怎么利用多线程来下载一个数据呢？" class="headerlink" title="怎么利用多线程来下载一个数据呢？"></a>怎么利用多线程来下载一个数据呢？</h4><p>可以采取分块下载的策略。首先，通过 HEAD 请求获取文件的总大小。然后根据文件大小和线程数，将文件进行切割。每个线程负责下载一个特定范围的数据。</p>
<p>可以通过设置 HTTP 请求头的 Range 字段指定下载的字节区间。例如，Range: bytes&#x3D;0-1023 表示下载文件的前 1024 字节。</p>
<p>最后启动多线程下载。</p>
<p>代码片段 1：获取文件大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://javabetter.cn/file.zip&quot;</span>);</span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">connection.setRequestMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">fileSize</span> <span class="operator">=</span> connection.getContentLength(); <span class="comment">// 获取文件大小</span></span><br><span class="line">connection.disconnect();</span><br></pre></td></tr></table></figure>
<p>代码片段 2：下载文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downloadChunk</span><span class="params">(String url, <span class="type">int</span> start, <span class="type">int</span> end, String outputPath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">fileUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (HttpURLConnection) fileUrl.openConnection();</span><br><span class="line">        connection.setRequestProperty(<span class="string">&quot;Range&quot;</span>, <span class="string">&quot;bytes=&quot;</span> + start + <span class="string">&quot;-&quot;</span> + end);</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> connection.getInputStream();</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(outputPath, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        file.seek(start); <span class="comment">// 定位到文件的相应位置</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> bytesRead;</span><br><span class="line">        <span class="keyword">while</span> ((bytesRead = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            file.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        connection.disconnect();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码片段 3：启动多线程下载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">fileSize</span> <span class="operator">=</span> <span class="number">100000000</span>; <span class="comment">// 假设文件大小为 100MB</span></span><br><span class="line"><span class="type">int</span> <span class="variable">chunkSize</span> <span class="operator">=</span> fileSize / numThreads;</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://javabetter.cn/file.zip&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">outputPath</span> <span class="operator">=</span> <span class="string">&quot;path/to/local/file.zip&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(numThreads);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i * chunkSize;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> (i == numThreads - <span class="number">1</span>) ? fileSize - <span class="number">1</span> : (start + chunkSize - <span class="number">1</span>);</span><br><span class="line">    executor.execute(() -&gt; downloadChunk(url, start, end, outputPath));</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714112439.png" alt="20250714112439"></p>
<h4 id="如果只要下载数据的前十个字节呢？"><a href="#如果只要下载数据的前十个字节呢？" class="headerlink" title="如果只要下载数据的前十个字节呢？"></a>如果只要下载数据的前十个字节呢？</h4><p>只需要设置 Range 字段为 Range: bytes&#x3D;0-9 即可。</p>
<h3 id="13-说一下-HTTP-的报文结构？"><a href="#13-说一下-HTTP-的报文结构？" class="headerlink" title="13.说一下 HTTP 的报文结构？"></a>13.说一下 HTTP 的报文结构？</h3><p>HTTP 的报文结构分为：<code>请求报文</code>和<code>响应报文</code>。两者在结构上很相似，都包含了<strong>起始行、头部和消息正文</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715095105.png" alt="20250715095105"></p>
<h4 id="说下-HTTP-的请求报文结构？"><a href="#说下-HTTP-的请求报文结构？" class="headerlink" title="说下 HTTP 的请求报文结构？"></a>说下 HTTP 的请求报文结构？</h4><p>请求报文由请求行、请求头部、空行和消息正文组成。如下所示：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.javabetter.cn</span><br><span class="line"><span class="attribute">Accept</span>: text/html</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br></pre></td></tr></table></figure>

<p>①、请求行包括请求方法、请求 URL 和 HTTP 协议的版本。例如：<code>GET /index.html HTTP/1.1</code>。</p>
<p>②、请求头部包含请求的附加信息，如客户端想要接收的内容类型、浏览器类型等。例如：</p>
<ul>
<li><code>Host: www.javabetter.cn</code>，表示请求的主机名（域名）</li>
<li><code>Accept: text/html</code>，表示客户端可以接收的媒体类型</li>
<li><code>User-Agent: Mozilla/5.0</code>，表示客户端的浏览器类型</li>
<li>Range：用于指定请求内容的范围，如断点续传时表示请求的字节范围。</li>
</ul>
<p>③、请求头部和消息正文之间有一个空行，表示请求头部结束。</p>
<p>④、消息正文是可选的，如 <code>POST</code> 请求中的表单数据；<code>GET</code> 请求中没有消息正文。</p>
<h4 id="说下-HTTP-响应报文结构？"><a href="#说下-HTTP-响应报文结构？" class="headerlink" title="说下 HTTP 响应报文结构？"></a>说下 HTTP 响应报文结构？</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br><span class="line"><span class="attribute">Content-Length</span>: 137582</span><br><span class="line"><span class="attribute">Expires</span>: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span>: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache 0.84</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;JakicDong&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>①、状态行<br>包括 HTTP 协议的版本、状态码（如 200、404）和状态消息（如 OK、NotFound）。例如：<code>HTTP/1.0 200 OK</code>。</p>
<p>②、响应头部<br>包含响应的附加信息，如服务器类型、内容类型、内容长度等。也是键值对，例如：</p>
<ul>
<li><code>Content-Type: text/plain</code>，表示响应的内容类型</li>
<li><code>Content-Length: 137582</code>，表示响应的内容长度</li>
<li><code>Expires: Thu, 05 Dec 1997 16:00:00 GMT</code>，表示资源的过期时间</li>
<li><code>Last-Modified: Wed, 5 August 1996 15:55:28 GMT</code>，表示资源的最后修改时间</li>
<li><code>Server: Apache 0.84</code>，表示服务器类型</li>
</ul>
<p>③、空行<br>表示响应头部结束。</p>
<p>④、消息正文（可选）<br>响应的具体内容，如 HTML 页面。不是所有的响应都有消息正文，如 204 No Content 状态码的响应。</p>
<h3 id="14-URI-和-URL-有什么区别"><a href="#14-URI-和-URL-有什么区别" class="headerlink" title="14.URI 和 URL 有什么区别?"></a>14.URI 和 URL 有什么区别?</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715100451.png" alt="20250715100451"></p>
<ul>
<li>URI，统一资源标识符(Uniform Resource Identifier， URI)，标识的是 Web 上每一种可用的资源，如 HTML 文档、图像、视频片段、程序等都是由一个 URI 进行标识的。</li>
<li>URL，统一资源定位符（Uniform Resource Location），它是 URI 的一种子集，主要作用是提供资源的路径。</li>
</ul>
<p>它们的主要区别在于，<code>URL</code> 除了提供了资源的标识，还提供了资源访问的方式。这么比喻，<code>URI</code> 像是身份证，可以唯一标识一个人，而 <code>URL</code> 更像一个住址，可以通过 <code>URL</code> 找到这个人——人类住址协议:&#x2F;&#x2F;地球&#x2F;中国&#x2F;北京市&#x2F;海淀区&#x2F;xx 职业技术学院&#x2F;14 号宿舍楼&#x2F;525 号寝&#x2F;张三.男。</p>
<h3 id="15-说下-HTTP1-0，1-1，2-0-的区别？"><a href="#15-说下-HTTP1-0，1-1，2-0-的区别？" class="headerlink" title="15.说下 HTTP1.0，1.1，2.0 的区别？"></a>15.说下 HTTP1.0，1.1，2.0 的区别？</h3><p><code>HTTP1.0</code> 默认是短连接，<code>HTTP 1.1</code> 默认是长连接，<code>HTTP 2.0</code> 采用的多路复用。</p>
<h4 id="说下-HTTP1-0"><a href="#说下-HTTP1-0" class="headerlink" title="说下 HTTP1.0"></a>说下 HTTP1.0</h4><ul>
<li><strong>无状态协议</strong>：HTTP 1.0 是无状态的，每个请求之间相互独立，服务器不保存任何请求的状态信息。</li>
<li><strong>非持久连接</strong>：默认情况下，每个 HTTP 请求&#x2F;响应对之后，连接会被关闭，属于短连接。这意味着对于同一个网站的每个资源请求，如 HTML 页面上的图片和脚本，都需要建立一个新的 TCP 连接。可以设置<code>Connection: keep-alive</code> 强制开启长连接。</li>
</ul>
<h4 id="说下-HTTP1-1"><a href="#说下-HTTP1-1" class="headerlink" title="说下 HTTP1.1"></a>说下 HTTP1.1</h4><ul>
<li><strong>持久连接</strong>：HTTP 1.1 引入了持久连接（也称为 HTTP keep-alive），默认情况下不会立即关闭连接，可以在一个连接上发送多个请求和响应。极大减轻了 TCP 连接的开销。</li>
<li><strong>流水线处理</strong>：HTTP 1.1 支持客户端在前一个请求的响应到达之前发送下一个请求，以提高传输效率。</li>
</ul>
<h4 id="说下-HTTP2-0"><a href="#说下-HTTP2-0" class="headerlink" title="说下 HTTP2.0"></a>说下 HTTP2.0</h4><ul>
<li><strong>二进制协议</strong>：HTTP 2.0 使用二进制而不是文本格式来传输数据，解析更加高效。</li>
<li><strong>多路复用</strong>：一个 TCP 连接上可以同时进行多个 HTTP 请求&#x2F;响应，解决了 HTTP 1.x 的队头阻塞问题。</li>
<li><strong>头部压缩</strong>：HTTP 协议不带状态，所以每次请求都必须附上所有信息。HTTP 2.0 引入了头部压缩机制，可以使用 gzip 或 compress 压缩后再发送，减少了冗余头部信息的带宽消耗。</li>
<li><strong>服务端推送</strong>：服务器可以主动向客户端推送资源，而不需要客户端明确请求。</li>
</ul>
<h3 id="16-HTTP-3-了解吗？"><a href="#16-HTTP-3-了解吗？" class="headerlink" title="16.HTTP&#x2F;3 了解吗？"></a>16.HTTP&#x2F;3 了解吗？</h3><p><code>HTTP/2.0</code> 基于 TCP 协议，而 <code>HTTP/3.0</code> 则基于 <code>QUIC</code> 协议，<code>Quick UDP Connections</code>，直译为快速 UDP 网络连接。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715101143.png" alt="20250715101143"></p>
<p>基于 TCP 的 HTTP&#x2F;2.0，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输的过程中，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，仍然会阻塞在它之后传输的流数据。</p>
<p>而基于 <code>UDP</code> 的 <code>QUIC</code> 协议可以更彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。</p>
<p>同时，<code>QUIC</code> 协议在传输的过程中就完成了 <code>TLS</code> 加密握手，更直接了。</p>
<h4 id="目前使用最广泛的是哪个HTTP版本？"><a href="#目前使用最广泛的是哪个HTTP版本？" class="headerlink" title="目前使用最广泛的是哪个HTTP版本？"></a>目前使用最广泛的是哪个HTTP版本？</h4><p>应该是 HTTP&#x2F;2，在 2022 年 1 月达到峰值，占所有网站的 46.9%。</p>
<p>统计网站：<a target="_blank" rel="noopener" href="https://w3techs.com/technologies/history_overview/site_element/all">w3techs</a></p>
<h3 id="17-HTTP-长连接了解吗？"><a href="#17-HTTP-长连接了解吗？" class="headerlink" title="17.HTTP 长连接了解吗？"></a>17.HTTP 长连接了解吗？</h3><p>在 HTTP 中，长连接是指客户端和服务器之间在一次 <code>HTTP</code> 通信完成后，不会立即断开，而是<strong>保留连接以供后续请求复用</strong>。<br>这种机制可以<strong>减少了频繁建立和关闭连接的开销</strong></p>
<h4 id="如何设置长连接？"><a href="#如何设置长连接？" class="headerlink" title="如何设置长连接？"></a>如何设置长连接？</h4><p>可以通过 <code>Connection: keep-alive</code> 实现。在 <code>HTTP/1.1</code> 中，长连接是默认开启的。</p>
<h4 id="在什么时候会超时呢？"><a href="#在什么时候会超时呢？" class="headerlink" title="在什么时候会超时呢？"></a>在什么时候会超时呢？</h4><ul>
<li>HTTP 一般会有 <code>httpd</code> 守护进程，里面可以设置 <code>keep-alive timeout</code>，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间</li>
<li>TCP 的<code> keep-alive</code> 包含三个参数，支持在系统内核的 <code>net.ipv4</code> 里面设置；当 TCP 连接之后，闲置了 <code>tcp_keepalive_time</code>，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 <code>tcp_keepalive_intvl</code> 再发一次，直到发送了 <code>tcp_keepalive_probes</code>，就会丢弃该连接。</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. tcp_keepalive_intvl = 15</span><br><span class="line">2. tcp_keepalive_probes = 5</span><br><span class="line">3. tcp_keepalive_time = 1800</span><br></pre></td></tr></table></figure>
<h3 id="18-说说-HTTP-与-HTTPS-有哪些区别？"><a href="#18-说说-HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="18.说说 HTTP 与 HTTPS 有哪些区别？"></a>18.说说 HTTP 与 HTTPS 有哪些区别？</h3><p><code>HTTPS</code> 是 <code>HTTP</code> 的增强版，在 <code>HTTP</code> 的基础上加入了 <code>SSL/TLS</code> 协议，<strong>确保数据在传输过程中是加密的</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715101851.png" alt="20250715101851"></p>
<p><code>HTTP</code> 的默认端⼝号是 <code>80</code>，<code>URL</code> 以<code>http://</code>开头；<br><code>HTTPS</code> 的默认端⼝号是 <code>443</code>，<code>URL</code> 以<code>https://</code>开头。</p>
<h3 id="19-为什么要用-HTTPS？"><a href="#19-为什么要用-HTTPS？" class="headerlink" title="19.为什么要用 HTTPS？"></a>19.为什么要用 HTTPS？</h3><p><code>HTTP</code> 是<strong>明文传输</strong>的，存在数据窃听、数据篡改和身份伪造等问题。而 <code>HTTPS</code> 通过引入 <code>SSL/TLS</code>，解决了这些问题。</p>
<p><code>SSL/TLS</code> 在加密过程中涉及到了<strong>两种类型的加密方法</strong>：</p>
<ul>
<li>非对称加密：<strong>服务器</strong>向<code>客户端</code>发送公钥，然后<code>客户端</code>用公钥加密自己的随机密钥，也就是会话密钥，发送给<strong>服务器</strong>，<strong>服务器</strong>用私钥解密，得到会话密钥。</li>
<li>对称加密：双方用会话密钥加密通信内容。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715102040.png" alt="20250715102040"></p>
<p>客户端会通过<code>数字证书</code>来验证服务器的身份，数字证书由 CA 签发，包含了服务器的公钥、证书的颁发机构、证书的有效期等。</p>
<h3 id="20-HTTPS是怎么建立连接的？"><a href="#20-HTTPS是怎么建立连接的？" class="headerlink" title="20.HTTPS是怎么建立连接的？"></a>20.HTTPS是怎么建立连接的？</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715102941.png" alt="20250715102941"></p>
<p>HTTPS 的连接建立在 <code>SSL/TLS</code> 握手之上，其过程可以分为两个阶段：<strong>握手阶段和数据传输阶段</strong>。</p>
<p>①、客户端向服务器发起请求</p>
<p>②、服务器接收到请求后，返回自己的数字证书，包含了公钥、颁发机构等信息。</p>
<p>③、客户端收到服务器的证书后，验证证书的合法性，如果合法，会生成一个随机码，然后用服务器的公钥加密这个随机码，发送给服务器。</p>
<p>④、服务器收到会话密钥后，用私钥解密，得到会话密钥。</p>
<p>⑤、客户端和服务器通过会话密码对通信内容进行加密，然后传输。</p>
<p>如果通信内容被截取，但由于没有会话密钥，所以无法解密。当通信结束后，连接会被关闭，会话密钥也会被销毁，下次通信会重新生成一个会话密钥。</p>
<h4 id="HTTPS-会加密-URL-吗？"><a href="#HTTPS-会加密-URL-吗？" class="headerlink" title="HTTPS 会加密 URL 吗？"></a>HTTPS 会加密 URL 吗？</h4><p>HTTPS 通过 <code>SSL/TLS</code> 协议确保了客户端与服务器之间交换的数据被加密，这包括 HTTP 头部和正文。</p>
<p>而 <code>URL</code> 是 HTTP 头部的一部分，因此这部分信息<strong>也是加密的</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715103149.png" alt="20250715103149"></p>
<p>但因为涉及到 <code>SSL</code> 握手的过程，所以域名信息会被暴露出来，需要注意。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715103246.png" alt="20250715103246"></p>
<p>另外，完整的 URL 可能在 Web 服务器的日志中记录，这些日志可能是明文的。还有，URL 在浏览器历史记录中也是可见的。</p>
<p>因此，<strong>敏感信息永远不应该通过 URL 传递，即使是在使用 HTTPS 的情况下</strong>。</p>
<h4 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h4><p>中间人攻击（Man-in-the-Middle, MITM）是一种常见的网络安全威胁，攻击者可以在通信的两端插入自己，以窃取通信双方的信息。</p>
<p>在很多电影中，都会存在这样的场景：主角通过某种方式，将自己伪装成中间人，然后窃取通信双方的信息，阿汤哥的碟中谍中就有很多类似的手笔。</p>
<p>中间人攻击是一个缺乏相互认证的攻击，因此大多数加密协议都会专门加入一些特殊的认证方法，以防止中间人攻击。像 SSL 协议，就是通过验证服务器的数字证书，是否由 CA（权威的受信任的数字证书认证机构）签发，来防止中间人攻击的。</p>
<h4 id="HTTPS怎么保证建立的信道是安全的？"><a href="#HTTPS怎么保证建立的信道是安全的？" class="headerlink" title="HTTPS怎么保证建立的信道是安全的？"></a>HTTPS怎么保证建立的信道是安全的？</h4><p>主要通过 SSL&#x2F;TLS 协议的多层次安全机制，首先在握手阶段，客户端和服务器使用得是<strong>非对称加密</strong>，生成的会话密钥只有服务器的私钥才能解密，而私钥只有服务器持有。</p>
<p>在数据传输阶段，即使攻击者拦截了通信数据，<strong>没有会话密钥也无法解密</strong>。</p>
<h4 id="HTTPS-能抓包吗？"><a href="#HTTPS-能抓包吗？" class="headerlink" title="HTTPS 能抓包吗？"></a>HTTPS 能抓包吗？</h4><p>可以，HTTPS 可以抓包，但因为通信内容是加密的，需要解密后才能查看。</p>
<p>其原理是通过一个中间人，<strong>伪造服务器证书</strong>，并取得客户端的信任，然后<strong>将客户端的请求转发给服务器，将服务器的响应转发给客户端，完成中间人攻击</strong>。</p>
<p>常用的抓包工具有 <code>Wireshark</code>、<code>Fiddler</code>、<code>Charles</code> 等。</p>
<h3 id="21-客户端怎么去校验证书的合法性？"><a href="#21-客户端怎么去校验证书的合法性？" class="headerlink" title="21.客户端怎么去校验证书的合法性？"></a>21.客户端怎么去校验证书的合法性？</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/74">HTTPS 握手过程中，客户端如何验证证书的合法性</a></p>
<p>首先，所有的证书都是由 CA 机构签发的，CA 机构是一个受信任的第三方机构，它会对证书的申请者进行身份验证，然后签发证书。</p>
<p>CA 就像是网络世界的公安局，具有极高的可信度。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715104158.png" alt="20250715104158"></p>
<p>CA 签发证书的过程是非常严格的：</p>
<ul>
<li>首先，CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；</li>
<li>然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 <code>Certificate Signature</code>；</li>
<li>最后将 <code>Certificate Signature</code> 添加在⽂件证书上，形成数字证书。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715104419.png" alt="20250715104419"></p>
<h3 id="22-如何理解-HTTP-协议是无状态的？"><a href="#22-如何理解-HTTP-协议是无状态的？" class="headerlink" title="22.如何理解 HTTP 协议是无状态的？"></a>22.如何理解 HTTP 协议是无状态的？</h3><p>HTTP 协议是无状态的，这意味着每个 HTTP 请求<strong>都是独立的</strong>，服务器不会保留任何关于客户端请求的历史信息。</p>
<p>换句话说，我家大门常打开，是人是神都欢迎，我不在乎，只要给钱，哦不，按规矩，一切好办。</p>
<ul>
<li>每个 <code>HTTP</code> 请求都包含了所必须的信息，服务器在处理当前请求时，<strong>不依赖于之前的任何请求信息</strong>。</li>
<li>服务器不会记录任何客户端请求的状态，<strong>每次请求都像是第一次与服务器通信</strong>。</li>
</ul>
<p>由于 HTTP 是无状态的，像用户的购物车状态就必须通过其他方式来保持，如在<strong>每次请求中传递用户的 ID</strong>，或者使用 <code>Cookie</code> 在客户端保存购物车状态。</p>
<h4 id="那有什么办法记录状态呢？"><a href="#那有什么办法记录状态呢？" class="headerlink" title="那有什么办法记录状态呢？"></a>那有什么办法记录状态呢？</h4><ol>
<li><code>Cookies</code>：服务器通过 <code>Set-Cookie</code> 响应头将状态信息存储在客户端，客户端在后续请求中发送该 Cookie 以维持状态。</li>
<li><code>Session</code>：服务器生成一个<strong>唯一的会话 ID</strong>，存储在 Cookie 中，并在服务器端维护与该会话 ID 关联的状态信息。</li>
<li><code>Token</code>：使用 JWT（JSON Web Token）等机制在客户端存储状态信息，客户端在每次请求中发送该 Token。</li>
</ol>
<h3 id="23-说说-Session-和-Cookie-有什么联系和区别"><a href="#23-说说-Session-和-Cookie-有什么联系和区别" class="headerlink" title="23.说说 Session 和 Cookie 有什么联系和区别?"></a>23.说说 Session 和 Cookie 有什么联系和区别?</h3><p>先来看看什么是 <code>Session</code> 和 <code>Cookie</code> ：</p>
<ul>
<li><code>Cookie</code> 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。<strong>服务端可以根据这个 Cookie 判断用户的身份和状态</strong>。</li>
<li><code>Session</code> 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。不同的是 <code>cookie</code> 保存在客户端浏览器中，而 <code>session</code> 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 session。客户端浏览器再次访问时只需要从该 session 中查找用户的状态。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715105420.png" alt="20250715105420"></p>
<blockquote>
<p>Session 和 Cookie 到底有什么不同呢？</p>
</blockquote>
<ul>
<li><strong>存储位置</strong>不一样，<code>Cookie</code> 保存在客户端，<code>Session</code> 保存在服务器端。</li>
<li><strong>存储数据类型</strong>不一样，<code>Cookie</code> 只能保存 ASCII，<code>Session</code> 可以存任意数据类型，一般情况下我们可以在 <code>Session</code> 中保持一些常用变量信息，比如说 <code>UserId</code> 等。</li>
<li><strong>有效期不同</strong>，<code>Cookie</code> 可设置为长时间保持，比如我们经常使用的默认登录功能，<code>Session</code> 一般有效时间较短，客户端关闭或者 <code>Session</code> 超时都会失效。</li>
<li><strong>隐私策略不同</strong>，<code>Cookie</code> 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；<code>Session</code> 存储在服务端，安全性相对 <code>Cookie</code> 要好一些。</li>
<li><strong>存储大小不同</strong>， 单个 <code>Cookie</code> 保存的数据不能超过 4K，<code>Session</code> 可存储数据远高于 Cookie。</li>
</ul>
<blockquote>
<p>Session 和 Cookie 有什么关联呢？</p>
</blockquote>
<p>可以使用 <code>Cookie</code> 记录 <code>Session</code> 的标识。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715105708.png" alt="20250715105708"></p>
<ul>
<li>用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。</li>
<li>当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ul>
<blockquote>
<p><strong>分布式环境下 Session 怎么处理呢？</strong></p>
</blockquote>
<p>分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的 Session。</p>
<p>这时候怎么办呢？</p>
<p>可以使用 <code>Redis</code> 等分布式缓存来存储 <code>Session</code>，在多台服务器之间共享。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715105908.png" alt="20250715105908"></p>
<blockquote>
<p><strong>客户端无法使用 Cookie 怎么办？</strong></p>
</blockquote>
<p>有可能客户端无法使用 Cookie，比如浏览器禁用 Cookie，或者客户端是安卓、IOS 等等。</p>
<p>这时候怎么办？<code>SessionID</code> 怎么存？怎么传给服务端呢？</p>
<p>首先是 <code>SessionID</code> 的存储，可以使用客户端的本地存储，比如浏览器的 <code>sessionStorage</code>。</p>
<p>接下来怎么传呢？</p>
<ul>
<li>拼接到 URL 里：直接把 <code>SessionID</code> 作为 URL 的请求参数</li>
<li>放到请求头里：把 <code>SessionID</code> 放到请求的 Header 里，比较常用。</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="24-详细说一下-TCP-的三次握手机制"><a href="#24-详细说一下-TCP-的三次握手机制" class="headerlink" title="24.详细说一下 TCP 的三次握手机制"></a>24.详细说一下 TCP 的三次握手机制</h3><p>TCP（传输控制协议）的<strong>三次握手机制</strong>是一种用于在两个 TCP 主机之间建立一个可靠连接的过程。这个机制确保了两端的通信是同步的，并且在数据传输开始前，双方都准备好了进行通信。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715110041.png" alt="20250715110041"></p>
<p>①、第一次握手：SYN（最开始都是 CLOSE，之后服务器进入 LISTEN）</p>
<ul>
<li><strong>发起连接</strong>：客户端发送一个 TCP 报文段到服务器。这个报文段的头部中，SYN 位被设置为 1，表明这是一个连接请求。同时，客户端会随机选择一个序列号（Sequence Number），假设为 x，发送给服务器。</li>
<li><strong>目的</strong>：客户端通知服务器它希望建立连接，并告知服务器自己的初始序列号。</li>
<li><strong>状态</strong>：客户端进入 SYN_SENT 状态。</li>
</ul>
<p>②、第二次握手：SYN + ACK</p>
<ul>
<li><strong>确认并应答</strong>：服务器收到客户端的连接请求后，如果同意建立连接，它会发送一个应答 TCP 报文段给客户端。在这个报文段中，SYN 位和 ACK 位都被设置为 1。服务器也会选择自己的一个随机序列号，假设为 y，并将客户端的序列号加 1（即 x+1）作为确认号（Acknowledgment Number），发送给客户端。</li>
<li><strong>目的</strong>：服务器告诉客户端，它的连接请求被接受了，并通知客户端自己的初始序列号。</li>
<li><strong>状态</strong>：服务器进入 SYN_RCVD 状态。</li>
</ul>
<p>③、第三次握手：ACK</p>
<ul>
<li><strong>最终确认</strong>：客户端收到服务器的应答后，还需要向服务器发送一个确认。这个 TCP 报文段的 ACK 位被设置为 1，确认号被设置为服务器序列号加 1（即 y+1），而自己的序列号是 x+1。</li>
<li><strong>目的</strong>：客户端确认收到了服务器的同步应答，完成三次握手，建立连接。</li>
<li><strong>状态</strong>：客户端进入 ESTABLISHED 状态，当服务器接收到这个包时，也进入 ESTABLISHED 状态</li>
</ul>
<p>用大白话讲 TCP 三次握手就是：</p>
<p>三十年前的农村，电话还没有普及，所以，通信基本靠吼。</p>
<p>老张和老王是邻居，这天老张下地了，结果家里有事，热心的邻居老王赶紧跑到村口，开始叫唤老王。</p>
<ul>
<li>老王：老张唉！我是老王，你能听得到吗？</li>
<li>老张一听，是老王的声音：老王老王，我是老张，我能听得到，你能听得到吗？</li>
<li>老王一听，嗯，没错，是老张：老张，我听到了，我有事要跟你说。</li>
</ul>
<p>“你老婆要生了，赶紧回去吧！”</p>
<p>老张风风火火地赶回家，老婆顺利地生了个带把的大胖小子。握手的故事充满了幸福和美满。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715110431.png" alt="20250715110431"></p>
<h4 id="可以再举一个例子说明-TCP-三次握手吗？"><a href="#可以再举一个例子说明-TCP-三次握手吗？" class="headerlink" title="可以再举一个例子说明 TCP 三次握手吗？"></a>可以再举一个例子说明 TCP 三次握手吗？</h4><p>当然可以，你（客户端）在一个拥挤的聚会上遇到了你想交谈的美女（服务器）。因为周围很吵，你们需要确认对方都准备好交流，并清楚地听到对方说的每一句话。</p>
<p><strong>①、第一次握手：打招呼</strong></p>
<ul>
<li>你走向那个美女，大声说：“嘿，我是小二，我们可以聊聊吗？”（你发送了一个连接请求，告诉服务器你想深入交流，并提供了你的微信号<code>x</code>，也就是你们交谈的起点）</li>
</ul>
<p><strong>②、第二次握手：对方回应</strong></p>
<ul>
<li>美女一看你挺帅挺有气质，回答说：“嗨，我是小青，可以聊聊。”（服务器接受你的请求，同样愿意深入交流，告诉你它的微信号<code>y</code>，并确认了你的微信号<code>x+1</code>，表示它准备好了）</li>
</ul>
<p><strong>③、第三次握手：确认准备就绪</strong></p>
<ul>
<li>你听到美女的回答后，对她说：“太好了，我们以后就微信上聊吧。”（你确认了美女的回答，也告诉她你准备好开始了，通过发送确认号<code>y+1</code>）</li>
</ul>
<p><strong>④、聊天开始</strong></p>
<p>这时候，你们两个就确认彼此都准备好深入交流了，可以开始你们的对话了。</p>
<h4 id="说说-SYN-的概念？"><a href="#说说-SYN-的概念？" class="headerlink" title="说说 SYN 的概念？"></a>说说 SYN 的概念？</h4><p><code>SYN</code> 是 TCP 协议中用来建立连接的一个标志位，全称为 <code>Synchronize Sequence Numbers</code>，也就是同步序列编号。</p>
<p>SYN 不仅确保了序列号的同步，使得后续的数据能够有序传输，还能防止旧的报文段被误认为是新连接。</p>
<h3 id="25-TCP-握手为什么是三次，为什么不能是两次？不能是四次？"><a href="#25-TCP-握手为什么是三次，为什么不能是两次？不能是四次？" class="headerlink" title="25.TCP 握手为什么是三次，为什么不能是两次？不能是四次？"></a>25.TCP 握手为什么是三次，为什么不能是两次？不能是四次？</h3><p>使用<strong>三次握手可以建立一个可靠的连接</strong>。这一过程的目的是确保双方都知道对方已准备好进行通信，并同步双方的序列号，从而保持数据包的顺序和完整性。</p>
<h4 id="为什么-TCP-握手不能是两次？"><a href="#为什么-TCP-握手不能是两次？" class="headerlink" title="为什么 TCP 握手不能是两次？"></a>为什么 TCP 握手不能是两次？</h4><ul>
<li>为了<strong>防止服务器一直等，等到黄花菜都凉了</strong>。</li>
<li>为了<strong>防止客户端已经失效的连接请求突然又传送到了服务器</strong>。</li>
</ul>
<p>要知道，网络传输是有延时的（要通过网络光纤、WIFI、卫星信号传输等）。</p>
<p>假如说客户端发起了 SYN&#x3D;1 的第一次握手。服务器也及时回复了 SYN&#x3D;2 和 ACK&#x3D;1 的第二次握手，但是这个 ACK&#x3D;1 的确认报文段因为某些原因在传输过程中丢失了。</p>
<p>如果没有第三次握手告诉服务器，客户端收到了服务器的回应，那服务器是不知道客户端有没有接收到的。</p>
<p>于是服务器就一直干巴巴地开着端口在等着客户端发消息呢，但其实客户端并没有收到服务器的回应，心灰意冷地跑了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715112316.png" alt="20250715112316"></p>
<p>还有一种情况是，一个旧的、延迟的连接请求（SYN&#x3D;1）被服务器接受，导致服务器错误地开启一个不再需要的连接。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715112359.png" alt="20250715112359"></p>
<p>举个例子：假设你（客户端）给你的朋友（服务器）发送了一个邮件（连接请求）。因为某些原因，这封邮件迟迟没有到达朋友那里，可能是因为邮局的延误。于是你决定再发一封新的邮件。朋友收到了第二封邮件，你们成功地建立了连接并开始通信。</p>
<p>但是，过了很久，那封延误的旧邮件突然也到了你朋友那里。如果没有一种机制来识别和处理这种延误的邮件，你的朋友可能会以为这是一个新的连接请求，并尝试响应它，但其实你已经重新发了请求，原来的不需要了。这就导致了不必要的混乱和资源浪费。</p>
<p>所以我们需要“三次握手”来确认这个过程：</p>
<p>第一次握手：客户端发送 SYN 包（连接请求）给服务器，如果这个包延迟了，客户端不会一直等待，它<strong>可能会重试并发送一个新的连接请求</strong>。<br>第二次握手：服务器收到 SYN 包后，发送一个 SYN-ACK 包（确认接收到连接请求）回客户端。<br>第三次握手：客户端收到 SYN-ACK 包后，再发送一个 ACK 包给服务器，确认收到了服务器的响应。</p>
<h4 id="为什么不是四次？"><a href="#为什么不是四次？" class="headerlink" title="为什么不是四次？"></a>为什么不是四次？</h4><p>三次握手已经足够创建可靠的连接了，没有必要再多一次握手。</p>
<h4 id="什么是泛洪攻击？"><a href="#什么是泛洪攻击？" class="headerlink" title="什么是泛洪攻击？"></a>什么是泛洪攻击？</h4><p>泛洪攻击（SYN Flood Attack）是一种常见的 DoS（拒绝服务）攻击，攻击者会发送大量的伪造的 TCP 连接请求，导致服务器资源耗尽，无法处理正常的连接请求。</p>
<p>半连接服务拒绝，也称为 SYN 洪泛攻击或 SYN Flood。</p>
<p>所谓的半连接就是指在 TCP 的三次握手过程中，当服务器接收到来自客户端的第一个 SYN 包后，它会回复一个 SYN-ACK 包，此时连接处于“半开”状态，因为连接的建立还需要客户端发送最后一个 ACK 包。</p>
<p>在收到最后的 ACK 包之前，服务器会为这个尚未完成的连接分配一定的资源，并在它的队列中保留这个连接的位置。</p>
<h4 id="如果让你重新设计，怎么设计？"><a href="#如果让你重新设计，怎么设计？" class="headerlink" title="如果让你重新设计，怎么设计？"></a>如果让你重新设计，怎么设计？</h4><p>如果重新设计 TCP 的连接建立过程，可以考虑引入 <code>SYN cookies</code>，这种技术通过在 <code>SYN-ACK</code> 响应中编码连接信息，从而在不占用大量资源的情况下验证客户端。</p>
<h3 id="26-三次握手中每一次没收到报文会发生什么情况？"><a href="#26-三次握手中每一次没收到报文会发生什么情况？" class="headerlink" title="26.三次握手中每一次没收到报文会发生什么情况？"></a>26.三次握手中每一次没收到报文会发生什么情况？</h3><ul>
<li><strong>第一次握手</strong>服务端未收到 SYN 报文</li>
</ul>
<p>服务端不会进行任何的动作，而客户端由于一段时间内没有收到服务端发来的确认报文，等待一段时间后会<strong>重新发送 SYN 报文</strong>，如果仍然没有回应，会重复这个过程，直到发送次数超过最大重传次数限制，就会返回连接建立失败。</p>
<ul>
<li><strong>第二次握手</strong>客户端未收到服务端响应的 ACK 报文</li>
</ul>
<p>客户端会继续重传，直到次数限制；而服务端此时<strong>会阻塞在 accept()处</strong>，等待客户端发送 ACK 报文</p>
<ul>
<li><strong>第三次握手</strong>服务端为收到客户端发送过来的 ACK 报文</li>
</ul>
<p>服务端同样会采用类似客户端的<strong>超时重传机制</strong>，如果重试次数超过限制，则 accept()调用返回-1，服务端建立连接失败；而此时客户端认为自己已经建立连接成功，因此开始向服务端发送数据，但是服务端的 accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送来的数据时会发送 <code>RST</code> 报文给客户端，消除客户端单方面建立连接的状态。</p>
<h3 id="27-第二次握手传回了-ACK，为什么还要传回-SYN？"><a href="#27-第二次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="27.第二次握手传回了 ACK，为什么还要传回 SYN？"></a>27.第二次握手传回了 ACK，为什么还要传回 SYN？</h3><p><code>ACK</code> 是为了告诉客户端传来的数据<strong>已经接收无误</strong>。</p>
<p>而传回 <code>SYN</code> 是为了告诉客户端，<strong>服务端响应的确实是客户端发送的报文</strong>。</p>
<h3 id="28-第-3-次握手可以携带数据吗？"><a href="#28-第-3-次握手可以携带数据吗？" class="headerlink" title="28.第 3 次握手可以携带数据吗？"></a>28.第 3 次握手可以携带数据吗？</h3><p>第 3 次握手是可以携带数据的。</p>
<p>此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。</p>
<p>第一次握手不能携带数据是<strong>出于安全的考虑</strong>，因为如果允许携带数据，攻击者每次在 SYN 报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成 CPU 和内存的消耗。</p>
<h3 id="29-了解-TCP-半连接状态吗？"><a href="#29-了解-TCP-半连接状态吗？" class="headerlink" title="29.了解 TCP 半连接状态吗？"></a>29.了解 TCP 半连接状态吗？</h3><p>TCP 半连接指的是在 TCP 三次握手过程中，服务器接收到了客户端的 SYN 包，但还没有完成第三次握手，此时的连接处于一种<strong>未完全建立的状态</strong>。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716103538.png" alt="20250716103538"></p>
<p>如果服务器回复了 <code>SYN-ACK</code>，但客户端还没有回复 <code>ACK</code>，该连接将一直保留在半连接队列中，直到超时或被拒绝。</p>
<h4 id="说说半连接队列？"><a href="#说说半连接队列？" class="headerlink" title="说说半连接队列？"></a>说说半连接队列？</h4><p>TCP 进入三次握手前，服务端会从 CLOSED 状态变为 LISTEN 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716103635.png" alt="20250716103635"></p>
<p>顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。</p>
<ul>
<li>TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 SYN 队列，即<code>半连接队列</code>。</li>
<li>当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即<code>全连接队列</code>。</li>
</ul>
<h4 id="什么是-SYN-Flood-？"><a href="#什么是-SYN-Flood-？" class="headerlink" title="什么是 SYN Flood ？"></a>什么是 SYN Flood ？</h4><p>SYN Flood 是一种典型的 <code>DDos</code> 攻击，它在短时间内，伪造不存在的 IP 地址, 向服务器发送大量 SYN 报文。当服务器回复 <code>SYN+ACK</code> 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 SYN 接收队列（半连接队列），使得服务器不能为正常⽤户服务。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716105715.png" alt="20250716105715"></p>
<h4 id="那有什么应对方案呢？"><a href="#那有什么应对方案呢？" class="headerlink" title="那有什么应对方案呢？"></a>那有什么应对方案呢？</h4><p>主要有 <code>syn cookie</code> 和 <code>SYN Proxy</code> 防火墙等。</p>
<ul>
<li><code>syn cookie</code>：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。</li>
<li><code>SYN Proxy</code> 防火墙：服务器防火墙会对收到的每一个 SYN 报文进行<strong>代理和回应</strong>，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。</li>
</ul>
<h3 id="30-说说-TCP-四次挥手的过程？"><a href="#30-说说-TCP-四次挥手的过程？" class="headerlink" title="30.说说 TCP 四次挥手的过程？"></a>30.说说 TCP 四次挥手的过程？</h3><p>TCP 连接的断开过程被形象地概括为<strong>四次挥手</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716105801.png" alt="20250716105801"></p>
<p><strong>第一次挥手</strong>：客户端向服务器发送一个 <code>FIN</code> 结束报文，表示客户端没有数据要发送了，但仍然可以接收数据。客户端进入 <code>FIN-WAIT-1</code> 状态。</p>
<p><strong>第二次挥手</strong>：服务器接收到 <code>FIN</code> 报文后，向客户端发送一个 <code>ACK</code> 报文，确认已接收到客户端的 <code>FIN</code> 请求。服务器进入 <code>CLOSE-WAIT</code> 状态，客户端进入 <code>FIN-WAIT-2</code> 状态。</p>
<p><strong>第三次挥手</strong>：服务器向客户端发送一个 <code>FIN</code> 报文，表示服务器也没有数据要发送了。服务器进入 <code>LAST-ACK </code>状态。</p>
<p><strong>第四次挥手</strong>：客户端接收到 <code>FIN</code> 报文后，向服务器发送一个 <code>ACK</code> 报文，确认已接收到服务器的 <code>FIN</code> 请求。客户端进入 <code>TIME-WAIT</code> 状态，等待一段时间以确保服务器接收到 <code>ACK</code> 报文。服务器接收到 <code>ACK</code> 报文后进入 <code>CLOSED</code> 状态。客户端在等待一段时间后也进入 <code>CLOSED</code> 状态。</p>
<h3 id="31-TCP-挥手为什么需要四次呢？"><a href="#31-TCP-挥手为什么需要四次呢？" class="headerlink" title="31.TCP 挥手为什么需要四次呢？"></a>31.TCP 挥手为什么需要四次呢？</h3><p>因为 <strong>TCP 是全双工通信协议</strong>，数据的发送和接收需要两次一来一回，也就是四次，来确保双方都能正确关闭连接。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716110915.png" alt="20250716110915"></p>
<ol>
<li>第一次挥手：客户端表示数据发送完成了，准备关闭，你确认一下。</li>
<li>第二次挥手：服务端回话说 ok，我马上处理完数据，稍等。</li>
<li>第三次挥手：服务端表示处理完了，可以关闭了。</li>
<li>第四次挥手：客户端说好，进入 TIME_WAIT 状态，确保服务端关闭连接后，自己再关闭连接。</li>
</ol>
<h3 id="32-TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？"><a href="#32-TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？" class="headerlink" title="32.TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？"></a>32.TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</h3><blockquote>
<p><strong>为什么需要等待？</strong></p>
</blockquote>
<p><strong>1. 为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN + ACK</strong> 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。</p>
<p><strong>2. 防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p>
<blockquote>
<p><strong>为什么等待的时间是 2MSL？</strong></p>
</blockquote>
<p><code>MSL</code> 是 <code>Maximum Segment Lifetime</code>，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。</p>
<p><code>TIME_WAIT</code> 等待 2 倍的 MSL，⽐较合理的解释是：⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716112349.png" alt="20250716112349"></p>
<p>⽐如如果被动关闭⽅没有收到断开连接的最后的 <code>ACK</code> 报⽂，就会触发超时重发 <code>Fin</code> 报⽂，另⼀⽅接收到 <code>FIN</code> 后，会重发 <code>ACK</code> 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。</p>
<h3 id="33-保活计时器有什么用？"><a href="#33-保活计时器有什么用？" class="headerlink" title="33.保活计时器有什么用？"></a>33.保活计时器有什么用？</h3><p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。</p>
<p>设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用<code>保活计时器</code>了。</p>
<p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
<h3 id="34-CLOSE-WAIT-和-TIME-WAIT-的状态和意义？"><a href="#34-CLOSE-WAIT-和-TIME-WAIT-的状态和意义？" class="headerlink" title="34.CLOSE-WAIT 和 TIME-WAIT 的状态和意义？"></a>34.CLOSE-WAIT 和 TIME-WAIT 的状态和意义？</h3><h4 id="CLOSE-WAIT-状态有什么意义？"><a href="#CLOSE-WAIT-状态有什么意义？" class="headerlink" title="CLOSE-WAIT 状态有什么意义？"></a>CLOSE-WAIT 状态有什么意义？</h4><p>服务端收到客户端关闭连接的请求并确认之后，就会进入 <code>CLOSE-WAIT</code> 状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而 <code>CLOSE-WAIT</code> 状态就是为了<strong>保证服务端在关闭连接之前将待发送的数据处理完</strong>。</p>
<h4 id="TIME-WAIT-有什么意义？"><a href="#TIME-WAIT-有什么意义？" class="headerlink" title="TIME-WAIT 有什么意义？"></a>TIME-WAIT 有什么意义？</h4><p><code>TIME-WAIT</code> 发生在第四次挥手，当客户端在发送 <code>ACK</code> 确认对方的 <code>FIN</code> 报文后，会进入 <code>TIME_WAIT</code> 状态。</p>
<p>它存在的意义主要有两个：</p>
<ul>
<li>在 <code>TIME_WAIT</code> 状态中，客户端可以重新发送 <code>ACK</code> 确保对方正常关闭连接。</li>
<li>在 <code>TIME_WAIT</code> 持续的 <code>2MSL</code> 时间后，确保旧数据包完全消失，避免它们干扰未来建立的新连接。</li>
</ul>
<blockquote>
<p>补充：MSL（Maximum Segment Lifetime）：TCP 报文段在网络中的最大存活时间，通常为 30 秒到 2 分钟</p>
</blockquote>
<h3 id="35-TIME-WAIT-状态过多会导致什么问题？怎么解决？"><a href="#35-TIME-WAIT-状态过多会导致什么问题？怎么解决？" class="headerlink" title="35.TIME_WAIT 状态过多会导致什么问题？怎么解决？"></a>35.TIME_WAIT 状态过多会导致什么问题？怎么解决？</h3><blockquote>
<p><strong>TIME_WAIT 状态过多会导致什么问题?</strong></p>
</blockquote>
<p>如果服务器有处于 <code>TIME-WAIT</code> 状态的 TCP，则说明是由服务器⽅主动发起的断开请求。</p>
<p>过多的 <code>TIME-WAIT</code> 状态主要的危害有两种：</p>
<p>第⼀是<strong>内存资源占⽤</strong>；</p>
<p>第⼆是<strong>对端⼝资源的占⽤</strong>，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；</p>
<blockquote>
<p><strong>怎么解决 TIME_WAIT 状态过多？</strong></p>
</blockquote>
<ul>
<li>服务器可以设置 SO_REUSEADDR 套接字来通知内核，如果端口被占用，但是 TCP 连接位于 TIME_WAIT 状态时可以重用端口。</li>
<li>还可以使用长连接的方式来减少 TCP 的连接和断开，在长连接的业务里往往不需要考虑 TIME_WAIT 状态。</li>
</ul>
<h3 id="36-说说-TCP-报文头部的格式？"><a href="#36-说说-TCP-报文头部的格式？" class="headerlink" title="36.说说 TCP 报文头部的格式？"></a>36.说说 TCP 报文头部的格式？</h3><p>一个 TCP 报文段主要由<code>报文段头部（Header）</code>和<code>数据</code>两部分组成。头部包含了确保数据可靠传输所需的各种控制信息，比如说序列号、确认号、窗口大小等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717092859.png" alt="20250717092859"></p>
<ul>
<li><strong>源端口号</strong>（Source Port）：16 位（2 个字节），用于标识发送端的应用程序。</li>
<li><strong>目标端口号</strong>（Destination Port）：也是 16 位，用于标识接收端的应用程序。</li>
<li><strong>序列号</strong>（Sequence Number）：32 位，用于标识从 TCP 发送者发送的数据字节流中的第一个字节的顺序号。确保数据按顺序接收。</li>
<li><strong>确认号</strong>（Acknowledgment Number）：32 位，如果 ACK 标志被设置，则该字段包含发送确认的序列号，即接收 TCP 希望收到的下一个序列号。</li>
<li><strong>数据偏移</strong>（Data Offset）：4 位，表示 TCP 报文头部的长度，用于指示数据开始的位置。</li>
<li><strong>保留</strong>（Reserved）：6 位，为将来使用预留，目前必须置为 0。</li>
<li><strong>控制位</strong>（Flags）：共 6 位，包括 URG（紧急指针字段是否有效）、ACK（确认字段是否有效）、PSH（提示接收端应该尽快将这个报文段交给应用层）、RST（重置连接）、SYN（同步序号，用于建立连接）、FIN（结束发送数据）。</li>
<li><strong>窗口大小</strong>（Window）：16 位，用于流量控制，表示接收端还能接收的数据的字节数（基于接收缓冲区的大小）。</li>
<li><strong>校验和</strong>（Checksum）：16 位，覆盖整个 TCP 报文段（包括 TCP 头部、数据和一个伪头部）的校验和，用于检测数据在传输过程中的任何变化。</li>
<li><strong>紧急指针</strong>（Urgent Pointer）：16 位，只有当 URG 控制位被设置时才有效，指出在报文段中有紧急数据的位置。</li>
</ul>
<h3 id="37-TCP-为什么可靠？"><a href="#37-TCP-为什么可靠？" class="headerlink" title="37.TCP 为什么可靠？"></a>37.TCP 为什么可靠？</h3><p>TCP 首先通过三次握手和四次挥手来<strong>保证连接的可靠性</strong>，然后通过校验和、序列号、确认应答、超时重传、滑动窗口等机制来<strong>保证数据的可靠传输</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://www.noction.com/blog/tcp-header">推荐阅读：TCP 校验和计算方法</a></p>
<p>①、校验和：TCP 报文段包括一个<code>校验和</code>字段，用于检测报文段在传输过程中的变化。如果接收方检测到校验和错误，就会丢弃这个报文段。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717093709.png" alt="20250717093709"></p>
<p>②、<strong>序列号&#x2F;确认机制</strong>：TCP 将数据分成多个小段，每段数据都有唯一的序列号，以确保数据包的顺序传输和完整性。同时，发送方如果没有收到接收方的确认应答，会重传数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095429.png" alt="20250717095429"></p>
<p>③、<strong>流量控制</strong>：接收方会发送窗口大小告诉发送方它的接收能力。发送方会根据窗口大小调整发送速度，避免网络拥塞。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095450.png" alt="20250717095450"></p>
<p>④、<strong>超时重传</strong>：如果发送方发送的数据包超过了最大生存时间，接收方还没有收到，发送方会重传数据包以保证丢失数据重新传输。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095514.png" alt="20250717095514"></p>
<p>⑤、<strong>拥塞控制</strong>：TCP 会采用慢启动的策略，一开始发的少，然后逐步增加，当检测到网络拥塞时，会降低发送速率。在网络拥塞缓解后，传输速率也会自动恢复。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095532.png" alt="20250717095532"></p>
<h3 id="38-说说-TCP-的流量控制？"><a href="#38-说说-TCP-的流量控制？" class="headerlink" title="38.说说 TCP 的流量控制？"></a>38.说说 TCP 的流量控制？</h3><p>TCP 提供了一种机制，可以<strong>让发送端根据接收端的实际接收能力控制发送的数据量</strong>，这就是流量控制。<br>TCP 通过滑动窗口来控制流量，我们看下简要流程：</p>
<ul>
<li>首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717100157.png" alt="20250717100157"></li>
<li>假如当前发送方给接收方发送了 200 个字节，那么，发送方的SND.NXT会右移 200 个字节，也就是说当前的可用窗口减少了 200 个字节。</li>
<li>接受方收到后，放到缓冲队列里面，REV.WND &#x3D;400-200&#x3D;200 字节，所以 win&#x3D;200 字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节</li>
<li>发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND &#x3D; 400-200-100&#x3D;100 字节，即 win&#x3D;100 返回发送方。</li>
<li>发送方继续发送 100 字节过来，这时候，接收窗口 win 变为 0。</li>
<li>发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送。</li>
</ul>
<h3 id="39-详细说说-TCP-的滑动窗口？"><a href="#39-详细说说-TCP-的滑动窗口？" class="headerlink" title="39.详细说说 TCP 的滑动窗口？"></a>39.详细说说 TCP 的滑动窗口？</h3><p>TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。</p>
<p>“用一个比喻，我们在微信上聊天，你打完一句话，我回复一句之后，你才能打下一句。假如我没有及时回复呢？你是把话憋着不说吗？然后傻傻等到我回复之后再接着发下一句？”</p>
<p>为了解决这个问题，TCP 引入了<strong>窗口</strong>，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。</p>
<p>TCP 头部有个字段叫 <code>win</code>，也即那个 <strong>16 位的窗口大小</strong>，它告诉对方本端的 <code>TCP</code> 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到<strong>流量控制</strong>的目的。</p>
<p>“通俗点讲，就是接受方每次收到数据包，在<strong>发送确认报文的时候</strong>，同时告诉发送方，<strong>自己的缓存区还有多少空余空间</strong>，缓冲区的空余空间，我们就称之为<code>接受窗口大小</code>。这就是 <code>win</code>。”</p>
<p>TCP 滑动窗口分为两种: <code>发送窗口</code>和<code>接收窗口</code>。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p>
<ul>
<li>已发送且已收到 ACK 确认</li>
<li>已发送但未收到 ACK 确认</li>
<li>未发送但可以发送</li>
<li>未发送也不可以发送</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717101303.png" alt="20250717101303"></p>
<ul>
<li>深蓝色框里就是发送窗口。</li>
<li><code>SND.WND</code>: 表示发送窗口的大小, 上图虚线框的格子数是 10 个，即发送窗口大小是 10。</li>
<li><code>SND.NXT</code>：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。</li>
<li><code>SND.UNA</code>: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</li>
</ul>
<p>接收方的滑动窗口包含三大部分，如下：</p>
<ul>
<li>已成功接收并确认</li>
<li>未收到数据但可以接收</li>
<li>未收到数据并不可以接收的数据</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717101631.png" alt="20250717101631"></p>
<ul>
<li>蓝色框内，就是接收窗口。</li>
<li>REV.WND: 表示接收窗口的大小, 上图虚线框的格子就是 9 个。</li>
<li>REV.NXT: 下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</li>
</ul>
<h3 id="40-了解-Nagle-算法和延迟确认吗？"><a href="#40-了解-Nagle-算法和延迟确认吗？" class="headerlink" title="40.了解 Nagle 算法和延迟确认吗？"></a>40.了解 Nagle 算法和延迟确认吗？</h3><blockquote>
<p><strong>Nagle 算法和延迟确认是干什么的？</strong></p>
</blockquote>
<p>当我们 TCP 报⽂的承载的数据⾮常⼩的时候，例如⼏个字节，那么整个⽹络的效率是很低的，因为每个 TCP 报⽂中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，⽽数据只有⼏个字节，所以在整个报⽂中有效数据占有的比例就会⾮常低。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717101740.png" alt="20250717101740"></p>
<p>这就好像快递员开着⼤货⻋送⼀个⼩包裹⼀样浪费。</p>
<p>那么就出现了常⻅的两种策略，来减少⼩报⽂的传输，分别是：</p>
<ul>
<li><code>Nagle 算法</code></li>
<li><code>延迟确认</code></li>
</ul>
<blockquote>
<p><strong>Nagle 算法</strong></p>
</blockquote>
<p>Nagle 算法：<strong>任意时刻，最多只能有一个未被确认的小段</strong>。所谓 “小段”，指的是小于 <code>MSS</code> 尺寸的数据块，所谓 “未被确认”，是指一个数据块发送出去后，没有收到对方发送的 ACK 确认该数据已收到。</p>
<p>Nagle 算法的策略：</p>
<ul>
<li>没有已发送未确认报⽂时，⽴刻发送数据。</li>
<li>存在未确认报⽂时，直到「没有已发送未确认报⽂」或「数据⻓度达到 MSS ⼤⼩」时，再发送数据。</li>
</ul>
<p>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件。</p>
<blockquote>
<p><strong>延迟确认</strong></p>
</blockquote>
<p>事实上当没有携带数据的 ACK，它的⽹络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报⽂。</p>
<p>为了解决 ACK 传输效率低问题，所以就衍⽣出了 <strong>TCP</strong> 延迟确认。</p>
<p>TCP 延迟确认的策略：</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据⼀起⽴刻发送给对⽅</li>
<li>当没有响应数据要发送时，ACK 将会延迟⼀段时间，以等待是否有响应数据可以⼀起发送</li>
<li>如果在延迟等待发送 ACK 期间，对⽅的第⼆个数据报⽂⼜到达了，这时就会⽴刻发送 ACK</li>
</ul>
<p>一般情况下，<strong>Nagle 算法和延迟确认</strong>不能一起使用，Nagle 算法意味着延迟发，<strong>延迟确认</strong>意味着延迟接收，两个凑在一起就会造成更大的延迟，会产生性能问题。</p>
<h3 id="41-说说-TCP-的拥塞控制？"><a href="#41-说说-TCP-的拥塞控制？" class="headerlink" title="41.说说 TCP 的拥塞控制？"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/sidebar/sanfene/network.html#_41-%E8%AF%B4%E8%AF%B4-tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">41.说说 TCP 的拥塞控制？</a></h3><h4 id="什么是拥塞控制？"><a href="#什么是拥塞控制？" class="headerlink" title="什么是拥塞控制？"></a>什么是拥塞控制？</h4><p>流量控制是为了<strong>避免发送⽅的数据填满接收⽅的缓存</strong>，但并不能控制整个⽹络。</p>
<p>⼀般来说，计算机⽹络会处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p>
<p>当⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包延时、丢失等，这时 <strong>TCP</strong> 就会重传数据，但重传会增加⽹络负担，于是会导致更⼤的延迟以及更多的丢包，就进⼊了恶性循环….</p>
<p>所以，TCP 被设计成了⼀个非常⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据流。</p>
<p>拥塞控制的⽬的就是避免发送⽅的数据填满整个⽹络。</p>
<p>就像是一个水管，不能让太多的水（数据流）流入水管，如果超过水管的承受能力，水管会被撑爆（丢包）。</p>
<p>发送方会维护一个<strong>拥塞窗口 cwnd</strong> 的变量，调节所要发送数据的量。</p>
<h4 id="什么是拥塞窗⼝？和发送窗⼝有什么关系呢？"><a href="#什么是拥塞窗⼝？和发送窗⼝有什么关系呢？" class="headerlink" title="什么是拥塞窗⼝？和发送窗⼝有什么关系呢？"></a>什么是拥塞窗⼝？和发送窗⼝有什么关系呢？</h4><p>拥塞窗⼝ <strong>cwnd</strong>是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。</p>
<p>发送窗⼝ <code>swnd</code> 和接收窗⼝ <code>rwnd</code> 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是 <code>swnd = min(cwnd, rwnd)</code>，也就是拥塞窗⼝和接收窗⼝中的<strong>最⼩值</strong>。</p>
<p>拥塞窗⼝ <code>cwnd</code> 变化的规则：</p>
<ul>
<li>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</li>
<li>但⽹络中出现了拥塞， cwnd 就减少；</li>
</ul>
<h4 id="拥塞控制有哪些常用算法？"><a href="#拥塞控制有哪些常用算法？" class="headerlink" title="拥塞控制有哪些常用算法？"></a>拥塞控制有哪些常用算法？</h4><p>拥塞控制主要有这几种常用算法：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717102823.png" alt="20250717102823"></p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<p>①、慢启动算法</p>
<p>慢启动算法，慢慢启动。</p>
<p>它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，<strong>每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）</strong>。<strong>每轮次</strong>发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。</p>
<p>举个例子：</p>
<ul>
<li>连接建⽴完成后，⼀开始初始化 cwnd &#x3D; 1 ，表示可以传⼀个 MSS ⼤⼩的数据。</li>
<li>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发 2 个，所以这⼀次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发 4 个，所以这⼀次能够发送 8 个。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717102916.png" alt="20250717102916"></li>
</ul>
<p>发包的个数是指数性的增⻓。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103327.png" alt="20250717103327"></p>
<p>为了防止 <code>cwnd</code> 增长过大引起网络拥塞，还需设置一个慢启动阀值 <code>ssthresh（slow start threshold）</code>状态变量。当<code>cwnd</code>到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当 <code>cwnd &gt;ssthresh</code> 时，进入了拥塞避免算法。</p>
<p>②、拥塞避免算法<br>一般来说，慢启动阀值 <code>ssthresh</code> 是 65535 字节，cwnd到达慢启动阀值后</p>
<ul>
<li>每收到一个 <code>ACK</code> 时，cwnd &#x3D; cwnd + 1&#x2F;cwnd</li>
<li>当每过一个 <code>RTT</code> 时，cwnd &#x3D; cwnd + 1</li>
</ul>
<p>显然这是一个<strong>线性上升的算法</strong>，避免过快导致网络拥塞问题。<br>接着上面慢启动的例子，假定 ssthresh 为 8 ：</p>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9 个 MSS ⼤⼩的数据，变成了线性增⻓。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103500.png" alt="20250717103500"></p>
<p>③、拥塞发生</p>
<p>当网络拥塞发生<strong>丢包</strong>时，会有两种情况：</p>
<ul>
<li>RTO 超时重传</li>
<li>快速重传</li>
</ul>
<p>如果是发生了 <strong>RTO 超时重传</strong>，就会使用拥塞发生算法</p>
<ul>
<li>慢启动阀值 sshthresh &#x3D; cwnd &#x2F;2</li>
<li>cwnd 重置为 1</li>
<li>进入新的慢启动过程</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103608.png" alt="20250717103608"></p>
<p>这种方式就像是飙车的时候急刹车，还飞速倒车，这。。。</p>
<p>其实还有更好的处理方式，就是<code>快速重传</code>。发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待 RTO 超时再重传。</p>
<p>发⽣快速重传的拥塞发⽣算法：</p>
<p>拥塞窗口大小 <code>cwnd = cwnd/2</code><br>慢启动阀值 <code>ssthresh = cwnd</code><br>进入快速恢复算法</p>
<p>④、快速恢复</p>
<p>快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。</p>
<p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>sshthresh</code> 已被更新：</p>
<ul>
<li>cwnd &#x3D; cwnd &#x2F;2</li>
<li>sshthresh &#x3D; cwnd</li>
</ul>
<p>然后，进⼊快速恢复算法如下：</p>
<ul>
<li>cwnd &#x3D; sshthresh + 3</li>
<li>重传重复的那几个 ACK（即丢失的那几个数据包）</li>
<li>如果再收到重复的 ACK，那么 cwnd &#x3D; cwnd +1</li>
<li>如果收到新数据的 ACK 后, cwnd &#x3D; sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103856.png" alt="20250717103856"></p>
<h3 id="42-说说-TCP-的重传机制？"><a href="#42-说说-TCP-的重传机制？" class="headerlink" title="42.说说 TCP 的重传机制？"></a>42.说说 TCP 的重传机制？</h3><p>超时重传机制是 <code>TCP</code> 的核心之一，它能确保在网络传输中如果某些数据包丢失或没有及时到达的话，TCP 能够重新发送这些数据包，以保证数据完整性。</p>
<p>其原理是在发送某个数据后开启一个计时器，如果在一定时间内没有得到发送数据报的 <code>ACK</code> 报文，就重新发送数据，直到发送成功为止。</p>
<p>重传包括<code>超时重传</code>、<code>快速重传</code>、<code>带选择确认的重传（SACK）</code>和<code>重复 SACK</code> 四种。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104021.png" alt="20250717104021"></p>
<h4 id="超时时间应该设置为多少呢？"><a href="#超时时间应该设置为多少呢？" class="headerlink" title="超时时间应该设置为多少呢？"></a>超时时间应该设置为多少呢？</h4><p><code>TCP</code> 中的重传超时时间（RTO，Retransmission Timeout）不是一个固定的值，而是动态计算的，目的是为了适应不同的网络条件。</p>
<p><code>RTO</code> 有个标准方法的计算公式，叫 <strong>Jacobson &#x2F; Karels 算法</strong>。</p>
<p>①、计算 SRTT（Smoothed RTT，平滑往返时间），以避免单次测量中的抖动影响重传时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRTT = (<span class="number">1</span> - α) * SRTT + α * RTT</span><br></pre></td></tr></table></figure>

<p>其中，α 是一个常量，通常取值为 0.125（即1&#x2F;8），表示新测量值对平滑RTT的影响比例。</p>
<p><code>RTT</code>，也就是 <code>Round-Trip Time</code>，往返时间，即数据包从发送到接收到确认的时间。TCP 会对每个数据包的 RTT 进行测量，并不断更新这个值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104143.png" alt="20250717104143"></p>
<p>②、计算 RTTVAR (RTT Variation，表示RTT的变化量，用于衡量RTT的波动)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTTVAR = (<span class="number">1</span> - β) * RTTVAR + β * (|RTT - SRTT|)</span><br></pre></td></tr></table></figure>
<p>β 通常取值为 0.25（即1&#x2F;4），表示对RTTVAR更新的权重。</p>
<p>③、最后，得出最终的 RTO</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO = SRTT + max(G, <span class="number">4</span> x RTTVAR)</span><br></pre></td></tr></table></figure>

<p>G 是一个小的常量偏移量，用来防止RTO过小。一般来说，G 的值通常是1毫秒。</p>
<p>一般来说，RTO 略微大于 RTT，效果是最佳的。</p>
<ul>
<li>如果 RTO 设置很大，可能等了很久都没有重发。</li>
<li>如果 RTO 设置很小，那很可能数据还没有丢失，就开始重发了。</li>
</ul>
<p>超时重传不是十分完美的重传方案，它有这些缺点：</p>
<ul>
<li>当报文丢失时，需要等待一定的超时周期，才开始重传。</li>
<li>当报文丢失时，在等待超时的过程中，可能会出现这种情况：后面的报文已经被接收端接收了但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传。</li>
<li>并且，对于 TCP 来说，如果发生一次超时重传，下次的时间间隔就会加倍。</li>
</ul>
<h4 id="什么是快速重传？"><a href="#什么是快速重传？" class="headerlink" title="什么是快速重传？"></a>什么是快速重传？</h4><p>TCP 还有另外⼀种快速重传（<strong>Fast Retransmit</strong>）机制，它不以时间为驱动，⽽是以数据驱动重传。</p>
<p>它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。</p>
<p>可以用它来解决超时重发的时间等待问题，快速重传流程如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104352.png" alt="20250717104352"></p>
<p>在上图，发送⽅发出了 1，2，3，4，5 份数据：</p>
<ul>
<li>第⼀份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li>发送端收到了三个 <strong>Ack &#x3D; 2</strong> 的确认，知道了 <strong>Seq2</strong> 还没有收到，就会在定时器过期之前，重传丢失的 <strong>Seq2</strong>。</li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<p>快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题。</p>
<p>⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<p>根据 TCP 不同的实现，以上两种情况都是有可能的。可⻅，这是⼀把双刃剑。</p>
<p>为了解决不知道该重传哪些 TCP 报⽂，于是就有 SACK ⽅法。</p>
<h4 id="什么是带选择确认的重传-SACK"><a href="#什么是带选择确认的重传-SACK" class="headerlink" title="什么是带选择确认的重传(SACK)"></a>什么是带选择确认的重传(SACK)</h4><p>为了解决应该重传多少个包的问题? TCP 提供了<strong>带选择确认的重传</strong>（即 SACK，Selective Acknowledgment）。</p>
<p><strong>SACK 机制</strong>就是，在快速重传的基础上，<strong>接收方返回最近收到报文段的序列号范围</strong>，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104711.png" alt="20250717104711"></p>
<p>如上图中，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重发。</p>
<h4 id="什么是重复-SACK（D-SACK）"><a href="#什么是重复-SACK（D-SACK）" class="headerlink" title="什么是重复 SACK（D-SACK）"></a>什么是重复 SACK（D-SACK）</h4><p><code>D-SACK</code>，英文是 Duplicate SACK，是在 SACK 的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。</p>
<p>DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</p>
<p>例如 <code>ACK</code> 丢包导致的数据包重复：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104804.png" alt="20250717104804"></p>
<ul>
<li><p>接收⽅发给发送⽅的两个 ACK 确认应答都丢失了，所以发送⽅超时后，重传第⼀个数据包（3000 ~<br>3499）</p>
</li>
<li><p>于是接收⽅发现数据是重复收到的，于是回了⼀个 SACK &#x3D; 3000<del>3500，告诉「发送⽅」 3000</del>3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK 。这样发送⽅就知道了，数据没有丢，是接收⽅的 ACK 确认报⽂丢了。</p>
</li>
</ul>
<h3 id="43-说说-TCP-的粘包和拆包？"><a href="#43-说说-TCP-的粘包和拆包？" class="headerlink" title="43.说说 TCP 的粘包和拆包？"></a>43.说说 TCP 的粘包和拆包？</h3><p>TCP 的粘包和拆包更多的是业务上的概念！</p>
<blockquote>
<p><strong>什么是 TCP 粘包和拆包？</strong></p>
</blockquote>
<p>TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一<strong>个完整的包可能会被 TCP 拆分成多个包进行发送</strong>，<strong>也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是所谓的 TCP 粘包和拆包问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104919.png" alt="20250717104919"></p>
<blockquote>
<p><strong>为什么会产生粘包和拆包呢?</strong></p>
</blockquote>
<ul>
<li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li>
<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li>
</ul>
<blockquote>
<p><strong>那怎么解决呢？</strong></p>
</blockquote>
<ul>
<li>发送端将每个数据包封装为固定长度</li>
<li>在数据尾部增加特殊字符进行分割</li>
<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li>
</ul>
<h3 id="63-一个TCP连接可以发送多少次HTTP请求-（补充）"><a href="#63-一个TCP连接可以发送多少次HTTP请求-（补充）" class="headerlink" title="63.一个TCP连接可以发送多少次HTTP请求?（补充）"></a>63.一个TCP连接可以发送多少次HTTP请求?（补充）</h3><p>一个 TCP 连接可以发送多少次 HTTP 请求，取决于 HTTP 协议的版本。</p>
<p>在 HTTP&#x2F;1.0 中，每个 HTTP 请求-响应使用一个单独的 TCP 连接。这意味着每次发送 HTTP 请求都需要建立一个新的 TCP 连接。</p>
<p><code>HTTP/1.1</code> 引入了持久连接（Persistent Connection），默认情况下允许在一个 TCP 连接上发送多个 HTTP 请求。</p>
<p>通过使用 <code>Connection: keep-alive</code> 头部实现，保持连接打开状态，直到明确关闭为止。这极大地提高了效率，因为无需为每个请求都建立新的连接。</p>
<p>此外，<code>HTTP/1.1</code> 支持请求管道化（Pipelining），允许客户端在收到前一个响应之前发送多个请求。</p>
<p>HTTP&#x2F;2 进一步优化了连接复用，允许在单个 TCP 连接上同时发送多个请求和响应，这些请求和响应被分割成帧并通过流传输。HTTP&#x2F;2 的多路复用（Multiplexing）机制显著提高了并发性能和资源利用效率。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="44-说说-TCP-和-UDP-的区别？"><a href="#44-说说-TCP-和-UDP-的区别？" class="headerlink" title="44.说说 TCP 和 UDP 的区别？"></a>44.说说 TCP 和 UDP 的区别？</h3><p><code>TCP</code> 是<strong>面向连接</strong>的，而 <code>UDP</code> 是<strong>无连接的</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718095307.png" alt="20250718095307"></p>
<p>TCP 就像是打电话一对一私聊，UDP 就像是拿个大喇叭在广播。</p>
<p>在数据传输开始之前，TCP 需要先建立连接，数据传输完成后，再断开连接。这个过程通常被称为“三次握手”、“四次挥手”。</p>
<p>UDP 是无连接的，发送数据之前不需要建立连接，发送完毕也不需要断开，数据以数据报形式发送。</p>
<p>换句话说：TCP 是可靠的，它通过确认机制、重发机制等来保证数据的可靠传输。而 UDP 是不可靠的，数据包可能会丢失、重复、乱序。</p>
<h4 id="说说-TCP-和-UDP-的应用场景？"><a href="#说说-TCP-和-UDP-的应用场景？" class="headerlink" title="说说 TCP 和 UDP 的应用场景？"></a>说说 TCP 和 UDP 的应用场景？</h4><ul>
<li><strong>TCP：</strong> 适用于那些<strong>对数据准确性要求高于数据传输速度</strong>的场合。例如：网页浏览、电子邮件、文件传输（FTP）、远程控制、数据库链接。</li>
<li><strong>UDP：</strong> 适用于<strong>对速度要求高、可以容忍一定数据丢失</strong>的场合。例如：QQ 聊天、在线视频、网络语音电话、广播通信。容忍一定的数据丢失。</li>
</ul>
<h4 id="你会如何设计-QQ-中的网络协议？"><a href="#你会如何设计-QQ-中的网络协议？" class="headerlink" title="你会如何设计 QQ 中的网络协议？"></a>你会如何设计 QQ 中的网络协议？</h4><p>首先，我们要实现登录功能，这是使用 QQ 的第一步，为了保证账号和密码的安全性，我们可以选择 <code>TCP + SSL/TLS</code> 协议来<strong>进行登录</strong>。</p>
<p>因为 TCP 协议是一种可靠的传输协议，能够保证数据的完整性，而 <code>SSL/TLS</code> 能够对通信进行加密，保证数据的安全性。</p>
<p>接下来，我们需要考虑消息传递的实时性，如语音视频通话等，这时候我们可以选择 <code>UDP</code> 协议。UDP 的传输速度更快，对于实时性服务来说，速度是最重要的。</p>
<h4 id="如何保证消息的不丢失？"><a href="#如何保证消息的不丢失？" class="headerlink" title="如何保证消息的不丢失？"></a>如何保证消息的不丢失？</h4><p>对于 TCP 协议来说，如果数据包在传输过程中丢失，TCP 协议会自动进行重传。</p>
<p>而对于 UDP 协议来说，我们可以通过<strong>应用层的重传机制</strong>来保证消息的不丢失。当接收方收到消息后，返回一个确认信息给发送方，如果发送方在一定时间内没有收到确认信息，就重新发送消息。</p>
<p>同时，每个消息都附带一个<strong>唯一的序列号</strong>，接收方根据序列号判断是否有消息丢失，如果发现序列号不连续，就可以要求发送方重新发送。这样还可以防止消息重复。</p>
<p>当然了，<strong>消息持久化</strong>也很重要，可以将消息<strong>保存在服务器或者本地的数据库</strong>中，即使在网络中断或者其他异常情况下，也能从数据库中恢复消息。</p>
<h3 id="45-为什么-QQ-采用-UDP-协议？"><a href="#45-为什么-QQ-采用-UDP-协议？" class="headerlink" title="45.为什么 QQ 采用 UDP 协议？"></a>45.为什么 QQ 采用 UDP 协议？</h3><p>PS：这是多年前的老题了，拉出来怀怀旧。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718100733.png" alt="20250718100733"></p>
<ul>
<li>首先，QQ 并不是完全基于 UDP 实现。比如在使用 QQ 进行<strong>文件传输等活动的时</strong>候，就会使用 <strong>TCP</strong> 作为可靠传输的保证。</li>
<li>使用 <code>UDP</code> 进行交互通信的好处在于，<strong>延迟较短</strong>，对数据丢失的处理比较简单。同时，TCP 是一个全双工协议，需要建立连接，所以<strong>网络开销也会相对大</strong>。</li>
<li>如果使用 QQ 语音和 QQ 视频的话，UDP 的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。</li>
<li>由于 QQ 的服务器<strong>设计容量是海量级的应用</strong>，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用 UDP 协议与客户端进行通讯才能保证这种超大规模的服务</li>
</ul>
<p>简单总结一下：UDP 协议<strong>是无连接方式的协议</strong>，它的<strong>效率高</strong>，<strong>速度快</strong>，<strong>占资源少</strong>，对服务器的压力比较小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。QQ 采用的通信协议以 UDP 为主，辅以 TCP 协议。</p>
<h3 id="46-UDP-协议为什么不可靠？"><a href="#46-UDP-协议为什么不可靠？" class="headerlink" title="46.UDP 协议为什么不可靠？"></a>46.UDP 协议为什么不可靠？</h3><p>UDP 在传输数据之前<strong>不需要先建立连接</strong>，远地主机的运输层在接收到 <code>UDP</code> 报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付：不确认，不重传，无超时</li>
<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<h3 id="47-DNS-为什么要用-UDP"><a href="#47-DNS-为什么要用-UDP" class="headerlink" title="47.DNS 为什么要用 UDP?"></a>47.DNS 为什么要用 UDP?</h3><p>更准确地说，<strong>DNS 既使用 TCP 又使用 UDP</strong>。</p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为<strong>数据同步传送的数据量比一个请求和应答的数据量要多</strong>，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p>
<p>当客户端想 DNS 服务器查询域名（域名解析）的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节，用 UDP 传输时，不需要创建连接，从而大大提高了响应速度，但这要求域名解析服务器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="48-IP-协议的定义和作用？"><a href="#48-IP-协议的定义和作用？" class="headerlink" title="48.IP 协议的定义和作用？"></a>48.IP 协议的定义和作用？</h3><p><code>IP</code> 协议（Internet Protocol）用于在计算机网络之间传输数据包，它定义了数据包的格式和处理规则，确保数据能够从一个设备传输到另一个设备，可能跨越多个中间网络设备（如路由器）。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718103720.png" alt="20250718103720"></p>
<h4 id="IP-协议有哪些作用？"><a href="#IP-协议有哪些作用？" class="headerlink" title="IP 协议有哪些作用？"></a>IP 协议有哪些作用？</h4><p>①、<strong>寻址</strong>：每个<strong>连接到网络的设备都有一个唯一的 IP 地址</strong>。IP 协议使用这些地址来标识数据包的源地址和目的地址，确保数据包能够准确地传输到目标设备。</p>
<p>②、<strong>路由</strong>：IP 协议负责决定数据包在网络传输中的路径。比如说路由器使用路由表和 IP 地址信息来确定数据包的最佳传输路径。</p>
<p>③、<strong>分片和重组</strong>：当数据包过大无法在某个网络上传输时，IP 协议会将数据包分成更小的片段进行传输。接收端会根据头部信息将这些片段重新组装成完整的数据包。</p>
<h4 id="举一个实际的例子来说明？"><a href="#举一个实际的例子来说明？" class="headerlink" title="举一个实际的例子来说明？"></a>举一个实际的例子来说明？</h4><p>假设有两个设备 A 和 B 通过互联网通信，A 的 IP 地址是 <code>192.168.1.1</code>，B 的 IP 地址是 <code>203.0.113.5</code>。数据包的传输过程如下：</p>
<p>①、设备 A 发送数据包：</p>
<ul>
<li>设备 A 创建一个 IP 数据包，设置源地址为 <code>192.168.1.1</code>，目的地址为 <code>203.0.113.5</code>，将要传输的数据放入数据部分。</li>
<li>数据包封装后，通过本地网络发送到路由器。</li>
</ul>
<p>②、路由器转发数据包：</p>
<ul>
<li>路由器根据路由表查找目的地址 <code>203.0.113.5</code>，确定数据包的传输路径。</li>
<li>数据包可能经过多个中间路由器，每个路由器都根据路由表选择下一跳，最终到达目标设备的网络。</li>
</ul>
<p>③、设备 B 接收数据包：</p>
<ul>
<li>设备 B 接收数据包，读取 <code>IP</code> 头部信息，验证数据包的完整性。</li>
<li>并数据部分取出，交给上层协议处理（如 TCP 或 UDP）。</li>
</ul>
<h3 id="49-IP-地址有哪些分类？"><a href="#49-IP-地址有哪些分类？" class="headerlink" title="49.IP 地址有哪些分类？"></a>49.IP 地址有哪些分类？</h3><p>一个 <code>IP</code> 地址在这个互联网范围内是唯一的，一般可以这么认为，<code>IP 地址 = &#123;&lt;网络号&gt;，&lt;主机号&gt;&#125;</code>。</p>
<ol>
<li><strong>网络号</strong>：它标志主机所连接的网络地址表示<strong>属于互联网的哪一个网络</strong>。</li>
<li><strong>主机号</strong>：它标志主机地址表示其属于该<strong>网络中的哪一台主机</strong>。</li>
</ol>
<p>IP 地址分为 A，B，C，D，E 五大类：</p>
<ul>
<li>A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位。</li>
<li>B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位。</li>
<li>C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位。</li>
<li>D 类地址 (224~239)：以 1110 开头，保留为多播地址。</li>
<li>E 类地址 (240~255)：以 1111 开头，保留位为将来使用</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718104718.png" alt="20250718104718"></p>
<h3 id="50-域名和-IP-的关系？一个-IP-可以对应多个域名吗？"><a href="#50-域名和-IP-的关系？一个-IP-可以对应多个域名吗？" class="headerlink" title="50.域名和 IP 的关系？一个 IP 可以对应多个域名吗？"></a>50.域名和 IP 的关系？一个 IP 可以对应多个域名吗？</h3><ul>
<li><code>IP</code> 地址在同一个网络中是唯一的，用来标识每一个网络上的设备，其相当于一个人的身份证号</li>
<li>域名在同一个网络中也是唯一的，就像是一个人的名字、绰号</li>
</ul>
<p>假如你有多个不用的绰号，你的朋友可以用其中任何一个绰号叫你，但你的身份证号码却是唯一的。但同时你的绰号也可能和别人重复，假如你不在，有人叫你的绰号，其它人可能就答应了。</p>
<p>一个域名可以对应多个 IP，但这种情况 DNS 做负载均衡的，在用户访问过程中，<strong>一个域名只能对应一个 IP</strong>。</p>
<p>而一个 <strong>IP 却可以对应多个域名</strong>，是一对多的关系。</p>
<h3 id="51-IPV4-地址不够如何解决？"><a href="#51-IPV4-地址不够如何解决？" class="headerlink" title="51.IPV4 地址不够如何解决？"></a>51.IPV4 地址不够如何解决？</h3><p>我们知道，IP 地址有 <code>32</code> 位，可以标记 2 的 32 次方个地址，听起来很多，但是全球的网络设备数量已经远远超过这个数字，所以 IPV4 地址已经不够用了，那怎么解决呢？</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718105151.png" alt="20250718105151"></p>
<ul>
<li>DHCP：动态主机配置协议，动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用。</li>
<li>CIDR：无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效地分配 IPv4 的地址空间，但无法从根本上解决地址耗尽的问题。</li>
<li>NAT：网络地址转换协议，我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题，然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网主机进行通信时，NAT 方法可以将该主机 IP 地址转换为全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</li>
<li>IPv6：作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使给地球上每一粒沙子都分配一个 IP 地址也够用，该协议能够从根本上解决 IPv4 地址不够用的问题。</li>
</ul>
<h3 id="52-说下-ARP-协议的工作过程？"><a href="#52-说下-ARP-协议的工作过程？" class="headerlink" title="52.说下 ARP 协议的工作过程？"></a>52.说下 ARP 协议的工作过程？</h3><p>ARP（Address Resolution Protocol，地址解析协议）是网络通信中的一种协议，主要目的是将网络层的 <code>IP</code> 地址解析为链路层的 <code>MAC</code> 地址。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718105938.png" alt="20250718105938"></p>
<p>①、ARP 请求</p>
<p>当主机 A 要发送数据给主机 B 时，首先会在自己的 ARP 缓存中查找主机 B 的 MAC 地址。</p>
<p>如果没有找到，主机 A 会向网络中广播一个 ARP 请求数据包，请求网络中的所有主机告诉它们的 MAC 地址；这个请求包含了请求设备和目标设备的 IP 和 MAC 地址。</p>
<p>②、ARP 应答</p>
<p>网络中的所有主机都会收到这个 ARP 请求，但只有主机 B 会回复 ARP 应答，告诉主机 A 自己的 MAC 地址。</p>
<p>并且主机 B 会将主机 A 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中，以便下次通信时直接使用。</p>
<p>③、更新 ARP 缓存</p>
<p>主机 A 收到主机 B 的 ARP 应答后，也会将主机 B 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中。</p>
<h3 id="53-为什么既有-IP-地址，又有-MAC-地址？"><a href="#53-为什么既有-IP-地址，又有-MAC-地址？" class="headerlink" title="53.为什么既有 IP 地址，又有 MAC 地址？"></a>53.为什么既有 IP 地址，又有 MAC 地址？</h3><blockquote>
<p><strong>MAC 地址和 IP 地址都有什么作用？</strong></p>
</blockquote>
<ul>
<li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址，用来定义网络设备的位置，不可变更。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</li>
</ul>
<blockquote>
<p><strong>为什么有了 MAC 地址还需要 IP 地址？</strong></p>
</blockquote>
<p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪个子网，不然一次路由器收到数据包都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是最多共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256T 的内存，显然是不现实的。</p>
<p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p>
<blockquote>
<p><strong>为什么有了 IP 地址还需要 MAC 地址？</strong></p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718110409.png" alt="20250718110409"></p>
<ul>
<li>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候，或者在分配 IP 的过程中。我们需要 MAC 地址来区分不同的设备。</li>
<li>IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。</li>
</ul>
<h3 id="54-ICMP-协议的功能？"><a href="#54-ICMP-协议的功能？" class="headerlink" title="54.ICMP 协议的功能？"></a>54.ICMP 协议的功能？</h3><p>ICMP（Internet Control Message Protocol） ，网际控制报文协议。</p>
<ul>
<li>ICMP 协议是一种面向<code>无连接</code>的协议，用于传输出错报告控制信息。</li>
<li>它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括<strong>报告错误、交换受限控制和状态信息</strong>等。</li>
<li>当遇到 <code>IP</code> 数据无法访问目标、<code>IP</code> 路由器无法按当前的传输速率转发数据包等情况时，会自动发送 <code>ICMP</code> 消息。</li>
</ul>
<p>比如我们日常使用得比较多的 <strong>ping</strong>，就是基于 <code>ICMP</code> 的。</p>
<h3 id="55-说下-ping-的原理？"><a href="#55-说下-ping-的原理？" class="headerlink" title="55.说下 ping 的原理？"></a>55.说下 ping 的原理？</h3><p>ping，<strong>Packet Internet Groper</strong>，一个网络工具，主要用来测试网络连接的可达性和延迟。</p>
<p>Ping 的过程主要基于 ICMP（Internet Control Message Protocol，互联网控制消息协议）实现，其基本过程包括：</p>
<p>①、当执行 Ping 命令，如<code>ping javabetter.cn</code>，Ping 首先解析域名获取 IP 地址，然后向目标 IP 发送一个 ICMP Echo Request 消息。</p>
<p>②、当目标 IP 收到 ICMP Echo Request 消息后，它会生成一个 ICMP Echo Reply 消息并返回，即 Ping 响应消息。</p>
<p>③、发起 Ping 命令的设备接收到 <code>ICMP Echo Reply</code> 消息后，计算并显示从发送 <code>Echo Request</code> 到接收到 <code>Echo Reply</code>的时间（通常称为往返时间 RTT，Round-Trip Time），以及可能的丢包情况。</p>
<p><code>Ping</code> 通常会发送多个请求，以便提供平均响应时间和丢包率等信息，以便我们了解网络连接的质量。</p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="56-说说有哪些安全攻击？"><a href="#56-说说有哪些安全攻击？" class="headerlink" title="56.说说有哪些安全攻击？"></a>56.说说有哪些安全攻击？</h3><p>网络安全攻击主要分为两种类型，<code>被动攻击</code>和<code>主动攻击</code>：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719105300.png" alt="20250719105300"></p>
<ul>
<li><p><strong>被动攻击</strong>：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为截获，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。由于攻击者没有修改数据，使得这种攻击很难被检测到。</p>
</li>
<li><p><strong>主动攻击</strong>：直接对现有的数据和服务造成影响，常见的主动攻击类型有：</p>
</li>
<li><p><strong>篡改</strong>：攻击者故意篡改网络上送的报文，甚至把完全伪造的报文传送给接收方。</p>
</li>
<li><p><strong>恶意程序</strong>：恶意程序种类繁多，包括计算机病毒、计算机蠕虫、特洛伊木马、后门入侵、流氓软件等等。</p>
</li>
<li><p><strong>拒绝服务 Dos</strong>：攻击者向服务器不停地发送分组，使服务器无法提供正常服务。</p>
</li>
</ul>
<h3 id="57-DNS-劫持了解吗？"><a href="#57-DNS-劫持了解吗？" class="headerlink" title="57.DNS 劫持了解吗？"></a>57.DNS 劫持了解吗？</h3><p><code>DNS 劫持</code>即<code>域名劫持</code>，是通过将原域名对应的 IP 地址进行替换，从而使用户访问到错误的网站，或者使用户无法正常访问网站的一种攻击方式。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719110943.png" alt="20250719110943"></p>
<p>域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它主持，并将新的域名信息保存在所指定的 DNS 服务器中，从而使用户无法对原域名来进行解析以访问目标地址。</p>
<blockquote>
<p><strong>DNS 劫持的步骤是什么样的？</strong></p>
</blockquote>
<ol>
<li>获取要劫持的域名信息：攻击者会首先访问域名查询要劫持的站点的域名信息。</li>
<li>控制域名响应的 E-Mail 账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的 E-mail 账号所对应的密码，更高级的攻击者甚至能够直接对 E-Mail 进行信息窃取。</li>
<li>修改注册信息：当攻击者破解了 E-Mail 后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS 服务器信息等。</li>
<li>使用 E-Mail 收发确认函：在修改完注册信息后，攻击者 E-Mail 在真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成 DNS 劫持。</li>
</ol>
<blockquote>
<p><strong>怎么应对 DNS 劫持？</strong></p>
</blockquote>
<ul>
<li>直接通过 IP 地址访问网站，避开 DNS 劫持</li>
<li>由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目标网址的正常访问，例如计算机首选 DNS 服务器的地址固定为 8.8.8.8。</li>
</ul>
<h3 id="58-什么是-CSRF-攻击？如何避免？"><a href="#58-什么是-CSRF-攻击？如何避免？" class="headerlink" title="58.什么是 CSRF 攻击？如何避免？"></a>58.什么是 CSRF 攻击？如何避免？</h3><blockquote>
<p><strong>什么是 CSRF 攻击？</strong></p>
</blockquote>
<p>CSRF，跨站请求伪造（英文全称是 Cross-site request forgery），是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p>
<blockquote>
<p><strong>CSRF 是如何攻击的呢？</strong></p>
</blockquote>
<p>来看一个例子：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719111207.png" alt="20250719111207"></p>
<ol>
<li>用户登陆银行，没有退出，浏览器包含了 用户 在银行的身份认证信息。</li>
<li>攻击者将伪造的转账请求，包含在在帖子</li>
<li>用户在银行网站保持登陆的情况下，浏览帖子</li>
<li>将伪造的转账请求连同身份认证信息，发送到银行网站</li>
<li>银行网站看到身份认证信息，以为就是 用户的合法操作，最后造成用户资金损失。</li>
</ol>
<blockquote>
<p><strong>怎么应对 CSRF 攻击呢？</strong></p>
</blockquote>
<ul>
<li><strong>检查 Referer 字段</strong></li>
</ul>
<p>HTTP 头中的 Referer 字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF 攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证 Referer 值来防御 CSRF 攻击。</p>
<ul>
<li><strong>添加校验 token</strong></li>
</ul>
<p>以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<ul>
<li><strong>敏感操作多重校验</strong></li>
</ul>
<p>对一些敏感的操作，除了需要校验用户的认证信息，还可以通过邮箱确认、验证码确认这样的方式多重校验。</p>
<h3 id="59-什么是-DoS、DDoS、DRDoS-攻击？"><a href="#59-什么是-DoS、DDoS、DRDoS-攻击？" class="headerlink" title="59.什么是 DoS、DDoS、DRDoS 攻击？"></a>59.什么是 DoS、DDoS、DRDoS 攻击？</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719111233.png" alt="20250719111233"></p>
<ul>
<li><strong>DOS</strong>: (Denial of Service), 翻译过来就是拒绝服务, 一切能引起拒绝 行为的攻击都被称为 DOS 攻击。最常见的 DoS 攻击就有<strong>计算机网络宽带攻击</strong>、<strong>连通性攻击</strong>。</li>
<li><strong>DDoS</strong>: (Distributed Denial of Service)，翻译过来是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器，并利用这些机器对受害者同时实施攻击。</li>
</ul>
<p>主要形式有流量攻击和资源耗尽攻击，常见的 DDoS 攻击有：<strong>SYN Flood、Ping of Death、ACK Flood、UDP Flood</strong> 等。</p>
<ul>
<li><strong>DRDoS</strong>: (Distributed Reflection Denial of Service)，中文是分布式反射拒绝服务，该方式靠的是发送大量带有被害者 IP 地址的数据包给攻击主机，然后攻击主机对 IP 地址源做出大量回应，从而形成拒绝服务攻击。</li>
</ul>
<blockquote>
<p><strong>如何防范 DDoS?</strong></p>
</blockquote>
<p>针对 DDoS 中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足带宽的前提下，我们应该尽量提升路由器、网卡、交换机等硬件设施的配置。</p>
<p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能够有效对抗海量的 SYN 攻击包。我们也可以安装专业的抗 DDoS 防火墙，从而对抗 SYN Flood 等流量型攻击。瓷碗，负载均衡，CDN 等技术都能有效对抗 DDos 攻击。</p>
<h3 id="60-什么是-XSS-攻击，如何避免"><a href="#60-什么是-XSS-攻击，如何避免" class="headerlink" title="60.什么是 XSS 攻击，如何避免?"></a>60.什么是 XSS 攻击，如何避免?</h3><p>XSS 攻击也是比较常见，XSS，叫<strong>跨站脚本攻击（Cross-Site Scripting）</strong>，因为会与层叠样式表 (Cascading Style Sheets, CSS) 的缩写混淆，因此有人将跨站脚本攻击缩写为 XSS。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览网页的时候，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。</p>
<p>XSS 攻击一般分三种类型：<strong>存储型 、反射型 、DOM 型 XSS</strong></p>
<blockquote>
<p><strong>XSS 是如何攻击的呢？</strong></p>
</blockquote>
<p>简单说，XSS 的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。</p>
<p>拿反射型举个例子吧，流程图如下：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 URL 时，访问正常网站服务器</li>
<li>网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行，请求恶意服务器，发送用户数据</li>
<li>攻击者就可以窃取用户的数据，以此冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719111300.png" alt="20250719111300"></p>
<blockquote>
<p><strong>如何应对 XSS 攻击？</strong></p>
</blockquote>
<ul>
<li>对输入进行过滤，过滤标签等，只允许合法值。</li>
<li>HTML 转义</li>
<li>对于链接跳转，如<code>&lt;a href=&quot;xxx&quot;</code> 等，要校验内容，禁止以 script 开头的非法链接。</li>
<li>限制输入长度</li>
</ul>
<h3 id="61-对称加密与非对称加密有什么区别？"><a href="#61-对称加密与非对称加密有什么区别？" class="headerlink" title="61.对称加密与非对称加密有什么区别？"></a>61.对称加密与非对称加密有什么区别？</h3><p><strong>对称加密</strong>：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES 等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719111323.png" alt="20250719111323"></p>
<p><strong>非对称加密</strong>：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有 RSA。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250719111341.png" alt="20250719111341"></p>
<h3 id="62-RSA-和-AES-算法有什么区别？"><a href="#62-RSA-和-AES-算法有什么区别？" class="headerlink" title="62.RSA 和 AES 算法有什么区别？"></a>62.RSA 和 AES 算法有什么区别？</h3><ul>
<li><strong>RSA</strong></li>
</ul>
<p>采用非对称加密的方式，采用公钥进行加密，私钥解密的形式。其私钥长度一般较长，由于需要大数的乘幂求模等运算，其运算速度较慢，不合适大量数据文件加密。</p>
<ul>
<li><strong>AES</strong></li>
</ul>
<p>采用对称加密的方式，其秘钥长度最长只有 256 个比特，加密和解密速度较快，易于硬件实现。由于是对称加密，通信双方在进行数据传输前需要获知加密密钥。</p>

<div class="article-footer slide-up fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap slide-up" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/07/15/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B47%E6%9C%88/2025.7.15%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.7.15学习日记</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/07/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B47%E6%9C%88/2025.7.14%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.7.14学习日记</a></div></section></div>







<footer class="page-footer slide-up footnote"><hr><div class="text"><p>本站由 <a href="/">JakicDong</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0">Stellar 1.30.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper slide-up toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">1.计算机网络体系的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">说说 OSI 七层模型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-TCP-IP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">说说 TCP&#x2F;IP 四层模型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">说说五层体系结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-text">TCP三次握手四次挥手工作在哪一层？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9F"><span class="toc-text">讲一下计算机网络？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%AF%8F%E4%B8%80%E5%B1%82%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">2.说一下每一层对应的网络协议有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%82%A3%E4%B9%88%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E8%BE%93%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">3.那么数据在各层之间是怎么传输的呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%BC%E5%90%88"><span class="toc-text">网络综合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5-url-%E5%88%B0%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">4.从浏览器地址栏输入 url 到显示网页的过程了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E8%BF%87%E7%A8%8B%E9%83%BD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">各个过程都使用了哪些协议？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%B4%E8%AF%B4-DNS-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">5.说说 DNS 的解析过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%B4%E8%AF%B4-WebSocket-%E4%B8%8E-Socket-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6.说说 WebSocket 与 Socket 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="toc-text">7.说一下你了解的端口及对应的服务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B9%B3%E5%B8%B8%E6%9C%89%E6%8A%93%E5%8C%85%E5%90%97%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%EF%BC%9F"><span class="toc-text">8.平常有抓包吗（补充）？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AF%B4%E8%AF%B4-HTTP-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-text">8.说说 HTTP 常用的状态码及其含义？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-301-%E5%92%8C-302-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">说一下 301 和 302 的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-HTTP-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">9.HTTP 有哪些请求方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E7%9A%84-GET-%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%86%99%E6%93%8D%E4%BD%9C%E5%90%97"><span class="toc-text">HTTP 的 GET 方法可以实现写操作吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89%EF%BC%9F%E5%B9%82%E7%AD%89%E6%96%B9%E6%B3%95%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">什么是幂等？幂等方法了解哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%AF%B4%E2%BC%80%E4%B8%8B-GET-%E5%92%8C-POST-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">10.说⼀下 GET 和 POST 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-GET-%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">11.GET 的长度限制是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-HTTP-%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">12.HTTP 请求的过程与原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9D%A5%E4%B8%8B%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%91%A2%EF%BC%9F"><span class="toc-text">怎么利用多线程来下载一个数据呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%8F%AA%E8%A6%81%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%8D%E5%8D%81%E4%B8%AA%E5%AD%97%E8%8A%82%E5%91%A2%EF%BC%9F"><span class="toc-text">如果只要下载数据的前十个字节呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%AF%B4%E4%B8%80%E4%B8%8B-HTTP-%E7%9A%84%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">13.说一下 HTTP 的报文结构？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B-HTTP-%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">说下 HTTP 的请求报文结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B-HTTP-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">说下 HTTP 响应报文结构？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-URI-%E5%92%8C-URL-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">14.URI 和 URL 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E8%AF%B4%E4%B8%8B-HTTP1-0%EF%BC%8C1-1%EF%BC%8C2-0-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">15.说下 HTTP1.0，1.1，2.0 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B-HTTP1-0"><span class="toc-text">说下 HTTP1.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B-HTTP1-1"><span class="toc-text">说下 HTTP1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B-HTTP2-0"><span class="toc-text">说下 HTTP2.0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-HTTP-3-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">16.HTTP&#x2F;3 了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B9%BF%E6%B3%9B%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AAHTTP%E7%89%88%E6%9C%AC%EF%BC%9F"><span class="toc-text">目前使用最广泛的是哪个HTTP版本？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-HTTP-%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">17.HTTP 长连接了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">如何设置长连接？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%B6%85%E6%97%B6%E5%91%A2%EF%BC%9F"><span class="toc-text">在什么时候会超时呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%AF%B4%E8%AF%B4-HTTP-%E4%B8%8E-HTTPS-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">18.说说 HTTP 与 HTTPS 有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-HTTPS%EF%BC%9F"><span class="toc-text">19.为什么要用 HTTPS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-HTTPS%E6%98%AF%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F"><span class="toc-text">20.HTTPS是怎么建立连接的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS-%E4%BC%9A%E5%8A%A0%E5%AF%86-URL-%E5%90%97%EF%BC%9F"><span class="toc-text">HTTPS 会加密 URL 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">什么是中间人攻击？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%BB%BA%E7%AB%8B%E7%9A%84%E4%BF%A1%E9%81%93%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">HTTPS怎么保证建立的信道是安全的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS-%E8%83%BD%E6%8A%93%E5%8C%85%E5%90%97%EF%BC%9F"><span class="toc-text">HTTPS 能抓包吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%8E%E4%B9%88%E5%8E%BB%E6%A0%A1%E9%AA%8C%E8%AF%81%E4%B9%A6%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7%EF%BC%9F"><span class="toc-text">21.客户端怎么去校验证书的合法性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-HTTP-%E5%8D%8F%E8%AE%AE%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%EF%BC%9F"><span class="toc-text">22.如何理解 HTTP 协议是无状态的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E8%AE%B0%E5%BD%95%E7%8A%B6%E6%80%81%E5%91%A2%EF%BC%9F"><span class="toc-text">那有什么办法记录状态呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E8%AF%B4%E8%AF%B4-Session-%E5%92%8C-Cookie-%E6%9C%89%E4%BB%80%E4%B9%88%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">23.说说 Session 和 Cookie 有什么联系和区别?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B-TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">24.详细说一下 TCP 的三次握手机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%86%8D%E4%B8%BE%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%90%97%EF%BC%9F"><span class="toc-text">可以再举一个例子说明 TCP 三次握手吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-SYN-%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="toc-text">说说 SYN 的概念？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-TCP-%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F%E4%B8%8D%E8%83%BD%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-text">25.TCP 握手为什么是三次，为什么不能是两次？不能是四次？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E6%8F%A1%E6%89%8B%E4%B8%8D%E8%83%BD%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F"><span class="toc-text">为什么 TCP 握手不能是两次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-text">为什么不是四次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">什么是泛洪攻击？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-text">如果让你重新设计，怎么设计？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%AD%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%94%B6%E5%88%B0%E6%8A%A5%E6%96%87%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">26.三次握手中每一次没收到报文会发生什么情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86-ACK%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9E-SYN%EF%BC%9F"><span class="toc-text">27.第二次握手传回了 ACK，为什么还要传回 SYN？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E7%AC%AC-3-%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-text">28.第 3 次握手可以携带数据吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E4%BA%86%E8%A7%A3-TCP-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E5%90%97%EF%BC%9F"><span class="toc-text">29.了解 TCP 半连接状态吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-text">说说半连接队列？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-SYN-Flood-%EF%BC%9F"><span class="toc-text">什么是 SYN Flood ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88%E5%91%A2%EF%BC%9F"><span class="toc-text">那有什么应对方案呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E8%AF%B4%E8%AF%B4-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">30.说说 TCP 四次挥手的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-TCP-%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E5%91%A2%EF%BC%9F"><span class="toc-text">31.TCP 挥手为什么需要四次呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2MSL-%E6%89%8D%E8%BF%9B%E5%85%A5-CLOSED-%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">32.TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E4%BF%9D%E6%B4%BB%E8%AE%A1%E6%97%B6%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">33.保活计时器有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-CLOSE-WAIT-%E5%92%8C-TIME-WAIT-%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-text">34.CLOSE-WAIT 和 TIME-WAIT 的状态和意义？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CLOSE-WAIT-%E7%8A%B6%E6%80%81%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-text">CLOSE-WAIT 状态有什么意义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TIME-WAIT-%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-text">TIME-WAIT 有什么意义？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-TIME-WAIT-%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">35.TIME_WAIT 状态过多会导致什么问题？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E8%AF%B4%E8%AF%B4-TCP-%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9F"><span class="toc-text">36.说说 TCP 报文头部的格式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E9%9D%A0%EF%BC%9F"><span class="toc-text">37.TCP 为什么可靠？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E8%AF%B4%E8%AF%B4-TCP-%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">38.说说 TCP 的流量控制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4-TCP-%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9F"><span class="toc-text">39.详细说说 TCP 的滑动窗口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E4%BA%86%E8%A7%A3-Nagle-%E7%AE%97%E6%B3%95%E5%92%8C%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4%E5%90%97%EF%BC%9F"><span class="toc-text">40.了解 Nagle 算法和延迟确认吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E8%AF%B4%E8%AF%B4-TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">41.说说 TCP 的拥塞控制？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">什么是拥塞控制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A5%E5%A1%9E%E7%AA%97%E2%BC%9D%EF%BC%9F%E5%92%8C%E5%8F%91%E9%80%81%E7%AA%97%E2%BC%9D%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E5%91%A2%EF%BC%9F"><span class="toc-text">什么是拥塞窗⼝？和发送窗⼝有什么关系呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">拥塞控制有哪些常用算法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E8%AF%B4%E8%AF%B4-TCP-%E7%9A%84%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">42.说说 TCP 的重传机制？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E5%BA%94%E8%AF%A5%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%A4%9A%E5%B0%91%E5%91%A2%EF%BC%9F"><span class="toc-text">超时时间应该设置为多少呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%EF%BC%9F"><span class="toc-text">什么是快速重传？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%A6%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4%E7%9A%84%E9%87%8D%E4%BC%A0-SACK"><span class="toc-text">什么是带选择确认的重传(SACK)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%A4%8D-SACK%EF%BC%88D-SACK%EF%BC%89"><span class="toc-text">什么是重复 SACK（D-SACK）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E8%AF%B4%E8%AF%B4-TCP-%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F"><span class="toc-text">43.说说 TCP 的粘包和拆包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E5%8F%AF%E4%BB%A5%E5%8F%91%E9%80%81%E5%A4%9A%E5%B0%91%E6%AC%A1HTTP%E8%AF%B7%E6%B1%82-%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">63.一个TCP连接可以发送多少次HTTP请求?（补充）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E8%AF%B4%E8%AF%B4-TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">44.说说 TCP 和 UDP 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-TCP-%E5%92%8C-UDP-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">说说 TCP 和 UDP 的应用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1-QQ-%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">你会如何设计 QQ 中的网络协议？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-text">如何保证消息的不丢失？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E4%B8%BA%E4%BB%80%E4%B9%88-QQ-%E9%87%87%E7%94%A8-UDP-%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">45.为什么 QQ 采用 UDP 协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-UDP-%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E9%9D%A0%EF%BC%9F"><span class="toc-text">46.UDP 协议为什么不可靠？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-DNS-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-UDP"><span class="toc-text">47.DNS 为什么要用 UDP?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP"><span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#48-IP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">48.IP 协议的定义和作用？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP-%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">IP 协议有哪些作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%99%85%E7%9A%84%E4%BE%8B%E5%AD%90%E6%9D%A5%E8%AF%B4%E6%98%8E%EF%BC%9F"><span class="toc-text">举一个实际的例子来说明？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-IP-%E5%9C%B0%E5%9D%80%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-text">49.IP 地址有哪些分类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E5%9F%9F%E5%90%8D%E5%92%8C-IP-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F%E4%B8%80%E4%B8%AA-IP-%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%BA%94%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%E5%90%97%EF%BC%9F"><span class="toc-text">50.域名和 IP 的关系？一个 IP 可以对应多个域名吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-IPV4-%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%A4%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">51.IPV4 地址不够如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E8%AF%B4%E4%B8%8B-ARP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">52.说下 ARP 协议的工作过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A2%E6%9C%89-IP-%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%8F%88%E6%9C%89-MAC-%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-text">53.为什么既有 IP 地址，又有 MAC 地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-ICMP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">54.ICMP 协议的功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E8%AF%B4%E4%B8%8B-ping-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">55.说下 ping 的原理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-text">网络安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E8%AF%B4%E8%AF%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">56.说说有哪些安全攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-DNS-%E5%8A%AB%E6%8C%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">57.DNS 劫持了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">58.什么是 CSRF 攻击？如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E4%BB%80%E4%B9%88%E6%98%AF-DoS%E3%80%81DDoS%E3%80%81DRDoS-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">59.什么是 DoS、DDoS、DRDoS 攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-text">60.什么是 XSS 攻击，如何避免?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">61.对称加密与非对称加密有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-RSA-%E5%92%8C-AES-%E7%AE%97%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">62.RSA 和 AES 算法有什么区别？</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function (response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function (data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function (error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.30.0" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script defer src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const slideUp = {
      distance: `16px`,
      duration: `800`,
      interval: `100`,
      scale: `1`,
      opacity: 0,
      easing: "ease-out"
    };
    ScrollReveal().reveal('.l_left .slide-up', slideUp);
    ScrollReveal().reveal('.l_main .slide-up', slideUp);
    ScrollReveal().reveal('.l_right .slide-up', slideUp);
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script><script src="/js/check-in.js"></script></div></body></html>
