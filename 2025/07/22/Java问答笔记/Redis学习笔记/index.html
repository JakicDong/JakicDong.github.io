
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0" theme-name="Stellar" theme-version="1.30.0">
  
  <meta name="generator" content="Hexo 7.0.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄 - Jakic's Blog</title>

  
    <meta name="description" content="数据结构为五雷法，持久化是还阳术——施主可要参悟这「键值天道」玄机？">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄">
<meta property="og:url" content="https://jakicdong.github.io/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Jakic&#39;s Blog">
<meta property="og:description" content="数据结构为五雷法，持久化是还阳术——施主可要参悟这「键值天道」玄机？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250725112831.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250725112927.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250726113716.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250726113912.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811101352.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811102451.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811102931.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103014.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103028.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103046.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103115.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103129.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103146.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103203.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103219.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205152.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205641.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205919.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912210551.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912210654.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211024.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211154.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211332.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912215413.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912215459.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912215527.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912215558.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912215722.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913100035.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913100220.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913104621.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913104709.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913105114.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913105824.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913113222.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913113235.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095518.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095613.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928161918.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928162003.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928162408.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163257.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163337.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163355.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163542.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163946.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928164026.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928164208.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928165143.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928165506.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095627.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095640.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095649.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928170721.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928170750.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928170909.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928170958.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928171009.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-60497f1e-8afb-44b3-bb7a-d4c29e5ac484.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017190721.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017190805.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017191223.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017191400.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240709135618.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017192514.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017192546.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017192613.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017193800.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017193813.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194014.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194024.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194045.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194056.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194217.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194302.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194341.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194612.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194846.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194935.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195239.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195331.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195349.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195430.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195507.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195932.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017200028.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017200511.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201053.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201245.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201313.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201418.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201440.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201504.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201546.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201613.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017202156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017202216.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017202942.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203115.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203224.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203323.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203335.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203348.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203404.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203559.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203838.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017204303.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017204312.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022093956.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022094156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022094922.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022095153.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-288af5a2-ae5a-427a-95e9-b4a658b01386.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022100013.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022101036.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022105702.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022105811.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110143.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110356.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110609.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110559.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110834.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110950.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111121.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111140.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111245.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111409.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111527.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111804.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111831.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111848.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111942.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022112218.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022112241.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022112415.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250525074224.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250525075244.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240326214119.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250527111551.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240326214800.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240326215240.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250527115004.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250527120727.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-e4b192a1-3ba7-4f4e-98de-e93f437cff7c.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-bc6d05be-3701-4e23-b4ca-6330c949f020.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-54bbcc36-0b00-4142-a6eb-bf2ef48c2213.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250528203451.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529063154.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240314101439.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529063910.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529065426.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529065131.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529082025.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529082120.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529082216.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529082551.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529085332.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529085959.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529090547.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250530151227.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250601080336.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-38aee4c1-efd2-495e-8a6d-164d21a129b1.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250601092704.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250601094500.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250601082813.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-710cdd19-98ea-4e96-b579-ff1ebb0d5de9.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20241122191044.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20241122192038.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250602113225.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918110433.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250603092903.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240816113330.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250602112537.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-a1b2d2f9-6895-4749-9bda-9314f08bca68.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-7c038f2c-b5ee-4229-9449-713fab3b1855.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-9934b4a2-c253-4d42-acf4-c6c940840779.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604112041.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604112357.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604113025.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-886ee2a8-fb02-4908-bbba-d4ad2a211094.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604113520.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604114217.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604114432.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-1adef9c0-8feb-4836-8997-84bda96e2498.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-833dbfb2-7c79-4e7b-a143-8a4a2936cdd8.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250605132505.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250605134114.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250605135850.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607094736.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240403105313.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240403105754.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607100252.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250605142339.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-2541fd26-4e84-467d-8d8c-c731154a85d7.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-fc26a4e7-1c8d-4e82-b7f8-1f6b43d16d38.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-e08347a6-efd5-47c0-9adb-23baff82dbbd.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250606105102.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250606105352.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250606111301.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250608111336.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-08391728-5ba8-42a0-a287-9284451e0ee7.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607102238.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607103728.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607104019.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607110105.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607103155.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250608115835.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250608112525.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250608113417.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-%E4%BA%8C%E5%93%A5%EF%BC%8C%E6%88%91%E6%84%9F%E8%A7%89%E4%BD%A0%E8%BF%99%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%E5%86%99%E7%9A%84%E7%9C%9F%E4%B8%8D%E9%94%99%EF%BC%8C%E2%91%A4%E4%B9%8B%E5%89%8D.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-6be492f7-9f92-4607-a4c4-81a612a3d7bd.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20241225105623.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250609093621.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250609093736.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b5d224c2-53ee-40a3-9efc-2feb7dd3d7a8.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604112846.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250609094439.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250609094615.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250609100519.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-3b9785b0-6573-4c2d-8b7d-d5d1be799e26.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250610105328.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250610110115.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250610112125.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-%E4%BA%8C%E5%93%A5%EF%BC%8C%E6%88%91%E6%98%AF%E4%B9%8B%E5%89%8D%E5%8F%91%E9%82%AE%E4%BB%B6%E8%AF%B7%E6%82%A8%E4%BF%AE%E6%94%B9%E7%AE%80.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250612102525.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240420102552.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250612103728.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250612104416.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250612104916.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250612152123.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250613104134.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240420104633.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240420104921.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240420114025.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250613110150.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20250614112846.png">
<meta property="article:published_time" content="2025-07-21T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-23T02:53:31.341Z">
<meta property="article:author" content="JakicDong">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250725112831.png">
  
  
  
  <meta name="keywords" content="基础,Java">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.30.0">


  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/logo.png">
  

  

  
<!-- hexo injector head_end start --><script src="./func.js"></script><!-- hexo injector head_end end --></head>
<link rel="stylesheet" href="/css/check-in.css"><body><div class="sitebg"><div class="siteblur"></div></div>

<div class="l_body content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://avatars.githubusercontent.com/u/130200522?v=4" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Jakic's Blog</div><div class="sub normal cap">学习生活记录</div><div class="sub hover cap" style="opacity:0"> 踏上取经路,比抵达灵山更重要</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客首页" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="打卡墙" href="/check-in" style="color:#1976D2"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="github" target="_blank" rel="noopener" href="https://github.com/JakicDong/" style="color:#1BCDFC"><svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle"> <path fill="#cccccc" d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path> </svg></a><a class="nav-item" title="力扣" target="_blank" rel="noopener" href="https://leetcode.cn/u/dong7/" style="color:#3DC550"><svg width="59" height="22" viewBox="0 0 59 22" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-full w-auto max-w-none"> <path fill-rule="evenodd" clip-rule="evenodd" d="M27.8226 17.4752C28.3202 16.1443 28.7218 14.5458 28.9859 12.6607C29.1277 11.6491 29.2845 10.1658 29.4568 8.20813H35.2561C35.2637 8.20813 35.2713 8.20828 35.2789 8.20857C35.6071 8.22119 35.8628 8.49743 35.8502 8.82558L35.4996 17.9427C35.4873 18.262 35.2249 18.5144 34.9054 18.5144H33.2974C32.8595 18.5144 32.5046 18.8694 32.5046 19.3072C32.5046 19.7451 32.8595 20.1 33.2974 20.1H35.4776C36.3533 20.1 37.0631 19.3901 37.0631 18.5144L37.4595 8.20813C37.4595 7.33244 36.7497 6.62254 35.874 6.62254H29.5913C29.671 5.65054 29.7537 4.58575 29.8394 3.42794C29.8718 2.99129 29.544 2.61109 29.1074 2.57874C28.6707 2.54639 28.2905 2.87414 28.2582 3.3108C28.1689 4.51669 28.0829 5.62069 28.0004 6.62254H25.3695C24.9316 6.62254 24.5767 6.97749 24.5767 7.41534C24.5767 7.85318 24.9316 8.20813 25.3695 8.20813H27.8651C27.7 10.07 27.5501 11.4816 27.4157 12.4407C27.1674 14.2124 26.7941 15.6986 26.3374 16.9199C26.0981 17.5599 25.8527 18.0822 25.6163 18.4944C25.5366 18.6333 25.4649 18.7474 25.4029 18.8378C25.3703 18.8853 25.3512 18.9109 25.3475 18.9155C25.0722 19.256 25.1252 19.7552 25.4657 20.0305C25.8062 20.3057 26.3054 20.2528 26.5806 19.9123C26.6737 19.7971 26.8159 19.5898 26.9917 19.2833C27.271 18.7963 27.5531 18.1959 27.8226 17.4752ZM48.5586 17.3184V7.72969H55.6831C56.3474 7.72969 56.883 8.26047 56.883 8.9117V16.4576C56.883 17.1088 56.3474 17.6396 55.6831 17.6396H53.3916C52.7274 17.6396 52.1918 17.1088 52.1918 16.4576V10.1081C52.1918 9.67022 51.8369 9.31528 51.399 9.31528C50.9612 9.31528 50.6062 9.67022 50.6062 10.1081V16.4576C50.6062 17.9877 51.8548 19.2252 53.3916 19.2252H55.6831C57.2199 19.2252 58.4686 17.9877 58.4686 16.4576V8.9117C58.4686 7.38157 57.2199 6.14411 55.6831 6.14411H48.5586V3.76573C48.5586 3.32788 48.2037 2.97294 47.7658 2.97294C47.328 2.97294 46.9731 3.32788 46.9731 3.76573V6.14411H44.1983C43.7604 6.14411 43.4055 6.49905 43.4055 6.9369C43.4055 7.37475 43.7604 7.72969 44.1983 7.72969H46.9731V12.465L44.3002 13.5341C43.8937 13.6968 43.696 14.1581 43.8586 14.5647C44.0212 14.9712 44.4826 15.1689 44.8891 15.0063L46.9731 14.1727V17.3184C46.9731 18.3666 46.0906 19.2252 44.9911 19.2252C44.5532 19.2252 44.1983 19.5801 44.1983 20.018C44.1983 20.4558 44.5532 20.8108 44.9911 20.8108C46.9567 20.8108 48.5586 19.2522 48.5586 17.3184Z" fill="white"></path> <path d="M13.3797 16.4636C13.874 15.9701 14.674 15.9714 15.1667 16.4665C15.6593 16.9616 15.6581 17.7631 15.1638 18.2566L12.9691 20.4481C10.9443 22.4699 7.64261 22.4992 5.58369 20.5162C5.57179 20.5048 4.655 19.6058 1.63058 16.6402C-0.381491 14.6673 -0.581941 11.5104 1.31147 9.4831L4.84172 5.7031C6.7209 3.69085 10.1849 3.47093 12.3335 5.20847L15.5398 7.80152C16.0828 8.24065 16.1676 9.03757 15.7292 9.58151C15.2909 10.1254 14.4953 10.2104 13.9523 9.77127L10.746 7.17824C9.62238 6.26954 7.65677 6.39434 6.68718 7.43259L3.15688 11.2126C2.23512 12.1996 2.33607 13.7895 3.39833 14.8311C5.61922 17.0088 7.33084 18.6871 7.33282 18.689C8.40324 19.72 10.134 19.7046 11.185 18.6551L13.3797 16.4636Z" fill="#FFA116"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M8.04824 14.2706C7.35039 14.2706 6.78467 13.7039 6.78467 13.0048C6.78467 12.3057 7.35039 11.739 8.04824 11.739H17.3671C18.0649 11.739 18.6306 12.3057 18.6306 13.0048C18.6306 13.7039 18.0649 14.2706 17.3671 14.2706H8.04824Z" fill="#B3B3B3"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M9.79343 0.401024C10.2702 -0.109469 11.0698 -0.136141 11.5794 0.34145C12.089 0.819042 12.1156 1.62004 11.6389 2.13054L3.15692 11.2126C2.23513 12.1995 2.33608 13.7894 3.39827 14.831L7.31536 18.6721C7.81405 19.1611 7.82258 19.9625 7.33442 20.4621C6.84626 20.9616 6.04626 20.9702 5.54757 20.4812L1.63046 16.6401C-0.381492 14.6671 -0.581942 11.5102 1.31155 9.48305L9.79343 0.401024Z" fill="white"></path> </svg></a><a class="nav-item" title="知识星球" target="_blank" rel="noopener" href="https://wx.zsxq.com/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="语雀" target="_blank" rel="noopener" href="https://www.yuque.com/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="sidebar-check-in">
    <div id="sidebar-check-in-calendar"></div>
</div>
<div class="widgets">
<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">专栏：学习博客</span></div><div class="widget-body"><a class="item" href="/2025/10/23/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">场景设计学习笔记-闯架构天宫演诸法,降需求心魔定禅心</span></a><a class="item" href="/2025/10/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%AC%AC%E4%BA%8C%E7%89%88)/"><span class="title">Spring学习笔记(第二版)-炼金丹炉铸Bean山 布注解阵控轮回盘</span></a><a class="item" href="/2025/10/18/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/MYDB%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">MYDB项目笔记</span></a><a class="item" href="/2025/10/17/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RAG%E7%9F%A5%E8%AF%86%E5%BA%93%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">RAG知识库项目笔记</span></a><a class="item" href="/2025/10/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="title">SQL刷题笔记</span></a><a class="item" href="/2025/10/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记-窥内存洞天观玄机,调GC轮回掌生死</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">设计模式学习笔记-布天罡阵降需求妖,演变化术破代码劫</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">微服务学习笔记-化整为零散作星,聚沙成塔架云台</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">操作系统学习笔记-掌轮回内核定纲常,渡进程内存化阴阳</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">分布式学习笔记-架天网布分布式,炼金丹渡一致劫</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">RocketMQ学习笔记-架消息桥通三界路 施持久咒定乾坤轮</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">MyBatis学习笔记-架映射桥通人神境 写SQL咒调数据兵</span></a><a class="item" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Linux学习笔记-踏终端登灵霄殿,执符咒驭众生器</span></a><a class="item" href="/2025/09/24/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E7%AE%80%E5%8E%86%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="title">简历对应知识点</span></a><a class="item" href="/2025/09/09/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Elasticsearch(ES)%E4%B8%8B%E8%BD%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><span class="title">Elasticsearch(ES)下载使用指南</span></a><a class="item" href="/2025/08/30/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/git%E7%A7%98%E9%92%A5%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86/"><span class="title">Redis学习笔记</span></a><a class="item" href="/2025/08/08/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java并发编程学习笔记-布天罗网锁线程妖,设八卦阵伏竞态魔</span></a><a class="item" href="/2025/08/06/3DGS/SSH%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"><span class="title">SSH远程调用开发环境</span></a><a class="item" href="/2025/08/05/3DGS/Ubuntu20%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%ACCUDA/"><span class="title">Ubuntu20使用多个版本CUDA</span></a><a class="item" href="/2025/08/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Thymeleaf%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"><span class="title">Thymeleaf模版引擎</span></a><a class="item" href="/2025/08/01/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架学习笔记-开乾坤袋纳百川 布玲珑局定山河</span></a><a class="item" href="/2025/07/30/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Natapp/"><span class="title">Natapp内网穿透使用</span></a><a class="item" href="/2025/07/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"><span class="title">微信扫码登录</span></a><a class="item" href="/2025/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%81%B5%E8%8C%B6%E5%B1%B1%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">灵茶山算法基础笔记</span></a><a class="item" href="/2025/07/25/Go%E5%9F%BA%E7%A1%80/Go%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">Go基础笔记</span></a><a class="item active" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JavaSE学习笔记-筑基篇开修行路,炼气层破语法障</span></a><a class="item" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/"><span class="title">程序员养生指南-调阴阳戒久坐劫 通经脉战代码妖</span></a><a class="item" href="/2025/07/14/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">计算机网络学习笔记-布协议栈通三界,架路由桥渡万维</span></a><a class="item" href="/2025/07/12/3DGS/%E4%BD%BF%E7%94%A8Postshot%E8%AE%AD%E7%BB%833DGS%E6%B5%81%E7%A8%8B/"><span class="title">使用Postshot训练3DGS模型流程</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/%E8%B7%A8%E5%9F%9F%E6%94%AF%E6%8C%81%E7%AC%94%E8%AE%B0/"><span class="title">跨域支持笔记</span></a><a class="item" href="/2025/07/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/MybatisPlus%E7%AC%94%E8%AE%B0/"><span class="title">MybatisPlus笔记</span></a><a class="item" href="/2025/06/25/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/TecHub%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">TecHub项目笔记</span></a><a class="item" href="/2025/06/24/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"><span class="title">技术派项目环境问题</span></a><a class="item" href="/2025/06/24/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"><span class="title">Unity游戏开发笔记</span></a><a class="item" href="/2025/06/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82B%E6%A0%91/"><span class="title">一次性搞懂B树</span></a><a class="item" href="/2025/06/12/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Spring学习笔记-开IOC瓶纳百川水 织AOP网覆三界尘</span></a><a class="item" href="/2025/06/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/nvm%E6%9B%B4%E6%94%B9node%E7%89%88%E6%9C%AC/"><span class="title">nvm更改node版本</span></a><a class="item" href="/2025/06/11/3DGS/3DGS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">3DGS学习笔记-撒神经点布星云阵 炼辐射场塑造化身</span></a><a class="item" href="/2025/06/11/3DGS/3DGS-Ubuntu%E7%8E%AF%E5%A2%83/"><span class="title">3DGS-Ubuntu环境.md</span></a><a class="item" href="/2025/06/10/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"><span class="title">Java集合框架笔记</span></a><a class="item" href="/2025/06/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Mysql学习笔记-布B+树阵锁苍龙 写SQL真言召天兵</span></a><a class="item" href="/2025/06/09/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">JVM学习笔记</span></a><a class="item" href="/2025/06/07/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/Java%E5%B9%B6%E5%8F%91%E7%AF%87/"><span class="title">Java并发篇</span></a><a class="item" href="/2025/06/06/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E9%94%AE%E8%AE%B0%E5%BD%95/"><span class="title">常用组合键记录-结印诀腾挪三界,弹指间呼风唤雨</span></a><a class="item" href="/2025/06/06/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/java30%E5%A4%A9%E7%AC%94%E8%AE%B0/"><span class="title">java30天学习笔记</span></a><a class="item" href="/2025/06/05/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/hello-world/"><span class="title">Hello World</span></a><a class="item" href="/2025/06/04/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E6%B4%BE%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><span class="title">技术派项目笔记</span></a><a class="item" href="/2025/06/02/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"><span class="title">个人博客搭建指南-架祥云自建菩提境,点慧灯独照博客天</span></a><a class="item" href="/2025/06/01/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/RabbitMQ%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/"><span class="title">RabbitMQ项目使用</span></a><a class="item" href="/2025/06/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">数据结构算法学习笔记-布天罡阵伏算法妖 炼金石破数据结构</span></a></div></widget>

<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/"><span class="title">程序员养生指南-调阴阳戒久坐劫 通经脉战代码妖</span></a><a class="item title" href="/2025/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%81%B5%E8%8C%B6%E5%B1%B1%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span class="title">灵茶山算法基础笔记</span></a><a class="item title" href="/2025/06/11/3DGS/3DGS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">3DGS学习笔记-撒神经点布星云阵 炼辐射场塑造化身</span></a><a class="item title" href="/2025/10/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%AC%AC%E4%BA%8C%E7%89%88)/"><span class="title">Spring学习笔记(第二版)-炼金丹炉铸Bean山 布注解阵控轮回盘</span></a><a class="item title" href="/2025/06/12/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Spring学习笔记-开IOC瓶纳百川水 织AOP网覆三界尘</span></a><a class="item title" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">RocketMQ学习笔记-架消息桥通三界路 施持久咒定乾坤轮</span></a><a class="item title" href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄</span></a><a class="item title" href="/2025/06/10/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Mysql学习笔记-布B+树阵锁苍龙 写SQL真言召天兵</span></a><a class="item title" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">MyBatis学习笔记-架映射桥通人神境 写SQL咒调数据兵</span></a><a class="item title" href="/2025/09/29/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="title">Linux学习笔记-踏终端登灵霄殿,执符咒驭众生器</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/10/23/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Java%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习博客</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-07-21T16:00:00.000Z">2025-07-22</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-10-23T02:53:31.341Z">2025-10-23</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Redis学习笔记-燃内存真火照幽冥 布集群阵通九霄</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content slide-up"><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="1-🌟说说什么是-Redis"><a href="#1-🌟说说什么是-Redis" class="headerlink" title="1.🌟说说什么是 Redis?"></a>1.🌟说说什么是 Redis?</h3><p><code>Redis</code> 是一种基于键值对的 <code>NoSQL</code> 数据库。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250725112831.png" alt="20250725112831"></p>
<p>它主要的特点是把数据放在<code>内存</code>当中，相比直接访问磁盘的关系型数据库，<strong>读写速度会快很多</strong>，基本上能达到微秒级的响应。</p>
<p>所以在一些对<code>性能要求很高</code>的场景，比如<strong>缓存热点数据、防止接口爆刷</strong>，都会用到 Redis。</p>
<p>不仅如此，Redis 还<code>支持持久化</code>，可以将内存中的数据异步落盘，以便服务宕机重启后能恢复数据。</p>
<h4 id="Redis-和-MySQL-的区别？"><a href="#Redis-和-MySQL-的区别？" class="headerlink" title="Redis 和 MySQL 的区别？"></a>Redis 和 MySQL 的区别？</h4><p>Redis 属于<strong>非关系型数据库</strong>，数据是通过<code>键值对</code>的形式放在内存当中的；MySQL 属于<strong>关系型数据库</strong>，数据以<code>行和列的形式</code>存储在磁盘当中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250725112927.png" alt="20250725112927"></p>
<p>实际开发中，会将 <code>MySQL</code> 作为主存储，<code>Redis</code> 作为缓存，通过先查 <code>Redis</code>，未命中再查 <code>MySQL</code> 并写回<code>Redi</code>s 的方式来提高系统的整体性能。</p>
<h4 id="TecHub项目里哪里用到了-Redis？"><a href="#TecHub项目里哪里用到了-Redis？" class="headerlink" title="TecHub项目里哪里用到了 Redis？"></a>TecHub项目里哪里用到了 Redis？</h4><p>在TecHub实战项目当中，有很多地方都用到了 Redis，比如说<code>用户活跃排行榜</code>用到了 <code>zset</code>，<code>作者白名单</code>用到了 <code>set</code>。<br>还有用户登录后的 <code>Session</code>、站点地图 <code>SiteMap</code>，分别用到了 Redis 的字符串和哈希表两种数据类型。<br>其中比较有挑战性的一个应用是，通过 Lua 脚本封装 Redis 的 setnex 命令来实现<strong>分布式锁</strong>，以保证在高并发场景下，热点文章在短时间内的高频访问不会击穿 MySQL。</p>
<h4 id="部署过-Redis-吗？"><a href="#部署过-Redis-吗？" class="headerlink" title="部署过 Redis 吗？"></a>部署过 Redis 吗？</h4><p>第一种回答版本：</p>
<p>我只在本地部署过单机版，下载 Redis 的安装包，解压后运行 <code>redis-server</code> 命令即可。</p>
<p>第二种回答版本：</p>
<p>我有在生产环境中部署单机版 Redis，从官网下载源码包解压后执行 <code>make &amp;&amp; make install</code> 编译安装。然后编辑 <code>redis.conf</code> 文件，开启远程访问、设置密码、限制内存、设置内存过期淘汰策略、开启 AOF 持久化等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0        # 允许远程访问</span><br><span class="line">requirepass your_password  # 设置密码</span><br><span class="line">maxmemory 4gb      # 限制内存，避免 OOM</span><br><span class="line">maxmemory-policy allkeys-lru  # 内存淘汰策略</span><br><span class="line">appendonly yes     # 开启 AOF 持久化</span><br></pre></td></tr></table></figure>

<p>第三种回答版本：</p>
<p>我有使用 Docker 拉取 Redis 镜像后进行容器化部署。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 redis:7.0-alpine</span><br></pre></td></tr></table></figure>
<h4 id="Redis-的高可用方案有部署过吗？"><a href="#Redis-的高可用方案有部署过吗？" class="headerlink" title="Redis 的高可用方案有部署过吗？"></a>Redis 的高可用方案有部署过吗？</h4><p>有部署过<strong>哨兵机制</strong>，这是一个相对成熟的<strong>高可用解决方案</strong>，我们生产环境部署的是一主两从的 Redis 实例，再加上三个 <code>Sentinel</code> 节点监控它们。<code>Sentinel</code> 的配置相对简单，主要设置了<strong>故障转移的判定条件</strong>和<strong>超时阈值</strong>。</p>
<p>主节点配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">appendonly yes&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>从节点配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 192.168.1.10 6379&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>哨兵节点配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.1.10 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure>

<p>当主节点发生故障时，<code>Sentinel</code> 能够自动检测并协商选出新的主节点，这个过程大概需要 <code>10-15</code> 秒。</p>
<p>另一个大型项目中，我们使用了 <code>Redis Cluster</code> 集群方案。该项目数据量大且增长快，需要水平扩展能力。我们部署了 6 个主节点，每个主节点配备一个从节点，形成了一个 3主3从 的初始集群。<code>Redis Cluster</code> 的设置比<code>Sentinel</code> 复杂一些，需要正确配置<strong>集群节点间通信</strong>、<strong>分片映射</strong>等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 redis-cli 创建集群</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis 会自动将 key 哈希到 16384 个槽位</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主节点均分槽位，从节点自动跟随</span></span><br><span class="line">redis-cli --cluster create \</span><br><span class="line"> 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \</span><br><span class="line"> 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \</span><br><span class="line"> --cluster-replicas 1</span><br></pre></td></tr></table></figure>
<p><code>Redis Cluster</code> 最大的优势是<strong>数据自动分片</strong>，我们可以通过简单地增加节点来扩展集群容量。此外，它的<strong>故障转移也很快</strong>，通常在几秒内就能完成。</p>
<p>对于一些轻量级应用，我也使用过<code>主从复制</code>加<code>手动故障转移</code>的方案。<code>主节点负责读写操作</code>，<code>从节点负责读操作</code>。手动故障转移时，我们会<code>先将从节点提升为主节点</code>，然后重新配置其他从节点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1\. 取消从节点身份</span></span><br><span class="line">redis-cli -h &lt;slave-ip&gt; slaveof no one</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2\. 将其他从节点指向新的主节点</span></span><br><span class="line">redis-cli -h &lt;other-slave-ip&gt; slaveof &lt;new-master-ip&gt; &lt;port&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-Redis-可以用来干什么？"><a href="#2-Redis-可以用来干什么？" class="headerlink" title="2.Redis 可以用来干什么？"></a>2.Redis 可以用来干什么？</h3><p>Redis 可以用来做<code>缓存</code>，比如说把<strong>高频访问的</strong>文章详情、商品信息、用户信息放入 Redis 当中，并通过<strong>设置过期时间来保证数据一致性</strong>，这样就可以减轻数据库的访问压力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250726113716.png" alt="20250726113716"></p>
<p>Redis 的 <code>Zset</code> 还可以用来实现积分榜、热搜榜，通过 <code>score</code> 字段进行排序，然后取前 N 个元素，就能实现 <code>TOPN</code> 的榜单功能。</p>
<p>利用 Redis 的 <code>SETNX</code> 命令或者 <code>Redisson</code> 还可以实现<code>分布式锁</code>，<strong>确保同一时间只有一个节点可以持有锁</strong>；为了防止出现死锁，可以给锁设置一个<code>超时时间</code>，到期后自动释放；并且最好开启一个<code>监听线程</code>，<strong>当任务尚未完成时给锁自动续期</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250726113912.png" alt="20250726113912"></p>
<p>如果是秒杀接口，还可以使用 Lua 脚本来实现令牌桶算法，限制每秒只能处理 N 个请求。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS[1]: 令牌桶的key</span></span><br><span class="line"><span class="comment">-- ARGV[1]: 桶容量</span></span><br><span class="line"><span class="comment">-- ARGV[2]: 令牌生成速率（每秒）</span></span><br><span class="line"><span class="comment">-- ARGV[3]: 当前时间戳（秒）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从Redis哈希表中获取当前令牌桶的状态</span></span><br><span class="line"><span class="keyword">local</span> bucket = redis.call(<span class="string">&#x27;HMGET&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;tokens&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>)</span><br><span class="line"><span class="comment">-- 当前令牌数（如果不存在则使用默认容量）</span></span><br><span class="line"><span class="keyword">local</span> tokens = <span class="built_in">tonumber</span>(bucket[<span class="number">1</span>]) <span class="keyword">or</span> ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 上次更新时间（如果不存在则使用当前时间）</span></span><br><span class="line"><span class="keyword">local</span> last_time = <span class="built_in">tonumber</span>(bucket[<span class="number">2</span>]) <span class="keyword">or</span> ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从参数中获取配置值</span></span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])      <span class="comment">-- 令牌生成速率（每秒）</span></span><br><span class="line"><span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])  <span class="comment">-- 桶容量</span></span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])       <span class="comment">-- 当前时间戳（秒）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算距离上次更新经过的时间差</span></span><br><span class="line"><span class="keyword">local</span> delta = <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="number">0</span>, now - last_time)</span><br><span class="line"><span class="comment">-- 计算应添加的令牌数（速率*时间差）</span></span><br><span class="line"><span class="keyword">local</span> add_tokens = delta * rate</span><br><span class="line"><span class="comment">-- 更新令牌数（不超过桶容量）</span></span><br><span class="line">tokens = <span class="built_in">math</span>.<span class="built_in">min</span>(capacity, tokens + add_tokens)</span><br><span class="line"><span class="comment">-- 记录本次更新时间</span></span><br><span class="line">last_time = now</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 默认不允许通过（0）</span></span><br><span class="line"><span class="keyword">local</span> allowed = <span class="number">0</span></span><br><span class="line"><span class="comment">-- 如果令牌数≥1，则消耗一个令牌并允许通过（1）</span></span><br><span class="line"><span class="keyword">if</span> tokens &gt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    tokens = tokens - <span class="number">1</span></span><br><span class="line">    allowed = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新Redis中的令牌桶状态</span></span><br><span class="line">redis.call(<span class="string">&#x27;HMSET&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;tokens&#x27;</span>, tokens, <span class="string">&#x27;timestamp&#x27;</span>, last_time)</span><br><span class="line"><span class="comment">-- 设置键的过期时间（防止长期不用的键占用内存）</span></span><br><span class="line">redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, KEYS[<span class="number">1</span>], <span class="number">3600</span>) <span class="comment">-- 过期时间可自定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回是否允许通过（1=允许，0=拒绝）</span></span><br><span class="line"><span class="keyword">return</span> allowed</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 Java 中调用 Lua 脚本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 令牌桶参数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 桶容量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rate</span> <span class="operator">=</span> <span class="number">2</span>;      <span class="comment">// 每秒2个令牌</span></span><br><span class="line"><span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;token_bucket:user:123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 Lua 脚本，返回 1 表示通过，0 表示被限流</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">allowed</span> <span class="operator">=</span> (Long) redis.eval(luaScript, <span class="number">1</span>, key, String.valueOf(capacity), String.valueOf(rate), String.valueOf(now));</span><br></pre></td></tr></table></figure>


<h3 id="3-🌟Redis有哪些数据类型？"><a href="#3-🌟Redis有哪些数据类型？" class="headerlink" title="3.🌟Redis有哪些数据类型？"></a>3.🌟Redis有哪些数据类型？</h3><p>Redis 支持五种基本数据类型，分别是<code>字符串</code>、<code>列表</code>、<code>哈希</code>、<code>集合</code>和<code>有序集合</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811101352.png" alt="20250811101352"></p>
<p>还有三种扩展数据类型，分别是用于位级操作的 Bitmap、用于基数估算的 HyperLogLog、支持存储和查询地理坐标的 GEO。</p>
<h4 id="详细介绍下字符串？"><a href="#详细介绍下字符串？" class="headerlink" title="详细介绍下字符串？"></a>详细介绍下字符串？</h4><p>字符串是最基本的数据类型，可以存储文本、数字或者二进制数据，最大容量是 <code>512 MB</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811102451.png" alt="20250811102451"></p>
<p>适合缓存单个对象，比如验证码、token、计数器等。</p>
<h4 id="详细介绍下列表？"><a href="#详细介绍下列表？" class="headerlink" title="详细介绍下列表？"></a>详细介绍下列表？</h4><p>列表是一个有序的元素集合，支持从头部或尾部插入&#x2F;删除元素，常用于消息队列或任务列表。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811102931.png" alt="20250811102931"></p>
<h4 id="详细介绍下哈希？"><a href="#详细介绍下哈希？" class="headerlink" title="详细介绍下哈希？"></a>详细介绍下哈希？</h4><p>哈希是一个键值对集合，适合存储对象，如商品信息、用户信息等。比如说 <code>value = &#123;name: &#39;沉默王二&#39;, age: 18&#125;</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103014.png" alt="20250811103014"></p>
<h4 id="详细介绍下集合？"><a href="#详细介绍下集合？" class="headerlink" title="详细介绍下集合？"></a>详细介绍下集合？</h4><p>集合是无序且不重复的，支持交集、并集操作，查询效率能达到 O(1) 级别，主要用于去重、标签、共同好友等场景。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103028.png" alt="20250811103028"></p>
<h4 id="详细介绍下有序集合？"><a href="#详细介绍下有序集合？" class="headerlink" title="详细介绍下有序集合？"></a>详细介绍下有序集合？</h4><p>有序集合的元素按分数进行排序，支持范围查询，适用于排行榜或优先级队列。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103046.png" alt="20250811103046"></p>
<h4 id="详细介绍下Bitmap？"><a href="#详细介绍下Bitmap？" class="headerlink" title="详细介绍下Bitmap？"></a>详细介绍下Bitmap？</h4><p>Bitmap 可以把一组二进制位紧凑地存储在一块连续内存中，每一位代表一个对象的状态，比如是否签到、是否活跃等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103101.png" alt="20250811103101"></p>
<p>比如用户 0 的已签到 1、用户 1 未签到 0、用户 2 已签到，Redis 就会把这些状态放进一个连续的二进制串 101，1 亿用户签到仅需 100,000,000 &#x2F; 8 &#x2F; 1024 ≈ 12MB 的空间，真的省到离谱。</p>
<h4 id="详细介绍下HyperLogLog？"><a href="#详细介绍下HyperLogLog？" class="headerlink" title="详细介绍下HyperLogLog？"></a>详细介绍下HyperLogLog？</h4><p>HyperLogLog 是一种用于基数统计的概率性数据结构，可以在仅有 12KB 的内存空间下，统计海量数据集中不重复元素的个数，误差率仅 0.81%。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103115.png" alt="20250811103115"></p>
<p>底层基于 LogLog 算法改进，先把每个元素哈希成一个二进制串，然后取前 14 位进行分组，放到 16384 个桶中，记录每组最大的前导零数量，最后用一个近似公式推算出总体的基数。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103129.png" alt="20250811103129"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103146.png" alt="20250811103146"></p>
<p>可以发现，哈希值越长前导零越多，也就说明集合里的元素越多。</p>
<p>大型网站 UV 统计系统示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UVCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordVisit</span><span class="params">(String date, String userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;uv:&quot;</span> + date;</span><br><span class="line">        jedis.pfadd(key, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getUV</span><span class="params">(String date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedis.pfcount(<span class="string">&quot;uv:&quot;</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getUVBetween</span><span class="params">(String startDate, String endDate)</span> &#123;</span><br><span class="line">        List&lt;String&gt; keys = getDateKeys(startDate, endDate);</span><br><span class="line">        <span class="keyword">return</span> jedis.pfcount(keys.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="详细介绍下GEO？"><a href="#详细介绍下GEO？" class="headerlink" title="详细介绍下GEO？"></a>详细介绍下GEO？</h4><p>GEO 用于存储和查询地理位置信息，可以用来计算两点之间的距离，查找某位置半径内的其他元素。</p>
<p>常见的应用场景包括：附近的人或者商家、计算外卖员和商家的距离、判断用户是否进入某个区域等。</p>
<p>底层基于 ZSet 实现，通过 Geohash 算法把经纬度编码成 score。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103203.png" alt="20250811103203"></p>
<p>比如说查询附近的商家时，Redis 会根据中心点经纬度反推可能的 Geohash 范围， 在 ZSet 上做范围查询，拿到候选点后，用 Haversine 公式精确计算球面距离，筛选出最终符合要求的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NearbyShopService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHOP_KEY</span> <span class="operator">=</span> <span class="string">&quot;shops:geo&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加商铺</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShop</span><span class="params">(String shopId, <span class="type">double</span> longitude, <span class="type">double</span> latitude)</span> &#123;</span><br><span class="line">        jedis.geoadd(SHOP_KEY, longitude, latitude, shopId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询附近的商铺</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GeoRadiusResponse&gt; <span class="title function_">getNearbyShops</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="type">double</span> longitude, </span></span><br><span class="line"><span class="params">            <span class="type">double</span> latitude, </span></span><br><span class="line"><span class="params">            <span class="type">double</span> radiusKm)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedis.georadius(SHOP_KEY, </span><br><span class="line">                             longitude, </span><br><span class="line">                             latitude, </span><br><span class="line">                             radiusKm, </span><br><span class="line">                             GeoUnit.KM, </span><br><span class="line">                             GeoRadiusParam.geoRadiusParam()</span><br><span class="line">                                         .withCoord()</span><br><span class="line">                                         .withDist()</span><br><span class="line">                                         .sortAscending()</span><br><span class="line">                                         .count(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算两个商铺之间的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getShopDistance</span><span class="params">(String shop1Id, String shop2Id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedis.geodist(SHOP_KEY, </span><br><span class="line">                           shop1Id, </span><br><span class="line">                           shop2Id, </span><br><span class="line">                           GeoUnit.KILOMETERS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么使用-hash-类型而不使用-string-类型序列化存储？"><a href="#为什么使用-hash-类型而不使用-string-类型序列化存储？" class="headerlink" title="为什么使用 hash 类型而不使用 string 类型序列化存储？"></a>为什么使用 hash 类型而不使用 string 类型序列化存储？</h4><p>为什么使用 hash 类型而不使用 string 类型序列化存储？<br>Hash 可以只读取或者修改某一个字段，而 String 需要一次性把整个对象取出来。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250811103219.png" alt="20250811103219"></p>
<p>比如说有一个用户对象 user &#x3D; {name: ‘沉默王二’, age: 18}，如果使用 Hash 存储，可以直接修改 age 字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<p>如果使用 String 存储，需要先取出整个对象，修改后再存回去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> redis.get(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(userJson, User.class);</span><br><span class="line">user.setAge(<span class="number">19</span>);</span><br><span class="line">redis.set(<span class="string">&quot;user:1&quot;</span>, JSON.toJSONString(user));</span><br></pre></td></tr></table></figure>

<h3 id="4-🌟Redis-为什么快呢？"><a href="#4-🌟Redis-为什么快呢？" class="headerlink" title="4.🌟Redis 为什么快呢？"></a>4.🌟Redis 为什么快呢？</h3><p>第一，Redis 的所有数据都放在内存中，而内存的读写速度本身就比磁盘快几个数量级。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205152.png" alt="20250912205152"></p>
<p>第二，Redis 采用了基于 IO 多路复用技术的事件驱动模型来处理客户端请求和执行 <code>Redis</code> 命令。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205641.png" alt="20250912205641"></p>
<p>其中的 IO 多路复用技术可以在只有一个线程的情况下，同时监听成千上万个客户端连接，解决传统 IO 模型中每个连接都需要一个独立线程带来的性能开销。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912205919.png" alt="20250912205919"></p>
<p>Redis 会根据操作系统选择最优的 IO 多路复用技术，比如 Linux 下使用 epoll，macOS 下使用 kqueue 等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll 的创建和使用</span></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">1024</span>); <span class="comment">// 创建 epoll 实例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加监听事件</span></span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = listen_sock;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listen_sock, &amp;ev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件发生</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">        <span class="comment">// 处理就绪的文件描述符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Redis 6.0 之前，包括连接建立、请求读取、响应发送，以及命令执行都是在主线程中顺序执行的，这样可以避免多线程环境下的锁竞争和上下文切换，因为 Redis 的绝大部分操作都是在内存中进行的，性能瓶颈主要是<strong>内存操作</strong>和<strong>网络通信</strong>，而不是 CPU。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912210551.png" alt="20250912210551"></p>
<p>为了进一步解决网络 IO 的性能瓶颈，Redis 6.0 引入了多线程机制，把网络 IO 和命令执行分开，网络 IO 交给线程池来处理，而命令执行仍然在主线程中进行，这样就可以充分利用多核 CPU 的性能。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912210654.png" alt="20250912210654"></p>
<p>主线程专注于命令执行，网络IO 由其他线程分担，在多核 CPU 环境下，Redis 的性能可以得到显著提升。</p>
<p>(有点像单片机的中断机制,保持主线程专注核心任务，让IO操作在后台异步处理，既保证了性能又保证了数据一致性。)</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211024.png" alt="20250912211024"></p>
<p>第三，Redis 对底层数据结构做了极致的优化，比如说 String 的底层数据结构动态字符串支持动态扩容、预分配冗余空间，能够减少内存碎片和内存分配的开销。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211154.png" alt="20250912211154"></p>
<p>总结:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912211332.png" alt="20250912211332"></p>
<h3 id="5-能详细说一下IO多路复用吗？"><a href="#5-能详细说一下IO多路复用吗？" class="headerlink" title="5.能详细说一下IO多路复用吗？"></a>5.能详细说一下IO多路复用吗？</h3><p>IO 多路复用是一种允许单个进程同时监视多个文件描述符的技术，使得程序能够高效处理多个并发连接而无需创建大量线程。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912215413.png" alt="Journey-C：IO 多路复用"><br>Journey-C：IO 多路复用</p>
<p>IO 多路复用的核心思想是：让单个线程可以等待多个文件描述符就绪，然后对就绪的描述符进行操作。这样可以在不使用多线程或多进程的情况下处理并发连接。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912215459.png" alt="20250912215459"><br>蛮荆：IO 多路复用和多线程</p>
<p>主要的实现机制包括 select、poll、epoll、kqueue 和 IOCP 等。</p>
<h4 id="请说说-select、poll、epoll、kqueue-和-IOCP-的区别？"><a href="#请说说-select、poll、epoll、kqueue-和-IOCP-的区别？" class="headerlink" title="请说说 select、poll、epoll、kqueue 和 IOCP 的区别？"></a>请说说 select、poll、epoll、kqueue 和 IOCP 的区别？</h4><p>(用户想知道内核中有哪些文件描述符有数据可读，内核会返回一个就绪的文件描述符列表，用户只需要遍历这个列表，就可以知道哪些文件描述符有数据可读。)<br>文件的描述符就是一个整数,代表一个打开的文件,或者一个网络连接。</p>
<p><code>select</code> 的缺点是单个进程能监视的文件描述符数量有限，一般为 1024 个，且每次调用都需要将文件描述符集合从用户态复制到内核态，然后遍历找出就绪的描述符，性能较差。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select 的基本使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, </span></span><br><span class="line"><span class="params">           fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">fd_set readfds;</span><br><span class="line">FD_ZERO(&amp;readfds);                <span class="comment">// 清空集合</span></span><br><span class="line">FD_SET(sockfd, &amp;readfds);         <span class="comment">// 添加监听套接字</span></span><br><span class="line">select(sockfd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(sockfd, &amp;readfds)) &#123; <span class="comment">// 检查是否就绪</span></span><br><span class="line">    <span class="comment">// 处理读事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>poll</code> 的优点是没有最大文件描述符数量的限制，但是每次调用仍然需要将文件描述符集合从用户态复制到内核态，依然需要遍历，性能仍然较差。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll 的基本使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">fds[<span class="number">0</span>].fd = sockfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;    <span class="comment">// 监听读事件</span></span><br><span class="line">poll(fds, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">    <span class="comment">// 处理读事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>epoll</code> 是 Linux 特有的 IO 多路复用机制，支持大规模并发连接，使用事件驱动模型，性能更高。其工作原理是将文件描述符注册到内核中，然后通过事件通知机制来处理就绪的文件描述符，不需要轮询，也不需要数据拷贝，更没有数量限制，所以性能非常高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll 的基本使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = sockfd;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == sockfd) &#123;</span><br><span class="line">            <span class="comment">// 处理读事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kqueue 是 BSD&#x2F;macOS 系统下的 IO 多路复用机制，类似于 epoll，支持大规模并发连接，使用事件驱动模型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kqueue</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kevent</span><span class="params">(<span class="type">int</span> kq, <span class="type">const</span> <span class="keyword">struct</span> kevent *changelist, <span class="type">int</span> nchanges, <span class="keyword">struct</span> kevent *eventlist, <span class="type">int</span> nevents, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>IOCP 是 Windows 系统下的 IO 多路复用机制，使用使用完成端口模型而非事件通知。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateIoCompletionPort</span><span class="params">(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="举个例子说一下-IO-多路复用？"><a href="#举个例子说一下-IO-多路复用？" class="headerlink" title="举个例子说一下 IO 多路复用？"></a>举个例子说一下 IO 多路复用？</h4><p>比如说我是一名数学老师，上课时提出了一个问题：“今天谁来证明一下勾股定律？”</p>
<p>同学小王举手，我就让小王回答；小李举手，我就让小李回答；小张举手，我就让小张回答。</p>
<p>这种模式就是 <code>IO 多路复用</code>，我只需要在讲台上等，谁举手谁回答，不需要一个一个去问。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912215527.png" alt="20250912215527"><br>有盐先生：IO 多路复用</p>
<p>Redis 就是使用 epoll 这样的 IO 多路复用机制，在单线程模型下实现高效的网络 IO，从而支持高并发的请求处理。</p>
<h4 id="举例子说一下阻塞-IO和-IO-多路复用的差别？"><a href="#举例子说一下阻塞-IO和-IO-多路复用的差别？" class="headerlink" title="举例子说一下阻塞 IO和 IO 多路复用的差别？"></a>举例子说一下阻塞 IO和 IO 多路复用的差别？</h4><p>假设我是一名老师，让学生解答一道题目。</p>
<p>我的第一种选择：按顺序逐个检查，先检查 A同学，然后是 B，之后是 C、D。。。这中间如果有一个学生卡住，全班都会被耽误。</p>
<p>这种就是<code>阻塞 IO</code>，不具有并发能力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912215558.png" alt="20250912215558"><br>阻塞 IO和 IO多路复用差别</p>
<p>我的第二种选择，我站在讲台上等，谁举手我去检查谁。C、D 举手，我去检查 C、D 的答案，然后继续回到讲台上等。此时 E、A 又举手，然后去处理 E 和 A。</p>
<h4 id="select、poll-和-epoll-的实现原理？"><a href="#select、poll-和-epoll-的实现原理？" class="headerlink" title="select、poll 和 epoll 的实现原理？"></a>select、poll 和 epoll 的实现原理？</h4><p>select 和 poll 都是通过把所有文件描述符传递给内核，由内核遍历判断哪些就绪。</p>
<p>select 将文件描述符 FD 通过 BitsMap 传入内核，轮询所有的 FD，通过调用 file-&gt;poll 函数查询是否有对应事件，没有就将 task 加入 FD 对应 file 的待唤醒队列，等待事件来临被唤醒。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250912215722.png" alt="20250912215722"><br>journey-c：select</p>
<p>poll 改进了连接数上限问题，不再用 BitsMap 来传入 FD，取而代之的是动态数组 pollfd，但本质上仍是线性遍历，性能没有提升太多。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913100035.png" alt="20250913100035"><br>journey-c：poll</p>
<p>select和poll的模式都是，一次将参数拷贝到内核空间，等有结果了再一次拷贝出去。</p>
<p>epoll 将监听的 FD 注册进内核的红黑树，由内核在事件触发时将就绪的 FD 放入 ready list。应用程序通过 epoll_wait 获取就绪的 FD，从而避免遍历所有连接的开销。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913100220.png" alt="20250913100220"><br>journey-c：epoll</p>
<p>epoll 最大的优点是：支持事件驱动 + 边缘触发(类似于上升沿)，ADD 时拷贝一次，epoll_wait 时利用 MMAP 和用户共享空间，直接拷贝数据到用户空间，因此在高并发场景下性能远高于 select 和 poll。</p>
<h3 id="6-Redis为什么早期选择单线程？"><a href="#6-Redis为什么早期选择单线程？" class="headerlink" title="6.Redis为什么早期选择单线程？"></a>6.Redis为什么早期选择单线程？</h3><p>第一，单线程模型不需要考虑复杂的锁机制，不存在多线程环境下的死锁、竞态条件等问题，开发起来更快，也更容易维护。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913104621.png" alt="20250913104621"><br>wsh-study.com：Redis的单线程模型</p>
<p>第二，Redis 是IO 密集型而非 CPU 密集型，主要受内存和网络 IO 限制，而非 CPU 的计算能力，单线程可以避免线程上下文切换的开销。</p>
<p>哪怕我们在一个普通的 Linux 服务器上启动 Redis 服务，它也能在 1s 内处理 1000000 个用户请求。</p>
<p>第三，单线程可以保证命令执行的原子性，无需额外的同步机制。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913104709.png" alt="20250913104709"><br>官方单线程解释</p>
<p>Redis 虽然最初采用了单线程设计，但后续的版本中也在特定方面引入了多线程，比如说 Redis 4.0 就引异步多线程，用于清理脏数据、释放无用连接、删除大 Key 等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从数据库中删除一个键、值以及相关的过期条目（如果有的话）。</span></span><br><span class="line"><span class="comment"> * 如果释放值对象需要大量的内存分配操作，该对象可能会被放入</span></span><br><span class="line"><span class="comment"> * 延迟释放列表中，而不是同步释放。延迟释放列表将在</span></span><br><span class="line"><span class="comment"> * bio.c 的另一个线程中进行回收。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">/* 从过期字典中删除条目不会释放键的 sds，</span></span><br><span class="line"><span class="comment">     * 因为它与主字典共享。 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果值对象只包含少量的内存分配，使用延迟释放方式</span></span><br><span class="line"><span class="comment">     * 实际上会更慢... 所以在一定阈值以下，我们就直接</span></span><br><span class="line"><span class="comment">     * 同步释放对象。 */</span></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="comment">// 计算value的回收收益</span></span><br><span class="line">        <span class="type">size_t</span> free_effort = lazyfreeGetFreeEffort(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果释放对象的工作量太大，就通过将对象添加到延迟释放列表</span></span><br><span class="line"><span class="comment">         * 在后台进行处理。</span></span><br><span class="line"><span class="comment">         * 注意，如果对象是共享的，现在就回收它是不可能的。这种情况</span></span><br><span class="line"><span class="comment">         * 很少发生，但是有时 Redis 核心的某些实现部分可能会调用</span></span><br><span class="line"><span class="comment">         * incrRefCount() 来保护对象，然后调用 dbDelete()。在这种</span></span><br><span class="line"><span class="comment">         * 情况下，我们会继续执行并到达 dictFreeUnlinkedEntry() </span></span><br><span class="line"><span class="comment">         * 调用，这相当于仅仅调用 decrRefCount()。 */</span></span><br><span class="line">        <span class="comment">// 只有回收收益超过一定值，才会执行异步删除，否则还是会退化到同步删除</span></span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>);</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放键值对，如果我们将 val 字段设置为 NULL 以便稍后</span></span><br><span class="line"><span class="comment">     * 延迟释放，那么就只释放键。 */</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方解释：<a target="_blank" rel="noopener" href="https://redis.io/topics/faq">https://redis.io/topics/faq</a></p>
<h3 id="7-Redis-6-0-使用多线程是怎么回事"><a href="#7-Redis-6-0-使用多线程是怎么回事" class="headerlink" title="7.Redis 6.0 使用多线程是怎么回事?"></a>7.Redis 6.0 使用多线程是怎么回事?</h3><p>Redis 6.0 的多线程<strong>仅用于处理网络 IO</strong>，包括网络数据的读取、写入，以及请求解析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">│ 单线程执行命令 │</span><br><span class="line">                  │    ↑    ↓     │</span><br><span class="line">┌─────────┐     ┌─┴────────────┴──┐</span><br><span class="line">│ I/O线程1 │ ←→ │                 │</span><br><span class="line">├─────────┤     │                 │</span><br><span class="line">│ I/O线程2 │ ←→ │    主线程       │</span><br><span class="line">├─────────┤     │                 │</span><br><span class="line">│ I/O线程3 │ ←→ │                 │</span><br><span class="line">└─────────┘     └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>而命令的执行依然是单线程，这种设计被称为“IO 线程化”，能够在高负载的情况下，最大限度地提升 Redis 的响应速度。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913105114.png" alt="20250913105114"><br>三分恶面渣逆袭：Redis6.0多线程</p>
<p>-— 这部分面试中可以不背，方便理解 start —-</p>
<p>这一变化主要是因为随着网络带宽和服务器性能的提升，Redis 的瓶颈从 <code>CPU</code> 逐渐转移到了<code>网络 IO</code>：</p>
<ul>
<li>带宽从 10Gbps 提升到 100Gbps，甚至更高。</li>
<li>请求的并发数从几千到几万，甚至几十万。</li>
</ul>
<p>单线程在高负载场景下处理网络 IO 出现了明显的性能瓶颈，Redis 的开发团队通过研究发现，在处理大数据包时，单线程 Redis 有超过 80% 的 CPU 时间花在<code>网络 IO</code> 上，而实际命令执行仅占 20% 左右。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913105824.png" alt="20250913105824"><br>wsh-study.com：Redis 6.0的多线程网络模型</p>
<p>Redis 6.0 的多线程 IO 模型主要包含三个核心步骤：</p>
<ul>
<li>仍然由<strong>主线程</strong>负责接收客户端的连接请求。</li>
<li><strong>主线程</strong>将连接请求分发给多个 <code>IO 线程</code>进行处理，主线程负责解析和执行命令。</li>
<li>命令执行完毕后，由多个 IO 线程将结果返回给客户端。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Redis 主事件循环（简化版）</span><br><span class="line">void beforeSleep(struct aeEventLoop *eventLoop) &#123;</span><br><span class="line">    // 1. 主线程分派读任务给 I/O 线程</span><br><span class="line">    handleClientsWithPendingReadsUsingThreads();</span><br><span class="line">    </span><br><span class="line">    // 2. 等待 I/O 线程完成读取</span><br><span class="line">    waitForIOThreads();</span><br><span class="line">    </span><br><span class="line">    // 3. 主线程处理命令</span><br><span class="line">    processInputBuffer();</span><br><span class="line">    </span><br><span class="line">    // 4. 主线程分派写任务给 I/O 线程</span><br><span class="line">    handleClientsWithPendingWritesUsingThreads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis 6.0 默认仍然使用单线程模式，但可以通过配置文件或命令行参数启用多线程模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 启用多线程模式</span><br><span class="line">io-threads 4</span><br><span class="line"></span><br><span class="line"># 启用多线程写入（Redis 6.0 默认只开启多线程读取）</span><br><span class="line">io-threads-do-reads yes</span><br></pre></td></tr></table></figure>

<p>建议将 IO 线程数设置为 CPU 核心数的一半，一般不建议超过 8 个。</p>
<p>经过多次测试，Redis 6.0 在处理 1-200 字节的小数据包时，性能提升 1.5-2 倍；在处理 1KB 以上的大数据包时提升约 3-5 倍。</p>
<p>-—这部分面试中可以不背，方便理解 end —-</p>
<h3 id="8-说说-Redis-的常用命令（补充）"><a href="#8-说说-Redis-的常用命令（补充）" class="headerlink" title="8.说说 Redis 的常用命令（补充）"></a>8.说说 Redis 的常用命令（补充）</h3><blockquote>
<p>2024 年 04 月 11 日增补</p>
</blockquote>
<p>一句话回答（也不用全部都背，挑三个就行）：</p>
<p>Redis 支持多种数据结构，常用的命令也比较多，比如说操作字符串可以用 <code>SET/GET/INCR</code>，操作哈希可以用 <code>HSET/HGET/HGETALL</code>，操作列表可以用 <code>LPUSH/LPOP/LRANGE</code>，操作集合可以用 <code>SADD/SISMEMBER</code>，操作有序集合可以用 <code>ZADD/ZRANGE/ZINCRBY</code>等，通用命令有 <code>EXPIRE/DEL/KEYS</code> 等。</p>
<p>-—这部分面试中可以不背，方便理解 start—-</p>
<p>①、操作字符串的命令有：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>SET key value</code></td>
<td>设置字符串键值</td>
<td><code>SET name jack</code></td>
</tr>
<tr>
<td><code>GET key</code></td>
<td>获取字符串值</td>
<td><code>GET name</code></td>
</tr>
<tr>
<td><code>INCR key</code></td>
<td>数值自增 1</td>
<td><code>INCR count</code></td>
</tr>
<tr>
<td><code>DECR key</code></td>
<td>数值自减 1</td>
<td><code>DECR stock</code></td>
</tr>
<tr>
<td><code>INCRBY key N</code></td>
<td>增加 N</td>
<td><code>INCRBY views 10</code></td>
</tr>
<tr>
<td><code>APPEND key value</code></td>
<td>追加字符串</td>
<td><code>APPEND log &quot;done&quot;</code></td>
</tr>
<tr>
<td><code>GETRANGE key start end</code></td>
<td>获取子串</td>
<td><code>GETRANGE name 0 3</code></td>
</tr>
<tr>
<td><code>MSET k1 v1 k2 v2</code></td>
<td>批量设置多个键值</td>
<td><code>MSET a 1 b 2</code></td>
</tr>
</tbody></table>
<p>②、操作列表的命令有：</p>
<ul>
<li><code>LPUSH key value</code>：将一个值插入到列表 key 的头部。</li>
<li><code>RPUSH key value</code>：将一个值插入到列表 key 的尾部。</li>
<li><code>LPOP key</code>：移除并返回列表 key 的头元素。</li>
<li><code>RPOP key</code>：移除并返回列表 key 的尾元素。</li>
<li><code>LRANGE key start stop</code>：获取列表 key 中指定范围内的元素。</li>
</ul>
<p>③、操作集合的命令有：</p>
<ul>
<li><code>SADD key member</code>：向集合 key 添加一个元素。</li>
<li><code>SREM key member</code>：从集合 key 中移除一个元素。</li>
<li><code>SMEMBERS key</code>：返回集合 key 中的所有元素。</li>
</ul>
<p>④、操作有序集合的命令有：</p>
<ul>
<li><code>ZADD key score member</code>：向有序集合 key 添加一个成员，或更新其分数。</li>
<li><code>ZRANGE key start stop [WITHSCORES]</code>：按照索引区间返回有序集合 key 中的成员，可选 WITHSCORES 参数返回分数。</li>
<li><code>ZREVRANGE key start stop [WITHSCORES]</code>：返回有序集合 key 中，指定区间内的成员，按分数递减。</li>
<li><code>ZREM key member</code>：移除有序集合 key 中的一个或多个成员。</li>
</ul>
<p>⑤、操作哈希的命令有：</p>
<ul>
<li><code>HSET key field value</code>：向键为 key 的哈希表中设置字段 field 的值为 value。</li>
<li><code>HGET key field</code>：获取键为 key 的哈希表中字段 field 的值。</li>
<li><code>HGETALL key</code>：获取键为 key 的哈希表中所有的字段和值。</li>
<li><code>HDEL key field</code>：删除键为 key 的哈希表中的一个或多个字段。</li>
</ul>
<h4 id="详细说说-set-命令？"><a href="#详细说说-set-命令？" class="headerlink" title="详细说说 set 命令？"></a>详细说说 set 命令？</h4><p>SET 命令用于设置字符串的 key，支持过期时间和条件写入，常用于设置缓存、实现分布式锁、延长 Session 等场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds | PX milliseconds | EXAT timestamp | PXAT timestamp-milliseconds | KEEPTTL] [NX | XX] [GET]</span><br></pre></td></tr></table></figure>

<p>默认情况下，SET 会覆盖键已有的值。</p>
<p>支持多种设置过期时间的方式，比如说 EX 设置秒级过期时间，PX 设置毫秒过期时间。</p>
<p>支持条件写入，使其可以实现原子性操作，比如说 NX 仅在键不存在时设置值，XX 仅在键存在时设置值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913113222.png" alt="20250913113222"><br>二哥的 Java 进阶之路：set 命令</p>
<p>缓存实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET user:profile:&#123;userid&#125; &#123;JSON数据&#125; EX 3600  # 存储用户资料，并设置1小时过期</span><br></pre></td></tr></table></figure>

<p>实现分布式锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock:resource_name &#123;random_value&#125; EX 10 NX  # 获取锁，10秒后自动释放</span><br></pre></td></tr></table></figure>

<p>存储 Session：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET session:&#123;sessionid&#125; &#123;session_data&#125; EX 1800  # 存储用户会话，30分钟过期</span><br></pre></td></tr></table></figure>

<h4 id="sadd-命令的时间复杂度是多少？"><a href="#sadd-命令的时间复杂度是多少？" class="headerlink" title="sadd 命令的时间复杂度是多少？"></a>sadd 命令的时间复杂度是多少？</h4><p>SADD 支持一次添加多个元素，返回值为实际添加成功的元素数量，时间复杂度为 O(N)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli SADD myset &quot;apple&quot; &quot;banana&quot; &quot;orange&quot;</span><br></pre></td></tr></table></figure>

<h4 id="incr命令了解吗？"><a href="#incr命令了解吗？" class="headerlink" title="incr命令了解吗？"></a>incr命令了解吗？</h4><p>INCR 是一个原子命令，可以将指定键的值加 1，如果 key 不存在，会先将其设置为 0，再执行加 1 操作。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250913113235.png" alt="20250913113235"><br>二哥的Java进阶之路：INCR</p>
<p>常用于网站访问量、文章点赞数等计数器的实现；结合过期时间实现限流器；生成分布式唯一 ID；库存扣减等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 限制用户每分钟最多访问10次</span><br><span class="line">FUNCTION limit_api_call(user_id)</span><br><span class="line">    current = INCR(&quot;rate:&quot;+user_id)</span><br><span class="line">    IF current == 1 THEN</span><br><span class="line">        EXPIRE(&quot;rate:&quot;+user_id, 60)</span><br><span class="line">    END</span><br><span class="line">    IF current &gt; 10 THEN</span><br><span class="line">        RETURN false  # 超出限制</span><br><span class="line">    ELSE</span><br><span class="line">        RETURN true   # 允许访问</span><br><span class="line">    END</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h3 id="9-单线程的Redis-QPS-能到多少？-补充"><a href="#9-单线程的Redis-QPS-能到多少？-补充" class="headerlink" title="9.单线程的Redis QPS 能到多少？(补充)"></a>9.单线程的Redis QPS 能到多少？(补充)</h3><blockquote>
<p>2024 年 4 月 14 日增补</p>
</blockquote>
<p>根据<a target="_blank" rel="noopener" href="https://redis.io/docs/latest/operate/oss_and_stack/management/optimization/benchmarks/">官方的基准测试</a>，一个普通服务器的 Redis 实例通常可以达到每秒十万左右的 QPS。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095518.png" alt="20251016095518"><br>每秒请求数能达到10 万级</p>
<p>-—这部分面试中可以不背，方便理解 start —-</p>
<p>Redis 的 QPS（每秒请求数）性能取决于多种因素，包括硬件配置、网络延迟、数据结构、命令类型等。</p>
<p>可以通过 <code>redis-benchmark</code> 命令进行基准测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h 127.0.0.1 -p 6379 -c 50 -n 10000</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-h</code>：指定 Redis 服务器的地址，默认是 127.0.0.1。</li>
<li><code>-p</code>：指定 Redis 服务器的端口，默认是 6379。</li>
<li><code>-c</code>：并发连接数，即同时有多少个客户端在进行测试。</li>
<li><code>-n</code>：请求总数，即测试过程中总共要执行多少个请求。</li>
</ul>
<p>2023 年前，我用的是一台 macOS，4 GHz 四核 Intel Core i7，32 GB 1867 MHz DDR3，测试结果如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095613.png" alt="20251016095613"><br>二哥的 Java 进阶之路：Redis 的基准测试</p>
<p>可以看得出，每秒能处理超过 10 万次请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPS = 总请求数 / 总耗时 = 10000 / 0.09 ≈ 111111 QPS</span><br></pre></td></tr></table></figure>

<p>延迟也非常低，99% 的请求都在 0.3ms 以内完成了。</p>
<p>-—这部分面试中可以不背，方便理解 end —-</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="10-🌟Redis的持久化方式有哪些？"><a href="#10-🌟Redis的持久化方式有哪些？" class="headerlink" title="10.🌟Redis的持久化方式有哪些？"></a>10.🌟Redis的持久化方式有哪些？</h3><p>主要有两种，RDB 和 AOF。RDB 通过创建时间点快照来实现持久化，AOF 通过记录每个写操作命令来实现持久化。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928161918.png" alt="20250928161918"><br>三分恶面渣逆袭：Redis持久化的两种方式</p>
<p>这两种方式可以单独使用，也可以同时使用。这样就可以保证 Redis 服务器在重启后不丢失数据，通过 <code>RDB</code> 和 <code>AOF</code> 文件来恢复内存中原有的数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928162003.png" alt="20250928162003"><br>Gaurav：RDB 和 AOF</p>
<h4 id="详细说一下-RDB？"><a href="#详细说一下-RDB？" class="headerlink" title="详细说一下 RDB？"></a>详细说一下 RDB？</h4><p>RDB 持久化机制可以在指定的时间间隔内将 Redis 某一时刻的数据保存到磁盘上的 RDB 文件中，当 Redis 重启时，可以通过加载这个 RDB 文件来恢复数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928162408.png" alt="20250928162408"><br>Animesh Gaitonde：RDB</p>
<p>RDB 持久化可以通过 <code>save</code> 和 <code>bgsave</code> 命令手动触发，也可以通过配置文件中的 <code>save</code> 指令自动触发。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163257.png" alt="20250928163257"><br>三分恶面渣逆袭：save和bgsave</p>
<p>save 命令会阻塞 Redis 进程，直到 RDB 文件创建完成。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163337.png" alt="20250928163337"><br>二哥的 Java 进阶之路：手动执行 RDB</p>
<p>bgsave 命令会在后台 fork 一个子进程来执行 RDB 持久化操作，主进程不会被阻塞。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163355.png" alt="20250928163355"><br>Mr于：Redis bgsave</p>
<h4 id="什么情况下会自动触发-RDB-持久化？"><a href="#什么情况下会自动触发-RDB-持久化？" class="headerlink" title="什么情况下会自动触发 RDB 持久化？"></a>什么情况下会自动触发 RDB 持久化？</h4><p>第一种，在 Redis 配置文件中设置 RDB 持久化参数 <code>save &lt;seconds&gt; &lt;changes&gt;</code>，表示在指定时间间隔内，如果有指定数量的键发生变化，就会自动触发 RDB 持久化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1      # 900 秒（15 分钟）内有 1 个 key 发生变化，触发快照</span><br><span class="line">save 300 10     # 300 秒（5 分钟）内有 10 个 key 发生变化，触发快照</span><br><span class="line">save 60 10000   # 60 秒内有 10000 个 key 发生变化，触发快照</span><br></pre></td></tr></table></figure>

<p>第二种，主从复制时，当从节点第一次连接到主节点时，主节点会自动执行 bgsave 生成 RDB 文件，并将其发送给从节点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163542.png" alt="20250928163542"><br>达摩院的BLOG：Redis 主从复制时 RDB 自动生成</p>
<p>第三种，如果没有开启 AOF，执行 shutdown 命令时，Redis 会自动保存一次 RDB 文件，以确保数据不会丢失。</p>
<h4 id="详细说一下-AOF？"><a href="#详细说一下-AOF？" class="headerlink" title="详细说一下 AOF？"></a>详细说一下 AOF？</h4><p>AOF 通过记录每个写操作命令，并将其追加到 AOF 文件来实现持久化，Redis 服务器宕机后可以通过重新执行这些命令来恢复数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928163946.png" alt="20250928163946"><br>Animesh Gaitonde：AOF</p>
<p>当 Redis 执行写操作时，会将写命令追加到 AOF 缓冲区；Redis 会根据同步策略将缓冲区的数据写入到 AOF 文件。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928164026.png" alt="20250928164026"><br>三分恶面渣逆袭：AOF工作流程</p>
<p>当 AOF 文件过大时，Redis 会自动进行 AOF 重写，剔除多余的命令，比如说多次对同一个 key 的 set 和 del，生成一个新的 AOF 文件；当 Redis 重启时，读取 AOF 文件中的命令并重新执行，以恢复数据。</p>
<h4 id="AOF-的刷盘策略了解吗？"><a href="#AOF-的刷盘策略了解吗？" class="headerlink" title="AOF 的刷盘策略了解吗？"></a>AOF 的刷盘策略了解吗？</h4><p>Redis 将 AOF 缓冲区的数据写入到 AOF 文件时，涉及两个系统调用：write 将数据写入到操作系统的缓冲区，fsync 将 OS 缓冲区的数据刷新到磁盘。</p>
<p>这里的刷盘涉及到三种策略：always、everysec 和 no。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928164208.png" alt="20250928164208"><br>bytebytego：Redis AOF 的刷盘策略</p>
<ul>
<li>always：每次写命令执行完，立即调用 fsync 同步到磁盘，这样可以保证数据不丢失，但性能较差。</li>
<li>everysec：每秒调用一次 fsync，将多条命令一次性同步到磁盘，性能较好，数据丢失的时间窗口为 1 秒。</li>
<li>no：不主动调用 fsync，由操作系统决定，性能最好，但数据丢失的时间窗口不确定，依赖于操作系统的缓存策略，可能会丢失大量数据。</li>
</ul>
<p>可以通过配置文件中的 appendfsync 参数进行设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync everysec  # 每秒 fsync 一次</span><br></pre></td></tr></table></figure>

<h4 id="说说AOF的重写机制？"><a href="#说说AOF的重写机制？" class="headerlink" title="说说AOF的重写机制？"></a>说说AOF的重写机制？</h4><p>由于 AOF 文件会随着写操作的增加而不断增长，为了解决这个问题， Redis 提供了重写机制来对 AOF 文件进行压缩和优化。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928165143.png" alt="20250928165143"><br>pdai.tech：AOF 文件瘦身</p>
<p>AOF 重写可以通过两种方式触发，第一种是手动执行 <code>BGREWRITEAOF</code> 命令，适用于需要立即减小AOF文件大小的场景。</p>
<p>第二种是在 Redis 配置文件中设置自动重写参数，比如说 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code>，表示当 AOF 文件大小超过指定值时，自动触发重写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  # 默认值100，表示当前AOF文件大小相比上次重写后大小增长了多少百分比时触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb  # 默认值64MB，表示AOF文件至少要达到这个大小才会考虑重写</span><br></pre></td></tr></table></figure>

<h4 id="AOF-重写的具体过程是怎样的？"><a href="#AOF-重写的具体过程是怎样的？" class="headerlink" title="AOF 重写的具体过程是怎样的？"></a>AOF 重写的具体过程是怎样的？</h4><p>Redis 在收到重写指令后，会创建一个子进程，并 fork 一份与父进程完全相同的数据副本，然后遍历内存中的所有键值对，生成重建它们所需的最少命令。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928165506.png" alt="20250928165506"><br>云烟成雨：Redis 的 AOF 重写机制</p>
<p>比如说多个 RPUSH 命令可以合并为一个带有多个参数的 RPUSH；</p>
<p>比如说一个键被设置后又被删除，这个键的所有操作都不会被写入新 AOF。</p>
<p>比如说使用 <code>SADD key member1 member2 member3</code> 代替多个单独的 <code>SADD key memberX</code>。</p>
<p>子进程在执行 AOF 重写的同时，主进程可以继续处理来自客户端的命令。</p>
<p>为了保证数据一致性，Redis 使用了 AOF 重写缓冲区机制，主进程在执行写操作时，会将命令同时写入旧的 AOF 文件和重写缓冲区。</p>
<p>等子进程完成重写后，会向主进程发送一个信号，主进程收到后将重写缓冲区中的命令追加到新的 AOF 文件中，然后调用操作系统的 rename，将旧的 AOF 文件替换为新的 AOF 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">主进程（fork）  </span><br><span class="line">   │  </span><br><span class="line">   ├─→ 子进程（生成新的 AOF 文件）  </span><br><span class="line">   │       │  </span><br><span class="line">   │       ├─→ 内存快照  </span><br><span class="line">   │       ├─→ 写入临时 AOF 文件  </span><br><span class="line">   │       ├─→ 通知主进程完成  </span><br><span class="line">   │  </span><br><span class="line">   ├─→ 主进程（追加缓冲区到新 AOF 文件）  </span><br><span class="line">   ├─→ 替换旧 AOF 文件  </span><br><span class="line">   ├─→ 重写完成</span><br></pre></td></tr></table></figure>

<p>AOF 重写期间，Redis 服务器会处于特殊状态：</p>
<ul>
<li>aof_child_pid 不为 0，表示有子进程在执行 AOF 重写</li>
<li>aof_rewrite_buf_blocks 链表不为空，存储 AOF 重写缓冲区内容</li>
</ul>
<p>如果在配置文件中设置 no-appendfsync-on-rewrite 为 yes，那么重写期间可能会暂停 AOF 文件的 fsync 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes                # 开启AOF</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;  # AOF文件名</span><br><span class="line">appendfsync everysec          # 写入磁盘策略</span><br><span class="line">no-appendfsync-on-rewrite no  # 重写期间是否临时关闭fsync</span><br><span class="line">auto-aof-rewrite-percentage 100   # AOF文件增长到原来多少百分比时触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb    # AOF文件最小多大时才允许重写</span><br></pre></td></tr></table></figure>

<h4 id="AOF-文件存储的是什么类型的数据？"><a href="#AOF-文件存储的是什么类型的数据？" class="headerlink" title="AOF 文件存储的是什么类型的数据？"></a>AOF 文件存储的是什么类型的数据？</h4><p>AOF 文件存储的是 Redis 服务器接收到的写命令数据，以 Redis 协议格式保存。</p>
<p>这种格式的特点是，每个命令以*开头，后跟参数的数量，每个参数前用<code>$</code>符号，后跟参数字节长度，然后是参数的实际内容。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095627.png" alt="20251016095627"><br>二哥的Java 进阶之路：AOF文件内容格式</p>
<h4 id="AOF重写期间命令可能会写入两次，会造成什么影响？"><a href="#AOF重写期间命令可能会写入两次，会造成什么影响？" class="headerlink" title="AOF重写期间命令可能会写入两次，会造成什么影响？"></a>AOF重写期间命令可能会写入两次，会造成什么影响？</h4><p>AOF 重写期间命令会同时写入现有AOF文件和重写缓冲区，这种机制是有意设计的，并不会导致数据重复或不一致问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095640.png" alt="20251016095640"><br>UStarGao：AOF 双写机制</p>
<p>因为新旧文件是分离的，现有命令写入当前 AOF 文件，重写缓冲区的命令最终写入新的 AOF 文件，完成后，新文件通过原子性的 rename 操作替换旧文件。两个文件是完全分离的，不会导致同一个 AOF 文件中出现重复命令。</p>
<h3 id="11-RDB-和-AOF-各自有什么优缺点？"><a href="#11-RDB-和-AOF-各自有什么优缺点？" class="headerlink" title="11.RDB 和 AOF 各自有什么优缺点？"></a>11.RDB 和 AOF 各自有什么优缺点？</h3><p>RDB 通过 fork 子进程在特定时间点对内存数据进行全量备份，生成二进制格式的快照文件。其最大优势在于备份恢复效率高，文件紧凑，恢复速度快，适合大规模数据的备份和迁移场景。</p>
<p>缺点是可能丢失两次快照期间的所有数据变更。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251016095649.png" alt="20251016095649"><br>dfordebugging：rdb vs aof</p>
<p>AOF 会记录每一条修改数据的写命令。这种日志追加的方式让 AOF 能够提供接近实时的数据备份，数据丢失风险可以控制在 1 秒内甚至完全避免。</p>
<p>缺点是文件体积较大，恢复速度慢。</p>
<p>来个表格对比一下：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>RDB（快照）</th>
<th>AOF（命令日志）</th>
</tr>
</thead>
<tbody><tr>
<td>数据完整性</td>
<td>❌ 可能丢失几分钟数据</td>
<td>✅ 最多丢 1 秒数据</td>
</tr>
<tr>
<td>恢复速度</td>
<td>✅ 快（直接加载二进制快照）</td>
<td>❌ 慢（逐条 replay）</td>
</tr>
<tr>
<td>文件大小</td>
<td>✅ 小（压缩后）</td>
<td>❌ 大（命令追加）</td>
</tr>
<tr>
<td>性能影响</td>
<td>✅ 低（fork 后保存）</td>
<td>❌ 较高（每次写都记录）</td>
</tr>
<tr>
<td>写入方式</td>
<td>定期全量写</td>
<td>每次写命令就记录</td>
</tr>
<tr>
<td>适用场景</td>
<td>冷备份，灾难恢复</td>
<td>实时持久化，数据安全</td>
</tr>
<tr>
<td>默认状态</td>
<td>默认启用</td>
<td>Redis 7 默认也启用</td>
</tr>
<tr>
<td>重写机制</td>
<td>无</td>
<td>有（BGREWRITEAOF）</td>
</tr>
<tr>
<td>混合支持</td>
<td>Redis 4.0 后支持结合使用（aof-use-rdb-preamble）</td>
<td></td>
</tr>
</tbody></table>
<h3 id="12-RDB-和-AOF-如何选择？"><a href="#12-RDB-和-AOF-如何选择？" class="headerlink" title="12.RDB 和 AOF 如何选择？"></a>12.RDB 和 AOF 如何选择？</h3><p>在选择 Redis 持久化方案时，我会从业务需求和技术特性两个维度来考虑。</p>
<p>如果是缓存场景，可以接受一定程度的数据丢失，我会倾向于选择 RDB 或者完全不使用持久化。RDB 的快照方式对性能影响小，而且恢复速度快，非常适合这类场景。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928170721.png" alt="20250928170721"><br>洒脱的耿：Redis 做缓存</p>
<p>但如果是处理订单或者支付这样的核心业务，数据丢失将造成严重后果，那么 AOF 就成为必然选择。通过配置每秒同步一次，可以将潜在的数据丢失风险限制在可接受范围内。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928170750.png" alt="20250928170750"><br>极客时间：reids 在秒杀中的应用</p>
<p>在实际的项目当中，我更偏向于使用 RDB + AOF 的混合模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes # 开启 AOF</span><br><span class="line">appendfsync everysec # 每秒刷盘一次</span><br><span class="line">aof-use-rdb-preamble yes # 开启混合持久化，重启时优先加载 RDB，RDB 作为冷备，AOF 作为实时同步</span><br></pre></td></tr></table></figure>

<h3 id="13-Redis如何恢复数据？"><a href="#13-Redis如何恢复数据？" class="headerlink" title="13.Redis如何恢复数据？"></a>13.Redis如何恢复数据？</h3><p>当 Redis 服务重启时，它会优先查找 AOF 文件，如果存在就通过重放其中的命令来恢复数据；如果不存在或未启用 AOF，则会尝试加载 RDB 文件，直接将二进制数据载入内存来恢复。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928170909.png" alt="20250928170909"><br>三分恶面渣逆袭：Redis启动加载数据</p>
<p>如果 AOF 文件损坏的话，Redis 会尝试通过 <code>redis-check-aof</code> 工具来修复 AOF 文件，或者直接使用 <code>--repair</code> 参数来修复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --repair appendonly.aof</span><br></pre></td></tr></table></figure>

<p>虽然 Redis 还提供了 <code>redis-check-rdb</code> 工具来检查 RDB 文件的完整性，但它并不支持修复 RDB 文件，只能用来验证文件的完整性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-rdb dump.rdb</span><br></pre></td></tr></table></figure>

<h3 id="14-🌟Redis-4-0-的混合持久化了解吗？"><a href="#14-🌟Redis-4-0-的混合持久化了解吗？" class="headerlink" title="14.🌟Redis 4.0 的混合持久化了解吗？"></a>14.🌟Redis 4.0 的混合持久化了解吗？</h3><p>是的。</p>
<p>混合持久化结合了 RDB 和 AOF 两种方式的优点，解决了它们各自的不足。在 Redis 4.0 之前，我们要么面临 RDB 可能丢失数据的风险，要么承受 AOF 恢复慢的问题，很难两全其美。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928170958.png" alt="20250928170958"><br>Animesh Gaitonde：aof-use-rdb-preamble</p>
<p>混合持久化的工作原理非常巧妙：在 AOF 重写期间，先以 RDB 格式将内存中的数据快照保存到 AOF 文件的开头，再将重写期间的命令以 AOF 格式追加到文件末尾。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250928171009.png" alt="20250928171009"><br>三分恶面渣逆袭：混合持久化</p>
<p>这样，当需要恢复数据时，Redis 先加载 RDB 格式的数据来快速恢复大部分的数据，然后通过重放命令恢复最近的数据，这样就能在保证数据完整性的同时，提升恢复速度。</p>
<h4 id="如何设置持久化模式？"><a href="#如何设置持久化模式？" class="headerlink" title="如何设置持久化模式？"></a>如何设置持久化模式？</h4><p>启用混合持久化的方式非常简单，只需要在配置文件中设置 <code>aof-use-rdb-preamble yes</code> 就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<h4 id="你在开发中是怎么配置-RDB-和-AOF-的？"><a href="#你在开发中是怎么配置-RDB-和-AOF-的？" class="headerlink" title="你在开发中是怎么配置 RDB 和 AOF 的？"></a>你在开发中是怎么配置 RDB 和 AOF 的？</h4><p>对于大多数生产环境，我倾向于使用混合持久化方式，结合 RDB 和 AOF 的优点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 启用AOF</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 使用混合持久化</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line"># 每秒同步一次AOF，平衡性能和安全性</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># AOF重写触发条件：文件增长100%且至少达到64MB</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># RDB备份策略</span><br><span class="line">save 900 1    # 15分钟内有1个修改</span><br><span class="line">save 300 10   # 5分钟内有10个修改</span><br><span class="line">save 60 10000 # 1分钟内有10000个修改</span><br></pre></td></tr></table></figure>

<p>对于单纯的缓存场景，或者本地开发，我会只启用 RDB，关闭 AOF：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 禁用AOF</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># 较宽松的RDB策略</span><br><span class="line">save 3600 1    # 1小时内有1个修改</span><br><span class="line">save 300 100   # 5分钟内有100个修改</span><br></pre></td></tr></table></figure>

<p>而对于金融类等高一致性的系统，我通常会在关键时间窗口动态将 <code>appendfsync</code> 设置为 <code>always</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 启用AOF</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 使用混合持久化</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line"># 每个命令都同步（谨慎使用，性能影响大）</span><br><span class="line"># 通常我会在关键时间窗口动态修改为always</span><br><span class="line">appendfsync always</span><br><span class="line"></span><br><span class="line"># 更频繁的RDB快照</span><br><span class="line">save 300 1     # 5分钟内有1个修改</span><br><span class="line">save 60 100    # 1分钟内有100个修改</span><br></pre></td></tr></table></figure>

<p>另外，对于高并发场景，应该设置<code>no-appendfsync-on-rewrite yes</code>，避免 AOF 重写影响主进程性能；对于大型实例，也应该设置 <code>rdb-save-incremental-fsync yes</code> 来减少大型 RDB 保存对性能的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># AOF重写期间不fsync，AOF 重写期间，主进程不会对新写入的 AOF 缓冲区执行 fsync 操作（即不强制刷盘），而是等重写结束后再统一刷盘。</span><br><span class="line">no-appendfsync-on-rewrite yes</span><br><span class="line"># RDB 快照保存时采用增量 fsync，即每写入一定量的数据就执行一次 fsync，将数据分批同步到磁盘。</span><br><span class="line">rdb-save-incremental-fsync yes</span><br></pre></td></tr></table></figure>


<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="15-主从复制了解吗？"><a href="#15-主从复制了解吗？" class="headerlink" title="15.主从复制了解吗？"></a>15.主从复制了解吗？</h3><p>主从复制允许从节点维护主节点的数据副本。在这种架构中，一个主节点可以连接多个从节点，从而形成一主多从的结构。主节点负责处理写操作，从节点自动同步主节点的数据变更，并处理读请求，从而实现读写分离。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-60497f1e-8afb-44b3-bb7a-d4c29e5ac484.png" alt="三分恶面渣逆袭：Redis主从复制简图"></p>
<p>三分恶面渣逆袭：Redis主从复制简图</p>
<h4 id="主从复制的主要作用是什么"><a href="#主从复制的主要作用是什么" class="headerlink" title="主从复制的主要作用是什么?"></a>主从复制的主要作用是什么?</h4><p>第一，主节点负责处理写请求，从节点负责处理读请求，从而实现读写分离，减轻主节点压力的同时提升系统的并发能力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017190721.png" alt="20251017190721"><br>pdai.tech：主从复制的读写分离</p>
<p>第二，从节点可以作为主节点的数据备份，当主节点发生故障时，可以快速将从节点提升为新的主节点，从而保证系统的高可用性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017190805.png" alt="20251017190805"><br>系统运维：Redis主从+Sentinel集群</p>
<h4 id="什么情况下会出现主从复制数据不一致？"><a href="#什么情况下会出现主从复制数据不一致？" class="headerlink" title="什么情况下会出现主从复制数据不一致？"></a>什么情况下会出现主从复制数据不一致？</h4><p>Redis 的主从复制是异步进行的，因此在主节点宕机、网络波动或复制延迟较高时会出现从节点数据不同步的情况。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017191223.png" alt="20251017191223"><br>ningg.top：主从复制异步进行</p>
<p>比如主节点写入数据后宕机，但从节点还未来得及复制，就会出现数据不一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">时间线：→</span><br><span class="line"></span><br><span class="line">客户端  →  向主节点 SET user:1 二哥     →  主节点处理成功 ✅</span><br><span class="line">                            ↓</span><br><span class="line">                          正准备推送给从节点（异步复制）... 但还没推送完 ❌</span><br><span class="line">                            ↓</span><br><span class="line">                  —— 突然主节点宕机（机器死机、断网） 💥 ——</span><br><span class="line">                            ↓</span><br><span class="line">          Sentinel 监测到故障，failover：将从节点提升为新主节点 🧠</span><br><span class="line">                            ↓</span><br><span class="line">客户端继续请求：GET user:1 ❓→ 从节点返回：空 ❌（数据没同步过来）</span><br></pre></td></tr></table></figure>

<p>另一个容易被忽视的因素是主节点内存压力。当主节点内存接近上限并启用了淘汰策略时，某些键可能被自动删除，而这些删除操作如果未能及时同步，就会造成从节点保留了主节点已经不存在的数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017191400.png" alt="20251017191400"><br>图片来源于网络：主从不一致</p>
<h4 id="主从复制数据不一致的解决方案有哪些？"><a href="#主从复制数据不一致的解决方案有哪些？" class="headerlink" title="主从复制数据不一致的解决方案有哪些？"></a>主从复制数据不一致的解决方案有哪些？</h4><p>首先是网络层面的优化，理想情况下，主从节点应该部署在同一个网络区域内，避免跨区域的网络延迟。</p>
<p>其次是配置层面的调整，比如说适当增大复制积压缓冲区的大小和存活时间，以便从节点重连后进行增量同步而不是全量同步，以最大程度减少主从同步的延迟。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size 1mb  # 默认值 1MB，表示主节点的复制缓冲区大小</span><br><span class="line">repl-backlog-ttl 3600  # 默认值 3600 秒，表示主节点的复制缓冲区存活时间</span><br></pre></td></tr></table></figure>

<p>第三是引入监控和自动修复机制，定期检查主从节点的数据一致性。</p>
<p>比如说通过比较主从的 offset 差值判断从库是否落后。一旦超过设定阈值，就将从节点剔除，并重新进行全量同步。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240709135618.png" alt="极客时间：Redis 核心技术与实战"></p>
<p>极客时间：Redis 核心技术与实战</p>
<h3 id="16-Redis主从有几种常见的拓扑结构？"><a href="#16-Redis主从有几种常见的拓扑结构？" class="headerlink" title="16.Redis主从有几种常见的拓扑结构？"></a>16.Redis主从有几种常见的拓扑结构？</h3><p>主要有三种。</p>
<p>最基础的是一主一从，这种模式适合小型项目。一个主节点负责写入，一个从节点负责读和数据备份。这种结构虽然简单，但维护成本低。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017192514.png" alt="20251017192514"><br>三分恶面渣逆袭：一主一从</p>
<p>随着业务增长，读请求增多，可以考虑扩展为一主多从结构。主节点负责写入，多个从节点还可以分摊压力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017192546.png" alt="20251017192546"><br>三分恶面渣逆袭：一主多从结构</p>
<p>在跨地域部署场景中，树状主从结构可以有效降低主节点负载和需要传送给从节点的数据量。通过引入复制中间层，从节点不仅可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017192613.png" alt="20251017192613"><br>三分恶面渣逆袭：树状主从结构</p>
<h3 id="17-Redis的主从复制原理了解吗？"><a href="#17-Redis的主从复制原理了解吗？" class="headerlink" title="17.Redis的主从复制原理了解吗？"></a>17.Redis的主从复制原理了解吗？</h3><p>了解。</p>
<p>Redis 的主从复制是指通过异步复制将主节点的数据变更同步到从节点，从而实现数据备份和读写分离。这个过程大致可以分为三个阶段：建立连接、同步数据和传播命令。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017193800.png" alt="20251017193800"><br>pdai.tech：Redis主从复制原理</p>
<p>在建立连接阶段，从节点通过执行 <code>replicaof</code> 命令连接到主节点。连接建立后，从节点向主节点发送 <code>psync</code> 命令，请求数据同步。这时主节点会为该从节点创建一个连接和复制缓冲区。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017193813.png" alt="20251017193813"><br>MainWoods：复制缓冲区</p>
<p>同步数据阶段分为全量同步和增量同步。当从节点首次连接主节点时，会触发全量同步。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194014.png" alt="20251017194014"><br>ningG：增量同步和全量同步</p>
<p>在这个过程中，主节点会 fork 一个子进程生成 RDB 文件，同时将文件生成期间收到的写命令缓存到复制缓冲区。然后将 RDB 文件发送给从节点，从节点清空自己的数据并加载这个 RDB 文件。等 RDB 传输完成后，主节点再将缓存的写命令发送给从节点执行，确保数据完全一致。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194024.png" alt="20251017194024"><br>博客园多少幅度：主从数据复制过程</p>
<p>主从完成全量同步后，主要依靠传播命令阶段来保持数据的增量同步。主节点会将每次执行的写命令实时发送给所有从节点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194033.png" alt="20251017194033"><br>ningG：命令传播</p>
<p>Redis 2.8 版本后，主节点会为每个从节点维护一个复制积压缓冲区，用于存储最近的写命令。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194045.png" alt="20251017194045"><br>MainWoods：复制积压缓冲区</p>
<p>增量复制时，主节点会把要同步的写命令暂存一份到复制积压缓冲区。这样当从节点和主节点发生网络断连，从节点重新连接后，可以从复制积压缓冲区中复制尚未同步的写命令。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194056.png" alt="20251017194056"><br>增量复制</p>
<h3 id="18-详细说说全量同步和增量同步？"><a href="#18-详细说说全量同步和增量同步？" class="headerlink" title="18.详细说说全量同步和增量同步？"></a>18.详细说说全量同步和增量同步？</h3><p>全量同步会将主节点的完整数据集传输给从节点，通常发生在从节点首次连接主节点时。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194217.png" alt="20251017194217"><br>三分恶面渣逆袭：全量同步</p>
<p>此时，从节点发送 <code>psync ? -1</code> 命令请求同步。<code>?</code> 表示从节点没有主节点 ID，<code>-1</code> 表示没有偏移量。主节点收到后会回复 <code>FULLRESYNC</code>响应从节点。同时也会包含主库 runid 和复制偏移量 offset 两个参数。</p>
<p>然后 fork 一个子进程生成 RDB 文件，并将新的写命令存入复制缓冲区。</p>
<p>从库收到 RDB 文件后，清空旧数据并加载新的 RDB 文件。加载完成后，从节点会向主节点回复确认消息，主节点再将复制缓冲区中的数据发送给从节点，确保从节点的数据与主节点一致。</p>
<p>全量同步的代价很高，因为完整的 RDB 文件在生成时会占用大量的 CPU 和磁盘 IO；在网络传输时还会消耗掉不少带宽。</p>
<p>于是 Redis 在 2.8 版本后引入了增量同步的概念，目的是在断线重连后避免全量同步。</p>
<p>增量依赖三个关键要素：</p>
<p>①、复制偏移量：主从节点分别维护一个复制偏移量，记录传输的字节数。主节点每传输 N 个字节数据，自身的复制偏移量就会增加 N；从节点每收到 N 个字节数据，也会相应增加自己的偏移量。</p>
<p>②、主节点 ID：每个主节点都有一个唯一 ID，即复制 ID，用于标识主节点的数据版本。当主节点发生重启或者角色变化时，ID 会改变。</p>
<p>③、复制积压缓冲区：主节点维护的一个固定长度的先进先出队列，默认大小为 1M。主节点在向从节点发送命令的同时，也会将命令写入这个缓冲区。</p>
<p>当从节点与主节点断开重连后，会发送 <code>psync&#123;runId&#125;&#123;offset&#125;</code> 命令，带上之前记录的主节点 ID 和复制偏移量。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194302.png" alt="20251017194302"><br>三分恶面渣逆袭：增量同步</p>
<p>主节点收到这个命令后，会检查 runId 和 offset：</p>
<p>如果主节点 ID 与从节点提供的 runId 不匹配，说明主节点已经变化，必须进行全量同步。</p>
<p>如果 ID 匹配，主节点会查找从节点请求的偏移量之后的数据是否还在复制积压缓冲区。</p>
<p>如果在，只发送从该偏移量开始的增量数据，这就是增量同步；否则说明断线时间太长，积压缓冲区已经覆盖了这部分数据，需要全量同步。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194341.png" alt="20251017194341"><br>码哥字节：复制积压缓冲区</p>
<p>增量同步的优势显而易见：只传输断线期间的命令数据，大大减少了网络传输量和主从节点的负载，从节点也不需要清空重载数据，能更快地跟上主节点状态。</p>
<p>对于写入频繁或网络不稳定的环境，应该增大复制积压缓冲区的大小，确保短时间断线后能进行增量同步而不是全量同步。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">repl-backlog-size</span> <span class="string">1mb</span>  <span class="comment"># 默认值 1MB，表示主节点的复制缓冲区大小</span></span><br><span class="line"><span class="string">repl-backlog-ttl</span> <span class="number">3600</span>  <span class="comment"># 默认值 3600 秒，表示主节点的复制缓冲区存活时间</span></span><br></pre></td></tr></table></figure>

<h3 id="19-主从复制存在哪些问题呢？"><a href="#19-主从复制存在哪些问题呢？" class="headerlink" title="19.主从复制存在哪些问题呢？"></a>19.主从复制存在哪些问题呢？</h3><p>Redis 主从复制的最大挑战来自于它的异步特性，主节点处理完写命令后会立即响应客户端，而不会等待从节点确认，这就导致在某些情况下可能出现数据不一致。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194612.png" alt="20251017194612"><br>leonsh：主从同步</p>
<p>另一个常见问题是全量同步对系统的冲击。全量同步会<strong>占用大量的 CPU 和 IO 资源</strong>，尤其是在大数据量的情况下，会导致主节点的性能下降。</p>
<h4 id="脑裂问题了解吗？"><a href="#脑裂问题了解吗？" class="headerlink" title="脑裂问题了解吗？"></a>脑裂问题了解吗？</h4><p>在 Redis 的哨兵架构中，脑裂的典型表现为：主节点与哨兵、从节点之间的网络发生故障了，但与客户端的连接是正常的，就会出现两个“主节点”同时对外提供服务。</p>
<p>哨兵认为主节点已经下线了，于是会将一个从节点选举为新的主节点。但原主节点并不知情，仍然在继续处理客户端的请求。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194846.png" alt="20251017194846"><br>橡 皮 人：脑裂问题</p>
<p>等主节点网络恢复正常了，发现已经有新的主节点了，于是原主节点会自动降级为从节点。在降级过程中，它需要与新主节点进行全量同步，此时原主节点的数据会被清空。导致客户端在原主节点故障期间写入的数据全部丢失。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017194935.png" alt="20251017194935"><br>极客时间：脑裂问题导致数据丢失</p>
<p>为了防止这种数据丢失，Redis 提供了 min-slaves-to-write 和 min-slaves-max-lag 参数。</p>
<p>这两个参数可以设置最少需要多少个从节点在线，以及从节点的最大延迟时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设置主节点能进行数据同步的最少从节点数量</span><br><span class="line">min-slaves-to-write 1</span><br><span class="line"># 设置主从节点间进行数据同步时，从节点给主节点发送 ACK 消息的最大延迟（以秒为单位）</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>设置这两个参数后，如果主节点连接不到指定数量的从节点，或者从节点响应超时，主节点会拒绝写入请求，从而避免脑裂期间的数据冲突。</p>
<p>具体来说，当网络分区发生，主节点与从节点、哨兵之间的连接断开，但主节点与客户端的连接正常时，由于主节点无法再连接到任何从节点，或者延迟超过了设定值，比如说配置了<code>min-slaves-to-write 1</code>，主节点就会自动拒绝所有写请求。</p>
<p>同时在网络的另一侧，哨兵会检测到主节点”下线”，选举一个从节点成为新的主节点。由于原主节点已经停止接受写入，所以不会产生新的数据变更，等网络恢复后，即使原主节点降级为从节点并进行全量同步，也不会丢失网络分区期间的写入数据，因为根本就没有新的写入发生。</p>
<h3 id="20-Redis哨兵机制了解吗？"><a href="#20-Redis哨兵机制了解吗？" class="headerlink" title="20.Redis哨兵机制了解吗？"></a>20.Redis哨兵机制了解吗？</h3><p>Redis 中的哨兵用于监控主从集群的运行状态，并在主节点故障时自动进行故障转移。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195239.png" alt="20251017195239"><br>三分恶面渣逆袭：Redis Sentinel</p>
<p>核心功能包括监控、通知和自动故障转移。哨兵会定期检查主从节点是否按预期工作，当检测到主节点故障时，就在从节点中选举出一个新的主节点，并通知客户端连接到新的主节点。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控的主节点信息 + 多少个哨兵同意才算宕机</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379 </span><span class="number">2</span></span><br><span class="line"><span class="comment"># 多久不响应就标记为“主观下线”</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">5000</span></span><br><span class="line"><span class="comment"># 故障转移超时时间</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">60000</span></span><br><span class="line"><span class="comment"># 同时允许多少个从节点同步新主节点数据</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="21-Redis哨兵的工作原理知道吗？"><a href="#21-Redis哨兵的工作原理知道吗？" class="headerlink" title="21.Redis哨兵的工作原理知道吗？"></a>21.Redis哨兵的工作原理知道吗？</h3><p>哨兵的工作原理可以概括为 4 个关键步骤：定时监控、主观下线、领导者选举和故障转移。</p>
<p>首先，哨兵会定期向所有 Redis 节点发送 PING 命令来检测它们是否可达。如果在指定时间内没有收到回复，哨兵会将该节点标记为“主观下线”。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195331.png" alt="20251017195331"><br>原野漫步：sentinel</p>
<p>当一个哨兵判断主节点主观下线后，会询问其他哨兵的意见，如果达到配置的法定人数，主节点会被标记为“客观下线”。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195349.png" alt="20251017195349"><br>三分恶面渣逆袭：主观下线和客观下线</p>
<p>然后开始故障转移，这个过程中，哨兵会先选举出一个领导者，领导者再从从节点中选择一个最适合的节点作为新的主节点，选择标准包括复制偏移量、优先级等因素。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195430.png" alt="20251017195430"><br>围龙小子：领导者选举</p>
<p>确定新主节点后，哨兵会向其发送 <code>SLAVEOF NO ONE</code> 命令使其升级为主节点，然后向其他从节点发送 SLAVEOF 命令指向新主节点，最后通过发布&#x2F;订阅机制通知客户端主节点已经发生变化。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195507.png" alt="20251017195507"><br>一泽涟漪：Redis Sentinel故障转移</p>
<p>在实际部署中，为了保证哨兵机制的可靠性，通常建议至少部署三个哨兵节点，并且这些节点应分布在不同的物理机器上，降低单点故障风险。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017195932.png" alt="20251017195932"><br>守株阁：哨兵故障转移</p>
<p>同时，法定人数的设置也非常关键，一般建议设置为哨兵数量的一半加一，既能确保在少数哨兵故障时系统仍能正常工作，又能避免网络分区导致的脑裂问题。</p>
<h3 id="22-Redis领导者选举了解吗？"><a href="#22-Redis领导者选举了解吗？" class="headerlink" title="22.Redis领导者选举了解吗？"></a>22.Redis领导者选举了解吗？</h3><p>Redis 使用 Raft 算法实现领导者选举，目的是在主节点故障时，选出一个哨兵来负责执行故障转移操作。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017200028.png" alt="20251017200028"><br>二哥的 Java 进阶之路：领导者选举</p>
<p>选举过程是这样的：</p>
<p>①、当一个哨兵确认主节点客观下线后，会向其他哨兵节点发送请求，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。候选者会先给自己先投 1 票，然后等待其他哨兵节点的投票结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sentinel.c中的sentinelAskMasterStateToOtherSentinels函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelAskMasterStateToOtherSentinels</span><span class="params">(sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    di = dictGetIterator(master-&gt;sentinels);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelRedisInstance *sentinel = dictGetVal(de);</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只有在进入领导者选举阶段才发送投票请求</span></span><br><span class="line">        <span class="keyword">if</span> (master-&gt;failover_state == SENTINEL_FAILOVER_STATE_SELECT_LEADER) &#123;</span><br><span class="line">            <span class="comment">// 发送特殊的is-master-down-by-addr命令请求投票</span></span><br><span class="line">            retval = redisAsyncCommand(sentinel-&gt;cc,</span><br><span class="line">                sentinelReceiveVoteFromSentinel, sentinel,</span><br><span class="line">                <span class="string">&quot;SENTINEL is-master-down-by-addr %s %d %llu %s&quot;</span>,</span><br><span class="line">                master-&gt;addr-&gt;ip, master-&gt;addr-&gt;port,</span><br><span class="line">                (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)master-&gt;failover_epoch,</span><br><span class="line">                <span class="comment">// 这里发送自己的runid请求投票</span></span><br><span class="line">                sentinelGetMyRunID());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则只询问主节点状态，不请求投票</span></span><br><span class="line">            retval = redisAsyncCommand(sentinel-&gt;cc,</span><br><span class="line">                sentinelReceiveIsMasterDownReply, sentinel,</span><br><span class="line">                <span class="string">&quot;SENTINEL is-master-down-by-addr %s %d %llu *&quot;</span>,</span><br><span class="line">                master-&gt;addr-&gt;ip, master-&gt;addr-&gt;port,</span><br><span class="line">                (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②、收到请求的哨兵节点进行判断，如果候选者的日志和自己的一样新，任期号也小于自己，且之前没有投票过，就会投同意票 Y。否则回复 N。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sentinel.c中的sentinelCommand函数部分(处理SENTINEL命令)</span></span><br><span class="line"><span class="comment">// 处理is-master-down-by-addr命令</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;is-master-down-by-addr&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">/* SENTINEL IS-MASTER-DOWN-BY-ADDR &lt;ip&gt; &lt;port&gt; &lt;current-epoch&gt; &lt;runid&gt; */</span></span><br><span class="line">    sentinelRedisInstance *ri;</span><br><span class="line">    <span class="type">char</span> *master_ip = c-&gt;argv[<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">    <span class="type">int</span> master_port = atoi(c-&gt;argv[<span class="number">3</span>]-&gt;ptr);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> req_epoch = strtoull(c-&gt;argv[<span class="number">4</span>]-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="type">char</span> *req_runid = c-&gt;argv[<span class="number">5</span>]-&gt;ptr;</span><br><span class="line">    <span class="type">int</span> isdown = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *leader = <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> leader_epoch = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    ri = sentinelGetMasterByAddress(master_ip, master_port);</span><br><span class="line">    <span class="keyword">if</span> (ri) &#123;</span><br><span class="line">        isdown = ri-&gt;flags &amp; SRI_S_DOWN;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否是投票请求</span></span><br><span class="line">        <span class="keyword">if</span> (req_runid[<span class="number">0</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查是否已经在当前配置纪元中投过票</span></span><br><span class="line">            <span class="keyword">if</span> (req_epoch &gt; sentinel.current_epoch) &#123;</span><br><span class="line">                <span class="comment">// 更新自己的配置纪元</span></span><br><span class="line">                sentinel.current_epoch = req_epoch;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果我们觉得主节点下线了，且在这个epoch还没投过票，则投票</span></span><br><span class="line">            <span class="keyword">if</span> (isdown &amp;&amp; sentinel.current_epoch == req_epoch &amp;&amp;</span><br><span class="line">                sentinel.leader_epoch &lt; req_epoch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 记录投票信息</span></span><br><span class="line">                sentinel.leader_epoch = req_epoch;</span><br><span class="line">                sentinel.leader = sdsnew(req_runid);</span><br><span class="line">                leader = req_runid;</span><br><span class="line">                leader_epoch = req_epoch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回投票结果</span></span><br><span class="line">    addReplyMultiBulkLen(c,<span class="number">3</span>);</span><br><span class="line">    addReplyLongLong(c, isdown);</span><br><span class="line">    addReplyBulkCString(c, leader);</span><br><span class="line">    addReplyLongLong(c, leader_epoch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③、候选者收到投票后会统计自己的得票数，如果获得了集群中超过半数节点的投票，它就会当选为领导者。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sentinel.c中的sentinelReceiveVoteFromSentinel函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelReceiveVoteFromSentinel</span><span class="params">(redisAsyncContext *c, <span class="type">void</span> *reply, <span class="type">void</span> *privdata)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *sentinel = privdata;</span><br><span class="line">    sentinelRedisInstance *master = sentinel-&gt;master;</span><br><span class="line">    redisReply *r = reply;</span><br><span class="line">    <span class="type">char</span> *leader = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理回复</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; r-&gt;elements == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析回复中的leader信息</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;element[<span class="number">1</span>]-&gt;type == REDIS_REPLY_STRING)</span><br><span class="line">            leader = r-&gt;element[<span class="number">1</span>]-&gt;str;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否投给了我们</span></span><br><span class="line">        <span class="keyword">if</span> (leader &amp;&amp; <span class="built_in">strcmp</span>(leader, sentinelGetMyRunID()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录获得一票</span></span><br><span class="line">            dictAdd(master-&gt;sentinels_voted, sdsnew(sentinel-&gt;runid), sentinel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否获得多数票</span></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;failover_state == SENTINEL_FAILOVER_STATE_SELECT_LEADER) &#123;</span><br><span class="line">        <span class="type">int</span> voters = dictSize(master-&gt;sentinels) + <span class="number">1</span>; <span class="comment">// +1是因为包括自己</span></span><br><span class="line">        <span class="type">int</span> votes = dictSize(master-&gt;sentinels_voted) + <span class="number">1</span>; <span class="comment">// 自己也算一票</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果获得多数票(大于一半)</span></span><br><span class="line">        <span class="keyword">if</span> (votes &gt;= voters/<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 成为领导者，开始执行故障转移</span></span><br><span class="line">            sentinelEvent(LL_WARNING, <span class="string">&quot;+elected-leader&quot;</span>, master, <span class="string">&quot;%@&quot;</span>);</span><br><span class="line">            master-&gt;failover_state = SENTINEL_FAILOVER_STATE_FAILOVER_IN_PROGRESS;</span><br><span class="line">            sentinelFailoverSelectSlave(master);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④、如果没有哨兵在这一轮投票中获得超过半数的选票，这次选举就会失败，然后进行下一轮的选举。为了防止无限制的选举失败，每个哨兵都会有一个选举超时时间，且是随机的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sentinel.c中的sentinelFailoverSelectLeader函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverSelectLeader</span><span class="params">(sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查选举是否超时</span></span><br><span class="line">    <span class="type">mstime_t</span> election_timeout = SENTINEL_ELECTION_TIMEOUT * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mstime() - master-&gt;failover_start_time &gt; election_timeout) &#123;</span><br><span class="line">        <span class="comment">// 选举超时，重置状态</span></span><br><span class="line">        sentinelEvent(LL_WARNING, <span class="string">&quot;-failover-abort-timeout&quot;</span>, master, <span class="string">&quot;%@&quot;</span>);</span><br><span class="line">        sentinelAbortFailover(master);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他选举逻辑 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有足够票数且未超时，则继续等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 SENTINEL_ELECTION_TIMEOUT_MIN 通常为 0，SENTINEL_ELECTION_TIMEOUT_MAX 通常为 2000 毫秒。这样每个哨兵会在 0-2 秒的随机时间后开始选举，减少选举冲突。</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://hoverzheng.github.io/post/technology-blog/blockchain/raft%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A33--%E9%80%89%E4%B8%BB/">Raft算法的选主过程详解</a></p>
<h3 id="23-新的主节点是怎样被挑选出来的？"><a href="#23-新的主节点是怎样被挑选出来的？" class="headerlink" title="23.新的主节点是怎样被挑选出来的？"></a>23.新的主节点是怎样被挑选出来的？</h3><p>哨兵在挑选新的主节点时，非常精细化。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017200511.png" alt="20251017200511"><br>三分恶面渣逆袭：新主节点的挑选过程</p>
<p>首先，哨兵会对所有从节点进行一轮基础筛选，排除那些不满足基本条件的节点。比如说已下线的节点、网络连接不稳定的节点，以及优先级设为 0 明确不参与挑选的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一轮筛选：排除不满足基本条件的从节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numslaves; i++) &#123;</span><br><span class="line">    sentinelRedisInstance *slave = slaves[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排除已下线的从节点</span></span><br><span class="line">    <span class="keyword">if</span> (slave-&gt;flags &amp; (SRI_S_DOWN|SRI_O_DOWN)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 排除断开连接的从节点</span></span><br><span class="line">    <span class="keyword">if</span> (slave-&gt;link-&gt;disconnected) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 排除近期（5秒内）断过连的从节点</span></span><br><span class="line">    <span class="keyword">if</span> (mstime() - slave-&gt;link-&gt;last_avail_time &gt; <span class="number">5000</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 排除未建立主从复制的节点</span></span><br><span class="line">    <span class="keyword">if</span> (slave-&gt;slave_priority == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到第一个满足条件的从节点</span></span><br><span class="line">    selected = i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，哨兵会对剩下的从节点进行排序，选出最合适的主节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sentinel.c中的compareSlaves函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareSlaves</span><span class="params">(sentinelRedisInstance *a, sentinelRedisInstance *b)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 首先比较用户设置的优先级，值越小优先级越高</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;slave_priority != b-&gt;slave_priority)</span><br><span class="line">        <span class="keyword">return</span> (a-&gt;slave_priority &lt; b-&gt;slave_priority) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 2. 如果优先级相同，比较复制偏移量，偏移量越大数据越新</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;slave_repl_offset &gt; b-&gt;slave_repl_offset) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;slave_repl_offset &lt; b-&gt;slave_repl_offset) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 如果复制偏移量也相同，比较运行ID的字典序</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(a-&gt;runid, b-&gt;runid) &lt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序的标准有三个：</p>
<p>①、<strong>从节点优先级：</strong> slave-priority 的值越小优先级越高，优先级为 0 的从节点不会被选中。</p>
<p>②、<strong>复制偏移量：</strong> 偏移量越大意味着从节点的数据越新，复制的越完整。</p>
<p>③、<strong>运行 ID：</strong> 如果优先级和偏移量都相同，就比较运行 ID 的字典序，字典序小的优先。</p>
<p>选出新主节点后，哨兵会向其发送 <code>SLAVEOF NO ONE</code> 命令将其提升为主节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sentinel.c中的sentinelFailoverPromoteSlave函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverPromoteSlave</span><span class="params">(sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 选择最佳从节点的逻辑 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向选中的从节点发送SLAVEOF NO ONE命令，使其成为主节点</span></span><br><span class="line">    retval = redisAsyncCommand(slave-&gt;link-&gt;cc,</span><br><span class="line">        sentinelReceivePromotionResponseFromSlave, master,</span><br><span class="line">        <span class="string">&quot;SLAVEOF NO ONE&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    master-&gt;promoted_slave = slave;</span><br><span class="line">    slave-&gt;flags |= SRI_PROMOTED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录日志</span></span><br><span class="line">    sentinelEvent(LL_WARNING, <span class="string">&quot;+promoted-slave&quot;</span>, slave, <span class="string">&quot;%@&quot;</span>);</span><br><span class="line">    sentinelEvent(LL_WARNING, <span class="string">&quot;+failover-state-wait-promotion&quot;</span>, master, <span class="string">&quot;%@&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，哨兵会等待新主节点的角色转换完成，通过发送 INFO 命令检查其角色是否已变为 master 来确认。确认成功后，会更新所有从节点的复制目标，指向新的主节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF new-master-ip new-master-port</span><br></pre></td></tr></table></figure>

<h3 id="24-Redis集群了解吗？"><a href="#24-Redis集群了解吗？" class="headerlink" title="24.Redis集群了解吗？"></a>24.Redis集群了解吗？</h3><p>主从复制实现了读写分离和数据备份，哨兵机制实现了主节点故障时自动进行故障转移。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201053.png" alt="20251017201053"><br>三分恶面渣逆袭：Redis集群示意图</p>
<p>集群架构是对前两种方案的进一步扩展和完善，通过数据分片解决 Redis 单机内存大小的限制，当用户基数从百万增长到千万级别时，我们只需简单地向集群中添加节点，就能轻松应对不断增长的数据量和访问压力。</p>
<p>比如说我们可以将单实例模式下的数据平均分为 5 份，然后启动 5 个 Redis 实例，每个实例保存 5G 的数据，从而实现集群化。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201245.png" alt="20251017201245"><br>极客时间：切片集群架构图</p>
<h3 id="25-请详细说一说Redis-Cluster？（补充）"><a href="#25-请详细说一说Redis-Cluster？（补充）" class="headerlink" title="25.请详细说一说Redis Cluster？（补充）"></a>25.请详细说一说Redis Cluster？（补充）</h3><p>Redis Cluster 是 Redis 官方提供的一种分布式集群解决方案。其核心理念是去中心化，采用 P2P 模式，没有中心节点的概念。每个节点都保存着数据和整个集群的状态，节点之间通过 gossip 协议交换信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201313.png" alt="20251017201313"><br>Rajat Pachauri：Redis Cluster</p>
<p>在数据分片方面，Redis Cluster 使用哈希槽机制将整个集群划分为 16384 个单元。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201418.png" alt="20251017201418"><br>aditya goel：哈希槽分片</p>
<p>例如，如果我们有 4 个 Redis 实例，那么每个实例会负责 4000 多个哈希槽。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201440.png" alt="20251017201440"><br>Rajat Pachauri：分片结果</p>
<p>在计算哈希槽编号时，Redis Cluster 会通过 CRC16 算法先计算出键的哈希值，再对这个哈希值进行取模运算，得到一个 0 到 16383 之间的整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot = CRC16(key) mod <span class="number">16384</span></span><br></pre></td></tr></table></figure>

<p>这种方式可以将数据均匀地分布到各个节点上，避免数据倾斜的问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201504.png" alt="20251017201504"><br>三分恶面渣逆袭：槽</p>
<p>当需要存储或查询一个键值对时，Redis Cluster 会先计算这个键的哈希槽编号，然后根据哈希槽编号找到对应的节点进行操作。</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://adityagoel123.medium.com/scalability-ha-with-redis-cluster-3d6499084550">Redis Cluster</a></p>
<h3 id="26-集群中数据如何分区？"><a href="#26-集群中数据如何分区？" class="headerlink" title="26.集群中数据如何分区？"></a>26.集群中数据如何分区？</h3><p>常见的数据分区有三种：节点取余、一致性哈希和哈希槽。</p>
<p>节点取余分区简单明了，通过计算键的哈希值，然后对节点数量取余，结果就是目标节点的索引。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_node = hash(key) % N  <span class="comment">// N为节点数量</span></span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201546.png" alt="20251017201546"><br>三分恶面渣逆袭：节点取余分区</p>
<p>缺点是增加一个新节点后，节点数量从 N 变为 N+1，几乎所有的取余结果都会改变，导致大部分缓存失效。</p>
<p>为了解决节点变化导致的大规模数据迁移问题，一致性哈希分区出现了：它将整个哈希值空间想象成一个环，节点和数据都映射到这个环上。数据被分配到顺时针方向上遇到的第一个节点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017201613.png" alt="20251017201613"><br>三分恶面渣逆袭：一致性哈希分区</p>
<p>这种设计的巧妙之处在于，当节点数量变化时，只有部分数据需要重新分配。比如说我们从 5 个节点扩容到 8 个节点，理论上只有约 3&#x2F;8 的数据需要迁移，大大减轻了扩容时的系统压力。</p>
<p>但一致性哈希仍然有一个问题：数据分布不均匀。比如说在上面的例子中，节点 1 和节点 2 的数据量差不多，但节点 3 的数据量却远远小于它们。</p>
<p>Redis Cluster 的哈希槽分区在一致性哈希和节点取余的基础上，做了一些改进。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017202156.png" alt="20251017202156"><br>Dan Palmer：哈希槽</p>
<p>它将整个哈希值空间划分为 16384 个槽位，每个节点负责一部分槽，数据通过 CRC16 算法计算后对 16384 取模，确定它属于哪个槽。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot = CRC16(key) % <span class="number">16384</span></span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017202216.png" alt="20251017202216"><br>Dan Palmer：确定槽</p>
<p>假设系统中有 4 个节点，为其分配了 16 个槽(0-15)；</p>
<ul>
<li>槽 0-3 位于节点 node1；</li>
<li>槽 4-7 位于节点 node2；</li>
<li>槽 8-11 位于节点 node3；</li>
<li>槽 12-15 位于节点 node4。</li>
</ul>
<p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如将槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>，数据在节点上的分布仍然较为均衡。</p>
<p>如果此时增加 node5，也只需要将一部分槽分配给 node5 即可，比如说将槽 3、槽 7、槽 11、槽 15 迁移给 node5，节点上的其他槽位保留。</p>
<p>因为槽的个数刚好是 2 的 14 次方，和 HashMap 中数组的长度必须是 2 的幂次方有着异曲同工之妙。它能保证扩容后，大部分数据停留在扩容前的位置，只有少部分数据需要迁移到新的槽上。</p>
<h3 id="27-能说说-Redis-集群的原理吗？"><a href="#27-能说说-Redis-集群的原理吗？" class="headerlink" title="27.能说说 Redis 集群的原理吗？"></a>27.能说说 Redis 集群的原理吗？</h3><p>Redis 集群的搭建始于节点的添加和握手。每个节点通过设置 <code>cluster-enabled yes</code> 来开启集群模式。然后通过 <code>CLUSTER MEET</code> 进行握手，将对方添加到各自的节点列表中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017202942.png" alt="20251017202942"><br>三分恶面渣逆袭：节点和握手</p>
<p>这个过程设计的非常精巧：节点 A 发送 MEET 消息，节点 B 回复 PONG 并发送 PING，节点 A 回复 PONG，于是双向的通信链路就建立完成了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203115.png" alt="20251017203115"><br>happen：cluster meet</p>
<p>有趣的是，由于采用了 Gossip 协议，我们不需要让每对节点都执行握手。在一个多节点集群的部署中，仅需要让第一个节点与其他节点握手，其余节点就能通过信息传播自动发现并连接彼此。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203224.png" alt="20251017203224"><br>程序员历小冰：Gossip</p>
<p>握手完成后，可以通过 <code>CLUSTER ADDSLOTS</code> 命令为主节点分配哈希槽。当 16384 个槽全部分配完毕，集群正式进入就绪状态。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203323.png" alt="20251017203323"><br>三分恶面渣逆袭：分配槽</p>
<p>故障检测和恢复是保障 Redis 集群高可用的关键。每秒钟，节点会向一定数量的随机节点发送 PING 消息，当发现某个节点长时间未响应 PING 消息，就会将其标记为主观下线。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203335.png" alt="20251017203335"><br>三分恶面渣逆袭：主观下线</p>
<p>当半数以上的主节点都认为某节点主观下线时，这个节点就会被标记为“客观下线”。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203348.png" alt="20251017203348"><br>三分恶面渣逆袭：主观下线和客观下线</p>
<p>如果下线的是主节点，它的从节点之一将被选举为新的主节点，接管原主节点负责的哈希槽。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203404.png" alt="20251017203404"><br>三分恶面渣逆袭：选举投票</p>
<h4 id="部署-Redis-集群至少需要几个物理节点？"><a href="#部署-Redis-集群至少需要几个物理节点？" class="headerlink" title="部署 Redis 集群至少需要几个物理节点？"></a>部署 Redis 集群至少需要几个物理节点？</h4><p>部署一个生产环境可用的 Redis 集群，从技术角度来说，至少需要 3 个物理节点。</p>
<p>这个最小节点数的设定并非 Redis 技术上的硬性要求，而是基于高可用原则的实践考量。</p>
<p>从实践角度看，最经典的 Redis 集群配置是 3 主 3 从，共 6 个 Redis 实例。考虑到需要 3 个主节点和 3 个从节点，并且每对主从不能在同一物理机上，那么至少需要 3 个物理节点，每个物理节点上运行 1 个主节点和另一个主节点的从节点。</p>
<ul>
<li>物理节点1：主节点A + 从节点B’</li>
<li>物理节点2：主节点B + 从节点C’</li>
<li>物理节点3：主节点C + 从节点A’</li>
</ul>
<p>这种交错部署方式可以确保任何一个物理节点故障时，最多只影响一个主节点和一个不同主节点的从节点。</p>
<h3 id="28-说说Redis集群的动态伸缩？"><a href="#28-说说Redis集群的动态伸缩？" class="headerlink" title="28.说说Redis集群的动态伸缩？"></a>28.说说Redis集群的动态伸缩？</h3><p>Redis 集群动态伸缩的核心机制是通过重新分配哈希槽实现的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203559.png" alt="20251017203559"><br>三分恶面渣逆袭：集群的伸缩</p>
<p>当需要扩容时，首先通过 <code>CLUSTER MEET</code> 命令将新节点加入集群；然后使用 reshard 命令将部分哈希槽重新分配给新节点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017203838.png" alt="20251017203838"><br>三分恶面渣逆袭：扩容实例</p>
<p>-—这部分面试中可以不背start—-</p>
<p>准备新的节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># redis.conf</span><br><span class="line">port 6382</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6382.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>然后启动新的节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/redis-6382.conf</span><br></pre></td></tr></table></figure>

<p>接下来，使用 <code>CLUSTER MEET</code> 命令将新节点加入集群：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 cluster meet 127.0.0.1 6382</span><br></pre></td></tr></table></figure>

<p>检查新节点是否加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 cluster nodes</span><br></pre></td></tr></table></figure>

<p>然后，重新分配哈希槽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 127.0.0.1:6379</span><br></pre></td></tr></table></figure>

<p>在提示中输入要迁移的哈希槽范围。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 输入要迁移的槽数量，比如 4096（平均分配的话，16384/4=4096）。</span><br><span class="line">How many slots do you want to move (from 16384 total slots)? 4096</span><br><span class="line"># 输入 6382 节点的 ID（可通过 cluster nodes 命令查到）。</span><br><span class="line">What is the receiving node ID? &lt;6382的节点ID&gt;</span><br><span class="line"># 输入 all（表示从所有节点平均迁移）。</span><br><span class="line">Source node IDs? all</span><br><span class="line"># 输入 yes（表示确认迁移）。</span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure>

<p>检查检查槽分配情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 cluster slots</span><br></pre></td></tr></table></figure>

<p>验证集群的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6382 cluster info</span><br></pre></td></tr></table></figure>

<p>也可以直接一步到位：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 127.0.0.1:6379 --cluster-from all --cluster-to &lt;6382的节点ID&gt; --cluster-slots 4096 --cluster-yes</span><br></pre></td></tr></table></figure>

<p>-—这部分面试中可以不背end—-</p>
<p>缩容则是反向操作：先将要下线节点负责的所有槽迁移到其他节点，再通过 <code>CLUSTER FORGET</code> 命令将节点从集群中移除。</p>
<p>整个伸缩过程支持在线操作，无需停机，得益于 Redis 集群的 MOVED 和 ASK 重定向机制。当客户端访问的键不在当前节点时，会收到重定向响应，指引它连接到正确的节点。</p>
<h4 id="MOVED-和-ASK-重定向的区别？"><a href="#MOVED-和-ASK-重定向的区别？" class="headerlink" title="MOVED 和 ASK 重定向的区别？"></a>MOVED 和 ASK 重定向的区别？</h4><p>MOVED 重定向反映的是哈希槽的永久性变更。当客户端请求一个键，但键所在的槽不在当前节点时，节点会返回 MOVED 响应，告诉客户端这个槽现在归属于哪个节点。通常发生在集群完成重新分片后，槽的分配关系已经稳定。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017204303.png" alt="20251017204303"><br>Aaron Zhu：MOVED 重定向</p>
<p>比如说某个槽从节点 A 移动到节点 B 后，如果客户端仍向节点 A 请求该槽中的键，会收到 MOVED 响应，提示应该连接节点 B。</p>
<p>ASK 重定向出现在槽迁移过程中，表示请求的键可能已经从源节点迁移到了目标节点，但迁移尚未完成。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251017204312.png" alt="20251017204312"><br>Aaron Zhu：ASK 重定向</p>
<h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><h3 id="29-🌟什么是缓存击穿？"><a href="#29-🌟什么是缓存击穿？" class="headerlink" title="29.🌟什么是缓存击穿？"></a>29.🌟什么是缓存击穿？</h3><p>缓存击穿是指某个热点数据缓存过期时，大量请求就会穿透缓存直接访问数据库，导致数据库瞬间承受的压力巨大。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022093956.png" alt="20251022093956"><br>fengkui.net：缓存击穿</p>
<p>解决缓存击穿有两种常用的策略：</p>
<p>第一种是加互斥锁。当缓存失效时，第一个访问的线程先获取锁并负责重建缓存，其他线程等待或重试。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022094156.png" alt="20251022094156"><br>三分恶面渣逆袭：加锁更新</p>
<p>这种策略虽然会导致部分请求延迟，但实现起来相对简单。在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，我们就使用了 Redisson 的分布式锁来确保只有一个服务实例能更新缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;product::&quot;</span> + productId;</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock::&quot;</span> + productId);</span><br><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = database.queryProductById(productId);</span><br><span class="line">            cache.set(cacheKey, result, <span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 设置缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是永不过期策略。缓存项本身不设置过期时间，也就是永不过期，但在缓存值中维护一个逻辑过期时间。当缓存逻辑上过期时，返回旧值的同时，异步启动一个线程去更新缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">CacheItem</span> <span class="variable">item</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓存不存在，同步加载</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> db.query(key);</span><br><span class="line">        cache.set(key, <span class="keyword">new</span> <span class="title class_">CacheItem</span>(data, System.currentTimeMillis() + expireTime));</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.isLogicalExpired()) &#123;</span><br><span class="line">        <span class="comment">// 逻辑过期，异步刷新</span></span><br><span class="line">        asyncRefresh(key);</span><br><span class="line">        <span class="comment">// 返回旧数据</span></span><br><span class="line">        <span class="keyword">return</span> item.getData();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> item.getData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步刷新缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">asyncRefresh</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">    threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 重新查询数据库</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newData</span> <span class="operator">=</span> db.query(key);</span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        cache.set(key, <span class="keyword">new</span> <span class="title class_">CacheItem</span>(newData, System.currentTimeMillis() + expireTime));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>memo：2025 年 5 月 18 日修改至此，今天给<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">球友改简历时</a>，碰到一个西北工业大学的球友，这又是一所 985 院校，希望这个社群能把所有的 985 院校集齐，也希望去帮助到更多院校的同学，希望都能拿到一个满意的 offer。</p>
<h4 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h4><p>缓存穿透是指查询的数据在缓存中没有命中，因为数据压根不存在，所以请求会直接落到数据库上。如果这种查询非常频繁，就会给数据库造成很大的压力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022094922.png" alt="20251022094922"><br>fengkui.net：缓存穿透</p>
<p>缓存击穿是因为单个热点数据缓存失效导致的，而缓存穿透是因为查询的数据不存在，原因可能是自身的业务代码有问题，或者是恶意攻击造成的，比如爬虫。</p>
<p>常用的解决方案有两种：第一种是布隆过滤器，它是一种空间效率很高的数据结构，可以用来判断一个元素是否在集合中。</p>
<p>我们可以将所有可能存在的数据哈希到布隆过滤器中，查询时先检查布隆过滤器，如果布隆过滤器认为该数据不存在，就直接返回空；否则再去查询缓存，这样就可以避免无效的缓存查询。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022095153.png" alt="20251022095153"><br>酒剑仙：布隆过滤器解决缓存穿透</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存中不存在该key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheResult</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (cacheResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResult;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 布隆过滤器判断key是否可能存在</span></span><br><span class="line">    <span class="keyword">if</span> (!bloomFilter.mightContain(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 一定不存在，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可能存在，查询数据库</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dbResult</span> <span class="operator">=</span> db.query(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将结果放入缓存，包括空值</span></span><br><span class="line">    cache.set(key, dbResult != <span class="literal">null</span> ? dbResult : <span class="string">&quot;&quot;</span>, expireTime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dbResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布隆过滤器存在误判，即可能会认为某个数据存在，但实际上并不存在。但绝不会漏判，即如果布隆过滤器认为某个数据不存在，那它一定不存在。因此它可以有效拦截不存在的数据查询，减轻数据库压力。</p>
<p>第二种是<strong>缓存空值</strong>。对于不存在的数据，我们将空值写入缓存，并设置一个合理的过期时间。这样下次相同的查询就能直接从缓存返回，而不再访问数据库。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-288af5a2-ae5a-427a-95e9-b4a658b01386.png" alt="三分恶面渣逆袭：缓存空值/默认值"></p>
<p>三分恶面渣逆袭：缓存空值&#x2F;默认值</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheResult</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存命中，包括空值</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 特殊值表示空结果</span></span><br><span class="line">        <span class="keyword">if</span> (cacheResult.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheResult;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存未命中，查询数据库</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dbResult</span> <span class="operator">=</span> db.query(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入缓存，空值也缓存，但设置较短的过期时间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expireTime</span> <span class="operator">=</span> dbResult == <span class="literal">null</span> ? EMPTY_EXPIRE_TIME : NORMAL_EXPIRE_TIME;</span><br><span class="line">    cache.set(key, dbResult != <span class="literal">null</span> ? dbResult : <span class="string">&quot;&quot;</span>, expireTime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dbResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存空值的方法实现起来比较简单，但需要给空值设置一个合理的过期时间，以免数据库中新增了这些数据后，缓存仍然返回空值。</p>
<p>在实际的项目当中，还需要在接口层面做一些处理，比如说对参数进行校验，拦截明显不合理的请求；或者对疑似攻击的 IP 进行限流和封禁。</p>
<h4 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h4><p>缓存雪崩是指在某一时间段，大量缓存同时失效或者缓存服务突然宕机了，导致大量请求直接涌向数据库，导致数据库压力剧增，甚至引发系统崩溃的现象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022100013.png" alt="20251022100013"><br>三分恶面渣逆袭：缓存雪崩</p>
<p>缓存击穿是单个热点数据失效导致的，缓存穿透是因为请求不存在的数据，而缓存雪崩是因为大范围的缓存失效。</p>
<p>缓存雪崩主要有三种成因和应对策略。</p>
<p>第一种，大量缓存同时过期，解决方法是添加随机过期时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCache</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">    <span class="comment">// 基础过期时间，例如30分钟</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">baseExpireSeconds</span> <span class="operator">=</span> <span class="number">1800</span>;</span><br><span class="line">    <span class="comment">// 增加随机过期时间，范围0-300秒</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomSeconds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 最终过期时间为基础时间加随机时间</span></span><br><span class="line">    cache.set(key, value, baseExpireSeconds + randomSeconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，缓存服务崩溃，解决方法是使用高可用的缓存集群。</p>
<p>比如说使用 Redis Cluster 构建多节点集群，确保数据在多个节点上有备份，并且支持自动故障转移。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022101036.png" alt="20251022101036"><br>Rajat Pachauri：Redis Cluster</p>
<p>对于一些高频关键数据，可以配置本地缓存作为二级缓存，缓解 Redis 的压力。在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，我们就采用了多级缓存的策略，其中就包括使用本地缓存 Caffeine 来作为二级缓存，当 Redis 出现问题时自动切换到本地缓存。</p>
<p>这个过程称为“缓存降级”，保证 Redis 发生故障时，系统能够继续提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, UserPermissions&gt; permissionsCache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1000</span>)</span><br><span class="line">    .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build(<span class="built_in">this</span>::loadPermissionsFromRedis);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> UserPermissions <span class="title function_">loadPermissionsFromRedis</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisClient.getPermissions(userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// Redis 异常处理，尝试从本地缓存获取</span></span><br><span class="line">        <span class="keyword">return</span> permissionsCache.getIfPresent(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种，缓存服务正常但并发请求量超过了缓存服务的承载能力，这种情况下可以采用限流和降级措施。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试从缓存获取数据</span></span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 缓存服务异常，触发熔断</span></span><br><span class="line">        <span class="keyword">if</span> (circuitBreaker.shouldTrip()) &#123;</span><br><span class="line">            <span class="comment">// 直接从数据库获取，并进入降级模式</span></span><br><span class="line">            circuitBreaker.trip();</span><br><span class="line">            <span class="keyword">return</span> getFromDbDirectly(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getFromDbDirectly</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 实施限流保护</span></span><br><span class="line">    <span class="keyword">if</span> (!rateLimit.tryAcquire()) &#123;</span><br><span class="line">        <span class="comment">// 超过限流阈值，返回兜底数据或默认值</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultValue(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 限流通过，从数据库查询</span></span><br><span class="line">    <span class="keyword">return</span> db.query(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 22 暑期实习一面面试原题：缓存雪崩，如何解决</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手面经同学 7 Java 后端技术一面面试原题：说一下 缓存穿透、缓存击穿、缓存雪崩</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 7 Java 后端实习一面的原题：Redis 宕机会不会对权限系统有影响？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 7 Java 后端实习一面的原题：说一下 Redis 雪崩、穿透、击穿等场景的解决方案</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米同学 F 面试原题：缓存常见问题和解决方案（引申到多级缓存），多级缓存（redis，nginx，本地缓存）的实现思路</li>
</ol>
</blockquote>
<h3 id="30-🌟能说说布隆过滤器吗？"><a href="#30-🌟能说说布隆过滤器吗？" class="headerlink" title="30.🌟能说说布隆过滤器吗？"></a>30.🌟能说说布隆过滤器吗？</h3><p>布隆过滤器是一种空间效率极高的概率性数据结构，用于快速判断一个元素是否在一个集合中。它的特点是能够以极小的内存消耗，判断一个元素“一定不在集合中”或“可能在集合中”，常用来解决 Redis 缓存穿透的问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022105702.png" alt="20251022105702"><br>三分恶面渣逆袭：布隆过滤器</p>
<p>-—这部分面试中可以不背start—-</p>
<p>布隆过滤器的核心由一个很长的二进制向量和一系列哈希函数组成。</p>
<ul>
<li>初始化的时候，创建一个长度为 m 的位数组，初始值全为 0，同时选择 k 个不同的哈希函数</li>
<li>当添加一个元素时，用 k 个哈希函数计算出 k 个哈希值，然后对 m 取模，得到 k 个位置，将这些位置的二进制位都设为 1</li>
<li>当需要判断一个元素是否在集合中时，同样用 k 个哈希函数计算出 k 个位置，如果这些位置的二进制位有任何一个为 0，该元素一定不在集合中；如果全部为 1，则该元素可能在集合中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> BitSet bitSet;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bitSetSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numberOfHashFunctions;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">double</span> falsePositiveProbability, <span class="type">int</span> expectedNumberOfElements)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据预期元素数量和期望的误判率，计算最优的位数组大小和哈希函数个数</span></span><br><span class="line">        <span class="built_in">this</span>.bitSetSize = calculateOptimalBitSetSize(expectedNumberOfElements, falsePositiveProbability);</span><br><span class="line">        <span class="built_in">this</span>.numberOfHashFunctions = calculateOptimalNumberOfHashFunctions(expectedNumberOfElements, bitSetSize);</span><br><span class="line">        <span class="built_in">this</span>.bitSet = <span class="keyword">new</span> <span class="title class_">BitSet</span>(bitSetSize);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashes = createHashes(element);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> hash : hashes) &#123;</span><br><span class="line">            bitSet.set(Math.abs(hash % bitSetSize), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mightContain</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashes = createHashes(element);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> hash : hashes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bitSet.get(Math.abs(hash % bitSetSize))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果任何一位为0，元素一定不存在</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 所有位都为1，元素可能存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他辅助方法，如计算哈希值，计算最优参数等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-—这部分面试中可以不背end—-</p>
<h4 id="布隆过滤器存在误判吗？"><a href="#布隆过滤器存在误判吗？" class="headerlink" title="布隆过滤器存在误判吗？"></a>布隆过滤器存在误判吗？</h4><p>是的，布隆过滤器存在误判。它可能会错误地认为某个元素在集合中，而元素实际上并不在集合中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022105811.png" alt="20251022105811"><br>勇哥：布隆过滤器</p>
<p>但如果布隆过滤器认为某个元素不存在于集合中，那么它一定不存在。</p>
<p>误判产生的原因是因为哈希冲突。在布隆过滤器中，多个不同的元素可能映射到相同的位置。随着向布隆过滤器中添加的元素越来越多，位数组中的 1 也越来越多，发生哈希冲突的概率随之增加，误判率也就随之上升。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110143.png" alt="20251022110143"><br>勇哥：布隆过滤器的误判</p>
<p>误判率取决于以下 3 个因素：</p>
<ol>
<li>位数组的大小（m）：m 决定了可以存储的标志位数量。如果位数组过小，那么哈希碰撞的几率就会增加，从而导致更高的误判率。</li>
<li>哈希函数的数量（k）：k 决定了每个元素在位数组中标记的位数。哈希函数越多，碰撞的概率也会相应变化。如果哈希函数太少，过滤器很快会变得不精确；如果太多，误判率也会升高，效率下降。</li>
<li>存入的元素数量（n）：n 越多，哈希碰撞的几率越大，从而导致更高的误判率。</li>
</ol>
<p>要降低误判率，可以增加位数组的大小或者减少插入的元素数量。</p>
<p>要彻底解决布隆过滤器的误判问题，可以在布隆过滤器返回”可能存在”时，再通过数据库进行二次确认。</p>
<h4 id="布隆过滤器支持删除吗？"><a href="#布隆过滤器支持删除吗？" class="headerlink" title="布隆过滤器支持删除吗？"></a>布隆过滤器支持删除吗？</h4><p>布隆过滤器并不支持删除操作，这是它的一个重要限制。</p>
<p>当我们添加一个元素时，会将位数组中的 k 个位置设置为 1。由于多个不同元素可能共享相同的位，如果我们尝试删除一个元素，将其对应的 k 个位重置为 0，可能会错误地影响到其他元素的判断结果。</p>
<p>例如，元素 A 和元素 B 都将位置 5 设为 1，如果删除元素 A 时将位置 5 重置为 0，那么对元素 B 的查询就会产生错误的”不存在”结果，这违背了布隆过滤器的基本特性。</p>
<p>如果想要实现删除操作，可以使用计数布隆过滤器，它在每个位置上存储一个计数器而不是单一的位。这样可以通过减少计数器的值来实现删除操作，但会增加内存开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingBloomFilter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counters;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hashFunctions;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountingBloomFilter</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> hashFunctions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.hashFunctions = hashFunctions;</span><br><span class="line">        <span class="built_in">this</span>.counters = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] positions = getHashPositions(element);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> position : positions) &#123;</span><br><span class="line">            counters[position]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] positions = getHashPositions(element);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> position : positions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counters[position] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                counters[position]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mightContain</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] positions = getHashPositions(element);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> position : positions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counters[position] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getHashPositions(T element) &#123;</span><br><span class="line">        <span class="comment">// 计算哈希位置的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么不能用哈希表而是用布隆过滤器？"><a href="#为什么不能用哈希表而是用布隆过滤器？" class="headerlink" title="为什么不能用哈希表而是用布隆过滤器？"></a>为什么不能用哈希表而是用布隆过滤器？</h4><p>布隆过滤器最突出的优势是内存效率。</p>
<p>假如我们要判断 10 亿个用户 ID 是否曾经访问过特定页面，使用哈希表至少需要 10G 内存（每个 ID 至少需要8字节），而使用布隆过滤器只需要 1.2G 内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m ≈ -n*ln(p)/ln(2)² ≈ -10⁹*ln(0.01)/ln(2)² ≈ 9.6 billion bits ≈ 1.2GB</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 7 Java 后端实习一面的原题：有了解过布隆过滤器吗？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的TP联洲同学 5 Java 后端一面的原题：布隆过滤器原理，这种方式下5%的错误率可接受？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团同学 9 一面面试原题：布隆过滤器？布隆过滤器优点？为什么不能用哈希表要用布隆过滤器？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的理想汽车面经同学 2 一面面试原题：追问：说明一下布隆过滤器</li>
</ol>
</blockquote>
<h3 id="31-🌟如何保证缓存和数据库的数据⼀致性？"><a href="#31-🌟如何保证缓存和数据库的数据⼀致性？" class="headerlink" title="31.🌟如何保证缓存和数据库的数据⼀致性？"></a>31.🌟如何保证缓存和数据库的数据⼀致性？</h3><p>在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，对于文章标签这种允许短暂不一致的数据，我会采用 <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">Cache Aside</a> + TTL 过期机制来保证缓存和数据库的一致性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110356.png" alt="20251022110356"><br>技术派教程：MySQL 和 Redis 一致性</p>
<p>具体做法是读取时先查 Redis，未命中再查 MySQL，同时为缓存设置一个合理的过期时间；更新时先更新 MySQL，再删除 Redis。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取逻辑</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 先查缓存</span></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">user</span> <span class="operator">=</span> cache.get(<span class="string">&quot;user:&quot;</span> + userId);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存未命中，查数据库</span></span><br><span class="line">    user = database.selectUser(userId);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 放入缓存，设置合理的过期时间</span></span><br><span class="line">        cache.set(<span class="string">&quot;user:&quot;</span> + userId, user, <span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(UserInfo user)</span> &#123;</span><br><span class="line">    <span class="comment">// 先更新数据库</span></span><br><span class="line">    database.updateUser(user);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除缓存</span></span><br><span class="line">    cache.delete(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式简单有效，适用于读多写少的场景。TTL 过期时间也能够保证即使更新操作失败，未能及时删除缓存，过期时间也能确保数据最终一致。</p>
<h4 id="那再来说说为什么要删除缓存而不是更新缓存？"><a href="#那再来说说为什么要删除缓存而不是更新缓存？" class="headerlink" title="那再来说说为什么要删除缓存而不是更新缓存？"></a>那再来说说为什么要删除缓存而不是更新缓存？</h4><p>最初设计缓存策略时，我也考虑过直接更新缓存，但通过实践发现，删除缓存是更优的选择。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110609.png" alt="20251022110609"><br>技术派：更新 Redis 而不是删除 Redis</p>
<p>最主要的原因是在并发环境下，假设我们有两个并发的更新操作，如果采用更新缓存的策略，就可能出现这样的时序问题：</p>
<ul>
<li>操作 A 和操作 B 同时发生，A 先更新 MySQL 将值改为 10，B 后更新 MySQL 将值改为 11。但在缓存更新时，可能 B 先执行将缓存设为 11，然后 A 才执行将缓存设为10。这样就会造成 MySQL 是 11 但 Redis 是 10 的不一致状态。</li>
</ul>
<p>而采用删除策略，无论 A 和 B 谁先删除缓存，后续的读取操作都会从 MySQL 获取最新值。</p>
<p>另外，相对而言，删除缓存的速度比更新缓存的速度快得多。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110559.png" alt="20251022110559"><br>三分恶面渣逆袭：删除缓存和更新缓存</p>
<p>因为删除操作只是简单的 DEL 命令，而更新可能需要重新序列化整个对象再写入缓存。</p>
<h4 id="那再说说为什么要先更新数据库，再删除缓存？"><a href="#那再说说为什么要先更新数据库，再删除缓存？" class="headerlink" title="那再说说为什么要先更新数据库，再删除缓存？"></a>那再说说为什么要先更新数据库，再删除缓存？</h4><p>这个操作顺序的选择也是我在实际项目中踩过坑才深刻理解的。假设我们采用先删缓存再更新数据库的策略，在高并发场景下就可能出现这样的问题：</p>
<ul>
<li>线程 A 要更新用户信息，先删除了缓存</li>
<li>线程 B 恰好此时要读取该用户信息，发现缓存为空，于是查询数据库，此时还是旧值</li>
<li>线程 B 将查到的旧值重新放入缓存</li>
<li>线程 A 完成数据库更新</li>
</ul>
<p>结果就是数据库是新的值，但缓存中还是旧值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110834.png" alt="20251022110834"><br>技术派：先删 Redis 再更新 MySQL</p>
<p>而采用先更新数据库再删缓存的策略，即使出现类似的并发情况，最坏的情况也只是短暂地从缓存中读取到了旧值，但缓存删除后的请求会直接从数据库中获取最新值。</p>
<p>另外，如果先删缓存再更新数据库，当数据库更新失败时，缓存已经被删除了。这会导致短期内所有读请求都会穿透到数据库，对数据库造成额外的压力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022110950.png" alt="20251022110950"><br>三分恶面渣逆袭：先更数据库还是先删缓存</p>
<p>而先更新数据库再删缓存，如果数据库更新失败，缓存保持原状，系统仍然能继续正常提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先更新数据库</span></span><br><span class="line">        database.updateUser(user);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再删除缓存</span></span><br><span class="line">        cache.delete(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DatabaseException e) &#123;</span><br><span class="line">        <span class="comment">// 数据库更新失败，缓存保持原状，系统仍可正常提供服务</span></span><br><span class="line">        log.error(<span class="string">&quot;Database update failed&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CacheException e) &#123;</span><br><span class="line">        <span class="comment">// 缓存删除失败，数据库已更新，数据会在TTL后自动一致</span></span><br><span class="line">        log.warn(<span class="string">&quot;Cache deletion failed, will be eventually consistent&quot;</span>, e);</span><br><span class="line">        <span class="comment">// 可以选择不抛异常，因为有TTL兜底</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="那假如对缓存数据库一致性要求很高，该怎么办呢？"><a href="#那假如对缓存数据库一致性要求很高，该怎么办呢？" class="headerlink" title="那假如对缓存数据库一致性要求很高，该怎么办呢？"></a>那假如对缓存数据库一致性要求很高，该怎么办呢？</h4><p>当业务对缓存与数据库的一致性要求很高时，比如支付系统、库存管理等场景，我会采用多种策略来保证强一致性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111101.png" alt="20251022111101"><br>二哥的 Java 进阶之路：缓存强一致性</p>
<p>第一种，引入消息队列来保证缓存最终被删除，比如说在数据库更新的事务中插入一条本地消息记录，事务提交后异步发送给 MQ 进行缓存删除。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111121.png" alt="20251022111121"><br>三分恶面渣逆袭：消息队列保证key被删除</p>
<p>即使缓存删除失败，消息队列的重试机制也能保证最终一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(UserInfo user)</span> &#123;</span><br><span class="line">    <span class="comment">// 在事务中更新数据库</span></span><br><span class="line">    database.updateUser(user);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在同一事务中记录需要删除的缓存信息</span></span><br><span class="line">    <span class="type">LocalMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalMessage</span>(<span class="string">&quot;CACHE_DELETE&quot;</span>, <span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">    database.insertLocalMessage(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式发布事件，供监听器捕获</span></span><br><span class="line">    eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">UserUpdateEvent</span>(<span class="built_in">this</span>, <span class="string">&quot;user:&quot;</span> + user.getId()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务提交后发送MQ消息</span></span><br><span class="line"><span class="meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendCacheDeleteMessage</span><span class="params">(UserUpdateEvent event)</span> &#123;</span><br><span class="line">    messageQueue.send(<span class="string">&quot;cache-delete-topic&quot;</span>, event.getCacheKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，使用 <a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">Canal</a> 监听 MySQL 的 binlog，在数据更新时，将数据变更记录到消息队列中，消费者消息监听到变更后去删除缓存。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111140.png" alt="20251022111140"><br>三分恶面渣逆袭：数据库订阅+消息队列保证key被删除</p>
<p>这种方案的优势是完全解耦了业务代码和缓存维护逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanalListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheUpdateListener</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@EventHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUserUpdate</span><span class="params">(UserUpdateEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 从binlog事件中提取变更信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> event.getUserId();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送缓存删除消息</span></span><br><span class="line">        <span class="type">CacheDeleteMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheDeleteMessage</span>();</span><br><span class="line">        message.setCacheKey(<span class="string">&quot;user:&quot;</span> + userId);</span><br><span class="line">        messageQueue.send(<span class="string">&quot;cache-delete-topic&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者监听消息队列</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &quot;cache-delete-topic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleCacheDeleteMessage</span><span class="params">(CacheDeleteMessage message)</span> &#123;</span><br><span class="line">    <span class="comment">// 删除缓存</span></span><br><span class="line">    cache.delete(message.getCacheKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，如果说业务比较简单，不需要上消息队列，可以通过延迟双删策略降低缓存和数据库不一致的时间窗口，在第一次删除缓存之后，过一段时间之后，再次尝试删除缓存。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111245.png" alt="20251022111245"><br>三分恶面渣逆袭：延时双删</p>
<p>这种方式主要针对缓存不存在，但写入了脏数据的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(UserInfo user)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次删除缓存，减少不一致时间窗口</span></span><br><span class="line">    cache.delete(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新数据库</span></span><br><span class="line">    database.updateUser(user);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 立即删除缓存</span></span><br><span class="line">    cache.delete(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 延时删除，应对可能的并发读取</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 延时时间根据主从同步延迟调整</span></span><br><span class="line">            cache.delete(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，无论采用哪种策略，最好为缓存设置一个合理的过期时间作为最后的保障。即使所有的主动删除机制都失败了，TTL 也能确保数据最终达到一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据数据的重要程度设置不同的TTL</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCache</span><span class="params">(String key, Object value, DataImportance importance)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ttl;</span><br><span class="line">    <span class="keyword">switch</span> (importance) &#123;</span><br><span class="line">        <span class="keyword">case</span> HIGH:      <span class="comment">// 关键数据，短TTL</span></span><br><span class="line">            ttl = <span class="number">300</span>;  <span class="comment">// 5分钟</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MEDIUM:    <span class="comment">// 一般数据</span></span><br><span class="line">            ttl = <span class="number">1800</span>; <span class="comment">// 30分钟</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LOW:       <span class="comment">// 不太重要的数据</span></span><br><span class="line">            ttl = <span class="number">3600</span>; <span class="comment">// 1小时</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cache.setWithTTL(key, value, ttl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式虽然简单，但能确保即使出现极端情况，数据不一致的影响也是可控的。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为面经同学 8 技术二面面试原题：怎样保证数据的最终一致性？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 23 QQ 后台技术一面面试原题：数据一致性问题</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的微众银行同学 1 Java 后端一面的原题：MySQL 和缓存一致性问题了解吗？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团面经同学 3 Java 后端技术一面面试原题：如何保证 redis 缓存与数据库的一致性，为什么这么设计</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的比亚迪面经同学 12 Java 技术面试原题：怎么解决redis和mysql的缓存一致性问题</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 17 后端技术面试原题：双写一致性怎么解决的</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 9 面试原题：redis的数据和缓存不一致应该处理</li>
</ol>
</blockquote>
<h3 id="32-如何保证本地缓存和分布式缓存的一致？"><a href="#32-如何保证本地缓存和分布式缓存的一致？" class="headerlink" title="32.如何保证本地缓存和分布式缓存的一致？"></a>32.如何保证本地缓存和分布式缓存的一致？</h3><p>在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，为了减轻 Redis 的负载压力，我又追加了一层本地缓存 Caffeine。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111409.png" alt="20251022111409"><br>三分恶面渣逆袭：本地缓存+分布式缓存</p>
<p>为了保证 Caffeine 和 Redis 缓存的一致性，我采用的策略是当数据更新时，通过 Redis 的 pub&#x2F;sub 机制向所有应用实例发送缓存更新通知，收到通知后的实例立即更新或者删除本地缓存。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111527.png" alt="20251022111527"><br>三分恶面渣逆袭：本地缓存&#x2F;分布式缓存保持一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CaffeineCache localCache;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新数据库</span></span><br><span class="line">        database.update(key, value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新分布式缓存</span></span><br><span class="line">        redisTemplate.opsForValue().set(key, value, <span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送缓存更新通知</span></span><br><span class="line">        <span class="type">CacheUpdateMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheUpdateMessage</span>(key, <span class="string">&quot;UPDATE&quot;</span>, value);</span><br><span class="line">        redisTemplate.convertAndSend(<span class="string">&quot;cache-update-channel&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleCacheUpdate</span><span class="params">(CacheUpdateMessage message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;UPDATE&quot;</span>.equals(message.getAction())) &#123;</span><br><span class="line">            localCache.put(message.getKey(), message.getValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;DELETE&quot;</span>.equals(message.getAction())) &#123;</span><br><span class="line">            localCache.invalidate(message.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到消息可能丢失，我还会引入版本号机制作为补充。每次从 Redis 获取数据时添加一个最新的版本号。从本地缓存获取数据前，先检查自己的版本号是否是最新的，如果发现版本落后，就主动从 Redis 中获取最新数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VersionBasedCacheManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Caffeine 构建本地缓存：最多 1000 项，写入后 10 分钟过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cache&lt;String, VersionedData&gt; localCache = Caffeine.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">1000</span>)</span><br><span class="line">        .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存数据，优先使用本地缓存，必要时从 Redis 加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">VersionedData</span> <span class="variable">cached</span> <span class="operator">=</span> localCache.getIfPresent(key); <span class="comment">// 从本地缓存取出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 Redis 获取版本号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">versionStr</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key + <span class="string">&quot;:version&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 Redis 中没找到版本号，说明可能数据已失效，强制刷新</span></span><br><span class="line">        <span class="keyword">if</span> (versionStr == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadAndCache(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">remoteVersion</span> <span class="operator">=</span> Long.parseLong(versionStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果本地没有缓存，或版本落后于 Redis，强制刷新</span></span><br><span class="line">        <span class="keyword">if</span> (cached == <span class="literal">null</span> || cached.getVersion() &lt; remoteVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadAndCache(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 命中本地缓存且版本最新，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> cached.getData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Redis 加载数据和版本，并写入本地缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">loadAndCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="type">String</span> <span class="variable">versionStr</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key + <span class="string">&quot;:version&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">null</span> &amp;&amp; versionStr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">version</span> <span class="operator">=</span> Long.parseLong(versionStr);</span><br><span class="line">            localCache.put(key, <span class="keyword">new</span> <span class="title class_">VersionedData</span>(data, version));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？"><a href="#如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？" class="headerlink" title="如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？"></a>如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？</h4><p>我的思路是将二级缓存抽象成一个统一的组件。设计一个 CacheManager 作为核心入口，提供 get、put、evict 等基本操作，执行先查本地缓存，再查分布式缓存，最后查数据库的完整流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalCache localCache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisCache redisCache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheManager</span><span class="params">(LocalCache localCache, RedisCache redisCache, Database database)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.localCache = localCache;</span><br><span class="line">        <span class="built_in">this</span>.redisCache = redisCache;</span><br><span class="line">        <span class="built_in">this</span>.database = database;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 先查本地缓存</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> localCache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再查分布式缓存</span></span><br><span class="line">        value = redisCache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新本地缓存</span></span><br><span class="line">            localCache.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后查数据库</span></span><br><span class="line">        value = database.get(key);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新分布式缓存和本地缓存</span></span><br><span class="line">            redisCache.put(key, value);</span><br><span class="line">            localCache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地缓存和-Redis-的区别了解吗？"><a href="#本地缓存和-Redis-的区别了解吗？" class="headerlink" title="本地缓存和 Redis 的区别了解吗？"></a>本地缓存和 Redis 的区别了解吗？</h4><p>Redis 可以部署在多个节点上，支持数据分片、主从复制和集群。而本地缓存只能在单个服务器上使用。</p>
<p>对于读取频率极高、数据相对稳定、允许短暂不一致的数据，我优先选择本地缓存。比如系统配置信息、用户权限数据、商品分类信息等。</p>
<p>而对于需要实时同步、数据变化频繁、多个服务需要共享的数据，我会选择 Redis。比如用户会话信息、购物车数据、实时统计信息等。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 7 Java 后端实习一面的原题：怎么保证二级缓存和 Redis 缓存的数据一致性？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为面经同学 11 面试原题：使用的 guava cache 和 redis 是如何组合使用的？如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的去哪儿同学 1 技术二面的原题：redis 和本地缓存的区别，哪个效率高</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的拼多多面经同学 8 一面面试原题：缓存一致性如何保证</li>
</ol>
</blockquote>
<h3 id="33-什么是热Key？"><a href="#33-什么是热Key？" class="headerlink" title="33.什么是热Key？"></a>33.什么是热Key？</h3><p>所谓的热 Key，就是指在很短时间内被频繁访问的键。比如电商大促期间爆款商品的详情信息，流量明星爆瓜时的个人资料、热门话题等，都可能成为热Key。</p>
<p>由于 Redis 是单线程模型，大量请求集中到同一个键会导致该 Redis 节点的 CPU 使用率飙升，响应时间变长。</p>
<p>在 Redis 集群环境下，热Key 还会导致数据分布不均衡，某个节点承受的压力过大而其他节点相对空闲。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111804.png" alt="20251022111804"><br>飞猪开放平台：热 Key 造成缓存击穿</p>
<p>更严重的情况是，当热Key 过期或被误删时，会引发缓存击穿问题。</p>
<h4 id="那怎么监控热Key-呢？"><a href="#那怎么监控热Key-呢？" class="headerlink" title="那怎么监控热Key 呢？"></a>那怎么监控热Key 呢？</h4><p>临时的方案可以使用 <code>redis-cli --hotkeys</code> 命令来监控 Redis 中的热 Key。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h &lt;address&gt; -p &lt;port&gt; -a&lt;password&gt; — hotkey</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111831.png" alt="20251022111831"><br>飞猪开放平台：发现热点数据</p>
<p>或者在访问缓存时，在本地维护一个计数器，当某个键的访问次数在一分钟内超过设定阈值，就将其标记为热Key。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotKeyDetector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, AtomicLong&gt; accessCounter = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HOT_KEY_THRESHOLD</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHotKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> accessCounter.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>))</span><br><span class="line">                                  .incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> count &gt; HOT_KEY_THRESHOLD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-那怎么处理热Key-呢？"><a href="#34-那怎么处理热Key-呢？" class="headerlink" title="34.那怎么处理热Key 呢？"></a>34.那怎么处理热Key 呢？</h3><p>最有效的解决方法是增加本地缓存，将热 Key 缓存到本地内存中，这样请求就不需要访问 Redis 了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111848.png" alt="20251022111848"><br>三分恶面渣逆袭：热key处理</p>
<p>对于一些特别热的 Key，可以将其拆分成多个子 Key，然后随机分布到不同的 Redis 节点上。比如将 <code>hot_product:12345</code> 拆分成 <code>hot_product:12345:1</code>、<code>hot_product:12345:2</code> 等多个副本，读取时随机选择其中一个。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022111942.png" alt="20251022111942"><br>Jerry’s Notes：处理热 Key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getHotData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isHotKey(key)) &#123;</span><br><span class="line">        <span class="comment">// 随机选择一个副本</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">replica</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(HOT_KEY_REPLICAS);</span><br><span class="line">        <span class="keyword">return</span> redis.get(key + <span class="string">&quot;:&quot;</span> + replica);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> redis.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="35-怎么处理大-Key-呢？"><a href="#35-怎么处理大-Key-呢？" class="headerlink" title="35.怎么处理大 Key 呢？"></a>35.怎么处理大 Key 呢？</h3><p>大Key 是指占用内存空间较大的缓存键，比如超过 10M 的键值对。常见的大Key 类型包括：包含大量元素的 List、Set、Hash 结构，存储大文件的 String 类型，以及包含复杂嵌套对象的 JSON 数据等。</p>
<p>在内存有限的情况下，可能导致 Redis 内存不足。另外，大Key 还会导致主从复制同步延迟，甚至引发网络拥塞。</p>
<p>可以通过 <code>redis-cli --bigkeys</code> 命令来监控 Redis 中的大 Key。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022112218.png" alt="20251022112218"><br>二哥的 Java 进阶之路：bigkeys</p>
<p>或者编写脚本进行全量扫描：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigKeyScanner</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BIG_KEY_THRESHOLD</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;BigKeyInfo&gt; <span class="title function_">scanBigKeys</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;BigKeyInfo&gt; bigKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用SCAN命令遍历所有键</span></span><br><span class="line">        <span class="type">ScanOptions</span> <span class="variable">options</span> <span class="operator">=</span> ScanOptions.scanOptions().count(<span class="number">1000</span>).build();</span><br><span class="line">        Cursor&lt;<span class="type">byte</span>[]&gt; cursor = redisTemplate.executeWithStickyConnection(</span><br><span class="line">            connection -&gt; connection.scan(options)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cursor.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cursor.next());</span><br><span class="line">            <span class="type">long</span> <span class="variable">memory</span> <span class="operator">=</span> getKeyMemoryUsage(key);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (memory &gt; BIG_KEY_THRESHOLD) &#123;</span><br><span class="line">                bigKeys.add(<span class="keyword">new</span> <span class="title class_">BigKeyInfo</span>(key, memory, getKeyType(key)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> bigKeys;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getKeyMemoryUsage</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用MEMORY USAGE命令获取键的内存占用</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; </span><br><span class="line">            connection.memoryUsage(key.getBytes())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于大 Key 问题，最根本的解决方案是拆分大 Key，将其拆分成多个小 Key 存储。比如将一个包含大量用户信息的 Hash 拆分成多个小 Hash。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022112241.png" alt="20251022112241"><br>三分恶面渣逆袭：大key处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">splitBigKey</span><span class="params">(String bigKey)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; bigData = redisTemplate.opsForHash().entries(bigKey);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将大 Key 拆分成多个小 Key</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : bigData.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">smallKey</span> <span class="operator">=</span> bigKey + <span class="string">&quot;:&quot;</span> + entry.getKey();</span><br><span class="line">        redisTemplate.opsForValue().set(smallKey, entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除原始大 Key</span></span><br><span class="line">    redisTemplate.delete(bigKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，对于 JSON 数据，可以进行 Gzip 压缩后再存储，虽然会增加一些 CPU 开销，但在内存敏感的场景在是值得的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompressedData</span><span class="params">(String key, Object data)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(data);</span><br><span class="line">        <span class="type">byte</span>[] compressed = compress(json.getBytes());</span><br><span class="line">        redisTemplate.opsForValue().set(key, compressed);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Failed to compress data&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] compress(<span class="type">byte</span>[] data) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">GZIPOutputStream</span> <span class="variable">gzip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPOutputStream</span>(out)) &#123;</span><br><span class="line">        gzip.write(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/redis/user-guide/identify-and-handle-large-keys-and-hotkeys">阿里：发现并处理 Redis 的大 Key 和热 Key</a></li>
<li><a target="_blank" rel="noopener" href="https://dongzl.github.io/2021/01/14/03-Redis-Hot-Key/index.html">董宗磊：Redis 热 Key 发现以及解决办法</a></li>
</ul>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为 OD 的面试中出现过该题：讲一讲 Redis 的热 Key 和大 Key</li>
</ol>
</blockquote>
<h3 id="36-缓存预热怎么做呢？"><a href="#36-缓存预热怎么做呢？" class="headerlink" title="36.缓存预热怎么做呢？"></a>36.缓存预热怎么做呢？</h3><p>缓存预热是指在系统启动或者特定时间点，提前将热点数据加载到缓存中，避免冷启动时大量请求直接打到数据库。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20251022112415.png" alt="20251022112415"><br>geeksforgeeks.org：缓存预热</p>
<p>缓存预热的方法有多种，在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，我会在项目启动时将热门文章提前加载到 Redis 中，在每天凌晨定时将最新的站点地图更新到 Redis中，以确保用户在第一次访问时就能获取到缓存数据，从而减轻数据库的压力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用定时器方案，每天5:15分刷新站点地图，确保数据的一致性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 15 5 * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoRefreshCache</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;开始刷新sitemap.xml的url地址，避免出现数据不一致问题!&quot;</span>);</span><br><span class="line">    refreshSitemap();</span><br><span class="line">    log.info(<span class="string">&quot;刷新完成！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refreshSitemap</span><span class="params">()</span> &#123;</span><br><span class="line">    initSiteMap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">initSiteMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">lastId</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    RedisClient.del(SITE_MAP_CACHE_KEY);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        List&lt;SimpleArticleDTO&gt; list = articleDao.getBaseMapper().listArticlesOrderById(lastId, SCAN_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新站点地图信息，放到 Redis 当中</span></span><br><span class="line">        Map&lt;String, Long&gt; map = list.stream().collect(Collectors.toMap(s -&gt; String.valueOf(s.getId()), s -&gt; s.getCreateTime().getTime(), (a, b) -&gt; a));</span><br><span class="line">        RedisClient.hMSet(SITE_MAP_CACHE_KEY, map);</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt; SCAN_SIZE) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastId = list.get(list.size() - <span class="number">1</span>).getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动面经同学 1 技术二面面试原题：什么是缓存预热？如何解决？</li>
</ol>
</blockquote>
<h3 id="37-无底洞问题听说过吗？如何解决？"><a href="#37-无底洞问题听说过吗？如何解决？" class="headerlink" title="37.无底洞问题听说过吗？如何解决？"></a>37.无底洞问题听说过吗？如何解决？</h3><p>无底洞问题的核心在于，随着缓存节点数量的增加，虽然总的存储容量和理论吞吐量都在增长，但是单个请求的响应时间反而变长了。</p>
<p>这个问题的根本原因是网络通信开销的增加。当节点数量从几十个增长到几千个时，客户端需要与更多的节点进行通信。</p>
<p>其次就是数据分布的碎片化。随着节点增多，数据分散得更加细碎，原本可以在一个节点获取的相关数据，现在可能分散在多个节点上。</p>
<p>针对这个问题，可以采取以下几种解决方案：</p>
<p>第一，可以将同一节点的多个请求合并成一个批量请求，减少网络往返次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">batchGet</span><span class="params">(List&lt;String&gt; keys)</span> &#123;</span><br><span class="line">    <span class="comment">// 按节点分组keys</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; nodeKeysMap = groupKeysByNode(keys);</span><br><span class="line">    Map&lt;String, Object&gt; results = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并发访问各个节点</span></span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; futures = nodeKeysMap.entrySet().stream()</span><br><span class="line">        .map(entry -&gt; CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">node</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            List&lt;String&gt; nodeKeys = entry.getValue();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 批量获取该节点的数据</span></span><br><span class="line">            Map&lt;String, Object&gt; nodeResults = getFromNode(node, nodeKeys);</span><br><span class="line">            results.putAll(nodeResults);</span><br><span class="line">        &#125;))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待所有请求完成</span></span><br><span class="line">    CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二，可以使用一致性哈希算法来优化数据分布，减少数据迁移和重分布的开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalityAwareSharding</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNodeForKey</span><span class="params">(String key, String category)</span> &#123;</span><br><span class="line">        <span class="comment">// 相同类别的数据尽量分配到相同节点</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shardKey</span> <span class="operator">=</span> category + <span class="string">&quot;:&quot;</span> + (key.hashCode() % SHARDS_PER_CATEGORY);</span><br><span class="line">        <span class="keyword">return</span> consistentHash.getNode(shardKey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用户相关数据尽量在同一个节点</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserDataNode</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user_cluster_&quot;</span> + (userId.hashCode() % USER_CLUSTERS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Redis-运维"><a href="#Redis-运维" class="headerlink" title="Redis 运维"></a>Redis 运维</h2><h3 id="38-Redis-报内存不足怎么处理？"><a href="#38-Redis-报内存不足怎么处理？" class="headerlink" title="38.Redis 报内存不足怎么处理？"></a>38.Redis 报内存不足怎么处理？</h3><p>Redis 报内存不足时，通常是因为 Redis 占用的物理内存已经接近或者超过了配置的最大内存限制。这时可以采取以下几种步骤来处理：</p>
<p>第一，使用 <code>INFO memory</code> 命令查看 Redis 的内存使用情况，看看是否真的达到了最大内存限制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli INFO memory</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250525074224.png" alt="二哥的 Java 进阶之路：INFO memory"></p>
<p>二哥的 Java 进阶之路：INFO memory</p>
<p>第二，如果服务器还有可用内存的话，修改 <code>redis.conf</code> 中的 <code>maxmemory</code> 参数，增加 Redis 的最大内存限制。比如将最大内存设置为 8GB：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 8gb</span><br></pre></td></tr></table></figure>

<p>第三，修改 <code>maxmemory-policy</code> 参数来调整内存淘汰策略。比如可以选择 <code>allkeys-lru</code> 策略，让 Redis 自动删除最近最少使用的键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>

<p>memo：2025 年 5 月 25 日修改至此，今天在修改<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/jianli.html">球友简历</a>时，碰到一个西安交通大学本、上海交通大学硕的球友，985 本硕学历真的非常顶了，我会竭尽所能去帮助他，在秋招中斩获一个 SSP offer，冲！</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250525075244.png" alt="西安交通大学本、上海交通大学硕"></p>
<p>西安交通大学本、上海交通大学硕</p>
<h3 id="39-Redis-key过期策略有哪些？"><a href="#39-Redis-key过期策略有哪些？" class="headerlink" title="39.Redis key过期策略有哪些？"></a>39.Redis key过期策略有哪些？</h3><p>Redis 主要采用了两种过期删除策略来保证过期的 key 能够被及时删除，包括惰性删除和定期删除。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240326214119.png" alt="二哥的 Java 进阶之路：Redis 的过期淘汰策略"></p>
<p>二哥的 Java 进阶之路：Redis 的过期淘汰策略</p>
<p>惰性删除是最基本的策略，当客户端访问一个 key 时，Redis 会检查该 key 是否已过期，如果过期就会立即删除并返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 模拟惰性删除的逻辑</span><br><span class="line">public Object get(String key) &#123;</span><br><span class="line">    RedisKey redisKey = getKeyFromMemory(key);</span><br><span class="line">    </span><br><span class="line">    if (redisKey != null &amp;&amp; isExpired(redisKey)) &#123;</span><br><span class="line">        // key已过期，删除并返回null</span><br><span class="line">        deleteKey(key);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return redisKey != null ? redisKey.getValue() : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种策略的优点是不会有额外的 CPU 开销，只在访问 key 时才检查。但问题是如果一个过期的 key 永远不被访问，它就会一直占用内存。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250527111551.png" alt="java技术小馆：key 过期策略"></p>
<p>java技术小馆：key 过期策略</p>
<p>于是就有了定期删除策略，Redis 会定期随机选择一些设置了过期时间的 key 进行检查，删除其中已过期的 key。这个过程默认每秒执行 10 次，每次随机选择 20 个 key 进行检查。</p>
<p>-—这部分面试中可以不背 start—-</p>
<p>可以通过 <code>config get hz</code> 命令查看 Redis 内部定时任务的频率。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240326214800.png" alt="二哥的 Java 进阶之路：config get hz"></p>
<p>二哥的 Java 进阶之路：config get hz</p>
<p>hz 的值为“10”意味着 Redis 每秒执行 10 次定时任务 。可以通过 <code>CONFIG SET hz 20</code> 进行调整。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240326215240.png" alt="二哥本地 Redis 的配置文件路径和 hz 的默认值"></p>
<p>二哥本地 Redis 的配置文件路径和 hz 的默认值</p>
<p>-—这部分面试中可以不背 end—-</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 22 暑期实习一面面试原题：Redis key 删除策略</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的去哪儿面经同学 1 技术 2 面面试原题：redis 内存淘汰和过期策略</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 5 Java 后端技术一面面试原题：redis key过期策略</li>
</ol>
</blockquote>
<h3 id="40-🌟Redis有哪些内存淘汰策略？"><a href="#40-🌟Redis有哪些内存淘汰策略？" class="headerlink" title="40.🌟Redis有哪些内存淘汰策略？"></a>40.🌟Redis有哪些内存淘汰策略？</h3><p>当内存使用接近 maxmemory 限制时，Redis 会依据内存淘汰策略来决定删除哪些 key 以缓解内存压力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250527115004.png" alt="码哥字节：内存淘汰策略"></p>
<p>码哥字节：内存淘汰策略</p>
<p>常用的内存淘汰策略有八种，分别是默认的 noeviction，内存不足时不会删除任何 key，直接返回错误信息，生产环境下基本上不会使用。</p>
<p>然后是针对所有 key 的 allkeys-lru、allkeys-lfu 和 allkeys-random。lru 会删除最近最少使用的 key，在纯缓存场景中最常用，能自动保留热点数据；lfu 会删除访问频率最低的 key，更适合长期运行的系统；random 会随机删除一些 key，一般不推荐使用。</p>
<p>其次是针对设置了过期时间的 key，有 volatile-lru、volatile-lfu、volatile-ttl 和 volatile-random。</p>
<p>lru 在混合存储场景中经常使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class HybridStorageService &#123;</span><br><span class="line">    </span><br><span class="line">    // 重要数据不设置过期时间，临时数据设置过期时间</span><br><span class="line">    public void storeData(String key, Object data, DataImportance importance) &#123;</span><br><span class="line">        if (importance == DataImportance.HIGH) &#123;</span><br><span class="line">            // 重要数据不设置过期时间，在volatile-*策略下不会被淘汰</span><br><span class="line">            redisTemplate.opsForValue().set(key, data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 临时数据设置过期时间，可以被volatile-*策略淘汰</span><br><span class="line">            redisTemplate.opsForValue().set(key, data, Duration.ofHours(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lfu 适合需要保护某些重要数据不被淘汰的场景；ttl 优先删除即将过期的 key，在用户会话管理系统中推荐使用；random 仍然很少用。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米春招同学 K 一面面试原题：为什么 redis 快，淘汰策略 持久化</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的去哪儿面经同学 1 技术 2 面面试原题：redis 内存淘汰和过期策略</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的作业帮面经同学 1 Java 后端一面面试原题：redis内存淘汰策略</li>
</ol>
</blockquote>
<h3 id="41-LRU-和-LFU-的区别是什么？"><a href="#41-LRU-和-LFU-的区别是什么？" class="headerlink" title="41.LRU 和 LFU 的区别是什么？"></a>41.LRU 和 LFU 的区别是什么？</h3><p>LRU 是 Least Recently Used 的缩写，基于时间维度，淘汰最近最少访问的键。</p>
<p>LFU 是 Least Frequently Used 的缩写，基于次数维度，淘汰访问频率最低的键。</p>
<p>假设缓存中有三个数据 A、B、C，在 LRU 场景下，如果访问顺序是 A→B→C→A，那么此时的 LRU 顺序是B→C→A，如果需要淘汰，会先删除 B。</p>
<p>但在 LFU 场景下，如果 A 被访问了 5 次，B 被访问了 2 次，C 被访问了 1 次，那么无论最近的访问顺序如何，都会优先淘汰 C，因为它的访问频率最低。</p>
<p>LRU 更适合有明显时间局部性的场景，比如在新闻网站中，用户更关心最新的新闻，而昨天的新闻访问量会急剧下降。这种情况下，LRU 能很好地保留用户当前关心的热点内容。</p>
<p>LFU 则更适合有长期访问模式的场景，更强调“热度”，比如在电商平台中，某些商品可能长期保持热销状态，即使它们的访问时间间隔较长，但由于访问频率高，LFU 会优先保留这些商品的信息。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里系面经同学 19 饿了么面试原题：redis内存淘汰机制 延伸到LRU LFU</li>
</ol>
</blockquote>
<p>memo：2025 年 5 月 27 日，今天<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">球友发私信说</a>，拿到了哈啰和得物的实习 offer，恭喜他！🎉 还特意感谢了一下之前对他简历的修改和学习上的建议。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250527120727.png" alt="球友拿到了得物和哈啰的 offer"></p>
<p>球友拿到了得物和哈啰的 offer</p>
<h3 id="42-Redis发生阻塞了怎么解决？"><a href="#42-Redis发生阻塞了怎么解决？" class="headerlink" title="42.Redis发生阻塞了怎么解决？"></a>42.Redis发生阻塞了怎么解决？</h3><p>Redis 发生阻塞在生产环境中是比较严重的问题，当发现 Redis 变慢时，我会先通过 monitor 命令查看当前正在执行的命令，或者使用 slowlog 命令查看慢查询日志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前正在执行的命令</span><br><span class="line">redis-cli MONITOR</span><br><span class="line"></span><br><span class="line"># 查看慢查询日志</span><br><span class="line">redis-cli SLOWLOG GET 10</span><br><span class="line"></span><br><span class="line"># 检查客户端连接状况</span><br><span class="line">redis-cli CLIENT LIST</span><br></pre></td></tr></table></figure>

<p>通常情况下，大Key 是导致 Redis 阻塞的主要原因之一。比如说直接 DEL 一个包含几百万个元素的 Set，就会导致 Redis 阻塞几秒钟甚至更久。</p>
<p>这时候可以用 UNLINK 命令替代 DEL 来异步删除，避免阻塞主线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 UNLINK 异步删除大 Key</span><br><span class="line">redis-cli UNLINK big_key</span><br></pre></td></tr></table></figure>

<p>对于非常大的集合，可以使用 SCAN 命令分批删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void safeBatchProcess(String key) &#123;</span><br><span class="line">    ScanOptions options = ScanOptions.scanOptions().count(1000).build();</span><br><span class="line">    Cursor&lt;String&gt; cursor = redisTemplate.opsForSet().scan(key, options);</span><br><span class="line">    </span><br><span class="line">    while (cursor.hasNext()) &#123;</span><br><span class="line">        String member = cursor.next();</span><br><span class="line">        // 分批处理，避免阻塞</span><br><span class="line">        processElement(member);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，当 Redis 使用的内存超过物理内存时，操作系统会将部分内存交换到磁盘，这时候会导致 Redis 响应变慢。我的处理方式是：</p>
<p>使用 <code>free -h</code> 检查内存的使用情况 ；确认 Redis 的 maxmemory 设置是否合理；如果发生了内存交换，立即调整 maxmemory 并清理一些不重要的数据。</p>
<p>大量的客户端连接也可能会导致阻塞，这时候最好检查一下连接池的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConnectionConfig &#123;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public JedisConnectionFactory jedisConnectionFactory() &#123;</span><br><span class="line">        JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class="line">        poolConfig.setMaxTotal(200);        // 最大连接数</span><br><span class="line">        poolConfig.setMaxIdle(50);          // 最大空闲连接</span><br><span class="line">        poolConfig.setMinIdle(10);          // 最小空闲连接</span><br><span class="line">        poolConfig.setMaxWaitMillis(3000);  // 获取连接最大等待时间</span><br><span class="line">        poolConfig.setTestOnBorrow(true);   // 获取连接时检测有效性</span><br><span class="line">        </span><br><span class="line">        return new JedisConnectionFactory(poolConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗨嗨嗨，时隔两年，面渣逆袭<a target="_blank" rel="noopener" href="https://javabetter.cn/sidebar/sanfene/nixi.html">第二版 PDF 终于可以下载了</a>。我们做了大量的优化：</p>
<ol>
<li><strong>对于高频题</strong>：会标注在《<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>中出现的位置，哪家公司，原题是什么；如果你想节省时间的话，可以优先背诵这些题目，尽快做到知彼知己，百战不殆。</li>
<li><strong>结合项目</strong>：包括<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派</a>、<a target="_blank" rel="noopener" href="https://t.zsxq.com/0bhcI0Gs6">mydb</a>、<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/pmhub.html">pmhub</a>来组织语言，让面试官最大程度感受到你的诚意，而不是机械化的背诵。</li>
<li><strong>修复问题</strong>：第一版中出现的问题，包括球友们的私信反馈，网站留言区的评论，以及<a target="_blank" rel="noopener" href="https://github.com/itwanger/toBeBetterJavaer/issues"> GitHub 仓库中的 issue</a>，让这份面试指南更加完善。</li>
<li><strong>优化排版</strong>：增加手绘图，重新组织答案，使其更加口语化，从而更贴近面试官的预期。</li>
</ol>
<p>你可以扫下面的二维码（或者长按自动识别）关注【<strong>沉默王二</strong>】公众号，发送关键字 <strong>222</strong> 来获取 PDF 版本，如果面渣逆袭真的对你有帮助，希望能给二哥的公众号加一个星标，满足我那一丁点虚荣心，这将是我更新下去的最强动力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="微信扫码或者长按识别，或者微信搜索“沉默王二”"></p>
<p>面渣逆袭的整理工作真的太不容易了，花了我好多好多的时间和精力，内容完全免费，但质量却有口皆碑，就是为了做一点真正有意义的、纯粹的事情。</p>
<h2 id="Redis-应用"><a href="#Redis-应用" class="headerlink" title="Redis 应用"></a>Redis 应用</h2><h3 id="43-Redis如何实现异步消息队列？"><a href="#43-Redis如何实现异步消息队列？" class="headerlink" title="43.Redis如何实现异步消息队列？"></a>43.Redis如何实现异步消息队列？</h3><p>Redis 实现异步消息队列是一个很实用的技术方案，最简单的方式是使用 List 配合 LPUSH 和 RPOP 命令。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-e4b192a1-3ba7-4f4e-98de-e93f437cff7c.png" alt="三分恶面渣逆袭：list作为队列"></p>
<p>三分恶面渣逆袭：list作为队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class SimpleRedisQueue &#123;</span><br><span class="line">    </span><br><span class="line">    private final RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    // 生产者：向队列发送消息</span><br><span class="line">    public void sendMessage(String queueName, Object message) &#123;</span><br><span class="line">        redisTemplate.opsForList().leftPush(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 消费者：从队列获取消息</span><br><span class="line">    public Object receiveMessage(String queueName) &#123;</span><br><span class="line">        return redisTemplate.opsForList().rightPop(queueName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 阻塞式消费，避免轮询</span><br><span class="line">    public Object blockingReceive(String queueName, int timeoutSeconds) &#123;</span><br><span class="line">        List&lt;Object&gt; result = redisTemplate.opsForList()</span><br><span class="line">            .rightPop(queueName, timeoutSeconds, TimeUnit.SECONDS);</span><br><span class="line">        return result != null &amp;&amp; !result.isEmpty() ? result.get(0) : null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外就是用 Redis 的 Pub&#x2F;Sub 来实现简单的消息广播和订阅。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RedisPubSubService &#123;</span><br><span class="line">    </span><br><span class="line">    private final RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    // 发布消息到指定频道</span><br><span class="line">    public void publish(String channel, Object message) &#123;</span><br><span class="line">        redisTemplate.convertAndSend(channel, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 订阅频道</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void subscribe() &#123;</span><br><span class="line">        redisTemplate.setMessageListener((message, pattern) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;Received message: &quot; + message);</span><br><span class="line">        &#125;);</span><br><span class="line">        redisTemplate.getConnectionFactory().getConnection().subscribe(</span><br><span class="line">            new ChannelTopic(&quot;myChannel&quot;).getTopic().getBytes()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发布者将消息发布到指定的频道，订阅该频道的客户端就能收到消息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-bc6d05be-3701-4e23-b4ca-6330c949f020.png" alt="三分恶面渣逆袭：pub/sub"></p>
<p>三分恶面渣逆袭：pub&#x2F;sub</p>
<p>但是这两种方式都是不可靠的，因为没有 ACK 机制所以不能保证订阅者一定能收到消息，也不支持消息持久化。</p>
<h3 id="44-Redis如何实现延时消息队列"><a href="#44-Redis如何实现延时消息队列" class="headerlink" title="44.Redis如何实现延时消息队列?"></a>44.Redis如何实现延时消息队列?</h3><p>延时消息队列在实际业务中很常见，比如订单超时取消、定时提醒等场景。Redis 虽然不是专业的消息队列，但可以很好地实现延时队列功能。</p>
<p>核心思路是利用 ZSet 的有序特性，将消息作为 member，把消息的执行时间作为 score。这样消息就会按照执行时间自动排序，我们只需要定期扫描当前时间之前的消息进行处理就可以了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-54bbcc36-0b00-4142-a6eb-bf2ef48c2213.png" alt="三分恶面渣逆袭：zset实现延时队列"></p>
<p>三分恶面渣逆袭：zset实现延时队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class DelayedMessageQueue &#123;</span><br><span class="line">    </span><br><span class="line">    private final RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    // 发送延时消息</span><br><span class="line">    public void sendDelayedMessage(String queueName, Object message, long delaySeconds) &#123;</span><br><span class="line">        // 计算消息的执行时间</span><br><span class="line">        long executeTime = System.currentTimeMillis() + (delaySeconds * 1000);</span><br><span class="line">        </span><br><span class="line">        // 将消息加入ZSet，以执行时间作为score</span><br><span class="line">        redisTemplate.opsForZSet().add(queueName, message, executeTime);</span><br><span class="line">        </span><br><span class="line">        log.info(&quot;发送延时消息: &#123;&#125;, 延时: &#123;&#125;秒&quot;, message, delaySeconds);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 消费延时消息</span><br><span class="line">    @Scheduled(fixedDelay = 1000) // 每秒扫描一次</span><br><span class="line">    public void consumeDelayedMessages() &#123;</span><br><span class="line">        String queueName = &quot;delayed:queue&quot;;</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        // 获取已到期的消息（score &lt;= 当前时间）</span><br><span class="line">        Set&lt;Object&gt; messages = redisTemplate.opsForZSet()</span><br><span class="line">            .rangeByScore(queueName, 0, currentTime);</span><br><span class="line">        </span><br><span class="line">        for (Object message : messages) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 处理消息</span><br><span class="line">                processMessage(message);</span><br><span class="line">                </span><br><span class="line">                // 处理成功后从队列中移除</span><br><span class="line">                redisTemplate.opsForZSet().remove(queueName, message);</span><br><span class="line">                </span><br><span class="line">                log.info(&quot;处理延时消息成功: &#123;&#125;&quot;, message);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.error(&quot;处理延时消息失败: &#123;&#125;&quot;, message, e);</span><br><span class="line">                // 可以实现重试机制</span><br><span class="line">                handleFailedMessage(queueName, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现上，我会在生产者发送延时消息时，计算消息应该执行的时间戳，然后用 ZADD 命令将消息添加到 ZSet 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD delay_queue 1617024000 task1</span><br></pre></td></tr></table></figure>

<p>消费者通过定时任务，使用 ZRANGEBYSCORE 命令获取当前时间之前的所有消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE delay_queue -inf 1617024000</span><br></pre></td></tr></table></figure>

<p>处理完成后再用 ZREM 删除消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM delay_queue task1</span><br></pre></td></tr></table></figure>

<p>在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，我就用这种方式实现了文章定时发布的功能。作者在发布文章时，可以选择一个未来的时间节点，比如说 30 分钟后，系统就会向延时队列发送一条延时消息，然后定时任务就会在 30 分钟后将这条消息从延时队列中取出并发布文章。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 23 QQ 后台技术一面面试原题：Redis 实现延迟队列</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动面经同学 8 Java 后端实习一面面试原题：redis 数据结构，用什么结构实现延迟消息队列</li>
</ol>
</blockquote>
<p>memo：2025 年 5 月 28 日修改至此，今天<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">有球友在 VIP群里</a>发消息说拿到了荣耀的暑期实习 offer，虽然时间节点已经不早了，但越是到这个时候，确实容易捡漏。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250528203451.png" alt="球友的荣耀实习 OC了"></p>
<p>球友的荣耀实习 OC了</p>
<h3 id="45-🌟Redis支持事务吗？"><a href="#45-🌟Redis支持事务吗？" class="headerlink" title="45.🌟Redis支持事务吗？"></a>45.🌟Redis支持事务吗？</h3><p>是的，Redis 支持简单的事务，可以将 multi、exec、discard 和 watch 命令打包，然后一次性的按顺序执行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529063154.png" alt="Redis设计与实现：事务"></p>
<p>Redis设计与实现：事务</p>
<p>基本流程是用 multi 开启事务，然后执行一系列命令，最后用 exec 提交。这些命令会被放入队列，在 exec 时批量执行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240314101439.png" alt="二哥的 Java 进阶之路：Redis 事务"></p>
<p>二哥的 Java 进阶之路：Redis 事务</p>
<p>当客户端处于非事务状态时，所有发送给 Redis 服务的命令都会立即执行；但当客户端进入事务状态之后，这些命令会被放入一个事务队列中，然后立即返回 QUEUED，表示命令已入队。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529063910.png" alt="Redis设计与实现：事务和非事务的区别"></p>
<p>Redis设计与实现：事务和非事务的区别</p>
<p>当 exec 命令执行时，Redis 会将事务队列中的所有命令按先进先出的顺序执行。当事务队列里的命令全部执行完毕后，Redis 会返回一个数组，包含每个命令的执行结果。</p>
<p>discard 命令用于取消一个事务，它会清空事务队列并退出事务状态。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529065426.png" alt="二哥的 Java 进阶之路：discard"></p>
<p>二哥的 Java 进阶之路：discard</p>
<p>watch 命令用于监视一个或者多个 key，如果这个 key 在事务执行之前 被其他命令改动，那么事务将会被打断。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529065131.png" alt="码哥字节：watch"></p>
<p>码哥字节：watch</p>
<p>但 Redis 的事务与 MySQL 的有很大不同，它并不支持回滚，也不支持隔离级别。</p>
<h4 id="说一下-Redis-事务的原理？"><a href="#说一下-Redis-事务的原理？" class="headerlink" title="说一下 Redis 事务的原理？"></a>说一下 Redis 事务的原理？</h4><p>Redis 事务的原理并不复杂，核心就是一个”先排队，后执行”的机制。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529082025.png" alt="小生凡一：Redis事务"></p>
<p>小生凡一：Redis事务</p>
<p>当执行 MULTI 命令时，Redis 会给这个客户端打一个事务的标记，表示这个客户端后面发送的命令不会被立即执行，而是被放到一个队列里排队等着。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529082120.png" alt="小生凡一：MULTI"></p>
<p>小生凡一：MULTI</p>
<p>当 Redis 收到 EXEC 命令时，它会把队列里的命令一个个拿出来执行。因为 Redis 是单线程的，所以这个过程不会被其他命令打断，这就保证了Redis 事务的原子性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529082216.png" alt="小生凡一：WATCH"></p>
<p>小生凡一：WATCH</p>
<p>当执行 WATCH 命令时，Redis 会将 key 添加到全局监视字典中；只要这些 key 在 EXEC 前被其他客户端修改，Redis 就会给相关客户端打上脏标记，EXEC 时发现事务已被干扰就会直接取消整个事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 全局监视字典</span><br><span class="line">dict *watched_keys;</span><br><span class="line"></span><br><span class="line">typedef struct watchedKey &#123;</span><br><span class="line">    robj *key;</span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125; watchedKey;</span><br></pre></td></tr></table></figure>

<p>DISCARD 做的事情很简单直接，首先检查客户端是否真的在事务状态，如果不在就报错；如果在事务状态，就清空事务队列并退出事务状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void discardCommand(client *c) &#123;</span><br><span class="line">    if (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,&quot;DISCARD without MULTI&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redis-事务有哪些注意点？"><a href="#Redis-事务有哪些注意点？" class="headerlink" title="Redis 事务有哪些注意点？"></a>Redis 事务有哪些注意点？</h4><p>最重要的的一点是，Redis 事务不支持回滚，一旦 EXEC 命令被调用，所有命令都会被执行，即使有些命令可能执行失败。</p>
<h4 id="Redis事务为什么不支持回滚？"><a href="#Redis事务为什么不支持回滚？" class="headerlink" title="Redis事务为什么不支持回滚？"></a>Redis事务为什么不支持回滚？</h4><p>Redis 的核心设计理念是简单、高效，而不是完整的 ACID 特性。而实现回滚需要在执行过程中保存大量的状态信息，并在发生错误时逆向执行命令以恢复原始状态。这会增加 Redis 的复杂性和性能开销。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529082551.png" alt="redis.io：不支持事务回滚"></p>
<p>redis.io：不支持事务回滚</p>
<h4 id="Redis事务满足原子性吗？要怎么改进？"><a href="#Redis事务满足原子性吗？要怎么改进？" class="headerlink" title="Redis事务满足原子性吗？要怎么改进？"></a>Redis事务满足原子性吗？要怎么改进？</h4><p>Redis 的事务不能满足标准的原子性，因为它不支持事务回滚，也就是说，假如某个命令执行失败，整个事务并不会自动回滚到初始状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 一个转账事务</span><br><span class="line">redisTemplate.multi();</span><br><span class="line">redisTemplate.opsForValue().decrement(&quot;user:1:balance&quot;, 100); // 成功</span><br><span class="line">redisTemplate.opsForList().leftPush(&quot;user:1:balance&quot;, &quot;log&quot;);  // 类型错误，失败</span><br><span class="line">redisTemplate.opsForValue().increment(&quot;user:2:balance&quot;, 100);  // 还是会执行</span><br><span class="line">List&lt;Object&gt; results = redisTemplate.exec();</span><br><span class="line"></span><br><span class="line">// 结果：用户1被扣了钱，用户2也收到了钱，但中间的日志操作失败了</span><br><span class="line">// 这符合Redis的原子性定义，但不符合业务期望</span><br></pre></td></tr></table></figure>

<p>可以使用 Lua 脚本来替代事务，脚本运行期间，Redis 不会处理其他命令，并且我们可以在脚本中处理整个业务逻辑，包括条件检查和错误处理，保证要么执行成功，要么保持最初的状态，不会出现一个命令执行失败、其他命令执行成功的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ImprovedTransactionService &#123;</span><br><span class="line">    </span><br><span class="line">    public boolean atomicTransfer(String fromUser, String toUser, int amount) &#123;</span><br><span class="line">        String luaScript = </span><br><span class="line">            &quot;local from_key = KEYS[1] &quot; +</span><br><span class="line">            &quot;local to_key = KEYS[2] &quot; +</span><br><span class="line">            &quot;local amount = tonumber(ARGV[1]) &quot; +</span><br><span class="line">            </span><br><span class="line">            // 检查转出账户余额</span><br><span class="line">            &quot;local from_balance = redis.call(&#x27;GET&#x27;, from_key) &quot; +</span><br><span class="line">            &quot;if not from_balance then return -1 end &quot; +</span><br><span class="line">            </span><br><span class="line">            &quot;from_balance = tonumber(from_balance) &quot; +</span><br><span class="line">            &quot;if from_balance &lt; amount then return -2 end &quot; +</span><br><span class="line">            </span><br><span class="line">            // 检查转入账户是否存在</span><br><span class="line">            &quot;if redis.call(&#x27;EXISTS&#x27;, to_key) == 0 then return -3 end &quot; +</span><br><span class="line">            </span><br><span class="line">            // 所有检查通过，执行转账</span><br><span class="line">            &quot;redis.call(&#x27;DECRBY&#x27;, from_key, amount) &quot; +</span><br><span class="line">            &quot;redis.call(&#x27;INCRBY&#x27;, to_key, amount) &quot; +</span><br><span class="line">            </span><br><span class="line">            // 记录转账日志</span><br><span class="line">            &quot;local log = from_key .. &#x27;:&#x27; .. to_key .. &#x27;:&#x27; .. amount &quot; +</span><br><span class="line">            &quot;redis.call(&#x27;LPUSH&#x27;, &#x27;transfer:log&#x27;, log) &quot; +</span><br><span class="line">            </span><br><span class="line">            &quot;return 1&quot;;</span><br><span class="line">        </span><br><span class="line">        DefaultRedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;();</span><br><span class="line">        script.setScriptText(luaScript);</span><br><span class="line">        script.setResultType(Long.class);</span><br><span class="line">        </span><br><span class="line">        Long result = redisTemplate.execute(script, </span><br><span class="line">            Arrays.asList(&quot;user:&quot; + fromUser + &quot;:balance&quot;, &quot;user:&quot; + toUser + &quot;:balance&quot;),</span><br><span class="line">            amount);</span><br><span class="line">        </span><br><span class="line">        return result != null &amp;&amp; result == 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redis-事务的-ACID-特性如何体现？"><a href="#Redis-事务的-ACID-特性如何体现？" class="headerlink" title="Redis 事务的 ACID 特性如何体现？"></a>Redis 事务的 ACID 特性如何体现？</h4><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务在执行过程中如果某个命令失败了，其他命令还是会继续执行，不会回滚。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529085332.png" alt="小生凡一：Redis 事务的原子性"></p>
<p>小生凡一：Redis 事务的原子性</p>
<p>一致性指的是，如果数据在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据也应该是一致的。但 Redis 事务并不保证一致性，因为如果事务中的某个命令失败了，其他命令仍然会执行，就会出现数据不一致的情况。</p>
<p>Redis 是单线程执行事务的，并且不会中断，直到执行完所有事务队列中的命令为止。因此，我认为 Redis 的事务具有隔离性的特征。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529085959.png" alt="小生凡一：Redis 事务的隔离性"></p>
<p>小生凡一：Redis 事务的隔离性</p>
<p>Redis 事务的持久性完全依赖于 Redis 本身的持久化机制，如果开启了 AOF，那么事务中的命令会作为一个整体记录到 AOF 文件中，当然也要看 AOF 的 fsync 策略。</p>
<p>如果只开启了 RDB，事务中的命令可能会在下次快照前丢失。如果两个都没有开启，肯定是不满足持久性的。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为一面原题：说下 Redis 事务</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">二哥编程星球</a>球友<a target="_blank" rel="noopener" href="https://t.zsxq.com/BaHOh">枕云眠美团 AI 面试原题</a>：什么是 redis 的事务，它的 ACID 属性如何体现</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：Redis事务满足原子性吗？要怎么改进？</li>
</ol>
</blockquote>
<p>memo：2025 年 5 月 29 日，今天给球友<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">修改简历</a>时，碰到一个东南大学本硕博 3 985 的球友，这也是我已知信息中学历最高的球友了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250529090547.png" alt="星球来了一个东南大学本硕博的球友"></p>
<p>星球来了一个东南大学本硕博的球友</p>
<h3 id="46-有Lua脚本操作Redis的经验吗？"><a href="#46-有Lua脚本操作Redis的经验吗？" class="headerlink" title="46.有Lua脚本操作Redis的经验吗？"></a>46.有Lua脚本操作Redis的经验吗？</h3><p>Lua 脚本是处理 Redis 复杂操作的首选方案，比如说原子扣减库存、分布式锁、限流等业务场景，都可以通过 Lua 脚本来实现。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250530151227.png" alt="scalegrid.io：lua 脚本"></p>
<p>scalegrid.io：lua 脚本</p>
<p>在秒杀场景下，可以用 Lua 脚本把所有检查逻辑都写在一起：先看库存够不够，再看用户有没有买过，所有条件都满足才扣减库存。因为整个脚本是原子执行的，Redis 在执行期间不会处理其他命令，所以可以彻底解决超卖问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 这个秒杀脚本救了我的命</span><br><span class="line">String luaScript = </span><br><span class="line">    &quot;local stock = redis.call(&#x27;GET&#x27;, KEYS[1]) &quot; +</span><br><span class="line">    &quot;if not stock or tonumber(stock) &lt; tonumber(ARGV[2]) then &quot; +</span><br><span class="line">    &quot;    return -1 &quot; +  // 库存不足</span><br><span class="line">    &quot;end &quot; +</span><br><span class="line">    &quot;if redis.call(&#x27;SISMEMBER&#x27;, KEYS[2], ARGV[1]) == 1 then &quot; +</span><br><span class="line">    &quot;    return -2 &quot; +  // 重复购买</span><br><span class="line">    &quot;end &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;DECRBY&#x27;, KEYS[1], ARGV[2]) &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;SADD&#x27;, KEYS[2], ARGV[1]) &quot; +</span><br><span class="line">    &quot;return 1&quot;;</span><br></pre></td></tr></table></figure>

<p>在分布式锁场景下，我一开始用的 SETNX 命令来实现，结果发现如果程序异常退出，锁就死掉了。后来加了过期时间，但又发现可能误删其他线程的锁。最后还是用 Lua 脚本彻底解决了这个问题，确保只有锁的持有者才能释放锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 解锁脚本特别重要，必须验证是自己的锁才能删</span><br><span class="line">private final String UNLOCK_SCRIPT = </span><br><span class="line">    &quot;if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">    &quot;    return redis.call(&#x27;DEL&#x27;, KEYS[1]) &quot; +</span><br><span class="line">    &quot;else &quot; +</span><br><span class="line">    &quot;    return 0 &quot; +</span><br><span class="line">    &quot;end&quot;;</span><br></pre></td></tr></table></figure>

<p>甚至还可以用 Lua脚本实现滑动窗口限流器，一次性完成过期数据清理、计数检查、新记录添加三个操作，而且完全原子化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 滑动窗口限流，逻辑清晰，性能还好</span><br><span class="line">String luaScript = </span><br><span class="line">    &quot;local key = KEYS[1] &quot; +</span><br><span class="line">    &quot;local now = tonumber(ARGV[1]) &quot; +</span><br><span class="line">    &quot;local window = tonumber(ARGV[2]) &quot; +</span><br><span class="line">    &quot;local limit = tonumber(ARGV[3]) &quot; +</span><br><span class="line">    </span><br><span class="line">    // 先清理过期记录</span><br><span class="line">    &quot;redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, key, 0, now - window) &quot; +</span><br><span class="line">    </span><br><span class="line">    // 检查当前请求数</span><br><span class="line">    &quot;local current = redis.call(&#x27;ZCARD&#x27;, key) &quot; +</span><br><span class="line">    &quot;if current &lt; limit then &quot; +</span><br><span class="line">    &quot;    redis.call(&#x27;ZADD&#x27;, key, now, now) &quot; +</span><br><span class="line">    &quot;    return 1 &quot; +</span><br><span class="line">    &quot;else &quot; +</span><br><span class="line">    &quot;    return 0 &quot; +</span><br><span class="line">    &quot;end&quot;;</span><br></pre></td></tr></table></figure>

<p>memo：2025 年 5 月 30 日，今天<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">有球友在星球里</a>发消息说拿到了金山办公的 offer，问我该选 cpp 还是go，我的建议可以看看符合是否合理，不管如何选择，真的恭喜球友！</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250601080336.png" alt="球友拿到了金山办公的软件"></p>
<p>球友拿到了金山办公的软件</p>
<h3 id="47-Redis的管道Pipeline了解吗？"><a href="#47-Redis的管道Pipeline了解吗？" class="headerlink" title="47.Redis的管道Pipeline了解吗？"></a>47.Redis的管道Pipeline了解吗？</h3><p>了解，Pipeline 允许客户端一次性向 Redis 服务器发送多个命令，而不必等待一个命令响应后才能发送下一个。Redis 服务器会按照命令的顺序依次执行，并将所有结果打包返回给客户端。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-38aee4c1-efd2-495e-8a6d-164d21a129b1.png" alt="三分恶面渣逆袭：Pipelining示意图"></p>
<p>三分恶面渣逆袭：Pipelining示意图</p>
<p>正常情况下，每执行一个 Redis 命令都需要一次网络往返：发送命令 -&gt; 等待响应 -&gt; 发送下一个命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">客户端                    Redis服务器</span><br><span class="line">  |                           |</span><br><span class="line">  |------- SET key1 val1 ----&gt;|</span><br><span class="line">  |&lt;------ OK ---------------|</span><br><span class="line">  |------- SET key2 val2 ----&gt;|</span><br><span class="line">  |&lt;------ OK ---------------|</span><br><span class="line">  |------- GET key1 --------&gt;|</span><br><span class="line">  |&lt;------ val1 -------------|</span><br></pre></td></tr></table></figure>

<p>如果大量请求依次发送，网络延迟会显著增加请求的总执行时间，假如一次 RTT 的时间是 1 毫秒，3 个就是 3 毫秒。有了 Pipeline 后，可以一次性发送 3 个命令，总时间就只需要 1 毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RedisBatchService &#123;</span><br><span class="line">    </span><br><span class="line">    public void batchInsertUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">        // 不用Pipeline的错误做法 - 很慢</span><br><span class="line">        // for (User user : users) &#123;</span><br><span class="line">        //     redisTemplate.opsForValue().set(&quot;user:&quot; + user.getId(), user);</span><br><span class="line">        // &#125;</span><br><span class="line">        </span><br><span class="line">        // 使用Pipeline的正确做法</span><br><span class="line">        redisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">                for (User user : users) &#123;</span><br><span class="line">                    String key = &quot;user:&quot; + user.getId();</span><br><span class="line">                    byte[] keyBytes = key.getBytes();</span><br><span class="line">                    byte[] valueBytes = serialize(user);</span><br><span class="line">                    </span><br><span class="line">                    connection.set(keyBytes, valueBytes);</span><br><span class="line">                &#125;</span><br><span class="line">                return null; // Pipeline不需要返回值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，Pipeline 不是越大越好，太大会占用过多内存，通常建议每个 Pipeline 包含 1000 到 5000 个命令。可以根据实际情况调整。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void smartBatchInsert(List&lt;String&gt; data) &#123;</span><br><span class="line">    int batchSize = 1000; // 经验值，根据数据大小调整</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; data.size(); i += batchSize) &#123;</span><br><span class="line">        List&lt;String&gt; batch = data.subList(i, Math.min(i + batchSize, data.size()));</span><br><span class="line">        </span><br><span class="line">        redisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">                for (String item : batch) &#123;</span><br><span class="line">                    connection.set(item.getBytes(), item.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么场景下适合使用-Pipeline呢？"><a href="#什么场景下适合使用-Pipeline呢？" class="headerlink" title="什么场景下适合使用 Pipeline呢？"></a>什么场景下适合使用 Pipeline呢？</h4><p>需要批量插入、更新或删除数据，或者需要执行大量相似的命令时。比如：系统启动时的缓存预热 -&gt; 批量加载热点数据；比如统计数据的批量更新；比如大批量数据的导入导出；比如批量删除过期或无效的缓存。</p>
<h4 id="有了解过-Pipeline-的底层原理吗？"><a href="#有了解过-Pipeline-的底层原理吗？" class="headerlink" title="有了解过 Pipeline 的底层原理吗？"></a>有了解过 Pipeline 的底层原理吗？</h4><p>有，其实就是缓冲的思想。在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，我就在 RedisClient 类中封装了一个 PipelineAction 内部类，用来缓存命令。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250601092704.png" alt="技术派实战源码：PipelineAction"></p>
<p>技术派实战源码：PipelineAction</p>
<p>add 方法将命令包装成 Runnable 对象，放入 List 中。当执行 execute 方法时，再调用 RedisTemplate 的 executePipelined 方法开启管道模式将多个命令发送到 Redis 服务端。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250601094500.png" alt="二哥的 Java 进阶之路：RedisTemplate的executePipelined"></p>
<p>二哥的 Java 进阶之路：RedisTemplate的executePipelined</p>
<p>Redis 服务端从输入缓冲区读到命令后，会按照 RESP 协议进行命令拆解，再依次执行这些命令。执行结果会写入到输出缓冲区，最后再将所有结果一次性返回给客户端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct client &#123;</span><br><span class="line">    sds querybuf;           // 输入缓冲区</span><br><span class="line">    list *reply;            // 输出缓冲区链表</span><br><span class="line">    unsigned long reply_bytes; // 输出缓冲区大小</span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 8 面试原题：对pipeline的理解，什么场景适合使用pipeline？有了解过pipeline的底层？</li>
</ol>
</blockquote>
<p>memo：2025 年 6 月 1 日，今天<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">有球友在星球里</a>发消息说拿到了百得思维的offer，他是民办二本，对这个结果很满意，也很感谢面渣逆袭和星球的实战项目，让他摆脱了浑浑噩噩的日子。恭喜他！</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250601082813.png" alt="球友拿到了一家小厂的 offer"></p>
<p>球友拿到了一家小厂的 offer</p>
<h3 id="48-🌟Redis能实现分布式锁吗？"><a href="#48-🌟Redis能实现分布式锁吗？" class="headerlink" title="48.🌟Redis能实现分布式锁吗？"></a>48.🌟Redis能实现分布式锁吗？</h3><p>分布式锁是一种用于控制多个不同进程在分布式系统中访问共享资源的锁机制。它能确保在同一时刻，只有一个节点可以对资源进行访问，从而避免分布式场景下的并发问题。</p>
<p>可以使用 Redis 的 SETNX 命令实现简单的分布式锁。比如 <code>SET key value NX PX 3000</code> 就创建了一个锁名为 <code>key</code> 的分布式锁，锁的持有者为 <code>value</code>。NX 保证只有在 key 不存在时才能创建成功，EX 设置过期时间用以防止死锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-710cdd19-98ea-4e96-b579-ff1ebb0d5de9.png" alt="三分恶面渣逆袭：set原子命令"></p>
<p>三分恶面渣逆袭：set原子命令</p>
<h4 id="Redis如何保证-SETNX-不会发生冲突？"><a href="#Redis如何保证-SETNX-不会发生冲突？" class="headerlink" title="Redis如何保证 SETNX 不会发生冲突？"></a>Redis如何保证 SETNX 不会发生冲突？</h4><p>当我们使用 <code>SET key value NX EX 30</code> 这个命令进行加锁时，Redis 会把整个操作当作一个原子指令来执行。因为 Redis 的命令处理是单线程的，所以在同一时刻只能有一个命令在执行。</p>
<p>比如说两个客户端 A 和 B 同时请求同一个锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端A: SET lock_key uuid_a NX EX 30</span><br><span class="line">客户端B: SET lock_key uuid_b NX EX 30</span><br></pre></td></tr></table></figure>

<p>虽然这两个请求可能几乎同时到达 Redis 服务器，但 Redis 会严格按照到达的先后顺序来处理。假设 A 的请求先到，Redis 会先执行 A 的 SET 命令，这时 lock_key 被设置为 uuid_a。</p>
<p>当处理 B 的请求时，因为 lock_key 已经存在了，NX 条件不满足，所以 B 的 SET 命令会失败，返回 NULL。这样就保证了只有 A 能获取到锁。</p>
<p>关键点在于 NX 的语义：<code>NOT EXISTS</code>，只有在 key 不存在的时候才会设置成功。Redis 在执行这个命令时，会先检查 key 是否存在，如果不存在才会设置值，这整个过程是原子的，不会被其他命令打断。</p>
<h4 id="SETNX有什么问题，如何解决？"><a href="#SETNX有什么问题，如何解决？" class="headerlink" title="SETNX有什么问题，如何解决？"></a>SETNX有什么问题，如何解决？</h4><p>使用 SETNX 创建分布式锁时，虽然可以通过设置过期时间来避免死锁，但会误删锁。比如线程 A 获取锁后，业务执行时间比较长，锁过期了。这时线程 B 获取到锁，但线程 A 执行完业务逻辑后，会尝试删除锁，这时候删掉的其实是线程 B 的锁。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20241122191044.png" alt="技术派：Redis 锁"></p>
<p>技术派：Redis 锁</p>
<p>可以通过锁的自动续期机制来解决锁过期的问题，比如 Redisson 的看门狗机制，在后台启动一个定时任务，每隔一段时间就检查锁是否还被当前线程持有，如果是就自动延长过期时间。这样既避免了死锁，又防止了锁被提前释放。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20241122192038.png" alt="技术派：redisson 看门狗"></p>
<p>技术派：redisson 看门狗</p>
<p>memo：2025 年 6 月 2 日修改至此，今天在帮一个学院本球友分析 offer 选择后，他又回复说<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">多亏了星球才能一路走到现在</a>，很满足这个结果。看多了拿大厂 offer 球友的感谢，看到学院本也能取得满意的成绩，我也很开心。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250602113225.png" alt="学院本拿到offer 后对星球的认可"></p>
<p>学院本拿到offer 后对星球的认可</p>
<h4 id="Redisson了解多少？"><a href="#Redisson了解多少？" class="headerlink" title="Redisson了解多少？"></a>Redisson了解多少？</h4><p>Redisson 是一个基于 Redis 的 Java 客户端，它不只是对 Redis 的操作进行简单地封装，还提供了很多分布式的数据结构和服务，比如最常用的分布式锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(&quot;lock&quot;);</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redisson 的分布式锁比 SETNX 完善的得多，它的看门狗机制可以让我们在获取锁的时候省去手动设置过期时间的步骤，它在内部封装了一个定时任务，每隔 10 秒会检查一次，如果当前线程还持有锁就自动续期 30 秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private Long tryAcquire(long waitTime, long leaseTime, TimeUnit unit, long threadId) &#123;</span><br><span class="line">    return get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) &#123;</span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture;</span><br><span class="line">    if (leaseTime != -1) &#123;</span><br><span class="line">        // 手动设置过期时间</span><br><span class="line">        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 启用看门狗机制，使用默认的30秒过期时间</span><br><span class="line">        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,</span><br><span class="line">                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理获取锁成功的情况</span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果获取锁成功且启用看门狗机制</span><br><span class="line">        if (ttlRemaining == null) &#123;</span><br><span class="line">            if (leaseTime != -1) &#123;</span><br><span class="line">                internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scheduleExpirationRenewal(threadId); // 启动看门狗</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，Redisson 还提供了分布式限流器 RRateLimiter，基于令牌桶算法实现，用于控制分布式环境下的访问频率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// API 接口限流</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; getData() &#123;</span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;api.data&quot;</span>);</span><br><span class="line">        limiter.trySetRate(RateType.OVERALL, <span class="number">100</span>, <span class="number">1</span>, RateIntervalUnit.MINUTES);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (limiter.tryAcquire()) &#123;</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok(processData());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 限流触发</span></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(<span class="number">429</span>).body(<span class="string">&quot;Rate limit exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="详细说说Redisson的看门狗机制？"><a href="#详细说说Redisson的看门狗机制？" class="headerlink" title="详细说说Redisson的看门狗机制？"></a>详细说说Redisson的看门狗机制？</h4><p>Redisson 的看门狗机制是一种自动续期机制，用于解决分布式锁的过期问题。</p>
<p>基本原理是这样的：当调用 <code>lock()</code> 方法加锁时，如果没有显式设置过期时间，Redisson 会默认给锁加一个 30 秒的过期时间，同时启用一个名为“看门狗”的定时任务，每隔 10 秒（默认是过期时间的 1&#x2F;3），去检查一次锁是否还被当前线程持有，如果是，就自动续期，将过期时间延长到 30 秒。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918110433.png" alt="郭慕荣博客园：看门狗"></p>
<p>郭慕荣博客园：看门狗</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码展示核心逻辑</span><br><span class="line">private void renewExpiration() &#123;</span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager()</span><br><span class="line">        .newTimeout(new TimerTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run(Timeout timeout) &#123;</span><br><span class="line">                // 用 Lua 脚本检查并续期</span><br><span class="line">                if (redis.call(&quot;get&quot;, lockKey) == currentThreadId) &#123;</span><br><span class="line">                    redis.call(&quot;expire&quot;, lockKey, 30);</span><br><span class="line">                    // 递归调用，继续下一次续期</span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 10, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>续期的 Lua 脚本会检查锁的 value 是否匹配当前线程，如果匹配就延长过期时间。这样就能保证只有锁的真正持有者才能续期。</p>
<p>当调用 <code>unlock()</code> 方法时，看门狗任务会被取消。或者如果业务逻辑执行完但忘记 unlock 了，看门狗也会帮我们自动检查锁，如果锁已经不属于当前线程了，也会自动停止续期。</p>
<p>这样我们就不用担心业务执行时间过长导致锁被提前释放，也避免了手动估算过期时间的麻烦，同时也解决了分布式环境下的死锁问题。</p>
<h4 id="看门狗机制中的检查锁过程是原子操作吗？"><a href="#看门狗机制中的检查锁过程是原子操作吗？" class="headerlink" title="看门狗机制中的检查锁过程是原子操作吗？"></a>看门狗机制中的检查锁过程是原子操作吗？</h4><p>是的，Redisson 使用了 Lua 脚本来保证锁检查的原子性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250603092903.png" alt="二哥的 Java 进阶之路：看门狗 lua 脚本检查锁"></p>
<p>二哥的 Java 进阶之路：看门狗 lua 脚本检查锁</p>
<p>Redis 在执行 Lua 脚本时，会把整个脚本当作一个命令来处理，期间不会执行其他命令。所以 hexists 检查和 expire 续期是原子执行的。</p>
<h4 id="Redlock你了解多少？"><a href="#Redlock你了解多少？" class="headerlink" title="Redlock你了解多少？"></a>Redlock你了解多少？</h4><p>Redlock 是 Redis 作者 antirez 提出的一种分布式锁算法，用于解决单个 Redis 实例作为分布式锁时存在的单点故障问题。</p>
<p>Redlock 的核心思想是通过在多个完全独立的 Redis 实例上同时获取锁来实现容错。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240816113330.png" alt="二哥的 Java 进阶之路：RedissonRedLock"></p>
<p>二哥的 Java 进阶之路：RedissonRedLock</p>
<p>minLocksAmount 方法返回的 <code>locks.size()/2 + 1</code>，正是 Redlock 算法要求的少数服从多数原则。failedLocksLimit 方法会计算允许失败的锁数量，确保即使部分实例失败，只要成功的实例数量超过一半就认为获取锁成功。</p>
<p>红锁会尝试依次向所有 Redis 实例获取锁，并记录成功获取的锁数量，当数量达到 minLocksAmount 时就认为获取成功，否则释放已获取的锁并返回失败。</p>
<p>虽然 Redlock 存在一些争议，比如说时钟漂移问题、网络分区导致的脑裂问题，但它仍然是一个相对成熟的分布式锁解决方案。</p>
<h4 id="红锁能不能保证百分百上锁？"><a href="#红锁能不能保证百分百上锁？" class="headerlink" title="红锁能不能保证百分百上锁？"></a>红锁能不能保证百分百上锁？</h4><p>不能，Redlock 无法保证百分百上锁成功，这是由分布式系统的本质特性决定的。</p>
<p>当有网络分区时，客户端可能无法与足够数量的 Redis 实例通信。比如在 5 个 Redis 实例的部署中，如果网络分区导致客户端只能访问到 2 个实例，那么无论如何都无法满足红锁要求的少数服从多数原则，获取锁的时候必然失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    // ...</span><br><span class="line">    for (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span><br><span class="line">        RLock lock = iterator.next();</span><br><span class="line">        boolean lockAcquired;</span><br><span class="line">        try &#123;</span><br><span class="line">            lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; catch (RedisResponseTimeoutException e) &#123;</span><br><span class="line">            lockAcquired = false; // 网络超时导致失败</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            lockAcquired = false; // 其他异常导致失败</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 如果剩余可尝试的实例数量不足以达到多数派，直接退出</span><br><span class="line">        if (locks.size() - acquiredLocks.size() == failedLocksLimit()) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 检查是否达到多数派要求</span><br><span class="line">    if (acquiredLocks.size() &gt;= minLocksAmount(locks)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        unlockInner(acquiredLocks);</span><br><span class="line">        return false; // 未达到多数派，获取失败</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时钟漂移也会影响成功率。即使所有实例都可达，如果各个 Redis 实例之间存在明显的时钟漂移，或者客户端在获取锁的过程中耗时过长，比如网络延迟、GC 停顿等，都可能会导致锁在获取完成前就过期，从而获取失败。</p>
<p>在实际应用中，可以通过重试机制来提高锁的成功率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; maxRetries; i++) &#123;</span><br><span class="line">    if (redLock.tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(retryDelay);</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure>

<h4 id="项目中有用到分布式锁吗？"><a href="#项目中有用到分布式锁吗？" class="headerlink" title="项目中有用到分布式锁吗？"></a>项目中有用到分布式锁吗？</h4><p>在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/pmhub.html">PmHub</a>项目中，我有使用 Redission 的分布式锁来确保流程状态的更新按顺序执行，且不被其他流程服务干扰。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250602112537.png" alt="PmHub：分布式锁保障流程状态更新"></p>
<p>PmHub：分布式锁保障流程状态更新</p>
<h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><h3 id="49-🌟Redis都有哪些底层数据结构？"><a href="#49-🌟Redis都有哪些底层数据结构？" class="headerlink" title="49.🌟Redis都有哪些底层数据结构？"></a>49.🌟Redis都有哪些底层数据结构？</h3><p>Redis 之所以快，除了基于内存读写之外，还有很重要的一点就是它精心设计的底层数据结构。Redis 总共有 8 种核心的底层数据结构，我按照重要程度来说一下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-a1b2d2f9-6895-4749-9bda-9314f08bca68.png" alt="三分恶面渣逆袭：Redis Object对应的映射"></p>
<p>三分恶面渣逆袭：Redis Object对应的映射</p>
<p>首先是 SDS，这是 Redis 自己实现的动态字符串，它保留了 C 语言原生的字符串长度，所以获取长度的时间复杂度是 <code>O(1)</code>，在此基础上还支持动态扩容，以及存储二进制数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-7c038f2c-b5ee-4229-9449-713fab3b1855.png" alt="三分恶面渣逆袭：SDS"></p>
<p>三分恶面渣逆袭：SDS</p>
<p>然后是字典，更底层是用数组+链表实现的哈希表。它的设计很巧妙，用了两个哈希表，平时用第一个，rehash 的时候用第二个，这样可以渐进式地进行扩容，不会阻塞太久。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-9934b4a2-c253-4d42-acf4-c6c940840779.png" alt="三分恶面渣逆袭：字典"></p>
<p>三分恶面渣逆袭：字典</p>
<p>接下来压缩列表 ziplist，这个设计很有意思。Redis 为了节省内存，设计了这种紧凑型的数据结构，把所有元素连续存储在一块内存里。但是它有个致命问题叫”连锁更新”，就是当我们修改一个元素的时候，可能会导致后面所有的元素都要重新编码，性能会急剧下降。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604112041.png" alt="Shubhi Jain：Ziplist"></p>
<p>Shubhi Jain：Ziplist</p>
<p>为了解决压缩列表的问题，Redis 后来设计了 quicklist。这个设计思路很聪明，它把 ziplist 拆分成小块，然后用双向链表把这些小块串起来。这样既保持了 ziplist 节省内存的优势，又避免了连锁更新的问题，因为每个小块的 ziplist 都不会太大。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604112357.png" alt="Mr.于博客园：quicklist"></p>
<p>Mr.于博客园：quicklist</p>
<p>再后来，Redis 又设计了 listpack，这个可以说是 ziplist 的完美替代品。它最大的特点是每个元素只记录自己的长度，不记录前一个元素的长度，这样就彻底解决了连锁更新的问题。Redis 5.0 已经用 listpack 替换了 ziplist。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604113025.png" alt="baseoncpp：listpack"></p>
<p>baseoncpp：listpack</p>
<p>跳表skiplist 主要用在 ZSet 中。它的设计很巧妙，通过多层指针来实现快速查找，平均时间复杂度是 <code>O(log N)</code>。相比红黑树，跳表的实现更简单，而且支持范围查询，这对 Redis 的有序集合来说很重要。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-886ee2a8-fb02-4908-bbba-d4ad2a211094.png" alt="三分恶面渣逆袭：跳表"></p>
<p>三分恶面渣逆袭：跳表</p>
<p>还有整数集合intset，当 Set 中都是整数且元素数量较少时使用，内部是一个有序数组，查找用的二分法。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604113520.png" alt="zhangtielei.com：intset"></p>
<p>zhangtielei.com：intset</p>
<p>最后是双向链表LinkedList，早期版本的 Redis 会在 List 中用到，但 Redis 3.2 后就被 quicklist 替代了，因为纯链表的问题是内存不连续，影响 CPU 缓存性能。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604114217.png" alt="pdai：Redis 底层数据结构和数据类型关系"></p>
<p>pdai：Redis 底层数据结构和数据类型关系</p>
<p>memo：2025 年 6 月 4 日，<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">今天有球友</a>发喜报说拿到了京东零售的实习 offer，并且部门和业务还是挺不错的，恭喜他！6 月份还有机会，冲。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604114432.png" alt="球友拿到了京东的 offer"></p>
<p>球友拿到了京东的 offer</p>
<h4 id="简单介绍下链表？"><a href="#简单介绍下链表？" class="headerlink" title="简单介绍下链表？"></a>简单介绍下链表？</h4><p>Redis 的 linkedlist 是⼀个双向⽆环链表结构，和 Java 中的 <a target="_blank" rel="noopener" href="https://javabetter.cn/collection/linkedlist.html">LinkedList</a> 类似。</p>
<p>节点由 listNode 表示，每个节点都有指向其前置节点和后置节点的指针，头节点的前置和尾节点的后置均指向 null。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-1adef9c0-8feb-4836-8997-84bda96e2498.png" alt="三分恶面渣逆袭：链表linkedlist"></p>
<p>三分恶面渣逆袭：链表linkedlist</p>
<h4 id="关于整数集合，能再详细说说吗？"><a href="#关于整数集合，能再详细说说吗？" class="headerlink" title="关于整数集合，能再详细说说吗？"></a>关于整数集合，能再详细说说吗？</h4><p>整数集合是 Redis 中一个非常精巧的数据结构，当一个 Set 只包含整数元素，并且数量不多时，默认不超过 512 个，Redis 就会用 intset 来存储这些数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-833dbfb2-7c79-4e7b-a143-8a4a2936cdd8.png" alt="三分恶面渣逆袭：整数集合intset"></p>
<p>三分恶面渣逆袭：整数集合intset</p>
<p>intset 最有意思的地方是类型升级机制。它有三种编码方式：16位、32位和 64位，会根据存储的整数大小动态调整。比如原来存的都是小整数，用 16 位编码就够了，但突然插入了一个很大的数，超出了 16 位的范围，这时整个数组会升级到 32 位编码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    uint32_t encoding;   // 编码方式：16位、32位或64位</span><br><span class="line">    uint32_t length;     // 元素数量</span><br><span class="line">    int8_t contents[];   // 保存元素的数组</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>当然了，这种升级是有代价的，因为需要重新分配内存并复制数据，并且是不可逆的，但它的好处是可以节省内存空间，特别是在存储大量小整数时。</p>
<p>另外，所有元素在数组中按照从小到大的顺序排列，这样就可以使用二分查找来定位元素，时间复杂度为 <code>O(log N)</code>。</p>
<h4 id="说一下zset-的底层原理？"><a href="#说一下zset-的底层原理？" class="headerlink" title="说一下zset 的底层原理？"></a>说一下zset 的底层原理？</h4><p>ZSet 是 Redis 最复杂的数据类型，它有两种底层实现方式：压缩列表和跳表。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250605132505.png" alt="0xcafebabe：zset 的底层实现"></p>
<p>0xcafebabe：zset 的底层实现</p>
<p>当保存的元素数量少于 128 个，且保存的所有元素大小都小于 64 字节时，Redis 会采用压缩列表的编码方式；否则就用跳表。</p>
<p>当然，这两个条件都可以通过参数进行调整。</p>
<p>选择压缩列表作为底层实现时，每个元素会使用两个紧挨在一起的节点来保存：第一个节点保存元素的成员，第二个节点保存元素的分值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250605134114.png" alt="0xcafebabe：zset 使用压缩列表"></p>
<p>0xcafebabe：zset 使用压缩列表</p>
<p>所有元素按分值从小到大有序排列，小的放在靠近表头的位置，大的放在靠近表尾的位置。</p>
<p>但跳表的缺点是查找只能按顺序进行，时间复杂度为 <code>O(N)</code>，而且在最坏的情况下，插入和删除操作还可能会引起连锁更新。</p>
<p>当元素数量较多或元素较大时，Redis 会使用 skiplist 的编码方式；这个设计非常的巧妙，同时使用了两种数据结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    zskiplist *zsl;  // 跳跃表</span><br><span class="line">    dict *dict;      // 字典</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>跳表按分数有序保存所有元素，且支持范围查询（如 <code>ZRANGE</code>、<code>ZRANGEBYSCORE</code>），平均时间复杂度为 <code>O(log N)</code>。而哈希表则用来存储成员和分值的映射关系，查找时间复杂度为 <code>O(1)</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250605135850.png" alt="0xcafebabe：zset 使用跳表"></p>
<p>0xcafebabe：zset 使用跳表</p>
<p>虽然同时使用两种结构，但它们会通过指针来共享相同元素的成员和分值，因此不会浪费额外的内存。</p>
<h4 id="你知道为什么Redis-7-0要用listpack来替代ziplist吗？"><a href="#你知道为什么Redis-7-0要用listpack来替代ziplist吗？" class="headerlink" title="你知道为什么Redis 7.0要用listpack来替代ziplist吗？"></a>你知道为什么Redis 7.0要用listpack来替代ziplist吗？</h4><p>答：主要是为了解决压缩列表的一个核心问题——连锁更新。在压缩列表中，每个节点都需要记录前一个节点的长度信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607094736.png" alt="wenfh2020.com：redis ziplist"></p>
<p>wenfh2020.com：redis ziplist</p>
<p>当插入或删除一个节点时，如果这个操作导致某个节点的长度发生了变化，那么后续的节点可能都需要更新它们存储的”前一个节点长度”字段。最坏的情况下，一次操作可能触发整个链表的更新，时间复杂度会从 <code>O(1)</code>退化到 <code>O(n²)</code>。</p>
<p>而 listpack 的设计理念完全不同。它让每个节点只记录自己的长度信息，不再依赖前一个节点的长度。这样就从根本上避免了连锁更新的问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240403105313.png" alt="极客时间：listpack"></p>
<p>极客时间：listpack</p>
<p>listpack 中的节点不再保存其前一个节点的长度，而是保存当前节点的编码类型、数据和长度。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240403105754.png" alt="极客时间：listpack 的元素"></p>
<p>极客时间：listpack 的元素</p>
<h4 id="连锁更新是怎么发生的？"><a href="#连锁更新是怎么发生的？" class="headerlink" title="连锁更新是怎么发生的？"></a>连锁更新是怎么发生的？</h4><p>比如说我们有一个压缩列表，其中有几个节点的长度都是 253 个字节。在 ziplist 的编码中，如果前一个节点的长度小于 254 字节，我们只需要 1 个字节来存储这个长度信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607100252.png" alt="Hello Jelly：连锁更新"></p>
<p>Hello Jelly：连锁更新</p>
<p>但如果在这些节点前面插入一个长度为 254 字节的节点，那么原来只需要 1 个字节存储长度的节点现在需要 5 个字节来存储长度信息。这就会导致后续所有节点的长度信息都需要更新。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动商业化一面的原题：说说 Redis 的 zset，什么是跳表，插入一个节点要构建几层索引</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动面经同学 9 飞书后端技术一面面试原题：Redis 的数据类型，ZSet 的实现</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米暑期实习同学 E 一面面试原题：你知道 Redis 的 zset 底层实现吗</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 23 QQ 后台技术一面面试原题：zset 的底层原理</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手面经同学 7 Java 后端技术一面面试原题：说一下 ZSet 底层结构</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团同学 9 一面面试原题：redis的数据结构底层原理？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 27 云后台技术一面面试原题：Zset的底层实现？</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的得物面经同学 9 面试题目原题：Zset的底层如何实现？</li>
</ol>
</blockquote>
<p>memo：2025 年 6 月 5 日，今天有球友在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">VIP群里</a>咨询 offer 的选择，一个拼多多，一个快手，真让人羡慕的要死啊，😄</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250605142339.png" alt="拼多多和快手的 offer 选择"></p>
<p>拼多多和快手的 offer 选择</p>
<h3 id="50-Redis-为什么不用-C-语言的原生字符串？"><a href="#50-Redis-为什么不用-C-语言的原生字符串？" class="headerlink" title="50.Redis 为什么不用 C 语言的原生字符串？"></a>50.Redis 为什么不用 C 语言的原生字符串？</h3><p>第一，C 语言的字符串其实就是字符数组，以 <code>\0</code> 结尾，这意味着如果数据本身包含 <code>\0</code> 字节，就会被误认为字符串结束。但 Redis 需要存储各种类型的数据，包括图片、序列化对象等二进制数据，这些数据中很可能包含 <code>\0</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-2541fd26-4e84-467d-8d8c-c731154a85d7.png" alt="三分恶面渣逆袭：C语言的字符串"></p>
<p>三分恶面渣逆袭：C语言的字符串</p>
<p>第二，如果需要获取字符串长度，C 语言只能调用 <code>strlen()</code> 函数，时间复杂度是 <code>O(N)</code>，因为要遍历整个字符串直到遇到 <code>\0</code>。</p>
<p>第三，C 语言的字符串不会自动检查边界，如果往一个字符数组里写入超过其容量的数据，就会出现缓冲区溢出。</p>
<p>第四，C 语言的字符串不支持动态扩容，如果需要修改内容，就必须重新分配内存并复制数据，开销很大。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-fc26a4e7-1c8d-4e82-b7f8-1f6b43d16d38.png" alt="三分恶面渣逆袭：Redis sds"></p>
<p>三分恶面渣逆袭：Redis sds</p>
<p>Redis 设计的 SDS 完美解决了这些问题，获取长度可以直接通过 <code>len</code> 字段，时间复杂度为 <code>O(1)</code>；<code>free</code> 字段会记录剩余空间，因此 Redis 可以根据预分配策略动态扩容，不用在追加数据时重新分配内存；并且不依赖于 <code>\0</code> 结尾，可以存储任意二进制数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sds &#123;</span><br><span class="line">    int len;        // 字符串长度</span><br><span class="line">    int free;       // 剩余空间</span><br><span class="line">    char buf[];     // 字符数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="51-你研究过-Redis-的字典源码吗？"><a href="#51-你研究过-Redis-的字典源码吗？" class="headerlink" title="51.你研究过 Redis 的字典源码吗？"></a>51.你研究过 Redis 的字典源码吗？</h3><p>是的，有研究过。Redis 的字典分为三层，最外层是一个 dict 结构，包含两个哈希表 <code>ht[0]</code> 和 <code>ht[1]</code>，用于存储键值对。每个哈希表由一个数组和链表组成，数组用于快速定位，链表用于解决哈希冲突。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-e08347a6-efd5-47c0-9adb-23baff82dbbd.png" alt="三分恶面渣逆袭：Redis字典"></p>
<p>三分恶面渣逆袭：Redis字典</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 最外层的字典结构</span><br><span class="line">typedef struct dict &#123;</span><br><span class="line">    dictht ht[2];       // 两个哈希表！这是关键</span><br><span class="line">    long rehashidx;     // rehash索引，-1表示没有进行rehash</span><br><span class="line">    // ...</span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line">// 哈希表结构</span><br><span class="line">typedef struct dictht &#123;</span><br><span class="line">    dictEntry **table;  // 哈希表数组</span><br><span class="line">    unsigned long size; // 哈希表大小</span><br><span class="line">    unsigned long sizemask; // 哈希表大小掩码，用于计算索引值</span><br><span class="line">    unsigned long used; // 该哈希表已有节点的数量</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line">// 哈希表节点</span><br><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    void *key;              // 键</span><br><span class="line">    v;                 // 值</span><br><span class="line">    struct dictEntry *next; // 指向下个哈希表节点，形成链表</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>字典最核心的特点是渐进式 rehash，这是我觉得最精彩的部分。传统的哈希表扩容都是一次性完成的，但 Redis 不是这样的。</p>
<p>当负载因子触发 rehash 条件时，Redis 会为哈希表1 分配新的空间，通常是哈希表 0 的两倍大小，然后将 rehashidx 设置为 0。</p>
<p>接下来的关键是，Redis 不会一次性把所有数据从哈希表0 迁移到哈希表1，而是每次操作字典时，顺便迁移哈希表0 中 rehashidx 位置上的所有键值对。迁移完一个槽位后，rehashidx 递增，直到整个哈希表0 迁移完毕。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250606105102.png" alt="Kousik Nath：Redis rehash"></p>
<p>Kousik Nath：Redis rehash</p>
<p>这种设计的巧妙之处在于把 rehash 的开销分摊到了每次操作中。假设有一个几百万键的哈希表，如果一次性 rehash 可能需要几百毫秒，这对单线程的 Redis 来说是灾难性的。但通过渐进式 rehash，每次操作只增加很少的额外开销，用户基本感觉不到延迟。</p>
<p>在 rehash 期间，查找操作会先查 哈希表 0，没找到再查哈希表 1；但是新插入的数据只会放到哈希表 1 中。这样既可以保证数据的完整性，又能避免数据的重复。</p>
<h4 id="遇到哈希冲突怎么办？"><a href="#遇到哈希冲突怎么办？" class="headerlink" title="遇到哈希冲突怎么办？"></a>遇到哈希冲突怎么办？</h4><p>Redis 是通过链地址法来解决哈希冲突的，每个哈希表的槽位实际上是一个链表的头指针，当多个键的哈希值映射到同一个槽位时，这些键会以链表的形式串联起来。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250606105352.png" alt="Kousik Nath：哈希冲突"></p>
<p>Kousik Nath：哈希冲突</p>
<p>具体实现上，Redis 会通过哈希表节点的 next 指针，指向下一个具有相同哈希值的节点。当发生冲突时，新的键值对会插入到链表的头部，时间复杂度是 <code>O(1)</code>。查找时需要遍历整个链表，最坏的情况下时间复杂度为 <code>O(n)</code>，但通常链表都比较短。</p>
<p>另外，Redis 设计的哈希函数在分布上也比较均匀，能够有效减少哈希冲突的发生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/* MurmurHash2, by Austin Appleby</span><br><span class="line"> * Note - This code makes a few assumptions about how your machine behaves -</span><br><span class="line"> * 1. We can read a 4-byte value from any address without crashing</span><br><span class="line"> * 2. sizeof(int) == 4</span><br><span class="line"> *</span><br><span class="line"> * And it has a few limitations -</span><br><span class="line"> *</span><br><span class="line"> * 1. It will not work incrementally.</span><br><span class="line"> * 2. It will not produce the same results on little-endian and big-endian</span><br><span class="line"> *    machines.</span><br><span class="line"> */</span><br><span class="line">unsigned int dictGenHashFunction(const void *key, int len) &#123;</span><br><span class="line">    /* &#x27;m&#x27; and &#x27;r&#x27; are mixing constants generated offline.</span><br><span class="line">       They&#x27;re not really &#x27;magic&#x27;, they just happen to work well.  */</span><br><span class="line">    uint32_t seed = dict_hash_function_seed;</span><br><span class="line">    const uint32_t m = 0x5bd1e995;</span><br><span class="line">    const int r = 24;</span><br><span class="line"></span><br><span class="line">    /* Initialize the hash to a &#x27;random&#x27; value */</span><br><span class="line">    uint32_t h = seed ^ len;</span><br><span class="line"></span><br><span class="line">    /* Mix 4 bytes at a time into the hash */</span><br><span class="line">    const unsigned char *data = (const unsigned char *)key;</span><br><span class="line"></span><br><span class="line">    while(len &gt;= 4) &#123;</span><br><span class="line">        uint32_t k = *(uint32_t*)data;</span><br><span class="line"></span><br><span class="line">        k *= m;</span><br><span class="line">        k ^= k &gt;&gt; r;</span><br><span class="line">        k *= m;</span><br><span class="line"></span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= k;</span><br><span class="line"></span><br><span class="line">        data += 4;</span><br><span class="line">        len -= 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Handle the last few bytes of the input array  */</span><br><span class="line">    switch(len) &#123;</span><br><span class="line">    case 3: h ^= data[2] &lt;&lt; 16;</span><br><span class="line">    case 2: h ^= data[1] &lt;&lt; 8;</span><br><span class="line">    case 1: h ^= data[0]; h *= m;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /* Do a few final mixes of the hash to ensure the last few</span><br><span class="line">       * bytes are well-incorporated. */</span><br><span class="line">    h ^= h &gt;&gt; 13;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= h &gt;&gt; 15;</span><br><span class="line"></span><br><span class="line">    return (unsigned int)h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>memo：2025 年 6 月 6 日，今<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">天有球友咨询</a>去金山办公暑期实习，要提前学点什么？又一个凭借 Java 这个载体拿到 Go offer 的球友，说明在求职 Go 岗的时候，也不用说非要提前刻意去学习 Go，当然有一些基础是最好的，我之前也整理过 <a target="_blank" rel="noopener" href="https://javabetter.cn/xuexiluxian/go.html">Go 的学习路线</a>在 Java 进阶之路上。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250606111301.png" alt="拿下金山 offer"></p>
<p>拿下金山 offer</p>
<h3 id="52-🌟你了解跳表吗？"><a href="#52-🌟你了解跳表吗？" class="headerlink" title="52.🌟你了解跳表吗？"></a>52.🌟你了解跳表吗？</h3><p>跳表是一种非常巧妙的数据结构，它在有序链表的基础上建立了多层索引，最底层包含所有数据，每往上一层，节点数量就减少一半。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250608111336.png" alt="metahub follower：skiplist"></p>
<p>metahub follower：skiplist</p>
<p>它的核心思想是”用空间换时间”，通过多层索引来跳过大量节点，从而提高查找效率。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-08391728-5ba8-42a0-a287-9284451e0ee7.png" alt="三分恶面渣逆袭：跳表"></p>
<p>三分恶面渣逆袭：跳表</p>
<p>每个节点有 50% 的概率只在第 1 层出现，25% 的概率在第 2 层出现，依此类推。查找的时候从最高层开始水平移动，当下一个节点值大于目标时，就向下跳一层，直到找到目标节点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607102238.png" alt="Dylan Wang：Skiplist"></p>
<p>Dylan Wang：Skiplist</p>
<h4 id="怎么往跳表插入节点呢？"><a href="#怎么往跳表插入节点呢？" class="headerlink" title="怎么往跳表插入节点呢？"></a>怎么往跳表插入节点呢？</h4><p>首先是找到插入位置，从最高层的头节点开始，在每一层都找到应该插入位置的前驱节点，用一个 update 数组把这些前驱节点记录下来。这个查找过程和普通查找一样，在每层向右移动直到下个节点的值大于要插入的值，然后下降到下一层。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 记录每层的插入位置</span><br><span class="line">zskiplistNode *update[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">zskiplistNode *x;</span><br><span class="line">int i, level;</span><br><span class="line"></span><br><span class="line">// 从最高层开始查找</span><br><span class="line">x = zsl-&gt;header;</span><br><span class="line">for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</span><br><span class="line">    // 在当前层水平移动，找到插入位置</span><br><span class="line">    while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">           (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">             sdscmp(x-&gt;level[i].forward-&gt;ele, ele) &lt; 0)))</span><br><span class="line">    &#123;</span><br><span class="line">        x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    update[i] = x;  // 记录每层的前驱节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来随机生成新节点的层数。通常用一个循环，每次有 50% 的概率继续往上，直到随机失败或达到最大层数限制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Redis 中的随机层数生成</span><br><span class="line">int zslRandomLevel(void) &#123;</span><br><span class="line">    int level = 1;</span><br><span class="line">    while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))</span><br><span class="line">        level += 1;</span><br><span class="line">    return (level &lt; ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成新节点的层数</span><br><span class="line">level = zslRandomLevel();</span><br></pre></td></tr></table></figure>

<p>创建新节点后，从底层开始到新节点的最高层，在每一层都进行标准的链表插入操作。这一步要利用之前记录的 update 数组，将新节点插入到正确位置，然后更新前后指针的连接关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 更新前进指针</span><br><span class="line">for (i = 0; i &lt; level; i++) &#123;</span><br><span class="line">    x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">    update[i]-&gt;level[i].forward = x;</span><br><span class="line">    </span><br><span class="line">    // 更新跨度信息</span><br><span class="line">    x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);</span><br><span class="line">    update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新未涉及层的跨度</span><br><span class="line">for (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">    update[i]-&gt;level[i].span++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新后退指针</span><br><span class="line">x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];</span><br><span class="line">if (x-&gt;level[0].forward)</span><br><span class="line">    x-&gt;level[0].forward-&gt;backward = x;</span><br><span class="line">else</span><br><span class="line">    zsl-&gt;tail = x;</span><br><span class="line"></span><br><span class="line">// 更新跳表长度</span><br><span class="line">zsl-&gt;length++;</span><br></pre></td></tr></table></figure>

<p>我们来模拟一个跳表的插入过程，假设插入的数据依次是 22、19、7、3、37、11、26。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607103728.png" alt="zhangtielei.com：跳表插入过程"></p>
<p>zhangtielei.com：跳表插入过程</p>
<p>那假如我们在一个已经分布了 1、14、27、31、44、56、63、70、80、91 的跳表中插入一个 67 的节点，插入过程是这样的：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607104019.png" alt="Dylan Wang：插入节点"></p>
<p>Dylan Wang：插入节点</p>
<h4 id="zset为什么要使用跳表呢？"><a href="#zset为什么要使用跳表呢？" class="headerlink" title="zset为什么要使用跳表呢？"></a>zset为什么要使用跳表呢？</h4><p>第一，跳表天然就是有序的数据结构，查找、插入和删除都能保持 <code>O(log n)</code> 的时间复杂度。</p>
<p>第二，跳表支持范围查询，找到起始位置后可以直接沿着底层链表顺序遍历，满足 ZRANGE 按排名获取元素，或者 ZRANGEBYSCORE 按分值范围获取元素。</p>
<p>memo：2025 年 6 月 7 日，今天给一个学院本球友<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/jianli.html">修改简历</a>的时候，他提到实习的同事，都拿到了 20k 以上的 offer，甚至还有 25k 携程 offer 的，自己并不比他们差，问在实习、项目和能力上还能怎么提高？</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607110105.png" alt="学院本球友的目标和计划"></p>
<p>学院本球友的目标和计划</p>
<p>我想说的是，这就是为什么很多人选择跑来卷互联网开发的原因啊，上线比其他行业高太多了，虽然互联网开发的工作强度也大，但最起码能劳有所获。</p>
<h4 id="跳表是如何定义的呢？"><a href="#跳表是如何定义的呢？" class="headerlink" title="跳表是如何定义的呢？"></a>跳表是如何定义的呢？</h4><p>跳表本质上是一个多层链表，底层是一个包含所有元素的有序链表，上一层作为索引层，包含了下一层的部分节点；层数通过随机算法确定，理论上可以无限高。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250607103155.png" alt="metahub follower：跳表"></p>
<p>metahub follower：跳表</p>
<p>跳表节点包含分值 score、成员对象 obj、一个后退指针 backward，以及一个层级数组 level。每个层级包含 forward 前进指针和 span 跨度信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct skiplistNode &#123;</span><br><span class="line">    double score;                    // 分值（用于排序）</span><br><span class="line">    robj *obj;                      // 数据对象</span><br><span class="line">    struct skiplistNode *backward;   // 后退指针</span><br><span class="line">    struct skiplistLevel &#123;</span><br><span class="line">        struct skiplistNode *forward; // 前进指针</span><br><span class="line">        unsigned int span;           // 跨度（到下个节点的距离）</span><br><span class="line">    &#125; level[];                      // 层级数组</span><br><span class="line">&#125; skiplistNode;</span><br></pre></td></tr></table></figure>

<p>跳表本身包含头尾节点指针、节点总数 length 和当前最大层数 level。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct skiplist &#123;</span><br><span class="line">    struct skiplistNode *header, *tail; // 头尾节点</span><br><span class="line">    unsigned long length;               // 节点数量</span><br><span class="line">    int level;                         // 最大层数</span><br><span class="line">&#125; skiplist;</span><br></pre></td></tr></table></figure>

<h4 id="span-跨度有什么用？"><a href="#span-跨度有什么用？" class="headerlink" title="span 跨度有什么用？"></a>span 跨度有什么用？</h4><p>span 记录了当前节点到下一节点之间，底层到底跨越了几个节点，它的主要作用是快速找到 ZSet 中某个分值的排名。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250608115835.png" alt="Aparajita Pandey：span"></p>
<p>Aparajita Pandey：span</p>
<p>比如说我们执行 <code>ZRANK</code> 命令时，如果没有 span，就需要从头节点开始遍历每个节点，直到找到目标分值，这样时间复杂度是 <code>O(n)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 没有span的排名查询 - O(n)</span><br><span class="line">int getRankWithoutSpan(skiplist *zsl, double score, robj *obj) &#123;</span><br><span class="line">    skiplistNode *x = zsl-&gt;header-&gt;level[0].forward;</span><br><span class="line">    int rank = 0;</span><br><span class="line">    </span><br><span class="line">    while (x) &#123;</span><br><span class="line">        if (x-&gt;score == score &amp;&amp; equalStringObjects(x-&gt;obj, obj)) &#123;</span><br><span class="line">            return rank + 1;  // 排名从1开始</span><br><span class="line">        &#125;</span><br><span class="line">        rank++;</span><br><span class="line">        x = x-&gt;level[0].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但有了 span，我们在从高层往低层搜索的时候，可以直接跳过一些节点，快速定位到目标分值所在的范围。这样就能把时间复杂度降到 <code>O(log n)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">long skiplistGetRank(skiplist *zsl, double score, robj *obj) &#123;</span><br><span class="line">    skiplistNode *x = zsl-&gt;header;</span><br><span class="line">    unsigned long rank = 0;</span><br><span class="line">    </span><br><span class="line">    // 从最高层开始查找</span><br><span class="line">    for (int i = zsl-&gt;level - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">               (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                 compareStringObjects(x-&gt;level[i].forward-&gt;obj, obj) &lt; 0))) &#123;</span><br><span class="line">            </span><br><span class="line">            rank += x-&gt;level[i].span;  // 累加跨度</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 找到目标节点</span><br><span class="line">        if (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">            equalStringObjects(x-&gt;level[i].forward-&gt;obj, obj)) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            return rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么跳表的范围查询效率比字典高？"><a href="#为什么跳表的范围查询效率比字典高？" class="headerlink" title="为什么跳表的范围查询效率比字典高？"></a>为什么跳表的范围查询效率比字典高？</h4><p>字典是通过哈希函数将键值对分散存储的，元素在内存中是无序分布的，没有任何顺序关系。而跳表本身就是有序的数据结构，所有元素按照分值从小到大排列。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250608112525.png" alt="WARRIOR：跳表"></p>
<p>WARRIOR：跳表</p>
<p>当需要进行范围查询时，字典必须遍历所有元素，逐个检查每个元素是否在指定范围内，时间复杂度是 <code>O(n)</code>。比如要找分值在 60 到 80 之间的所有元素，字典只能把整个哈希表扫描一遍，因为它无法知道符合条件的元素在哪里。</p>
<p>而跳表的范围查询就高效多了。首先用 <code>O(log n)</code> 时间找到范围的起始位置，然后沿着底层的有序链表顺序遍历，直到超出范围为止。总时间复杂度是 <code>O(log n + k)</code>，其中 k 是结果集的大小。这种效率差异在数据量大的时候非常明显。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250608113417.png" alt="晴天哥：zset 底层由字典和跳表组成"></p>
<p>晴天哥：zset 底层由字典和跳表组成</p>
<p>这也是为什么 Redis 的 zset 要用跳表而不是纯哈希表的重要原因，因为 zset 经常需要 ZRANGE、ZRANGEBYSCORE 这类范围操作。实际上 Redis 的 zset 是跳表和哈希表的组合：跳表保证有序性支持范围查询，哈希表保证 <code>O(1)</code> 的单点查找效率，两者互补。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米暑期实习同学 E 一面面试原题：为什么 hash 表范围查询效率比跳表低</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的得物面经同学 8 一面面试原题：跳表的结构</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团面经同学 4 一面面试原题：Redis 跳表</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里系面经同学 19 饿了么面试原题：跳表了解吗</li>
</ol>
</blockquote>
<p>memo：2025 年 6 月 8 日，今天<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">有球友发信息</a>称赞 Java 进阶之路的内容写得好，说实话，我是有这个自信的，基本上所写的内容也都是我这些年从读到的所有书籍、视频、教程中提炼到的精华，把一些难懂晦涩的知识都用通俗易懂的语言表达出来，配合手绘图，能让人更容易理解。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-%E4%BA%8C%E5%93%A5%EF%BC%8C%E6%88%91%E6%84%9F%E8%A7%89%E4%BD%A0%E8%BF%99%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%E5%86%99%E7%9A%84%E7%9C%9F%E4%B8%8D%E9%94%99%EF%BC%8C%E2%91%A4%E4%B9%8B%E5%89%8D.png" alt="球友对二哥的 Java 进阶之路的称赞"></p>
<p>球友对二哥的 Java 进阶之路的称赞</p>
<h3 id="53-压缩列表了解吗？"><a href="#53-压缩列表了解吗？" class="headerlink" title="53.压缩列表了解吗？"></a>53.压缩列表了解吗？</h3><p>答：压缩列表是 Redis 为了节省内存而设计的一种紧凑型数据结构，它会把所有数据连续存储在一块内存当中。</p>
<p>整个结构包含头部信息，如总的字节数、尾部偏移量、节点数量，以及连续的节点数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-6be492f7-9f92-4607-a4c4-81a612a3d7bd.png" alt="三分恶面渣逆袭：压缩列表组成部分"></p>
<p>三分恶面渣逆袭：压缩列表组成部分</p>
<p>当 list、hash 和 set 的数据量较小且值都不大时，底层会使用压缩列表来实现。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20241225105623.png" alt="截图来自 Redis 官网"></p>
<p>截图来自 Redis 官网</p>
<p>通常情况在，每个节点包含三个部分：前一个节点的长度、编码类型和实际的数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250609093621.png" alt="happytree001：ziplist entry"></p>
<p>happytree001：ziplist entry</p>
<p>前一个节点的长度是为了支持从后往前遍历；当前一个节点的长度小于 254 字节时，使用 1 字节存储；否则用 5 字节存储，第一个字节设置为 254，后四个字节存储实际长度。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250609093736.png" alt="happytree001：ziplist prevlen"></p>
<p>happytree001：ziplist prevlen</p>
<p>编码类型会根据数据的实际情况选择最紧凑的存储方式。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b5d224c2-53ee-40a3-9efc-2feb7dd3d7a8.png" alt="三分恶面渣逆袭：压缩列表示例"></p>
<p>三分恶面渣逆袭：压缩列表示例</p>
<p>但压缩列表有个致命问题，就是连锁更新。当插入或删除节点导致某个节点长度发生变化时，可能会影响后续所有节点存储的“前一个节点长度”字段，最坏情况下时间复杂度会退化到 <code>O(n²)</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250604112846.png" alt="hjcenry.com：连锁更新"></p>
<p>hjcenry.com：连锁更新</p>
<h4 id="ziplist-的节点数量会超过-65535-吗？"><a href="#ziplist-的节点数量会超过-65535-吗？" class="headerlink" title="ziplist 的节点数量会超过 65535 吗？"></a>ziplist 的节点数量会超过 65535 吗？</h4><p>不会。</p>
<p>Zllen 字段的类型是 <code>uint16_t</code>，最大值为 65535，也就是 2 的 16次方，所以压缩列表的节点数量不会超过 65535。</p>
<p>当节点数量小于 65535 时，该字段会存储实际的数量；否则该字段就固定为 65535，实际存储的数量需要逐个遍历节点来计算。</p>
<h4 id="ziplist-的编码类型了解多少？"><a href="#ziplist-的编码类型了解多少？" class="headerlink" title="ziplist 的编码类型了解多少？"></a>ziplist 的编码类型了解多少？</h4><p>ziplist 的编码类型设计得很精巧，主要分为字符串编码和整数编码两大类，目的是用最少的字节存储数据。</p>
<p>比如 0 到 12 这些小整数直接编码在 type 字段中，只需要 1 个字节。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>11000000</td>
<td>1字节</td>
<td>int16_t类型整数，2 字节</td>
</tr>
<tr>
<td>11010000</td>
<td>1字节</td>
<td>int32_t类型整数，4 字节</td>
</tr>
<tr>
<td>11100000</td>
<td>1字节</td>
<td>int64_t类型整数，8 字节</td>
</tr>
<tr>
<td>11110000</td>
<td>1字节</td>
<td>24位有符号整数 ，3 字节</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1字节</td>
<td>数据范围在[0-12]，数据包含在编码中</td>
</tr>
</tbody></table>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250609094439.png" alt="happytree001：ziplist 小整数编码"></p>
<p>happytree001：ziplist 小整数编码</p>
<p>对于字符串编码，根据字符串长度有三种格式。长度小于 63 字节的用 00 开头的单字节编码，剩余 6 位存储长度。长度在 63 到 16383 之间的用 01 开头的双字节编码，剩余 14 位存储长度。超过 16383 字节的用 10 开头，后面跟 4 字节存储长度。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>00pppppp</td>
<td>1字节</td>
<td>0-63 字节的字符串</td>
</tr>
<tr>
<td>01pppppp qqqqqqqq</td>
<td>2字节</td>
<td>64-16383字节的字符串</td>
</tr>
<tr>
<td>10______ qqqqqqqq rrrrrrrr ssssssss tttttttt</td>
<td>5字节</td>
<td>16384-4294967295字节的字符串</td>
</tr>
</tbody></table>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250609094615.png" alt="happytree001：ziplist 字符串编码"></p>
<p>happytree001：ziplist 字符串编码</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的同学 30 腾讯音乐面试原题：什么情况下使用压缩列表</li>
</ol>
</blockquote>
<p>memo：2025 年 6 月 9 日修改至此，今天<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">有球友特意发私信</a>，感谢面渣逆袭对他的帮助。对，这么棒的内容，我依然选择了免费，因为我相信知识是有价值的，只有诚恳的分享出来才能让更多人受益。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250609100519.png" alt="球友对面渣逆袭的认可"></p>
<p>球友对面渣逆袭的认可</p>
<h3 id="54-quicklist-了解吗？"><a href="#54-quicklist-了解吗？" class="headerlink" title="54.quicklist 了解吗？"></a>54.quicklist 了解吗？</h3><p>quicklist 是 Redis 在 3.2 版本时引入的，专门用于 List 的底层实现，它实际上是一个混合型数据结构，结合了压缩列表和双向链表的优点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-3b9785b0-6573-4c2d-8b7d-d5d1be799e26.png" alt="三分恶面渣逆袭：quicklist"></p>
<p>三分恶面渣逆袭：quicklist</p>
<p>在早期的版本中，List 会根据元素的数量和大小采用两种不同的底层数据结构，当元素较少或者较小时，会使用压缩列表；否则用双向链表。</p>
<p>但这种设计有个问题，就是当 List 中的元素数量较多时，压缩列表会因为连锁更新导致性能下降，而双向链表又会占用更多内存。</p>
<p>quicklist 通过将 List 拆分为多个小的 ziplist，再通过指针链接成一个双向链表，巧妙的解决了这个问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250610105328.png" alt="影中人lx：quicklist"></p>
<p>影中人lx：quicklist</p>
<p>默认情况下，每个 ziplist 可以存储 8KB 的数据，假如每个元素的大小恰好是 1KB，那么一个 quicklist 就可以存储 8 个元素。80 个这样的元素就会被分成 10 个 ziplist。</p>
<p>这样既保留了压缩列表的内存紧凑性，又减少了双向链表指针的数量，进一步降低了内存开销。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250610110115.png" alt="metahub follower：ziplist"></p>
<p>metahub follower：ziplist</p>
<p>除此之外，quicklist 还有一个重要的特性，就是它的可配置性，可以通过填充因子控制每个 ziplist 节点的大小。当填充因子为正数时，它还可以限制每个 ziplist 最多包含的元素数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 填充因子，默认 -2（8KB）</span><br><span class="line">list-max-ziplist-size 10</span><br></pre></td></tr></table></figure>

<p>如果想进一步节省内存，quicklist 还支持对中间节点进行 LZF 压缩，压缩深度为 1 时，表示除了首尾各 1 个节点不压缩外，其他节点都压缩。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 压缩深度，默认 0（不压缩）</span><br><span class="line">list-compress-depth 1</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250610112125.png" alt="wingsxdu.com：LZF 压缩算法"></p>
<p>wingsxdu.com：LZF 压缩算法</p>
<h4 id="LZF-压缩算法了解吗？"><a href="#LZF-压缩算法了解吗？" class="headerlink" title="LZF 压缩算法了解吗？"></a>LZF 压缩算法了解吗？</h4><p>LZF 是一种快速的无损压缩算法，主要用于减少数据存储空间。它的核心思想是通过查找重复数据来实现压缩，通过一个滑动窗口来查找重复的字节序列，并将这些序列替换为更短的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入数据: &quot;hello world hello redis&quot;</span><br><span class="line"></span><br><span class="line">步骤1: 处理 &quot;hello world &quot;</span><br><span class="line">- 建立字典，记录字节序列位置</span><br><span class="line"></span><br><span class="line">步骤2: 遇到重复的 &quot;hello&quot;</span><br><span class="line">- 在字典中找到之前的 &quot;hello&quot; 位置</span><br><span class="line">- 用 (距离, 长度) 对替换: (12, 5)</span><br><span class="line"></span><br><span class="line">输出: &quot;hello world &quot; + (12,5) + &quot; redis&quot;</span><br></pre></td></tr></table></figure>

<p>嗨嗨嗨，时隔两年，面渣逆袭<a target="_blank" rel="noopener" href="https://javabetter.cn/sidebar/sanfene/nixi.html">第二版 PDF 终于可以下载了</a>。我们做了大量的优化：</p>
<ol>
<li><strong>对于高频题</strong>：会标注在《<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>中出现的位置，哪家公司，原题是什么；如果你想节省时间的话，可以优先背诵这些题目，尽快做到知彼知己，百战不殆。</li>
<li><strong>结合项目</strong>：包括<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派</a>、<a target="_blank" rel="noopener" href="https://t.zsxq.com/0bhcI0Gs6">mydb</a>、<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/pmhub.html">pmhub</a>来组织语言，让面试官最大程度感受到你的诚意，而不是机械化的背诵。</li>
<li><strong>修复问题</strong>：第一版中出现的问题，包括球友们的私信反馈，网站留言区的评论，以及<a target="_blank" rel="noopener" href="https://github.com/itwanger/toBeBetterJavaer/issues"> GitHub 仓库中的 issue</a>，让这份面试指南更加完善。</li>
<li><strong>优化排版</strong>：增加手绘图，重新组织答案，使其更加口语化，从而更贴近面试官的预期。</li>
</ol>
<p>你可以扫下面的二维码（或者长按自动识别）关注【<strong>沉默王二</strong>】公众号，发送关键字 <strong>222</strong> 来获取 PDF 版本，如果面渣逆袭真的对你有帮助，希望能给二哥的公众号加一个星标，满足我那一丁点虚荣心，这将是我更新下去的最强动力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="微信扫码或者长按识别，或者微信搜索“沉默王二”"></p>
<p>面渣逆袭的整理工作真的太不容易了，花了我好多好多的时间和精力，内容完全免费，但质量却有口皆碑，就是为了做一点真正有意义的、纯粹的事情。</p>
<p>memo：2025 年 6 月 10 日，今天<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">有球友发信息</a>说找我修改了简历后，又按照星球的学习资料好好学了一下之后，拿到了字节跳动的 offer，并特意发了一个大红包来感谢。这种被认可被需要的感觉，真好！</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-%E4%BA%8C%E5%93%A5%EF%BC%8C%E6%88%91%E6%98%AF%E4%B9%8B%E5%89%8D%E5%8F%91%E9%82%AE%E4%BB%B6%E8%AF%B7%E6%82%A8%E4%BF%AE%E6%94%B9%E7%AE%80.png" alt="球友拿到了字节跳动的 offer"></p>
<p>球友拿到了字节跳动的 offer</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="55-假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#55-假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="55.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>55.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h3><p>我会使用 SCAN 命令配合 MATCH 参数来解决。</p>
<p>比如要找以 <code>user:</code> 开头的 key，可以执行 <code>SCAN 0 MATCH user:* COUNT 1000</code>。</p>
<p>SCAN 的优势在于它是基于游标的增量迭代，每次只返回一小批结果，不会阻塞服务器。可以从游标 0 开始，每次处理返回的 key 列表，然后用返回的下一个游标继续扫描，直到游标回到 0 表示扫描完成。</p>
<p>使用 Spring Data Redis 的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RedisKeyService &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    public List&lt;String&gt; scanKeysByPrefix(String prefix, int batchSize) &#123;</span><br><span class="line">        List&lt;String&gt; keys = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        ScanOptions options = ScanOptions.scanOptions()</span><br><span class="line">                .match(prefix + &quot;*&quot;)</span><br><span class="line">                .count(batchSize)</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        try (Cursor&lt;String&gt; cursor = redisTemplate.scan(options)) &#123;</span><br><span class="line">            while (cursor.hasNext()) &#123;</span><br><span class="line">                keys.add(cursor.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return keys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>千万不要用 KEYS 命令，因为 KEYS 会阻塞 Redis 服务器直到遍历完所有 key，在生产环境中对 1 亿个 key 执行 KEYS 是非常危险的。</p>
<p>memo：2025 年 6 月 11 日修改至此，今天有读者留言说，找实习的时候背了一个月的<a target="_blank" rel="noopener" href="https://javabetter.cn/sidebar/sanfene/nixi.html">面渣逆袭</a>，然后快手和美团都拿到 offer 了。能帮助到，也是我做技术博主最开心的一件事情了，也感谢读者给的口碑。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250612102525.png" alt="拿到快手和美团的读者发来感谢"></p>
<p>拿到快手和美团的读者发来感谢</p>
<h3 id="56-Redis在秒杀场景下可以扮演什么角色？"><a href="#56-Redis在秒杀场景下可以扮演什么角色？" class="headerlink" title="56.Redis在秒杀场景下可以扮演什么角色？"></a>56.Redis在秒杀场景下可以扮演什么角色？</h3><p>秒杀是一种非常特殊的业务场景，它的特点是在极短时间内会有大量用户涌入系统，对系统的并发处理能力、响应速度和数据一致性都提出了极高的要求。在这种场景下，Redis 作为一种高性能的内存数据库，能够发挥多方面的关键作用。</p>
<p>比如说在秒杀开始前，我们可以将商品信息、库存数据等预先加载到 Redis 中，这样大量的用户读请求就可以直接从 Redis 中获取响应，而不必每次都去访问数据库，这样就能大大减轻数据库的访问压力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240420102552.png" alt="许令波-秒杀系统的设计"></p>
<p>许令波-秒杀系统的设计</p>
<p>其次，Redis 在库存控制方面具有得天独厚的优势。秒杀最核心的问题之一就是容易发生超卖。Redis 提供的原子操作如 DECR、DECRBY 等命令，可以确保在高并发环境下库存计数的准确性。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250612103728.png" alt="京东云：超卖"></p>
<p>京东云：超卖</p>
<p>更复杂的逻辑，可以通过 Lua 脚本来实现，因为 Lua 脚本在 Redis 中是原子执行的，所以可以包含复杂的判断和操作逻辑，比如先检查库存是否充足，再进行扣减，这整个过程是不会被其他操作打断的。</p>
<p>第三点，Redis 的分布式锁可以确保多个用户同时抢购同一件商品时的操作是互斥的，保证数据一致性的同时，还可以用来防止用户重复下单。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250612104416.png" alt="小米信息技术团队：Redis 分布式锁"></p>
<p>小米信息技术团队：Redis 分布式锁</p>
<p>第四点，限流削峰。秒杀开始的瞬间，可能会有成千上万的请求同时到达，如果不加控制，很容易导致系统崩溃。Redis 可以实现多种限流算法，比如简单的计数器限流、令牌桶或漏桶算法等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250612104916.png" alt="zhuangyongxin.github.io：令牌桶"></p>
<p>zhuangyongxin.github.io：令牌桶</p>
<p>通过限流算法我们可以控制单位时间内系统能够处理的请求数量，超出部分可以排队或者直接拒绝，从而保护系统的稳定运行。</p>
<p>memo：2025 年 6 月 12 日修改至此，今天<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">有球友发信息说</a>，大二就拿下了美团的实习 offer，特意发来感谢，说我的付出对他有着巨大的帮助，真的很感动，每一个懂得感恩的球友，你们也是我坚持下去的最强动力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250612152123.png" alt="大二那些美团，特意发来感谢，面渣的口碑继续+1"></p>
<p>大二那些美团，特意发来感谢，面渣的口碑继续+1</p>
<h4 id="Redis具体如何实现削峰呢？"><a href="#Redis具体如何实现削峰呢？" class="headerlink" title="Redis具体如何实现削峰呢？"></a>Redis具体如何实现削峰呢？</h4><p>削峰的本质是将瞬时的高流量请求缓冲起来，通过排队、限流等机制，使系统以一个可承受的速度来处理请求。</p>
<p>那第一步就是缓存预热。在秒杀活动开始前，先把商品信息这些热点数据提前加载到 Redis 中。这样用户访问商品页面时，可以直接从 Redis 读取，数据库基本上不会有压力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250613104134.png" alt="天翼云小翼：Redis 缓存预热"></p>
<p>天翼云小翼：Redis 缓存预热</p>
<p>第二步是引入消息队列，特别是下单这种写操作，不能让用户等太久，但后端处理订单、扣库存这些操作又比较重。所以可以用 Redis 的 List 做了个队列，或者直接用 RocketMQ 这种标准的消息中间件，用户下单后立即返回”订单提交成功”，然后把订单数据丢到队列里，后台服务慢慢消费。这样既保证了用户体验，又避免了系统被瞬时写请求压垮。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240420104633.png" alt="许令波-排队"></p>
<p>许令波-排队</p>
<p>第三步，可以在秒杀活动中加入答题环节，只有答对题目的用户才能参与秒杀活动，这样可以最大程度减少无效请求。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240420104921.png" alt="许令波-答题"></p>
<p>许令波-答题</p>
<p>一个比较完整的秒杀削峰处理方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class SeckillServiceImpl implements SeckillService &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private CommodityService commodityService;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 秒杀请求入口</span><br><span class="line">     */</span><br><span class="line">    public Result seckill(Long userId, Long commodityId) &#123;</span><br><span class="line">        // 1. 用户请求频率限制</span><br><span class="line">        if (!countRateLimit(&quot;user:&quot; + userId, 5, 60)) &#123;</span><br><span class="line">            return Result.error(&quot;请求过于频繁&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 2. 商品是否在秒杀时间内</span><br><span class="line">        if (!isInSeckillTime(commodityId)) &#123;</span><br><span class="line">            return Result.error(&quot;秒杀未开始或已结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 3. 是否还有库存(快速失败)</span><br><span class="line">        String stockKey = &quot;seckill:stock:&quot; + commodityId;</span><br><span class="line">        Integer stock = Integer.valueOf(redisTemplate.opsForValue().get(stockKey));</span><br><span class="line">        if (stock != null &amp;&amp; stock &lt;= 0) &#123;</span><br><span class="line">            return Result.error(&quot;商品已售罄&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 4. 全局限流</span><br><span class="line">        if (!acquireToken(&quot;global&quot;, 1000, 100)) &#123;</span><br><span class="line">            // 系统负载过高，将请求放入队列延迟处理</span><br><span class="line">            enqueueDelayedRequest(userId, commodityId);</span><br><span class="line">            return Result.success(&quot;秒杀请求已受理，排队处理中&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 5. 检查用户是否已购买</span><br><span class="line">        if (hasUserBought(userId, commodityId)) &#123;</span><br><span class="line">            return Result.error(&quot;您已经购买过该商品&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 6. 将请求放入队列，返回排队状态</span><br><span class="line">        String requestId = generateRequestId(userId, commodityId);</span><br><span class="line">        enqueueRequest(userId, commodityId, requestId);</span><br><span class="line">        </span><br><span class="line">        return Result.success(&quot;秒杀请求已提交，请等待结果&quot;, requestId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 异步处理秒杀请求</span><br><span class="line">     */</span><br><span class="line">    @Scheduled(fixedRate = 50) // 每50ms处理一批</span><br><span class="line">    public void processSeckillQueue() &#123;</span><br><span class="line">        String queueKey = &quot;seckill:queue&quot;;</span><br><span class="line">        </span><br><span class="line">        // 批量处理，控制处理速度</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            String requestJson = redisTemplate.opsForList().leftPop(queueKey);</span><br><span class="line">            if (requestJson == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            SeckillRequest request = JSON.parseObject(requestJson, SeckillRequest.class);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 执行秒杀核心逻辑</span><br><span class="line">                boolean success = doSeckill(request.getUserId(), request.getCommodityId());</span><br><span class="line">                </span><br><span class="line">                // 更新请求状态，便于用户查询</span><br><span class="line">                String statusKey = &quot;seckill:status:&quot; + request.getRequestId();</span><br><span class="line">                redisTemplate.opsForValue().set(statusKey, success ? &quot;SUCCESS&quot; : &quot;FAILED&quot;, 1, TimeUnit.HOURS);</span><br><span class="line">                </span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.error(&quot;处理秒杀请求失败&quot;, e);</span><br><span class="line">                // 记录失败状态</span><br><span class="line">                String statusKey = &quot;seckill:status:&quot; + request.getRequestId();</span><br><span class="line">                redisTemplate.opsForValue().set(statusKey, &quot;ERROR&quot;, 1, TimeUnit.HOURS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 秒杀核心逻辑</span><br><span class="line">     */</span><br><span class="line">    private boolean doSeckill(Long userId, Long commodityId) &#123;</span><br><span class="line">        // 使用Lua脚本保证原子性操作</span><br><span class="line">        String script = </span><br><span class="line">            &quot;-- 检查库存\n&quot; +</span><br><span class="line">            &quot;local stockKey = KEYS[1]\n&quot; +</span><br><span class="line">            &quot;local stock = tonumber(redis.call(&#x27;get&#x27;, stockKey))\n&quot; +</span><br><span class="line">            &quot;if stock == nil or stock &lt;= 0 then\n&quot; +</span><br><span class="line">            &quot;    return 0\n&quot; +</span><br><span class="line">            &quot;end\n&quot; +</span><br><span class="line">            &quot;\n&quot; +</span><br><span class="line">            &quot;-- 检查是否重复购买\n&quot; +</span><br><span class="line">            &quot;local boughtKey = KEYS[2]\n&quot; +</span><br><span class="line">            &quot;local hasBought = redis.call(&#x27;sismember&#x27;, boughtKey, ARGV[1])\n&quot; +</span><br><span class="line">            &quot;if hasBought == 1 then\n&quot; +</span><br><span class="line">            &quot;    return -1\n&quot; +</span><br><span class="line">            &quot;end\n&quot; +</span><br><span class="line">            &quot;\n&quot; +</span><br><span class="line">            &quot;-- 扣减库存并记录购买\n&quot; +</span><br><span class="line">            &quot;redis.call(&#x27;decr&#x27;, stockKey)\n&quot; +</span><br><span class="line">            &quot;redis.call(&#x27;sadd&#x27;, boughtKey, ARGV[1])\n&quot; +</span><br><span class="line">            &quot;\n&quot; +</span><br><span class="line">            &quot;-- 返回成功\n&quot; +</span><br><span class="line">            &quot;return 1&quot;;</span><br><span class="line">        </span><br><span class="line">        String stockKey = &quot;seckill:stock:&quot; + commodityId;</span><br><span class="line">        String boughtKey = &quot;seckill:bought:&quot; + commodityId;</span><br><span class="line">        </span><br><span class="line">        Long result = (Long) redisTemplate.execute(</span><br><span class="line">            new DefaultRedisScript&lt;&gt;(script, Long.class),</span><br><span class="line">            Arrays.asList(stockKey, boughtKey),</span><br><span class="line">            userId.toString()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        if (result == 1) &#123;</span><br><span class="line">            // 创建订单(可以进一步异步化)</span><br><span class="line">            createOrder(userId, commodityId);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他辅助方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redis如何做限流呢？"><a href="#Redis如何做限流呢？" class="headerlink" title="Redis如何做限流呢？"></a>Redis如何做限流呢？</h4><p>限流是为了控制系统的请求速率，防止系统被过多的请求压垮。</p>
<p>Redis 实现限流最简单的方法是基于计数器的固定窗口限流。比如限制用户每分钟最多访问 100 次，我们就用 INCR 命令给每个用户设个计数器，key 是 <code>rate_limit:用户ID:分钟时间戳</code>，每次请求就加 1，同时设置 60 秒过期。如果计数超过 100 就拒绝请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">String key = &quot;rate_limit:&quot; + userId;</span><br><span class="line">// 尝试获取当前计数</span><br><span class="line">Long count = redis.get(key);</span><br><span class="line">// 如果key不存在，设置为1并设置过期时间</span><br><span class="line">if (count == null) &#123;</span><br><span class="line">    redis.setex(key, 60, &quot;1&quot;); // 60秒窗口期</span><br><span class="line">    return true; // 允许访问</span><br><span class="line">&#125;</span><br><span class="line">// 如果计数未超过限制</span><br><span class="line">if (count &lt; maxRequests) &#123;</span><br><span class="line">    redis.incr(key);</span><br><span class="line">    return true; // 允许访问</span><br><span class="line">&#125;</span><br><span class="line">return false; // 拒绝访问</span><br></pre></td></tr></table></figure>

<p>这种方法简单粗暴，但有个问题就是临界时间会有突刺，比如用户在第 59 秒访问了 100 次，第 61 秒又访问 100 次，相当于 2 秒内访问了 200 次。</p>
<p>第二种就是滑动窗口限流，通过 Redis 的 ZSET 来实现，把每次请求的时间戳作为 score 存进去，然后用 ZREMRANGEBYSCORE 删除窗口外的旧数据，再用 ZCARD 统计当前窗口内的请求数。这样限流就比较均匀了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">String key = &quot;sliding_window:&quot; + userId;</span><br><span class="line">long now = System.currentTimeMillis();</span><br><span class="line">// 添加当前请求到有序集合，score为当前时间戳</span><br><span class="line">redis.zadd(key, now, String.valueOf(now));</span><br><span class="line">// 移除时间窗口之前的请求数据</span><br><span class="line">redis.zremrangeByScore(key, 0, now - windowSize);</span><br><span class="line">// 设置key过期时间，避免冷用户持续占用内存</span><br><span class="line">redis.expire(key, windowSize / 1000 + 1);</span><br><span class="line">// 获取当前窗口的请求数</span><br><span class="line">Long count = redis.zcard(key);</span><br><span class="line">return count &lt;= maxRequests;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，通常会采用令牌桶算法，它就像在帝都&#x2F;魔都买车，摇到号才有资格，没摇到就只能等下一次（😁）。</p>
<p>可以在 Redis 里存两个值，一个是令牌数量，一个是上次更新时间。每次请求时用 Lua 脚本计算应该补充多少令牌，然后判断是否有足够的令牌。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240420114025.png" alt="李子捌：令牌桶"></p>
<p>李子捌：令牌桶</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- Redis Lua脚本实现令牌桶算法</span><br><span class="line">local key = KEYS[1]  -- 限流的key</span><br><span class="line">local max_permits = tonumber(ARGV[1])  -- 最大令牌数</span><br><span class="line">local permits_per_second = tonumber(ARGV[2])  -- 每秒产生的令牌数</span><br><span class="line">local required_permits = tonumber(ARGV[3])  -- 请求的令牌数</span><br><span class="line"></span><br><span class="line">-- 获取当前时间</span><br><span class="line">local time = redis.call(&#x27;time&#x27;)</span><br><span class="line">local now_micros = tonumber(time[1]) * 1000000 + tonumber(time[2])</span><br><span class="line"></span><br><span class="line">-- 获取上次更新的时间和当前存储的令牌数</span><br><span class="line">local last_micros = tonumber(redis.call(&#x27;hget&#x27;, key, &#x27;last_micros&#x27;) or 0)</span><br><span class="line">local stored_permits = tonumber(redis.call(&#x27;hget&#x27;, key, &#x27;stored_permits&#x27;) or 0)</span><br><span class="line"></span><br><span class="line">-- 计算时间间隔内新产生的令牌数</span><br><span class="line">local interval_micros = now_micros - last_micros</span><br><span class="line">local new_permits = interval_micros * permits_per_second / 1000000</span><br><span class="line">stored_permits = math.min(max_permits, stored_permits + new_permits)</span><br><span class="line"></span><br><span class="line">-- 判断令牌是否足够</span><br><span class="line">local result = 0</span><br><span class="line">if stored_permits &gt;= required_permits then</span><br><span class="line">    -- 令牌足够，更新令牌数和时间</span><br><span class="line">    stored_permits = stored_permits - required_permits</span><br><span class="line">    result = 1</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 更新Redis中的数据</span><br><span class="line">redis.call(&#x27;hset&#x27;, key, &#x27;last_micros&#x27;, now_micros)</span><br><span class="line">redis.call(&#x27;hset&#x27;, key, &#x27;stored_permits&#x27;, stored_permits)</span><br><span class="line">redis.call(&#x27;expire&#x27;, key, 10)  -- 设置过期时间，避免长期占用内存</span><br><span class="line"></span><br><span class="line">return result</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的农业银行面经同学 3 Java 后端面试原题：秒杀问题（错峰、削峰、前端、流量控制）</li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的滴滴面经同学 3 网约车后端开发一面原题：限流算法</li>
</ol>
</blockquote>
<p>memo：2025 年 6 月 13 日修改至此，今天在<a target="_blank" rel="noopener" href="https://javabetter.cn/zhishixingqiu/">修改简历</a>的过程中，碰到一位西安交通大学的球友，他整个校园经历是比较丰富的，先去了新加坡国立大学做暑期交换生，然后又去了加州大学伯克利分校做学期交换生，希望也都能在学校阶段尽量丰富自己的经历，争取多拿一些奖学金、实习经历，这样才能在毕业时有更强的竞争力。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250613110150.png" alt="西安交通大学的球友"></p>
<p>西安交通大学的球友</p>
<h3 id="57-客户端宕机后-Redis-服务端如何感知到？"><a href="#57-客户端宕机后-Redis-服务端如何感知到？" class="headerlink" title="57.客户端宕机后 Redis 服务端如何感知到？"></a>57.客户端宕机后 Redis 服务端如何感知到？</h3><p>TCP 的 keepalive 是 Redis 用来检测客户端连接状态的主要机制，默认值为 300 秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 针对低延迟场景，设置为60秒，表示每60秒发送一次keepalive探测</span><br><span class="line">config set tcp-keepalive 60</span><br></pre></td></tr></table></figure>

<p>当客户端与服务器在指定时间内没有任何数据交互时，Redis 服务器会发送 TCP ACK 探测包，如果连续多次没有收到响应，TCP 协议栈会通知 Redis 服务端连接已断开，之后，Redis 服务端会清理相关的连接资源，释放连接。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.tobebetterjavaer.com/stutymore/redis-20250614112846.png" alt="二哥的Java进阶之路：默认的tcp-keepalive和 timeout"></p>
<p>二哥的Java进阶之路：默认的tcp-keepalive和 timeout</p>
<p>另外还有一个 timeout 参数，用来控制客户端连接的空闲超时时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 表示600秒内没有任何命令则断开连接</span><br><span class="line">config set timeout 600</span><br></pre></td></tr></table></figure>

<p>默认值为 0，表示永不断开连接；当设置为非零值时，如果客户端在指定时间内没有发送任何命令，服务端会主动断开连接。</p>
<p>Redis 服务器会定期检查空闲连接是否超时，检查频率由 hz 参数控制；这将有助于释放那些客户端异常退出但 TCP 连接未正常关闭的资源。</p>
<p>不同的连接池也会有自己的连接检测机制，比如 Jedis 连接池可以通过设置 <code>testOnBorrow</code> 和 <code>testWhileIdle</code> 来启用连接检测。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 是否启用连接池</span><br><span class="line">spring.redis.jedis.pool.enabled=true</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.jedis.pool.max-active=200</span><br><span class="line"># 连接池最大空闲连接数</span><br><span class="line">spring.redis.jedis.pool.max-idle=200</span><br><span class="line"># 连接池最小空闲连接数</span><br><span class="line">spring.redis.jedis.pool.min-idle=50</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.jedis.pool.max-wait=3000</span><br><span class="line"># 空闲连接检查间隔（毫秒）</span><br><span class="line">spring.redis.jedis.pool.time-between-eviction-runs=60000</span><br></pre></td></tr></table></figure>

<div class="article-footer slide-up fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap slide-up" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/07/22/Java%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">JavaSE学习笔记-筑基篇开修行路,炼气层破语法障</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/07/22/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B47%E6%9C%88/2025.7.22%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.7.22学习日记</a></div></section></div>







<footer class="page-footer slide-up footnote"><hr><div class="text"><p>本站由 <a href="/">JakicDong</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.0">Stellar 1.30.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper slide-up toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%F0%9F%8C%9F%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF-Redis"><span class="toc-text">1.🌟说说什么是 Redis?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%92%8C-MySQL-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Redis 和 MySQL 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TecHub%E9%A1%B9%E7%9B%AE%E9%87%8C%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86-Redis%EF%BC%9F"><span class="toc-text">TecHub项目里哪里用到了 Redis？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E8%BF%87-Redis-%E5%90%97%EF%BC%9F"><span class="toc-text">部署过 Redis 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E6%9C%89%E9%83%A8%E7%BD%B2%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">Redis 的高可用方案有部署过吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redis-%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2.Redis 可以用来干什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%F0%9F%8C%9FRedis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">3.🌟Redis有哪些数据类型？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="toc-text">详细介绍下字符串？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8B%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="toc-text">详细介绍下列表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8B%E5%93%88%E5%B8%8C%EF%BC%9F"><span class="toc-text">详细介绍下哈希？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8B%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-text">详细介绍下集合？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-text">详细介绍下有序集合？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8BBitmap%EF%BC%9F"><span class="toc-text">详细介绍下Bitmap？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8BHyperLogLog%EF%BC%9F"><span class="toc-text">详细介绍下HyperLogLog？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8BGEO%EF%BC%9F"><span class="toc-text">详细介绍下GEO？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-hash-%E7%B1%BB%E5%9E%8B%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8-string-%E7%B1%BB%E5%9E%8B%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-text">为什么使用 hash 类型而不使用 string 类型序列化存储？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%F0%9F%8C%9FRedis-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%E5%91%A2%EF%BC%9F"><span class="toc-text">4.🌟Redis 为什么快呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%83%BD%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-text">5.能详细说一下IO多路复用吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4-select%E3%80%81poll%E3%80%81epoll%E3%80%81kqueue-%E5%92%8C-IOCP-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">请说说 select、poll、epoll、kqueue 和 IOCP 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E4%B8%80%E4%B8%8B-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-text">举个例子说一下 IO 多路复用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E5%AD%90%E8%AF%B4%E4%B8%80%E4%B8%8B%E9%98%BB%E5%A1%9E-IO%E5%92%8C-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="toc-text">举例子说一下阻塞 IO和 IO 多路复用的差别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select%E3%80%81poll-%E5%92%8C-epoll-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">select、poll 和 epoll 的实现原理？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A9%E6%9C%9F%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">6.Redis为什么早期选择单线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Redis-6-0-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B"><span class="toc-text">7.Redis 6.0 使用多线程是怎么回事?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AF%B4%E8%AF%B4-Redis-%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">8.说说 Redis 的常用命令（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4-set-%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-text">详细说说 set 命令？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sadd-%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">sadd 命令的时间复杂度是多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#incr%E5%91%BD%E4%BB%A4%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">incr命令了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84Redis-QPS-%E8%83%BD%E5%88%B0%E5%A4%9A%E5%B0%91%EF%BC%9F-%E8%A1%A5%E5%85%85"><span class="toc-text">9.单线程的Redis QPS 能到多少？(补充)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%F0%9F%8C%9FRedis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">10.🌟Redis的持久化方式有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B-RDB%EF%BC%9F"><span class="toc-text">详细说一下 RDB？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91-RDB-%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-text">什么情况下会自动触发 RDB 持久化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B-AOF%EF%BC%9F"><span class="toc-text">详细说一下 AOF？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E7%9A%84%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">AOF 的刷盘策略了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4AOF%E7%9A%84%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">说说AOF的重写机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E9%87%8D%E5%86%99%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">AOF 重写的具体过程是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">AOF 文件存储的是什么类型的数据？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E9%87%8D%E5%86%99%E6%9C%9F%E9%97%B4%E5%91%BD%E4%BB%A4%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%86%99%E5%85%A5%E4%B8%A4%E6%AC%A1%EF%BC%8C%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">AOF重写期间命令可能会写入两次，会造成什么影响？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-RDB-%E5%92%8C-AOF-%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">11.RDB 和 AOF 各自有什么优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-RDB-%E5%92%8C-AOF-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">12.RDB 和 AOF 如何选择？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Redis%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">13.Redis如何恢复数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%F0%9F%8C%9FRedis-4-0-%E7%9A%84%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">14.🌟Redis 4.0 的混合持久化了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">如何设置持久化模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE-RDB-%E5%92%8C-AOF-%E7%9A%84%EF%BC%9F"><span class="toc-text">你在开发中是怎么配置 RDB 和 AOF 的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">15.主从复制了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">主从复制的主要作用是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%9F"><span class="toc-text">什么情况下会出现主从复制数据不一致？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">主从复制数据不一致的解决方案有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Redis%E4%B8%BB%E4%BB%8E%E6%9C%89%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">16.Redis主从有几种常见的拓扑结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">17.Redis的主从复制原理了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-text">18.详细说说全量同步和增量同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-text">19.主从复制存在哪些问题呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">脑裂问题了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">20.Redis哨兵机制了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-Redis%E5%93%A8%E5%85%B5%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-text">21.Redis哨兵的工作原理知道吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-Redis%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">22.Redis领导者选举了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%96%B0%E7%9A%84%E4%B8%BB%E8%8A%82%E7%82%B9%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A2%AB%E6%8C%91%E9%80%89%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F"><span class="toc-text">23.新的主节点是怎样被挑选出来的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Redis%E9%9B%86%E7%BE%A4%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">24.Redis集群了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E8%AF%B7%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E8%AF%B4Redis-Cluster%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">25.请详细说一说Redis Cluster？（补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="toc-text">26.集群中数据如何分区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%83%BD%E8%AF%B4%E8%AF%B4-Redis-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">27.能说说 Redis 集群的原理吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2-Redis-%E9%9B%86%E7%BE%A4%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%87%A0%E4%B8%AA%E7%89%A9%E7%90%86%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="toc-text">部署 Redis 集群至少需要几个物理节点？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%AF%B4%E8%AF%B4Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8A%A8%E6%80%81%E4%BC%B8%E7%BC%A9%EF%BC%9F"><span class="toc-text">28.说说Redis集群的动态伸缩？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MOVED-%E5%92%8C-ASK-%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">MOVED 和 ASK 重定向的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="toc-text">缓存设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%F0%9F%8C%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F"><span class="toc-text">29.🌟什么是缓存击穿？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F"><span class="toc-text">什么是缓存穿透？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F"><span class="toc-text">什么是缓存雪崩？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%F0%9F%8C%9F%E8%83%BD%E8%AF%B4%E8%AF%B4%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%97%EF%BC%9F"><span class="toc-text">30.🌟能说说布隆过滤器吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AD%98%E5%9C%A8%E8%AF%AF%E5%88%A4%E5%90%97%EF%BC%9F"><span class="toc-text">布隆过滤器存在误判吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%94%AF%E6%8C%81%E5%88%A0%E9%99%A4%E5%90%97%EF%BC%9F"><span class="toc-text">布隆过滤器支持删除吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E8%80%8C%E6%98%AF%E7%94%A8%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9F"><span class="toc-text">为什么不能用哈希表而是用布隆过滤器？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%F0%9F%8C%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E2%BC%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-text">31.🌟如何保证缓存和数据库的数据⼀致性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E5%86%8D%E6%9D%A5%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-text">那再来说说为什么要删除缓存而不是更新缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E5%86%8D%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-text">那再说说为什么要先更新数据库，再删除缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E5%81%87%E5%A6%82%E5%AF%B9%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E8%A6%81%E6%B1%82%E5%BE%88%E9%AB%98%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%E5%91%A2%EF%BC%9F"><span class="toc-text">那假如对缓存数据库一致性要求很高，该怎么办呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E8%87%B4%EF%BC%9F"><span class="toc-text">32.如何保证本地缓存和分布式缓存的一致？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A4%9A%E4%B8%AA%E5%9C%B0%E6%96%B9%E9%83%BD%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%B0%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%BF%99%E4%B8%80%E5%9D%97%EF%BC%9F"><span class="toc-text">如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C-Redis-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">本地缓存和 Redis 的区别了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%ADKey%EF%BC%9F"><span class="toc-text">33.什么是热Key？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E6%80%8E%E4%B9%88%E7%9B%91%E6%8E%A7%E7%83%ADKey-%E5%91%A2%EF%BC%9F"><span class="toc-text">那怎么监控热Key 呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E9%82%A3%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%83%ADKey-%E5%91%A2%EF%BC%9F"><span class="toc-text">34.那怎么处理热Key 呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%A4%A7-Key-%E5%91%A2%EF%BC%9F"><span class="toc-text">35.怎么处理大 Key 呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E6%80%8E%E4%B9%88%E5%81%9A%E5%91%A2%EF%BC%9F"><span class="toc-text">36.缓存预热怎么做呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E6%97%A0%E5%BA%95%E6%B4%9E%E9%97%AE%E9%A2%98%E5%90%AC%E8%AF%B4%E8%BF%87%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">37.无底洞问题听说过吗？如何解决？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E8%BF%90%E7%BB%B4"><span class="toc-text">Redis 运维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#38-Redis-%E6%8A%A5%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">38.Redis 报内存不足怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-Redis-key%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">39.Redis key过期策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%F0%9F%8C%9FRedis%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">40.🌟Redis有哪些内存淘汰策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-LRU-%E5%92%8C-LFU-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">41.LRU 和 LFU 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-Redis%E5%8F%91%E7%94%9F%E9%98%BB%E5%A1%9E%E4%BA%86%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">42.Redis发生阻塞了怎么解决？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%BA%94%E7%94%A8"><span class="toc-text">Redis 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#43-Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-text">43.Redis如何实现异步消息队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">44.Redis如何实现延时消息队列?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%F0%9F%8C%9FRedis%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%90%97%EF%BC%9F"><span class="toc-text">45.🌟Redis支持事务吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-Redis-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">说一下 Redis 事务的原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F"><span class="toc-text">Redis 事务有哪些注意点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A%EF%BC%9F"><span class="toc-text">Redis事务为什么不支持回滚？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E6%BB%A1%E8%B6%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%9F%E8%A6%81%E6%80%8E%E4%B9%88%E6%94%B9%E8%BF%9B%EF%BC%9F"><span class="toc-text">Redis事务满足原子性吗？要怎么改进？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E7%9A%84-ACID-%E7%89%B9%E6%80%A7%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%EF%BC%9F"><span class="toc-text">Redis 事务的 ACID 特性如何体现？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E6%9C%89Lua%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9CRedis%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%90%97%EF%BC%9F"><span class="toc-text">46.有Lua脚本操作Redis的经验吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-Redis%E7%9A%84%E7%AE%A1%E9%81%93Pipeline%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">47.Redis的管道Pipeline了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8-Pipeline%E5%91%A2%EF%BC%9F"><span class="toc-text">什么场景下适合使用 Pipeline呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87-Pipeline-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">有了解过 Pipeline 的底层原理吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%F0%9F%8C%9FRedis%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-text">48.🌟Redis能实现分布式锁吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-SETNX-%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-text">Redis如何保证 SETNX 不会发生冲突？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SETNX%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">SETNX有什么问题，如何解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">Redisson了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4Redisson%E7%9A%84%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">详细说说Redisson的看门狗机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E6%A3%80%E6%9F%A5%E9%94%81%E8%BF%87%E7%A8%8B%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%90%97%EF%BC%9F"><span class="toc-text">看门狗机制中的检查锁过程是原子操作吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redlock%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">Redlock你了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%94%81%E8%83%BD%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E7%99%BE%E5%88%86%E7%99%BE%E4%B8%8A%E9%94%81%EF%BC%9F"><span class="toc-text">红锁能不能保证百分百上锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E7%94%A8%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-text">项目中有用到分布式锁吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%F0%9F%8C%9FRedis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">49.🌟Redis都有哪些底层数据结构？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8B%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="toc-text">简单介绍下链表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%EF%BC%8C%E8%83%BD%E5%86%8D%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E5%90%97%EF%BC%9F"><span class="toc-text">关于整数集合，能再详细说说吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bzset-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">说一下zset 的底层原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E4%B8%BA%E4%BB%80%E4%B9%88Redis-7-0%E8%A6%81%E7%94%A8listpack%E6%9D%A5%E6%9B%BF%E4%BB%A3ziplist%E5%90%97%EF%BC%9F"><span class="toc-text">你知道为什么Redis 7.0要用listpack来替代ziplist吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-text">连锁更新是怎么发生的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8-C-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="toc-text">50.Redis 为什么不用 C 语言的原生字符串？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E4%BD%A0%E7%A0%94%E7%A9%B6%E8%BF%87-Redis-%E7%9A%84%E5%AD%97%E5%85%B8%E6%BA%90%E7%A0%81%E5%90%97%EF%BC%9F"><span class="toc-text">51.你研究过 Redis 的字典源码吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">遇到哈希冲突怎么办？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%F0%9F%8C%9F%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%B7%B3%E8%A1%A8%E5%90%97%EF%BC%9F"><span class="toc-text">52.🌟你了解跳表吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%BE%80%E8%B7%B3%E8%A1%A8%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E5%91%A2%EF%BC%9F"><span class="toc-text">怎么往跳表插入节点呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zset%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E5%91%A2%EF%BC%9F"><span class="toc-text">zset为什么要使用跳表呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">跳表是如何定义的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#span-%E8%B7%A8%E5%BA%A6%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">span 跨度有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B7%B3%E8%A1%A8%E7%9A%84%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%AF%94%E5%AD%97%E5%85%B8%E9%AB%98%EF%BC%9F"><span class="toc-text">为什么跳表的范围查询效率比字典高？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">53.压缩列表了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ziplist-%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F%E4%BC%9A%E8%B6%85%E8%BF%87-65535-%E5%90%97%EF%BC%9F"><span class="toc-text">ziplist 的节点数量会超过 65535 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ziplist-%E7%9A%84%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">ziplist 的编码类型了解多少？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-quicklist-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">54.quicklist 了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LZF-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">LZF 压缩算法了解吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E5%81%87%E5%A6%82-Redis-%E9%87%8C%E9%9D%A2%E6%9C%89-1-%E4%BA%BF%E4%B8%AA-key%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89-10w-%E4%B8%AA-key-%E6%98%AF%E4%BB%A5%E6%9F%90%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%89%8D%E7%BC%80%E5%BC%80%E5%A4%B4%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E5%AE%83%E4%BB%AC%E5%85%A8%E9%83%A8%E6%89%BE%E5%87%BA%E6%9D%A5%EF%BC%9F"><span class="toc-text">55.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-Redis%E5%9C%A8%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%8F%AF%E4%BB%A5%E6%89%AE%E6%BC%94%E4%BB%80%E4%B9%88%E8%A7%92%E8%89%B2%EF%BC%9F"><span class="toc-text">56.Redis在秒杀场景下可以扮演什么角色？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%85%B7%E4%BD%93%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%89%8A%E5%B3%B0%E5%91%A2%EF%BC%9F"><span class="toc-text">Redis具体如何实现削峰呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%81%9A%E9%99%90%E6%B5%81%E5%91%A2%EF%BC%9F"><span class="toc-text">Redis如何做限流呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%95%E6%9C%BA%E5%90%8E-Redis-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A6%82%E4%BD%95%E6%84%9F%E7%9F%A5%E5%88%B0%EF%BC%9F"><span class="toc-text">57.客户端宕机后 Redis 服务端如何感知到？</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function (response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function (data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function (error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.30.0" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script defer src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const slideUp = {
      distance: `16px`,
      duration: `800`,
      interval: `100`,
      scale: `1`,
      opacity: 0,
      easing: "ease-out"
    };
    ScrollReveal().reveal('.l_left .slide-up', slideUp);
    ScrollReveal().reveal('.l_main .slide-up', slideUp);
    ScrollReveal().reveal('.l_right .slide-up', slideUp);
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script><script src="/js/check-in.js"></script></div></body></html>
