


<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/">学习博客</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-06-06T16:00:00.000Z">2025-06-07</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-06-30T11:53:36.916Z">2025-06-30</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Java并发篇</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><h3 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h3><ol>
<li>继承Thread类<br>需要重写run方法，然后调用start方法启动线程。</li>
<li>实现Runnable接口<br>需要重写run方法，然后调用start方法启动线程。</li>
<li>实现Callable接口<br>需要重写call方法，然后调用start方法启动线程。有返回值，通过 FutureTask 进⾏封装。</li>
</ol>
<h3 id="实现接口还是继承类？"><a href="#实现接口还是继承类？" class="headerlink" title="实现接口还是继承类？"></a>实现接口还是继承类？</h3><p>实现接口更好一些，java不支持多继承，但可以实现多个接口。</p>
<h2 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor用来管理多个异步操作（多个任务互不干扰，不需要同步操作）。</p>
<p>主要有三种Executor：<br>CachedThreadPool：⼀个任务创建⼀个线程；<br>FixedThreadPool：所有任务只能使⽤固定⼤⼩的线程；<br>SingleThreadExecutor：相当于⼤⼩为 1 的 FixedThreadPool。</p>
<h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>Daemon守护线程是⼀个服务线程，⽤于为其他线程提供服务。<br>所有非守护线程都执⾏完毕后，无论有没有守护线程，程序都会退出。<br>线程启动前可以通过setDaemon() 方法来设置该线程是否为守护线程。</p>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>Thread.sleep() 使当前线程暂停执⾏指定的时间，暂停期间，其他线程可以继续运⾏，不会受到阻塞。<br>sleep()可能会抛出InterruptedException异常，异常不会传回main()，所以必须在Thread类中捕获并处理。</p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>代表线程已经走完了重要的部分，可以让其他线程有机会执行。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>线程完成会自动关闭，但是如果线程异常也会提前关闭。</p>
<h3 id="InterruptedException-异常"><a href="#InterruptedException-异常" class="headerlink" title="InterruptedException 异常"></a>InterruptedException 异常</h3><p>线程在 sleep() 或 wait() 时被中断，会抛出 InterruptedException 异常。</p>
<h3 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h3><p>如果一个线程处于无限循环中，并且没有执行 sleep() 或 wait()，那么可以通过 interrupted() 来判断线程是否被中断。<br>如果线程被中断，interrupted() 会返回 true。<br>如果线程没有被中断，interrupted() 会返回 false。</p>
<h3 id="Executor的中断操作"><a href="#Executor的中断操作" class="headerlink" title="Executor的中断操作"></a>Executor的中断操作</h3><p>调用shutdown()方法会等待所有任务执行完毕后关闭Executor。<br>调用shutdownNow()方法会中断所有任务，相当于调用每个任务的interrupt()方法，然后关闭Executor。</p>
<p>如果只想中断某一个线程，可以通过submit() 方法提交一个Callable任务，然后调用Future的cancel()方法来中断任务。</p>
<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第⼀个是 JVM 实现的<br>synchronized，另⼀个是 JDK 实现的 ReentrantLock。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 是 Java 中的关键字，它可以修饰方法和代码块。<br>修饰方法时，锁的是当前对象。<br>修饰代码块时，锁的是括号中的对象。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
<h3 id="比较synchronized和ReentrantLock"><a href="#比较synchronized和ReentrantLock" class="headerlink" title="比较synchronized和ReentrantLock"></a>比较synchronized和ReentrantLock</h3><ol>
<li>锁的实现<br>synchronized 是 JVM 实现的，⽽ ReentrantLock 是 JDK 实现的。</li>
<li>性能<br>新版本 Java 对 synchronized 进⾏了很多优化，例如⾃旋锁，synchronized 与ReentrantLock 的性能⼤致相同。</li>
<li>等待可中断<br>当持有锁的线程⻓期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br>ReentrantLock 可中断，⽽ synchronized 不⾏。</li>
<li>公平锁<br>公平锁是指多个线程在等待同⼀个锁时，必须按照申请锁的时间顺序来依次获得锁。<br>synchronized 中的锁是⾮公平的，ReentrantLock 默认情况下也是⾮公平的，但是也可以是公平的。</li>
<li>锁绑定多个条件<br>⼀个 ReentrantLock 可以同时绑定多个 Condition 对象。</li>
</ol>
<h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。<br>因为synchronized 是 JVM 实现的，可以保证⾃⼰的线程安全，⽽ ReentrantLock 需要程序员手动释放锁，</p>
<h2 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h2><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>在一个线程中调用另一个线程的 join() 方法，会将当前线程挂起，直到被调用的线程执行完毕。</p>
<h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h3><p>wait() 使当前线程等待，直到其他线程调⽤ notify() 或 notifyAll() 方法。<br>notify() 随机唤醒⼀个等待线程，notifyAll() 唤醒所有等待线程。<br>wait()必须在 synchronized 块中调⽤,否则会抛出IllegalMonitorStateException异常。</p>
<h4 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h4><ol>
<li>wait() 是 Object 的⽅法，sleep() 是 Thread 的⽅法。</li>
<li>wait() 会释放锁，sleep() 不会释放锁。</li>
<li>wait() 可以被 notify() 或 notifyAll() 唤醒，sleep() 只能被中断。</li>
<li>wait() 必须在 synchronized 块中调⽤，sleep() 可以在任何位置调⽤。</li>
</ol>
<h3 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h3><p>java.util.concurrent 提供的 Condition 类，可以再Condition 上调⽤ await() 使线程等待.</p>
<p>相比wait()，await() 可以指定时间，超过时间会⾃动唤醒。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>一个线程通常只有一种状态,并且这里特指jvm线程状态,而不是操作系统线程状态.<br>线程状态有6种:<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250607142842.png" alt="20250607142842"></p>
<h3 id="新建-New"><a href="#新建-New" class="headerlink" title="新建(New)"></a>新建(New)</h3><p>创建后尚未启用.</p>
<h3 id="可运行-Runnable"><a href="#可运行-Runnable" class="headerlink" title="可运行(Runnable)"></a>可运行(Runnable)</h3><p>正在Java虚拟机中执行,但是它可能正在等待操作系统分配处理器资源.</p>
<h3 id="阻塞-Blocked"><a href="#阻塞-Blocked" class="headerlink" title="阻塞(Blocked)"></a>阻塞(Blocked)</h3><p>线程被阻塞,等待其他线程完成操作.</p>
<h3 id="等待-Waiting"><a href="#等待-Waiting" class="headerlink" title="等待(Waiting)"></a>等待(Waiting)</h3><p>线程等待其他线程执行特定操作.</p>
<h3 id="计时等待-Timed-Waiting"><a href="#计时等待-Timed-Waiting" class="headerlink" title="计时等待(Timed Waiting)"></a>计时等待(Timed Waiting)</h3><p>线程等待指定的时间.</p>
<h3 id="终止-Terminated"><a href="#终止-Terminated" class="headerlink" title="终止(Terminated)"></a>终止(Terminated)</h3><p>线程已经完成执行.</p>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250607143046.png" alt="20250607143046"></p>
<h2 id="J-U-C-AQS"><a href="#J-U-C-AQS" class="headerlink" title="J.U.C - AQS"></a>J.U.C - AQS</h2><p>java.util.concurrent （J.U.C）⼤⼤提⾼了并发性能，AQS 被认为是 J.U.C 的核⼼。<br>AQS是AbstractQueuedSynchronizer的缩写,是Java并发包中用来实现锁的基础框架.</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch用来控制一个或多个线程等待其他线程完成操作.</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>用来控制多个线程互相等待，直到到达某个公共屏障点（common barrier point）。<br>和CountDownLatch不同的是，CyclicBarrier的计数器可以被重置后使用，所以它被称为循环屏障。</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<h2 id="J-U-C-其它组件"><a href="#J-U-C-其它组件" class="headerlink" title="J.U.C - 其它组件"></a>J.U.C - 其它组件</h2><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>实现了Future接口和Runnable接口,可以作为Runnable被线程执行,也可以用来获取异步执行的结果.<br>适用于需要异步执行任务,并且需要获取结果的场景.</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>阻塞队列,可以用来实现生产者-消费者模式.</p>
<p>java.util.concurrent.BlockingQueue 接⼝有以下阻塞队列的实现：<br>FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定⻓度）<br>优先级队列 ：PriorityBlockingQueue</p>
<h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>和MapReduce类似,可以将⼤量的数据拆分成⼩量的数据，然后分⽴计算，最后将结果合并。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到⼀致的内存访问效果。</p>
<h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p>主内存是所有线程共享的内存区域，工作内存是每个线程独有的内存区域。</p>
<p>所有的变量都存储在主内存中，每个线程还有⾃⼰的⼯作内存，⼯作内存存储在⾼速缓存或者寄存器中，保存了该线程使⽤的变量的主内存副本拷⻉。<br>线程只能直接读写⾃⼰的⼯作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250607151535.png" alt="20250607151535"></p>
<h3 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250607151926.png" alt="20250607151926"></p>
<p>java内存模型规定了8种操作来完成主内存和工作内存之间的交互操作：<br>read：把⼀个变量的值从主内存传输到⼯作内存中<br>load：在 read 之后执⾏，把 read 得到的值放⼊⼯作内存的变量副本中<br>use：把⼯作内存中⼀个变量的值传递给执⾏引擎<br>assign：把⼀个从执⾏引擎接收到的值赋给⼯作内存的变量<br>store：把⼯作内存的⼀个变量的值传送到主内存中<br>write：在 store 之后执⾏，把 store 得到的值放⼊主内存的变量中<br>lock：作⽤于主内存的变量<br>unlock:作⽤于主内存的变量</p>
<h3 id="内存模型的三大特性"><a href="#内存模型的三大特性" class="headerlink" title="内存模型的三大特性"></a>内存模型的三大特性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>java内存模型保证了read、load、use、assign、store、write这6个操作是具有原子性的。<br>但是不保证这6个操作的组合是具有原子性的。<br>AtomicInteger 是⼀个提供原子操作的 Integer 类。<br>除了使用原子类外，还可以通过 synchronized 关键字来保证操作的原子性。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可⻅性指当⼀个线程修改了共享变量的值，其它线程能够⽴即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可⻅性的。<br>主要有三种可见性的实现方式:</p>
<ul>
<li>volatile</li>
<li>synchronized，对⼀个变量执⾏ unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造⽅法中⼀旦初始化完成，并且没有发⽣ this 逃逸（其它线程通过 this 引⽤访问到初始化了⼀半的对象），那么其它线程就能看⻅ final 字段的值。</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性指的是在本线程内观察，所有操作都是有序的；如果在⼀个线程观察另⼀个线程，所有操作都是无序的。<br>Java 内存模型是通过禁止指令重排序来保证有序性的。<br>主要有两种有序性的实现方式:</p>
<ul>
<li>volatile</li>
<li>synchronized，对⼀个变量执⾏ unlock 操作之前，必须把变量值同步回主内存。</li>
</ul>
<h3 id="先⾏发⽣原则"><a href="#先⾏发⽣原则" class="headerlink" title="先⾏发⽣原则"></a>先⾏发⽣原则</h3><p>先⾏发⽣原则是指如果在程序中两个操作的先后顺序与代码中的顺序相同，那么这两个操作就会先⾏发⽣。</p>
<h4 id="1-单⼀线程原则"><a href="#1-单⼀线程原则" class="headerlink" title="1. 单⼀线程原则"></a>1. 单⼀线程原则</h4><p>在单⼀线程中，在程序前⾯的操作先⾏发⽣于后⾯的操作。</p>
<h4 id="2-管程锁定规则"><a href="#2-管程锁定规则" class="headerlink" title="2. 管程锁定规则"></a>2. 管程锁定规则</h4><p>⼀个 unlock 操作先⾏发⽣于后⾯对同⼀个锁的 lock 操作。</p>
<h4 id="3-volatile-变量规则"><a href="#3-volatile-变量规则" class="headerlink" title="3. volatile 变量规则"></a>3. volatile 变量规则</h4><p>对⼀个 volatile 变量的写操作先⾏发⽣于后⾯对这个变量的读操作。</p>
<h4 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4. 线程启动规则"></a>4. 线程启动规则</h4><p>Thread 对象的 start() ⽅法调⽤先⾏发⽣于此线程的每⼀个动作。</p>
<h4 id="5-线程加⼊规则"><a href="#5-线程加⼊规则" class="headerlink" title="5. 线程加⼊规则"></a>5. 线程加⼊规则</h4><p>Thread 对象的结束先⾏发⽣于 join() ⽅法返回。</p>
<h4 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6. 线程中断规则"></a>6. 线程中断规则</h4><p>对线程interrupt()⽅法的调⽤先⾏发⽣于被中断线程的代码检测到中断事件的发⽣，可以通过 interrupted() ⽅法检测到是否有中断发⽣。</p>
<h4 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7. 对象终结规则"></a>7. 对象终结规则</h4><p>⼀个对象的初始化完成（构造⽅法执⾏结束）先⾏发⽣于它的 finalize() ⽅法的开始。</p>
<h4 id="8-传递性"><a href="#8-传递性" class="headerlink" title="8. 传递性"></a>8. 传递性</h4><p>如果操作 A 先⾏发⽣于操作 B，操作 B 先⾏发⽣于操作 C，那么操作 A 先⾏发⽣于操作 C。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多个线程不管以何种⽅式访问某个类，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的⾏为，那么就称这个类是线程安全的。</p>
<h3 id="线程安全有以下几种实现方法"><a href="#线程安全有以下几种实现方法" class="headerlink" title="线程安全有以下几种实现方法:"></a>线程安全有以下几种实现方法:</h3><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变（Immutable）的对象⼀定是线程安全的，不需要再采取任何的线程安全保障措施。只<br>要⼀个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不⼀致的状<br>态。多线程环境下，应当尽量使对象成为不可变，来满⾜线程安全。</p>
<p>不可变的类型：<br>final 关键字修饰的基本数据类型<br>String<br>枚举类型<br>Number 部分⼦类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等⼤<br>数据类型。但同为 Number 的原⼦类 AtomicInteger 和 AtomicLong 则是可变的。<br>对于集合类型，我们可以使⽤ Collections.unmodifiableXXX() 方法来获取⼀个不可变的集合。</p>
<h4 id="互斥同步-1"><a href="#互斥同步-1" class="headerlink" title="互斥同步"></a>互斥同步</h4><p>synchronized 和 ReentrantLock。</p>
<h4 id="⾮阻塞同步"><a href="#⾮阻塞同步" class="headerlink" title="⾮阻塞同步"></a>⾮阻塞同步</h4><p>阻塞同步是一种悲观的并发策略，即认为只要不去做正确的同步措施，那就肯定会出现问题。<br>而非阻塞是一种基于冲突检测的乐观并发策略，即不加锁，但是如果存在冲突，就重试当前操作直到成功。</p>
<h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>硬件⽀持的原⼦性操作最典型的是：⽐较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执⾏操作时，只有当 V的值等于 A，才将 V 的值更新为 B。</p>
<p>乐观锁需要操作、冲突检测这两个步骤具备原⼦性，这⾥就不能再使⽤互斥同步来保证了，只能靠硬件来完成。</p>
<h5 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h5><p>J.U.C 包⾥⾯的整数原⼦类 AtomicInteger 的⽅法调⽤了 Unsafe 类的 CAS 操作。</p>
<h5 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h5><p>如果⼀个变量初次读取的时候是 A 值，它的值被改成了 B，后来⼜被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。<br>J.U.C 包提供了⼀个带有标记的原⼦引⽤类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。<br>⼤部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改⽤传统的互斥同步可能会⽐原⼦类更⾼效。</p>
<h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p>要保证线程安全，并不是⼀定就要进⾏同步。如果⼀个⽅法本来就不涉及共享数据，那它⾃然就⽆须任何同步措施去保证正确性。</p>
<h5 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h5><p>多个线程访问同⼀个⽅法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机<br>栈中，属于线程私有的。</p>
<h5 id="线程本地存储（Thread-Local-Storage）"><a href="#线程本地存储（Thread-Local-Storage）" class="headerlink" title="线程本地存储（Thread Local Storage）"></a>线程本地存储（Thread Local Storage）</h5><p>如果⼀个变量在线程的⼀个⽅法中被TLS变量存储，并被其他⽅法读取和修改，那么即使两个线程执⾏的是同⼀个代码，它们也会访问到不同的数据。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>主要是针对synchronized关键字的优化。</p>
<h3 id="⾃旋锁"><a href="#⾃旋锁" class="headerlink" title="⾃旋锁"></a>⾃旋锁</h3><p>⾃旋锁虽然能避免进⼊阻塞状态从⽽减少开销，但是它需要进⾏忙循环操作占⽤ CPU 时间，<br>它只适⽤于共享数据的锁定状态很短的场景。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器在运⾏时，对代码进⾏扫描，去除不可能存在共享数据竞争的锁，<br>通过锁消除，可以节省毫无意义的请求锁时间。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>锁粗化是指虚拟机即时编译器在运⾏时，对代码进⾏扫描，将多个相邻的加锁操作合并为⼀个加锁操作，<br>通过锁粗化，可以节省加锁和释放锁的时间。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>JDK 1.6 引⼊了偏向锁和轻量级锁，从⽽让锁拥有了四个状态：⽆锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p>
<p>轻量级锁相比传统的重量级锁，它使用CAS操作来避免线程阻塞和唤醒的开销，同时也避免了操作系统层面的线程调度。<br>如果轻量级锁自旋或检测到有线程冲突，会升级为重量级锁。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是指在没有线程竞争的情况下，锁对象会偏向于使⽤它的线程，这样就不需要进⾏额外的加锁和解锁操作。</p>
<h2 id="多线程开发良好的实践"><a href="#多线程开发良好的实践" class="headerlink" title="多线程开发良好的实践"></a>多线程开发良好的实践</h2><ul>
<li>给线程起个有意义的名字，这样可以⽅便找 Bug。</li>
<li>缩⼩同步范围，从⽽减少锁争⽤。例如对于 synchronized，应该尽量使⽤同步块⽽不是同步⽅法。</li>
<li>多⽤同步⼯具少⽤ wait()和 notify() 。⾸先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，⽽⽤ wait()和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li>
<li>使⽤ BlockingQueue 实现⽣产者消费者问题。</li>
<li>多⽤并发集合少⽤同步集合，例如应该使⽤ ConcurrentHashMap ⽽不是 Hashtable。</li>
<li>使⽤本地变量和不可变类来保证线程安全。</li>
<li>使⽤线程池⽽不是直接创建线程，这是因为创建线程代价很⾼，线程池可以有效地利⽤有限的线程来启动任务。</li>
</ul>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/06/09/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B46%E6%9C%88/2025.6.9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.6.9学习日记</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/06/07/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B46%E6%9C%88/2025.6.7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.6.7学习日记</a></div></section></div>






