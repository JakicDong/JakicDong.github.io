


<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/">学习博客</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-06-03T16:00:00.000Z">2025-06-04</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-06-30T11:52:54.025Z">2025-06-30</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>技术派项目笔记</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="开启新项目要考虑的事情"><a href="#开启新项目要考虑的事情" class="headerlink" title="开启新项目要考虑的事情"></a>开启新项目要考虑的事情</h1><h2 id="业务模块拆解"><a href="#业务模块拆解" class="headerlink" title="业务模块拆解"></a>业务模块拆解</h2><p>首先对业务模块进行拆解，除了业务属性纬度以外，还有一个很重要的属性就是参与者角色。</p>
<p>首先对功能、模块划分、概要设计，详细设计有初步的了解。</p>
<p>主要就是功能模块设计 + DB 的设计。</p>
<h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><p>mysql 启动<br>redis 启动：<br>路径 ： D:\workTools\Redis-x64-3.2.100</p>
<p><code>redis-server.exe redis.windows.conf</code></p>
<p>启动成功，点击进入首页: <a target="_blank" rel="noopener" href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></p>
<h2 id="跑环境"><a href="#跑环境" class="headerlink" title="跑环境"></a>跑环境</h2><p><code>D:\sys\Desktop\Workplace\IDEA_Projects\paicoding</code>下载位置</p>
<p><code>git clone git@github.com:itwanger/paicoding.git D:\sys\Desktop\Workplace\IDEA_Projects\paicoding</code>git 下载</p>
<p>git clone 出现报错 ， 原因：github ssh 秘钥没有配置 1</p>
<p>打开运行，输入services.msc，确定</p>
<p>找到 OpenSSH Authentication Agent 服务，需开启它.</p>
<p> <strong>ssh-keygen -t rsa -C “你的邮箱地址”</strong></p>
<p>我用的是Administrator用户，执行完后，可以在 C:\Users\Administrator.ssh 目录下生成 <strong>id_rsa</strong> 和 <strong>id_rsa.pub</strong> 这两个文件。如果你没有用Administrator用户，也是在类似的目录下</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>该项目主要有五个模块，各模块功能如下：</p>
<p><strong>paicoding-api：</strong></p>
<p>用于定义一些通用的枚举、实体类，包含 DO（数据对象）、DTO（数据传输对象）、VO（视图对象）等，为不同层之间的数据交互提供统一的格式和规范。</p>
<p><strong>paicoding-core：</strong></p>
<p>核心工具和组件相关的模块，像工具包 util 以及通用的组件都放在这里。按照包路径对模块功能进行拆分，例如搜索、缓存、推荐等功能组件。</p>
<p><strong>paicoding-service：</strong></p>
<p>服务模块，负责业务相关的主要逻辑，数据库（DB）的操作都在这个模块中进行。</p>
<p><strong>paicoding-ui：</strong></p>
<p>存放 HTML 前端资源，包括 JavaScript、CSS、Thymeleaf 等，主要用于构建用户界面。</p>
<p><strong>paicoding-web：</strong></p>
<p>Web 模块，是 HTTP 请求的入口，也是项目启动的入口，同时包含权限身份校验、全局异常处理等功能。</p>
<h2 id="web-模块："><a href="#web-模块：" class="headerlink" title="web 模块："></a>web 模块：</h2><h3 id="admin："><a href="#admin：" class="headerlink" title="admin："></a>admin：</h3><p>admin 目录存放和管理后台相关的代码，主要处理管理员对系统的管理操作。</p>
<h3 id="common："><a href="#common：" class="headerlink" title="common："></a>common：</h3><p>common 一般用来存放项目通用的代码，提高代码的复用性和可维护性。</p>
<h3 id="comoinent："><a href="#comoinent：" class="headerlink" title="comoinent："></a>comoinent：</h3><p>TemplateEngineHelper</p>
<p>Thymeleaf模版渲染引擎，通过末班引擎进行服务端渲染（SSR），在初次渲染速度方面有显著优势。</p>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>ForumDataSourceInitializer</p>
<p>用来进行数据库表的初始化，首次启动时候执行：</p>
<p>DbChangeSetLoader</p>
<h1 id="杂项笔记"><a href="#杂项笔记" class="headerlink" title="杂项笔记"></a>杂项笔记</h1><h2 id="请求参数解析"><a href="#请求参数解析" class="headerlink" title="请求参数解析"></a>请求参数解析</h2><p>如果一个请求不会引起服务器上任何资源的状态变化，那就可以使用 GET 请求</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>技术派中的 AOP 记录接口访问日志是放在 paicoding-core 模块下的 mdc 包下。</p>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><h2 id="为什么要使用微服务而不是单体项目呢？"><a href="#为什么要使用微服务而不是单体项目呢？" class="headerlink" title="为什么要使用微服务而不是单体项目呢？"></a>为什么要使用微服务而不是单体项目呢？</h2><p>用不用微服务取决于业务量，能用单体的绝对不用微服务，毕竟单体的好处显而易见，当业务简单的时候，部署非常简单，技术架构也简单，不用考虑微服务间的调用什么的，但是随着业务的复杂，单体的缺点也就暴露出来了，例如修改一个模块上线，就要整个服务下线，这在某些业务中是不被允许的，其次单体复杂度高了，部署就缓慢了，出现问题排查也很困难，这些的前提就是业务复杂度提高了。</p>
<p>所以微服务的出现在我看来最初就是为了解决业务复杂单体所出现的问题的，将业务拆分到不同的模块，不同的模块单独部署开发，提高了开发效率，节省了维护时间成本，问题排查也方便了很多，微服务也并不是没有缺点，只不过是维护一个平衡，例如需要引入注册中心，为了方便配置的修改，还需要引入配置中心，不可能修改一个配置重新打包发布，服务间的调用组件，很多都是为了使用微服务而引入的。</p>
<p>所以没有哪种技术更好，只有哪种技术更符合当下的业务，抛开业务谈技术，在我看来并不是那么可靠。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>创建型设计模式，定义一个创建对象的接口，但让实现这个接口的类决定实例化哪个类。</p>
<p>工厂方法把类的实例化延迟到子类中进行。</p>
<p><code>@Bean</code> 就是一个工厂方法</p>
<h2 id="各种注解"><a href="#各种注解" class="headerlink" title="各种注解"></a>各种注解</h2><h3 id="Slf4j"><a href="#Slf4j" class="headerlink" title="@Slf4j"></a>@Slf4j</h3><p>@Slf4j：借助 Lombok 自动添加 SLF4J 日志记录器，简化日志记录代码。</p>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>@Configuration：把类标记为 Spring 配置类，允许在类里使用 @Bean 注解定义 Spring Bean。</p>
<p>在 Spring 应用启动时，Spring 会扫描带有 @Configuration 注解的类，将其作为配置类来处理，把类里使用 @Bean 注解定义的方法返回的对象注册到 Spring 容器中。</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>@Component：通用的组件注解，用于标记一个类为 Spring 组件，Spring 会自动扫描并将其注册到容器中。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h3><p>@Service：@Component 的特殊化注解，通常用于标记服务层类。</p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h3><p>@Repository：@Component 的特殊化注解，通常用于标记数据访问层类。</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>@Controller：@Component 的特殊化注解，通常用于标记 Web 控制器类。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p><code>@Bean</code>注册一个实体类</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="@"></a>@</h3><p>册一个实体类</p>
<h1 id="实体对象"><a href="#实体对象" class="headerlink" title="实体对象"></a>实体对象</h1><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250606102137.png" alt="20250606102137"></p>
<h2 id="用-GET-还是-POST"><a href="#用-GET-还是-POST" class="headerlink" title="用 GET 还是 POST"></a>用 GET 还是 POST</h2><p>GET - 从指定的资源请求数据。<br>POST - 向指定的资源提交要被处理的数据。</p>
<p>GET 请求是 HTTP 协议中的一种请求方法，通常用于请求访问指定的资源。如果一个请求不会导致服务器上任何资源的状态变化，那你就可以使用 GET 请求。</p>
<h1 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h1><ol>
<li>首先进入 filter，执行相关业务逻辑</li>
<li>若判定通行，则进入 Servlet 逻辑，Servlet 执行完毕之后，又返回 Filter，最后在返回给请求方</li>
<li>判定失败，直接返回，不需要将请求发给 Servlet</li>
</ol>
<h2 id="过滤器的使用"><a href="#过滤器的使用" class="headerlink" title="过滤器的使用"></a>过滤器的使用</h2><p>如果要使用过滤器，实现 Filter 接口，需要重写 doFilter 方法，在方法中编写过滤逻辑。<br>init: 初始化时执行<br>destory: 销毁时执行<br>doFilter: 重点关注这个，filter 规则命中的请求，都会走进来<br>三个参数，注意第三个 FilterChain，这里是经典的责任链设计模式<br>执行 filterChain.doFilter(servletRequest, servletResponse) 表示会继续将请求执行下去；若不执行这一句，表示这一次的 http 请求到此为止了，后面的走不下去了</p>
<h2 id="过滤器在项目中的应用"><a href="#过滤器在项目中的应用" class="headerlink" title="过滤器在项目中的应用"></a>过滤器在项目中的应用</h2><ol>
<li>身份识别,并保存身份到<code>ReqInfoContext</code>上下文中</li>
<li>记录请求记录</li>
<li>添加跨域支持</li>
</ol>
<h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题:"></a>跨域问题:</h3><p>跨域问题（CORS）的本质是浏览器的安全限制，而代理服务器是解决该问题的关键方案之一。以下通过​​场景化解析​​帮你彻底理解代理机制.</p>
<p>假如说:<br>前端​​：运行在 <a target="_blank" rel="noopener" href="http://localhost:5700/">http://localhost:5700</a><br>​​后端​​：运行在 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a><br>​​问题​​：前端直接请求后端接口时，浏览器会拦截并报错：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250609205544.png" alt="20250609205544"></p>
<p>代理与服务器间的通信属于服务器之间的通信,不受浏览器同源规则的约束.</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet的使用姿势，以及注册自定义的Servelt的四种姿势</p>
<h3 id="●-WebServlet-注解"><a href="#●-WebServlet-注解" class="headerlink" title="● @WebServlet 注解:"></a>● @WebServlet 注解:</h3><p>在自定义的servlet上添加Servlet3+的注解@WebServlet，来声明这个类是一个Servlet<br>和Fitler的注册方式一样，使用这个注解，需要配合Spring Boot的@ServletComponentScan，否则单纯的添加上面的注解并不会生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用注解的方式来定义并注册一个自定义Servlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/annotation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;[AnnotationServlet] welcome &quot;</span> + name);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要配置启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="●-ServletRegistrationBean-bean定义"><a href="#●-ServletRegistrationBean-bean定义" class="headerlink" title="● ServletRegistrationBean bean定义"></a>● ServletRegistrationBean bean定义</h3><p>在Filter的注册中，我们知道有一种方式是定义一个Spring的Bean<code>FilterRegistrationBean</code>来包装我们的自定义Filter，从而让Spring容器来管理我们的过滤器；同样的在Servlet中，也有类似的包装bean: <code>ServletRegistrationBean</code><br>自定义的bean如下，注意类上没有任何注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterBeanServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;[RegisterBeanServlet] welcome &quot;</span> + name);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要定义一个ServletRegistrationBean，让它持有RegisterBeanServlet的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ServletRegistrationBean <span class="title function_">servletBean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>();</span><br><span class="line">    registrationBean.addUrlMappings(<span class="string">&quot;/register&quot;</span>);</span><br><span class="line">    registrationBean.setServlet(<span class="keyword">new</span> <span class="title class_">RegisterBeanServlet</span>());</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="●-ServletContext-动态添加"><a href="#●-ServletContext-动态添加" class="headerlink" title="● ServletContext 动态添加"></a>● ServletContext 动态添加</h3><p>这种姿势，在实际的Servlet注册中，其实用得并不太多，主要思路是在ServletContext初始化后，借助javax.servlet.ServletContext#addServlet(java.lang.String, java.lang.Class&lt;? extends javax.servlet.Servlet&gt;)方法来主动添加一个Servlet</p>
<p>所以我们需要找一个合适的时机，获取ServletContext实例，并注册Servlet，在SpringBoot生态下，可以借助ServletContextInitializer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;[ContextServlet] welcome &quot;</span> + name);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfServletConfig</span> <span class="keyword">implements</span> <span class="title class_">ServletContextInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="type">ServletRegistration</span> <span class="variable">initServlet</span> <span class="operator">=</span> servletContext.addServlet(<span class="string">&quot;contextServlet&quot;</span>, ContextServlet.class);</span><br><span class="line">        initServlet.addMapping(<span class="string">&quot;/context&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1>
<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/06/05/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B46%E6%9C%88/2025.6.5%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/">2025.6.5学习日记</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/06/02/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">个人博客搭建</a></div></section></div>






