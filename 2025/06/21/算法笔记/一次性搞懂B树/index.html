


<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/">学习博客</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-06-20T16:00:00.000Z">2025-06-21</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-06-30T11:53:51.593Z">2025-06-30</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>一次性搞懂B树</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="可视化网站"><a href="#可视化网站" class="headerlink" title="可视化网站"></a>可视化网站</h1><p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">算法可视化网站</a></p>
<h1 id="B-Tree的引入"><a href="#B-Tree的引入" class="headerlink" title="B-Tree的引入"></a>B-Tree的引入</h1><h2 id="从磁盘查找数据效率低的原因"><a href="#从磁盘查找数据效率低的原因" class="headerlink" title="从磁盘查找数据效率低的原因"></a>从磁盘查找数据效率低的原因</h2><ul>
<li><p>读写数据越大速度越慢</p>
</li>
<li><p>读写次数越多速度越慢</p>
</li>
</ul>
<h2 id="设计文件查找系统"><a href="#设计文件查找系统" class="headerlink" title="设计文件查找系统"></a>设计文件查找系统</h2><p>索引可以提供更快的查询.</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>优点:等值查询比较快<br>缺点:</p>
<ol>
<li>hash冲突后,数据散列不均匀,产生大量线性查询,效率低</li>
<li>等值查询可以,但是遇到范围查询,需要遍历,hash不合适</li>
</ol>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h4><p>树 二叉树 BST二叉查找树 AVL平衡二叉树 红黑树 B树 B+树</p>
<h4 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树 BST"></a>二叉排序树 BST</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621110904.png" alt="20250621110904"><br>插入数据的时候得有序,必须保证:</p>
<ol>
<li>若左子树不为空,则左子树的所有节点的值小于根节点的值</li>
<li>若右子树不为空,则右子树的所有节点的值大于根节点的值</li>
</ol>
<p>问题:<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621111023.png" alt="20250621111023"><br>会退化为链表,查询效率降低为O(n).</p>
<h4 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 AVL"></a>平衡二叉树 AVL</h4><p>插入数据的时候保持二叉排序树平衡<br>左子树和右子树的高度差不能超过1.<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621111524.png" alt="20250621111524"> </p>
<p>问题:用插入的成本来弥补查询的成本,插入效率降低为O(logn),但是查询效率还是O(logn).一旦出现插入操作比查询操作多的情况就不合适了.</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621111731.png" alt="20250621111731"><br>最长子树不超过最短子树的2倍.</p>
<ul>
<li>性质1 :根节点是黑色的.</li>
<li>性质2 :每个红色的节点的两个子节点都是黑色.(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>性质3 :从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点.</li>
</ul>
<p>相当于不让AVL做大量的旋转操作.<br>红黑树口诀:左根右 , 根叶黑 . 不红红 , 黑路同.</p>
<p>问题: 当数据特别多的时候,树的深度会很大,就意味着IO的次数会变多,影响读取的效率.</p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B树就是一个有序的多路查询树.</p>
<p>满足下列要求的m叉树:</p>
<ol>
<li>书中每个节点只多有m个孩子节点(至多有m-1个关键字)</li>
<li>每个节节点的结构为:<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621142935.png" alt="20250621142935"><br><code>n</code>代表这个节点有几个关键字.<br><code>P0</code>第一个子树的地址.<br><code>k1</code>关键字</li>
</ol>
<p>例子:m&#x3D;4的4阶B树<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621143215.png" alt="20250621143215"><br>阶数代表单个节点最多有的子节点数量</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/06/21/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B46%E6%9C%88/2025.6.21%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.6.21学习日记</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/06/20/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B46%E6%9C%88/2025.6.20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.6.20学习日记</a></div></section></div>






