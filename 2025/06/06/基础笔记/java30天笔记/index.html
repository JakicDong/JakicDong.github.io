


<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2025/07/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97/">学习博客</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-06-05T16:00:00.000Z">2025-06-06</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-06-30T11:53:36.916Z">2025-06-30</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>java30天学习笔记</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>最好不使用 clone()来进行复制,可以使用拷贝构造函数或拷贝工厂来复制对象.</p>
<p>抽象类提供了⼀种 IS-A 的关系<br>接⼝更像是⼀种 LIKE-A 关系</p>
<h2 id="Fail-Fast-机制"><a href="#Fail-Fast-机制" class="headerlink" title="Fail-Fast 机制"></a>Fail-Fast 机制</h2><p>Fail-Fast 机制是 Java 集合(Collection)中的⼀种错误机制。当多个线程对同一个集合的内容进⾏操作时，就可能产⽣线程安全问题。<br>Fail-Fast 机制会⾃动检测到线程安全问题,在操作前后比较集合的结构变化次数是否相同，并抛出 <code>ConcurrentModificationException</code> 异常。</p>
<p>tips:禁⽌在foreach⾥执⾏元素的删除操作</p>
<h2 id="容器的一些解析"><a href="#容器的一些解析" class="headerlink" title="容器的一些解析"></a>容器的一些解析</h2><h3 id="vector和arraylist的比较"><a href="#vector和arraylist的比较" class="headerlink" title="vector和arraylist的比较"></a>vector和arraylist的比较</h3><p>vector是同步的，所以开销更大<br>vector每次扩容请求2倍，而arraylist是1.5倍</p>
<p>如果对线程安全有要求的话，可以选择Collections.synchronizedList() 或者使用CopyOnWriteArrayList保证线程安全。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>写操作在拷贝的数组上进行，而读操作在原数组上进行。<br>写操作需要加锁，防止并发写操作。<br>适用于读多写少的场景。<br><strong>问题:</strong><br>内存占用约占原数组的两倍。<br>数据一致性问题。</p>
<p>所以CopyOnWriteArrayList更加适合对内存不敏感以及实时性要求很高的场景。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>ArrayList是基于数组实现的，而LinkedList是基于链表实现的。<br>数组支持随机访问，而链表不支持随机访问。<br>数组的插入和删除操作需要移动元素，而链表的插入和删除操作只需要修改指针。<br>数组的空间利用率高，而链表的空间利用率低。<br>LinkedList适用于需要频繁插入和删除元素的场景。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>相当于分成了很多个桶，每个桶里面是一个链表，链表的每个节点是一个键值对，使用头插法插入节点。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap是线程安全的HashMap，它的实现方式是使用分段锁。<br>ConcurrentHashMap将整个HashMap分成了多个段，每个段都是一个HashMap。<br>每个段都有一个锁，当一个线程访问一个段时，其他线程也可以访问其他段。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap是HashMap的子类，它的实现方式是使用双向链表。<br>LinkedHashMap的迭代顺序是插入顺序或者访问顺序。<br>可以通过LinkedHashMap实现LRU缓存。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>主要是用来实现缓存的。<br>WeakHashMap的键是弱引用，当键不再被引用时，键值对会被自动移除。<br>WeakHashMap的迭代器是弱引用的，所以在迭代时可能会出现空指针异常。</p>
<h3 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h3><p>ConcurrentCache是一个线程安全的缓存，它的实现方式是使用ConcurrentHashMap。</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/06/07/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B46%E6%9C%88/2025.6.7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.6.7学习日记</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2025/06/06/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B025%E5%B9%B46%E6%9C%88/2025.6.6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">2025.6.6学习日记</a></div></section></div>






