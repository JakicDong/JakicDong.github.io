{"layout":"notes","date":"2025-07-14T00:00:00.000Z","posts":[{"title":"进阶之路-计算机网络","path":"2025/07/14/基础笔记/进阶之路-计算机网络/","excerpt":"","date":"2025-07-13T16:00:00.000Z","tags":["基础","计算机网络"],"content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"1-计算机网络体系的结构\"><a href=\"#1-计算机网络体系的结构\" class=\"headerlink\" title=\"1.计算机网络体系的结构\"></a>1.计算机网络体系的结构</h3><p>计算机网络体系结构通过将复杂的网络通信分解成不同的层次，来标准化交互的过程。常见的模型包括 <code>OSI 七层模型</code>、<code>TCP/IP 四层模型</code>和<code>五层体系结构</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714102442.png\" alt=\"20250714102442\"></p>\n<p>OSI 是理论上的网络通信模型，TCP&#x2F;IP 是实际应用层面上的网络通信模型，五层结构是为了方便理解和记忆。</p>\n<h4 id=\"说说-OSI-七层模型？\"><a href=\"#说说-OSI-七层模型？\" class=\"headerlink\" title=\"说说 OSI 七层模型？\"></a>说说 OSI 七层模型？</h4><p>OSI（Open System Interconnection）七层参考模型是一个网络架构模型，由国际标准化组织（ISO）提出，用于描述和标准化各种计算机网络的功能和过程。这七层从高到低分别是：</p>\n<ul>\n<li><strong>应用层</strong>：最靠近用户的层，负责处理特定的应用程序细节。这一层提供了网络服务与用户应用软件之间的接口。  例如，Web 浏览器、FTP 客户端和服务器、电子邮件客户端等。</li>\n<li><strong>表示层</strong>：确保从一个系统发送的信息可以被另一个系统的应用层读取。它负责数据的转换、压缩和加密。   例如，确保数据从一种编码格式转换为另一种，如 ASCII 到 EBCDIC。</li>\n<li><strong>会话层</strong>：管理用户的会话，控制网络上两节点间的对话和数据交换的管理。它负责建立、维护和终止会话。  例如，建立一个会话令牌，以便在网络上的两个节点之间传递。</li>\n<li><strong>传输层</strong>：提供端到端的通信服务，保证数据的完整性和正确顺序。这一层包括 <code>TCP</code> 和 <code>UDP</code> 等。</li>\n<li><strong>网络层</strong>：负责在多个网络之间进行数据传输，确保数据能够在复杂的网络结构中找到从源到目的地的最佳路径。这层使用的是 <code>IP（Internet Protocol）协议</code>。</li>\n<li><strong>数据链路层</strong>：在物理连接中提供可靠的传输，负责建立和维护两个相邻节点间的链路。包括帧同步、MAC（媒体访问控制）。</li>\n<li><strong>物理层</strong>：负责在物理媒介上实现原始的数据传输，比如电缆、光纤和无线信号传输。涉及的内容包括电压、接口、针脚、电缆的规格和传输速率等。</li>\n</ul>\n<h4 id=\"说说-TCP-IP-四层模型？\"><a href=\"#说说-TCP-IP-四层模型？\" class=\"headerlink\" title=\"说说 TCP&#x2F;IP 四层模型？\"></a>说说 TCP&#x2F;IP 四层模型？</h4><p>TCP&#x2F;IP 四层模型是互联网通信的核心，定义了一系列协议和标准，确保设备间可以可靠地进行数据传输。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714103206.png\" alt=\"20250714103206\"></p>\n<p>①、<strong>应用层（Application Layer）</strong>：直接面向用户和应用程序，提供各种网络服务。它包含了用于特定应用的协议和服务，如 HTTP（HyperText Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。</p>\n<p>示例：当在浏览器中输入一个 URL 并访问一个网页时，浏览器使用 HTTP 协议从 Web 服务器请求页面内容。</p>\n<p>②、<strong>传输层（Transport Layer）</strong>：提供端到端的通信服务，确保数据可靠传输。它负责分段数据、流量控制、错误检测和纠正。常见的传输层协议有 <code>TCP</code> 和 <code>UDP</code>。</p>\n<p>示例：当发送一封电子邮件时，TCP 协议确保邮件从你的客户端可靠地传输到邮件服务器。</p>\n<p>③、<strong>网际层</strong>：或者叫网络层（Internet Layer），负责在不同网络之间路由数据包，提供逻辑地址（IP 地址）和网络寻址功能。用于处理数据包的分组、转发和路由选择，确保数据可以从源端传输到目标端。</p>\n<p>常见协议：<code>IPv4</code>、<code>IPv6</code>、<code>ICMP（Internet Control Message Protocol）</code>。</p>\n<p>示例：当访问一个网站时，网络层协议（如 IPv4）将你的请求从你的计算机通过多个路由器传输到目标服务器。</p>\n<p>④、<strong>网络接口层（Network Access Layer）</strong>：或者叫链路层（Link Layer），负责将数字信号在物理通道（网线）中准确传输，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。</p>\n<p>常见协议：以太网（Ethernet）、Wi-Fi。</p>\n<p>示例：在一个局域网（LAN）中，计算机通过以太网连接交换机，链路层协议负责数据帧在网络设备间的传输。</p>\n<h4 id=\"说说五层体系结构？\"><a href=\"#说说五层体系结构？\" class=\"headerlink\" title=\"说说五层体系结构？\"></a>说说五层体系结构？</h4><p>是对 OSI 和 TCP&#x2F;IP 的折衷，它保留了 TCP&#x2F;IP 的实用性，同时提供了比四层模型更细致的分层，便于教学和理解网络的各个方面。</p>\n<ul>\n<li>应用层：作为网络服务和最终用户之间的接口。它提供了一系列供应用程序使用的协议，如 HTTP（网页）、FTP（文件传输）、SMTP（邮件传输）等。使用户的应用程序可以访问网络服务。</li>\n<li>传输层：提供进程到进程的通信管理，这一层确保数据按顺序、无错误地传输。主要协议包括 TCP 和 UDP。</li>\n<li>网络层：负责数据包从源到目的地的传输和路由选择，包括跨越多个网络（即互联网）。它使用逻辑地址（如 IP 地址）来唯一标识设备。路由器是网络层设备。</li>\n<li>数据链路层：确保从一个节点到另一个节点的可靠、有效的数据传输。交换机、网桥是数据链路层设备。</li>\n<li>物理层：电缆、光纤、无线电频谱、网络适配器等。</li>\n</ul>\n<h4 id=\"TCP三次握手四次挥手工作在哪一层？\"><a href=\"#TCP三次握手四次挥手工作在哪一层？\" class=\"headerlink\" title=\"TCP三次握手四次挥手工作在哪一层？\"></a>TCP三次握手四次挥手工作在哪一层？</h4><p>三次握手和四次挥手都是工作在<strong>传输层</strong>。<code>传输层（Transport Layer）</code>是 OSI 模型的第四层，负责提供端到端的通信服务，包括数据传输的建立、维护和终止。</p>\n<p><code>TCP</code> 作为一种面向连接的协议，通过<strong>三次握手建立连接</strong>，通过<strong>四次挥手终止连接</strong>，确保数据传输的可靠性和完整性。</p>\n<h4 id=\"讲一下计算机网络？\"><a href=\"#讲一下计算机网络？\" class=\"headerlink\" title=\"讲一下计算机网络？\"></a>讲一下计算机网络？</h4><p>计算机网络是指将多台计算机通过通信设备互联起来，实现资源共享和信息传递的系统。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714103951.png\" alt=\"20250714103951\"></p>\n<h3 id=\"2-说一下每一层对应的网络协议有哪些？\"><a href=\"#2-说一下每一层对应的网络协议有哪些？\" class=\"headerlink\" title=\"2.说一下每一层对应的网络协议有哪些？\"></a>2.说一下每一层对应的网络协议有哪些？</h3><p>一张表格总结常见网络协议：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104012.png\" alt=\"20250714104012\"></p>\n<h3 id=\"3-那么数据在各层之间是怎么传输的呢？\"><a href=\"#3-那么数据在各层之间是怎么传输的呢？\" class=\"headerlink\" title=\"3.那么数据在各层之间是怎么传输的呢？\"></a>3.那么数据在各层之间是怎么传输的呢？</h3><p>对于发送方而言，从<strong>上层到下层层层包装</strong>，对于接收方而言，从<strong>下层到上层，层层解开包装</strong>。</p>\n<ul>\n<li>发送方的应用进程向接收方的应用进程传送数据</li>\n<li>AP 先将数据交给本主机的应用层，应用层加上本层的控制信息 H5 就变成了下一层的数据单元</li>\n<li>传输层收到这个数据单元后，加上本层的控制信息 H4，再交给网络层，成为网络层的数据单元</li>\n<li>到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）</li>\n<li>最后的物理层，进行比特流的传输</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104213.png\" alt=\"20250714104213\"></p>\n<p>这个过程类似写信，写一封信，每到一层，就加一个信封，写一些地址的信息。到了目的地之后，又一层层解封，传向下一个目的地。</p>\n<h2 id=\"网络综合\"><a href=\"#网络综合\" class=\"headerlink\" title=\"网络综合\"></a>网络综合</h2><h3 id=\"4-从浏览器地址栏输入-url-到显示网页的过程了解吗？\"><a href=\"#4-从浏览器地址栏输入-url-到显示网页的过程了解吗？\" class=\"headerlink\" title=\"4.从浏览器地址栏输入 url 到显示网页的过程了解吗？\"></a>4.从浏览器地址栏输入 url 到显示网页的过程了解吗？</h3><p>这个过程包括多个步骤，涵盖了 <code>DNS 解析</code>、<code>TCP 连接</code>、<code>发送 HTTP 请求</code>、<code>服务器处理请求并返回 HTTP 响应</code>、<code>浏览器处理响应并渲染页面</code>等多个环节。</p>\n<ol>\n<li><strong>DNS 解析</strong>：浏览器会发起一个 DNS 请求到 DNS 服务器，将域名解析为服务器的 IP 地址。</li>\n<li><strong>TCP 连接</strong>：浏览器通过解析得到的 IP 地址与服务器建立 TCP 连接。这一步涉及到 TCP 的三次握手，用于确保双方都已经准备好进行数据传输了。</li>\n<li><strong>发送 HTTP 请求</strong>：浏览器构建 HTTP 请求，包括请求行、请求头和请求体；然后将请求发送到服务器。</li>\n<li><strong>服务器处理请求</strong>：服务器接收到 HTTP 请求后，根据请求的资源路径，经过后端处理，生成 HTTP 响应消息；响应消息包括状态行、响应头和响应体。</li>\n<li><strong>浏览器接收 HTTP 响应</strong>：浏览器接收到服务器返回的 HTTP 响应数据后，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。</li>\n<li><strong>断开连接</strong>：TCP 四次挥手，连接结束。</li>\n</ol>\n<p>我们以输入 <a href=\"http://www.baidu.com/\">www.baidu.com</a> 为例：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104653.png\" alt=\"20250714104653\"></p>\n<h4 id=\"各个过程都使用了哪些协议？\"><a href=\"#各个过程都使用了哪些协议？\" class=\"headerlink\" title=\"各个过程都使用了哪些协议？\"></a>各个过程都使用了哪些协议？</h4><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104751.png\" alt=\"20250714104751\"></p>\n<h3 id=\"5-说说-DNS-的解析过程？\"><a href=\"#5-说说-DNS-的解析过程？\" class=\"headerlink\" title=\"5.说说 DNS 的解析过程？\"></a>5.说说 DNS 的解析过程？</h3><p><code>DNS</code> 的全称是 Domain Name System，也就是<code>域名解析系统</code>，它可以将域名映射到对应的 IP 地址上，比如说我们访问 <a href=\"http://www.javabetter.cn,实际上访问的是我在阿里云上一台丐版服务器,它的/\">www.javabetter.cn，实际上访问的是我在阿里云上一台丐版服务器，它的</a> IP 地址是 xxx.xxx.xxx.xxx。</p>\n<p>当然了，也可以通过 IP 地址直接访问服务器，但不方便记忆，所以就有了域名系统。一个好的域名可以卖好多好多钱，像 javabetter.cn 这个域名，一年需要 39 块钱。</p>\n<p>域名到 IP 之间的映射，就需要 DNS 来完成。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104925.png\" alt=\"20250714104925\"></p>\n<p>我来说说 DNS 的解析过程吧：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714104947.png\" alt=\"20250714104947\"></p>\n<p>假设我们在浏览器地址栏里键入了 paicoding.com：</p>\n<p>浏览器会首先检查<strong>自己的缓存中是否有这个域名对应的 IP 地址</strong>，如果有，直接返回；如果没有，进入下一步。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714105341.png\" alt=\"20250714105341\"></p>\n<p>检查<strong>本地 DNS 缓存是否有该域名的记录</strong>。如果没有，向根域名服务器发送请求，根域名服务器将请求指向更具体的服务，如 com 顶级域名服务器。</p>\n<p>顶级域名服务器再将请求指向权限域名服务器，通常由域名注册机构直接管理，paicoding.com是在阿里云上注册的，所以阿里云会提供对应的 DNS 解析服务，将域名和阿里云服务器绑定起来。</p>\n<p>最终，浏览器使用获得的 IP 地址发起一个 HTTP 请求到目标服务器，然后该服务器返回所请求的网页内容。</p>\n<h3 id=\"6-说说-WebSocket-与-Socket-的区别？\"><a href=\"#6-说说-WebSocket-与-Socket-的区别？\" class=\"headerlink\" title=\"6.说说 WebSocket 与 Socket 的区别？\"></a>6.说说 WebSocket 与 Socket 的区别？</h3><ul>\n<li>Socket 其实就是等于 <strong>IP 地址 + 端口 + 协议</strong>。</li>\n</ul>\n<blockquote>\n<p>具体来说，Socket 是一套标准，它完成了对 TCP&#x2F;IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。</p>\n</blockquote>\n<ul>\n<li><code>WebSocket</code> 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决 <strong>http 不支持持久化连接</strong>的问题。</li>\n<li><code>Socket</code> 一个是<strong>网编编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</li>\n</ul>\n<h3 id=\"7-说一下你了解的端口及对应的服务？\"><a href=\"#7-说一下你了解的端口及对应的服务？\" class=\"headerlink\" title=\"7.说一下你了解的端口及对应的服务？\"></a>7.说一下你了解的端口及对应的服务？</h3><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714105809.png\" alt=\"20250714105809\"></p>\n<h3 id=\"8-平常有抓包吗（补充）？\"><a href=\"#8-平常有抓包吗（补充）？\" class=\"headerlink\" title=\"8.平常有抓包吗（补充）？\"></a>8.平常有抓包吗（补充）？</h3><p>我平常使用最多的就是 chrome 浏览器自带的 network 面板了，可以看到<code>请求的时间</code>、<code>请求的信息</code>，以及<code>响应信息</code>。</p>\n<p>更专业的还有 <code>fidder</code>、<code>wireshark</code> 等工具。</p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"8-说说-HTTP-常用的状态码及其含义？\"><a href=\"#8-说说-HTTP-常用的状态码及其含义？\" class=\"headerlink\" title=\"8.说说 HTTP 常用的状态码及其含义？\"></a>8.说说 HTTP 常用的状态码及其含义？</h3><p>HTTP 状态码用于表示服务器对<code>请求的处理结果</code>，可以分为 5 种：</p>\n<ul>\n<li><code>1xx</code> 服务器收到请求，需要进一步操作，例如 100 Continue。</li>\n<li><code>2xx</code> 请求成功处理，例如 200 OK。</li>\n<li><code>3xx</code> 重定向：需要进一步操作以完成请求；例如 304 Not Modified 表示资源未修改，客户端可以使用缓存。</li>\n<li><code>4xx</code> 客户端错误：请求有问题，例如 404 Not Found 表示资源不存在。</li>\n<li><code>5xx</code> 服务器错误，例如500 Internal Server Error 表示服务器内部错误。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714110047.png\" alt=\"20250714110047\"></p>\n<h4 id=\"说一下-301-和-302-的区别？\"><a href=\"#说一下-301-和-302-的区别？\" class=\"headerlink\" title=\"说一下 301 和 302 的区别？\"></a>说一下 301 和 302 的区别？</h4><ul>\n<li>301：永久性移动，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址。</li>\n<li>302：临时性性移动，服务器从另外的地址响应资源，但是客户端还应该使用这个地址。</li>\n</ul>\n<p>用一个比喻，301 就是嫁人的新垣结衣，302 就是有男朋友的长泽雅美。</p>\n<h3 id=\"9-HTTP-有哪些请求方式？\"><a href=\"#9-HTTP-有哪些请求方式？\" class=\"headerlink\" title=\"9.HTTP 有哪些请求方式？\"></a>9.HTTP 有哪些请求方式？</h3><p>HTTP 协议定义了多种请求方式，用以指示请求的目的。常见的请求方式有 <code>GET</code>、<code>POST</code>、<code>DELETE</code>、<code>PUT</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714110428.png\" alt=\"20250714110428\"></p>\n<ul>\n<li><code>GET</code>：请求检索指定的资源。应该只用于获取数据，并且是<strong>幂等的</strong>，即多次执行相同的 GET 请求应该返回相同的结果，并且<strong>不会改变资源的状态</strong>。</li>\n<li><code>POST</code>：向指定资源提交数据，请求服务器进行处理（如提交表单或上传文件）。数据被包含在请求体中。<strong>可能会创建新的资源或修改现有资源</strong>。</li>\n<li><code>DELETE</code>：<strong>删除</strong>指定的资源。</li>\n<li><code>PUT</code>：用于替换指定的资源。如果指定的资源不存在，创建一个新资源。</li>\n<li><code>HEAD</code>：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。可以用于检查资源是否存在，验证资源的更新时间等。</li>\n<li><code>OPTIONS</code>：用于获取服务器支持的 HTTP 请求方法。通常用于跨域请求中的预检请求（CORS）。</li>\n<li><code>TRACE</code>：<strong>回显服务器收到的请求</strong>，主要用于测试或诊断。但由于安全风险（可能暴露敏感信息），很多服务器会禁用 TRACE 请求。</li>\n<li><code>CONNECT</code>：建立一个到目标资源的隧道（通常用于 SSL&#x2F;TLS 代理），用于在客户端和服务器之间进行加密的隧道传输。</li>\n</ul>\n<h4 id=\"HTTP-的-GET-方法可以实现写操作吗\"><a href=\"#HTTP-的-GET-方法可以实现写操作吗\" class=\"headerlink\" title=\"HTTP 的 GET 方法可以实现写操作吗?\"></a>HTTP 的 GET 方法可以实现写操作吗?</h4><p>可以是可以，但是不推荐。</p>\n<p>使用 GET 执行写操作可能导致严重的安全问题，如跨站请求伪造（CSRF）。<br>实际开发中，也应该<strong>杜绝使用 GET 方法执行写操作</strong>。<br>通过在项目接口上明确指出需要的请求方式.<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714111209.png\" alt=\"20250714111209\"></p>\n<p>客户端一旦使用错误❎，将会收到一个 <code>405 Method Not Allowed</code> 的响应。</p>\n<h4 id=\"什么是幂等？幂等方法了解哪些？\"><a href=\"#什么是幂等？幂等方法了解哪些？\" class=\"headerlink\" title=\"什么是幂等？幂等方法了解哪些？\"></a>什么是幂等？幂等方法了解哪些？</h4><p><code>幂等（Idempotence）</code>是一个数学概念，用于描述某些操作的特性，<strong>即无论操作执行多少次，结果都是相同的</strong>。换句话说，幂等操作可以重复执行而不会改变系统状态。</p>\n<p>如果一个操作是幂等的，那么对同一资源执行该操作一次和执行多次的效果相同。</p>\n<p>在正确实现的条件下，<code>GET</code>、<code>HEAD</code>、<code>PUT</code>和 <code>DELETE</code> 等方法都是幂等的，而 <code>POST</code> 方法不是。</p>\n<p>例如，<code>GET /pageX HTTP/1.1</code> 幂等的。连续调用多次，客户端接收到的结果都是一样的：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/pageX</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\">GET /pageX HTTP/1.1</span><br><span class=\"line\">GET /pageX HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<p><code>DELETE /idX/delete HTTP/1.1</code> 是幂等的，<strong>即便是不同请求之间接收到的状态码不一样</strong>：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class=\"line\">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class=\"line\">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-说⼀下-GET-和-POST-的区别？\"><a href=\"#10-说⼀下-GET-和-POST-的区别？\" class=\"headerlink\" title=\"10.说⼀下 GET 和 POST 的区别？\"></a>10.说⼀下 GET 和 POST 的区别？</h3><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714111527.png\" alt=\"20250714111527\"></p>\n<p><code>GET</code> 请求主要用于<strong>获取数据</strong>，<strong>参数附加在 URL 中</strong>，存在<strong>长度限制</strong>，且容易被浏览器缓存，有安全风险；<br><code>POST</code> 请求用于提交数据，<strong>参数放在请求体中</strong>，适合提交大量或敏感的数据。</p>\n<p>另外，GET 请求是<strong>幂等的</strong>，多次请求不会改变服务器状态；而 POST 请求<strong>不是幂等的</strong>，可能对服务器数据有影响。</p>\n<h3 id=\"11-GET-的长度限制是多少？\"><a href=\"#11-GET-的长度限制是多少？\" class=\"headerlink\" title=\"11.GET 的长度限制是多少？\"></a>11.GET 的长度限制是多少？</h3><p>HTTP 中的 <code>GET</code> 方法是通过 URL 传递数据的，但是 URL 本身其实并没有对数据的长度进行限制，真正限制 <code>GET</code> 长度的是<strong>浏览器</strong>。</p>\n<p>例如 IE 浏览器对 URL 的最大限制是 2000 多个字符，大概 2kb 左右，像 Chrome、Firefox 等浏览器支持的 URL 字符数更多，其中 FireFox 中 URL 的最大长度限制是 65536 个字符，Chrome 则是 8182 个字符。</p>\n<p>这个长度限制也不是针对数据部分，<strong>而是针对整个 URL</strong>。</p>\n<h3 id=\"12-HTTP-请求的过程与原理？\"><a href=\"#12-HTTP-请求的过程与原理？\" class=\"headerlink\" title=\"12.HTTP 请求的过程与原理？\"></a>12.HTTP 请求的过程与原理？</h3><p>HTTP 是基于 <code>TCP/IP</code> 协议的<strong>应用层协议</strong>，它使用 <code>TCP</code> 作为传输层协议，通过建立 <code>TCP</code> 连接来传输数据。<br>HTTP 遵循标准的<strong>客户端-服务器模型</strong>，客户端打开连接发出请求，然后等待服务器返回的响应。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714111725.png\" alt=\"20250714111725\"></p>\n<ul>\n<li>在浏览器输入 URL 后，浏览器首先会通过 DNS 解析获取到服务器的 IP 地址，然后与服务器建立 TCP 连接。</li>\n<li>TCP 连接建立后，浏览器会向服务器发送 HTTP 请求。</li>\n<li>服务器收到请求后，会根据请求的信息处理请求。</li>\n<li>处理完请求后，服务器会返回一个 HTTP 响应给浏览器。</li>\n<li>浏览器收到响应后，会根据响应的信息渲染页面。然后，浏览器和服务器断开 TCP 连接。</li>\n</ul>\n<p>客户端发送一个请求到服务器，服务器处理请求并返回一个响应。这个过程是同步的，也就是说，客户端在发送请求后必须等待服务器的响应。在等待响应的过程中，客户端不会发送其他请求。</p>\n<h4 id=\"怎么利用多线程来下载一个数据呢？\"><a href=\"#怎么利用多线程来下载一个数据呢？\" class=\"headerlink\" title=\"怎么利用多线程来下载一个数据呢？\"></a>怎么利用多线程来下载一个数据呢？</h4><p>可以采取分块下载的策略。首先，通过 HEAD 请求获取文件的总大小。然后根据文件大小和线程数，将文件进行切割。每个线程负责下载一个特定范围的数据。</p>\n<p>可以通过设置 HTTP 请求头的 Range 字段指定下载的字节区间。例如，Range: bytes&#x3D;0-1023 表示下载文件的前 1024 字节。</p>\n<p>最后启动多线程下载。</p>\n<p>代码片段 1：获取文件大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">URL</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(<span class=\"string\">&quot;https://javabetter.cn/file.zip&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">HttpURLConnection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> (HttpURLConnection) url.openConnection();</span><br><span class=\"line\">connection.setRequestMethod(<span class=\"string\">&quot;HEAD&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">fileSize</span> <span class=\"operator\">=</span> connection.getContentLength(); <span class=\"comment\">// 获取文件大小</span></span><br><span class=\"line\">connection.disconnect();</span><br></pre></td></tr></table></figure>\n<p>代码片段 2：下载文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">downloadChunk</span><span class=\"params\">(String url, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, String outputPath)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">URL</span> <span class=\"variable\">fileUrl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(url);</span><br><span class=\"line\">        <span class=\"type\">HttpURLConnection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> (HttpURLConnection) fileUrl.openConnection();</span><br><span class=\"line\">        connection.setRequestProperty(<span class=\"string\">&quot;Range&quot;</span>, <span class=\"string\">&quot;bytes=&quot;</span> + start + <span class=\"string\">&quot;-&quot;</span> + end);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> connection.getInputStream();</span><br><span class=\"line\">        <span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(outputPath, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\">        file.seek(start); <span class=\"comment\">// 定位到文件的相应位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> bytesRead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((bytesRead = inputStream.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            file.write(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        file.close();</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">        connection.disconnect();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码片段 3：启动多线程下载</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">numThreads</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">fileSize</span> <span class=\"operator\">=</span> <span class=\"number\">100000000</span>; <span class=\"comment\">// 假设文件大小为 100MB</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">chunkSize</span> <span class=\"operator\">=</span> fileSize / numThreads;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;https://javabetter.cn/file.zip&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">outputPath</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;path/to/local/file.zip&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(numThreads);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> i * chunkSize;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> (i == numThreads - <span class=\"number\">1</span>) ? fileSize - <span class=\"number\">1</span> : (start + chunkSize - <span class=\"number\">1</span>);</span><br><span class=\"line\">    executor.execute(() -&gt; downloadChunk(url, start, end, outputPath));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">executor.shutdown();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250714112439.png\" alt=\"20250714112439\"></p>\n<h4 id=\"如果只要下载数据的前十个字节呢？\"><a href=\"#如果只要下载数据的前十个字节呢？\" class=\"headerlink\" title=\"如果只要下载数据的前十个字节呢？\"></a>如果只要下载数据的前十个字节呢？</h4><p>只需要设置 Range 字段为 Range: bytes&#x3D;0-9 即可。</p>\n<h3 id=\"13-说一下-HTTP-的报文结构？\"><a href=\"#13-说一下-HTTP-的报文结构？\" class=\"headerlink\" title=\"13.说一下 HTTP 的报文结构？\"></a>13.说一下 HTTP 的报文结构？</h3><p>HTTP 的报文结构分为：<code>请求报文</code>和<code>响应报文</code>。两者在结构上很相似，都包含了<strong>起始行、头部和消息正文</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715095105.png\" alt=\"20250715095105\"></p>\n<h4 id=\"说下-HTTP-的请求报文结构？\"><a href=\"#说下-HTTP-的请求报文结构？\" class=\"headerlink\" title=\"说下 HTTP 的请求报文结构？\"></a>说下 HTTP 的请求报文结构？</h4><p>请求报文由请求行、请求头部、空行和消息正文组成。如下所示：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /index.html HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.javabetter.cn</span><br><span class=\"line\"><span class=\"attribute\">Accept</span>: text/html</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br></pre></td></tr></table></figure>\n\n<p>①、请求行包括请求方法、请求 URL 和 HTTP 协议的版本。例如：<code>GET /index.html HTTP/1.1</code>。</p>\n<p>②、请求头部包含请求的附加信息，如客户端想要接收的内容类型、浏览器类型等。例如：</p>\n<ul>\n<li><code>Host: www.javabetter.cn</code>，表示请求的主机名（域名）</li>\n<li><code>Accept: text/html</code>，表示客户端可以接收的媒体类型</li>\n<li><code>User-Agent: Mozilla/5.0</code>，表示客户端的浏览器类型</li>\n<li>Range：用于指定请求内容的范围，如断点续传时表示请求的字节范围。</li>\n</ul>\n<p>③、请求头部和消息正文之间有一个空行，表示请求头部结束。</p>\n<p>④、消息正文是可选的，如 <code>POST</code> 请求中的表单数据；<code>GET</code> 请求中没有消息正文。</p>\n<h4 id=\"说下-HTTP-响应报文结构？\"><a href=\"#说下-HTTP-响应报文结构？\" class=\"headerlink\" title=\"说下 HTTP 响应报文结构？\"></a>说下 HTTP 响应报文结构？</h4><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.0 200 OK</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/plain</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 137582</span><br><span class=\"line\"><span class=\"attribute\">Expires</span>: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class=\"line\"><span class=\"attribute\">Last-Modified</span>: Wed, 5 August 1996 15:55:28 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span>: Apache 0.84</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;JakicDong&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>①、状态行<br>包括 HTTP 协议的版本、状态码（如 200、404）和状态消息（如 OK、NotFound）。例如：<code>HTTP/1.0 200 OK</code>。</p>\n<p>②、响应头部<br>包含响应的附加信息，如服务器类型、内容类型、内容长度等。也是键值对，例如：</p>\n<ul>\n<li><code>Content-Type: text/plain</code>，表示响应的内容类型</li>\n<li><code>Content-Length: 137582</code>，表示响应的内容长度</li>\n<li><code>Expires: Thu, 05 Dec 1997 16:00:00 GMT</code>，表示资源的过期时间</li>\n<li><code>Last-Modified: Wed, 5 August 1996 15:55:28 GMT</code>，表示资源的最后修改时间</li>\n<li><code>Server: Apache 0.84</code>，表示服务器类型</li>\n</ul>\n<p>③、空行<br>表示响应头部结束。</p>\n<p>④、消息正文（可选）<br>响应的具体内容，如 HTML 页面。不是所有的响应都有消息正文，如 204 No Content 状态码的响应。</p>\n<h3 id=\"14-URI-和-URL-有什么区别\"><a href=\"#14-URI-和-URL-有什么区别\" class=\"headerlink\" title=\"14.URI 和 URL 有什么区别?\"></a>14.URI 和 URL 有什么区别?</h3><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715100451.png\" alt=\"20250715100451\"></p>\n<ul>\n<li>URI，统一资源标识符(Uniform Resource Identifier， URI)，标识的是 Web 上每一种可用的资源，如 HTML 文档、图像、视频片段、程序等都是由一个 URI 进行标识的。</li>\n<li>URL，统一资源定位符（Uniform Resource Location），它是 URI 的一种子集，主要作用是提供资源的路径。</li>\n</ul>\n<p>它们的主要区别在于，<code>URL</code> 除了提供了资源的标识，还提供了资源访问的方式。这么比喻，<code>URI</code> 像是身份证，可以唯一标识一个人，而 <code>URL</code> 更像一个住址，可以通过 <code>URL</code> 找到这个人——人类住址协议:&#x2F;&#x2F;地球&#x2F;中国&#x2F;北京市&#x2F;海淀区&#x2F;xx 职业技术学院&#x2F;14 号宿舍楼&#x2F;525 号寝&#x2F;张三.男。</p>\n<h3 id=\"15-说下-HTTP1-0，1-1，2-0-的区别？\"><a href=\"#15-说下-HTTP1-0，1-1，2-0-的区别？\" class=\"headerlink\" title=\"15.说下 HTTP1.0，1.1，2.0 的区别？\"></a>15.说下 HTTP1.0，1.1，2.0 的区别？</h3><p><code>HTTP1.0</code> 默认是短连接，<code>HTTP 1.1</code> 默认是长连接，<code>HTTP 2.0</code> 采用的多路复用。</p>\n<h4 id=\"说下-HTTP1-0\"><a href=\"#说下-HTTP1-0\" class=\"headerlink\" title=\"说下 HTTP1.0\"></a>说下 HTTP1.0</h4><ul>\n<li><strong>无状态协议</strong>：HTTP 1.0 是无状态的，每个请求之间相互独立，服务器不保存任何请求的状态信息。</li>\n<li><strong>非持久连接</strong>：默认情况下，每个 HTTP 请求&#x2F;响应对之后，连接会被关闭，属于短连接。这意味着对于同一个网站的每个资源请求，如 HTML 页面上的图片和脚本，都需要建立一个新的 TCP 连接。可以设置<code>Connection: keep-alive</code> 强制开启长连接。</li>\n</ul>\n<h4 id=\"说下-HTTP1-1\"><a href=\"#说下-HTTP1-1\" class=\"headerlink\" title=\"说下 HTTP1.1\"></a>说下 HTTP1.1</h4><ul>\n<li><strong>持久连接</strong>：HTTP 1.1 引入了持久连接（也称为 HTTP keep-alive），默认情况下不会立即关闭连接，可以在一个连接上发送多个请求和响应。极大减轻了 TCP 连接的开销。</li>\n<li><strong>流水线处理</strong>：HTTP 1.1 支持客户端在前一个请求的响应到达之前发送下一个请求，以提高传输效率。</li>\n</ul>\n<h4 id=\"说下-HTTP2-0\"><a href=\"#说下-HTTP2-0\" class=\"headerlink\" title=\"说下 HTTP2.0\"></a>说下 HTTP2.0</h4><ul>\n<li><strong>二进制协议</strong>：HTTP 2.0 使用二进制而不是文本格式来传输数据，解析更加高效。</li>\n<li><strong>多路复用</strong>：一个 TCP 连接上可以同时进行多个 HTTP 请求&#x2F;响应，解决了 HTTP 1.x 的队头阻塞问题。</li>\n<li><strong>头部压缩</strong>：HTTP 协议不带状态，所以每次请求都必须附上所有信息。HTTP 2.0 引入了头部压缩机制，可以使用 gzip 或 compress 压缩后再发送，减少了冗余头部信息的带宽消耗。</li>\n<li><strong>服务端推送</strong>：服务器可以主动向客户端推送资源，而不需要客户端明确请求。</li>\n</ul>\n<h3 id=\"16-HTTP-3-了解吗？\"><a href=\"#16-HTTP-3-了解吗？\" class=\"headerlink\" title=\"16.HTTP&#x2F;3 了解吗？\"></a>16.HTTP&#x2F;3 了解吗？</h3><p><code>HTTP/2.0</code> 基于 TCP 协议，而 <code>HTTP/3.0</code> 则基于 <code>QUIC</code> 协议，<code>Quick UDP Connections</code>，直译为快速 UDP 网络连接。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715101143.png\" alt=\"20250715101143\"></p>\n<p>基于 TCP 的 HTTP&#x2F;2.0，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输的过程中，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，仍然会阻塞在它之后传输的流数据。</p>\n<p>而基于 <code>UDP</code> 的 <code>QUIC</code> 协议可以更彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。</p>\n<p>同时，<code>QUIC</code> 协议在传输的过程中就完成了 <code>TLS</code> 加密握手，更直接了。</p>\n<h4 id=\"目前使用最广泛的是哪个HTTP版本？\"><a href=\"#目前使用最广泛的是哪个HTTP版本？\" class=\"headerlink\" title=\"目前使用最广泛的是哪个HTTP版本？\"></a>目前使用最广泛的是哪个HTTP版本？</h4><p>应该是 HTTP&#x2F;2，在 2022 年 1 月达到峰值，占所有网站的 46.9%。</p>\n<p>统计网站：<a href=\"https://w3techs.com/technologies/history_overview/site_element/all\">w3techs</a></p>\n<h3 id=\"17-HTTP-长连接了解吗？\"><a href=\"#17-HTTP-长连接了解吗？\" class=\"headerlink\" title=\"17.HTTP 长连接了解吗？\"></a>17.HTTP 长连接了解吗？</h3><p>在 HTTP 中，长连接是指客户端和服务器之间在一次 <code>HTTP</code> 通信完成后，不会立即断开，而是<strong>保留连接以供后续请求复用</strong>。<br>这种机制可以<strong>减少了频繁建立和关闭连接的开销</strong></p>\n<h4 id=\"如何设置长连接？\"><a href=\"#如何设置长连接？\" class=\"headerlink\" title=\"如何设置长连接？\"></a>如何设置长连接？</h4><p>可以通过 <code>Connection: keep-alive</code> 实现。在 <code>HTTP/1.1</code> 中，长连接是默认开启的。</p>\n<h4 id=\"在什么时候会超时呢？\"><a href=\"#在什么时候会超时呢？\" class=\"headerlink\" title=\"在什么时候会超时呢？\"></a>在什么时候会超时呢？</h4><ul>\n<li>HTTP 一般会有 <code>httpd</code> 守护进程，里面可以设置 <code>keep-alive timeout</code>，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间</li>\n<li>TCP 的<code> keep-alive</code> 包含三个参数，支持在系统内核的 <code>net.ipv4</code> 里面设置；当 TCP 连接之后，闲置了 <code>tcp_keepalive_time</code>，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 <code>tcp_keepalive_intvl</code> 再发一次，直到发送了 <code>tcp_keepalive_probes</code>，就会丢弃该连接。</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. tcp_keepalive_intvl = 15</span><br><span class=\"line\">2. tcp_keepalive_probes = 5</span><br><span class=\"line\">3. tcp_keepalive_time = 1800</span><br></pre></td></tr></table></figure>\n<h3 id=\"18-说说-HTTP-与-HTTPS-有哪些区别？\"><a href=\"#18-说说-HTTP-与-HTTPS-有哪些区别？\" class=\"headerlink\" title=\"18.说说 HTTP 与 HTTPS 有哪些区别？\"></a>18.说说 HTTP 与 HTTPS 有哪些区别？</h3><p><code>HTTPS</code> 是 <code>HTTP</code> 的增强版，在 <code>HTTP</code> 的基础上加入了 <code>SSL/TLS</code> 协议，<strong>确保数据在传输过程中是加密的</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715101851.png\" alt=\"20250715101851\"></p>\n<p><code>HTTP</code> 的默认端⼝号是 <code>80</code>，<code>URL</code> 以<code>http://</code>开头；<br><code>HTTPS</code> 的默认端⼝号是 <code>443</code>，<code>URL</code> 以<code>https://</code>开头。</p>\n<h3 id=\"19-为什么要用-HTTPS？\"><a href=\"#19-为什么要用-HTTPS？\" class=\"headerlink\" title=\"19.为什么要用 HTTPS？\"></a>19.为什么要用 HTTPS？</h3><p><code>HTTP</code> 是<strong>明文传输</strong>的，存在数据窃听、数据篡改和身份伪造等问题。而 <code>HTTPS</code> 通过引入 <code>SSL/TLS</code>，解决了这些问题。</p>\n<p><code>SSL/TLS</code> 在加密过程中涉及到了<strong>两种类型的加密方法</strong>：</p>\n<ul>\n<li>非对称加密：<strong>服务器</strong>向<code>客户端</code>发送公钥，然后<code>客户端</code>用公钥加密自己的随机密钥，也就是会话密钥，发送给<strong>服务器</strong>，<strong>服务器</strong>用私钥解密，得到会话密钥。</li>\n<li>对称加密：双方用会话密钥加密通信内容。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715102040.png\" alt=\"20250715102040\"></p>\n<p>客户端会通过<code>数字证书</code>来验证服务器的身份，数字证书由 CA 签发，包含了服务器的公钥、证书的颁发机构、证书的有效期等。</p>\n<h3 id=\"20-HTTPS是怎么建立连接的？\"><a href=\"#20-HTTPS是怎么建立连接的？\" class=\"headerlink\" title=\"20.HTTPS是怎么建立连接的？\"></a>20.HTTPS是怎么建立连接的？</h3><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715102941.png\" alt=\"20250715102941\"></p>\n<p>HTTPS 的连接建立在 <code>SSL/TLS</code> 握手之上，其过程可以分为两个阶段：<strong>握手阶段和数据传输阶段</strong>。</p>\n<p>①、客户端向服务器发起请求</p>\n<p>②、服务器接收到请求后，返回自己的数字证书，包含了公钥、颁发机构等信息。</p>\n<p>③、客户端收到服务器的证书后，验证证书的合法性，如果合法，会生成一个随机码，然后用服务器的公钥加密这个随机码，发送给服务器。</p>\n<p>④、服务器收到会话密钥后，用私钥解密，得到会话密钥。</p>\n<p>⑤、客户端和服务器通过会话密码对通信内容进行加密，然后传输。</p>\n<p>如果通信内容被截取，但由于没有会话密钥，所以无法解密。当通信结束后，连接会被关闭，会话密钥也会被销毁，下次通信会重新生成一个会话密钥。</p>\n<h4 id=\"HTTPS-会加密-URL-吗？\"><a href=\"#HTTPS-会加密-URL-吗？\" class=\"headerlink\" title=\"HTTPS 会加密 URL 吗？\"></a>HTTPS 会加密 URL 吗？</h4><p>HTTPS 通过 <code>SSL/TLS</code> 协议确保了客户端与服务器之间交换的数据被加密，这包括 HTTP 头部和正文。</p>\n<p>而 <code>URL</code> 是 HTTP 头部的一部分，因此这部分信息<strong>也是加密的</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715103149.png\" alt=\"20250715103149\"></p>\n<p>但因为涉及到 <code>SSL</code> 握手的过程，所以域名信息会被暴露出来，需要注意。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715103246.png\" alt=\"20250715103246\"></p>\n<p>另外，完整的 URL 可能在 Web 服务器的日志中记录，这些日志可能是明文的。还有，URL 在浏览器历史记录中也是可见的。</p>\n<p>因此，<strong>敏感信息永远不应该通过 URL 传递，即使是在使用 HTTPS 的情况下</strong>。</p>\n<h4 id=\"什么是中间人攻击？\"><a href=\"#什么是中间人攻击？\" class=\"headerlink\" title=\"什么是中间人攻击？\"></a>什么是中间人攻击？</h4><p>中间人攻击（Man-in-the-Middle, MITM）是一种常见的网络安全威胁，攻击者可以在通信的两端插入自己，以窃取通信双方的信息。</p>\n<p>在很多电影中，都会存在这样的场景：主角通过某种方式，将自己伪装成中间人，然后窃取通信双方的信息，阿汤哥的碟中谍中就有很多类似的手笔。</p>\n<p>中间人攻击是一个缺乏相互认证的攻击，因此大多数加密协议都会专门加入一些特殊的认证方法，以防止中间人攻击。像 SSL 协议，就是通过验证服务器的数字证书，是否由 CA（权威的受信任的数字证书认证机构）签发，来防止中间人攻击的。</p>\n<h4 id=\"HTTPS怎么保证建立的信道是安全的？\"><a href=\"#HTTPS怎么保证建立的信道是安全的？\" class=\"headerlink\" title=\"HTTPS怎么保证建立的信道是安全的？\"></a>HTTPS怎么保证建立的信道是安全的？</h4><p>主要通过 SSL&#x2F;TLS 协议的多层次安全机制，首先在握手阶段，客户端和服务器使用得是<strong>非对称加密</strong>，生成的会话密钥只有服务器的私钥才能解密，而私钥只有服务器持有。</p>\n<p>在数据传输阶段，即使攻击者拦截了通信数据，<strong>没有会话密钥也无法解密</strong>。</p>\n<h4 id=\"HTTPS-能抓包吗？\"><a href=\"#HTTPS-能抓包吗？\" class=\"headerlink\" title=\"HTTPS 能抓包吗？\"></a>HTTPS 能抓包吗？</h4><p>可以，HTTPS 可以抓包，但因为通信内容是加密的，需要解密后才能查看。</p>\n<p>其原理是通过一个中间人，<strong>伪造服务器证书</strong>，并取得客户端的信任，然后<strong>将客户端的请求转发给服务器，将服务器的响应转发给客户端，完成中间人攻击</strong>。</p>\n<p>常用的抓包工具有 <code>Wireshark</code>、<code>Fiddler</code>、<code>Charles</code> 等。</p>\n<h3 id=\"21-客户端怎么去校验证书的合法性？\"><a href=\"#21-客户端怎么去校验证书的合法性？\" class=\"headerlink\" title=\"21.客户端怎么去校验证书的合法性？\"></a>21.客户端怎么去校验证书的合法性？</h3><p>推荐阅读：<a href=\"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/74\">HTTPS 握手过程中，客户端如何验证证书的合法性</a></p>\n<p>首先，所有的证书都是由 CA 机构签发的，CA 机构是一个受信任的第三方机构，它会对证书的申请者进行身份验证，然后签发证书。</p>\n<p>CA 就像是网络世界的公安局，具有极高的可信度。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715104158.png\" alt=\"20250715104158\"></p>\n<p>CA 签发证书的过程是非常严格的：</p>\n<ul>\n<li>首先，CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；</li>\n<li>然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 <code>Certificate Signature</code>；</li>\n<li>最后将 <code>Certificate Signature</code> 添加在⽂件证书上，形成数字证书。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715104419.png\" alt=\"20250715104419\"></p>\n<h3 id=\"22-如何理解-HTTP-协议是无状态的？\"><a href=\"#22-如何理解-HTTP-协议是无状态的？\" class=\"headerlink\" title=\"22.如何理解 HTTP 协议是无状态的？\"></a>22.如何理解 HTTP 协议是无状态的？</h3><p>HTTP 协议是无状态的，这意味着每个 HTTP 请求<strong>都是独立的</strong>，服务器不会保留任何关于客户端请求的历史信息。</p>\n<p>换句话说，我家大门常打开，是人是神都欢迎，我不在乎，只要给钱，哦不，按规矩，一切好办。</p>\n<ul>\n<li>每个 <code>HTTP</code> 请求都包含了所必须的信息，服务器在处理当前请求时，<strong>不依赖于之前的任何请求信息</strong>。</li>\n<li>服务器不会记录任何客户端请求的状态，<strong>每次请求都像是第一次与服务器通信</strong>。</li>\n</ul>\n<p>由于 HTTP 是无状态的，像用户的购物车状态就必须通过其他方式来保持，如在<strong>每次请求中传递用户的 ID</strong>，或者使用 <code>Cookie</code> 在客户端保存购物车状态。</p>\n<h4 id=\"那有什么办法记录状态呢？\"><a href=\"#那有什么办法记录状态呢？\" class=\"headerlink\" title=\"那有什么办法记录状态呢？\"></a>那有什么办法记录状态呢？</h4><ol>\n<li><code>Cookies</code>：服务器通过 <code>Set-Cookie</code> 响应头将状态信息存储在客户端，客户端在后续请求中发送该 Cookie 以维持状态。</li>\n<li><code>Session</code>：服务器生成一个<strong>唯一的会话 ID</strong>，存储在 Cookie 中，并在服务器端维护与该会话 ID 关联的状态信息。</li>\n<li><code>Token</code>：使用 JWT（JSON Web Token）等机制在客户端存储状态信息，客户端在每次请求中发送该 Token。</li>\n</ol>\n<h3 id=\"23-说说-Session-和-Cookie-有什么联系和区别\"><a href=\"#23-说说-Session-和-Cookie-有什么联系和区别\" class=\"headerlink\" title=\"23.说说 Session 和 Cookie 有什么联系和区别?\"></a>23.说说 Session 和 Cookie 有什么联系和区别?</h3><p>先来看看什么是 <code>Session</code> 和 <code>Cookie</code> ：</p>\n<ul>\n<li><code>Cookie</code> 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。<strong>服务端可以根据这个 Cookie 判断用户的身份和状态</strong>。</li>\n<li><code>Session</code> 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。不同的是 <code>cookie</code> 保存在客户端浏览器中，而 <code>session</code> 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 session。客户端浏览器再次访问时只需要从该 session 中查找用户的状态。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715105420.png\" alt=\"20250715105420\"></p>\n<blockquote>\n<p>Session 和 Cookie 到底有什么不同呢？</p>\n</blockquote>\n<ul>\n<li><strong>存储位置</strong>不一样，<code>Cookie</code> 保存在客户端，<code>Session</code> 保存在服务器端。</li>\n<li><strong>存储数据类型</strong>不一样，<code>Cookie</code> 只能保存 ASCII，<code>Session</code> 可以存任意数据类型，一般情况下我们可以在 <code>Session</code> 中保持一些常用变量信息，比如说 <code>UserId</code> 等。</li>\n<li><strong>有效期不同</strong>，<code>Cookie</code> 可设置为长时间保持，比如我们经常使用的默认登录功能，<code>Session</code> 一般有效时间较短，客户端关闭或者 <code>Session</code> 超时都会失效。</li>\n<li><strong>隐私策略不同</strong>，<code>Cookie</code> 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；<code>Session</code> 存储在服务端，安全性相对 <code>Cookie</code> 要好一些。</li>\n<li><strong>存储大小不同</strong>， 单个 <code>Cookie</code> 保存的数据不能超过 4K，<code>Session</code> 可存储数据远高于 Cookie。</li>\n</ul>\n<blockquote>\n<p>Session 和 Cookie 有什么关联呢？</p>\n</blockquote>\n<p>可以使用 <code>Cookie</code> 记录 <code>Session</code> 的标识。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715105708.png\" alt=\"20250715105708\"></p>\n<ul>\n<li>用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。</li>\n<li>当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>\n</ul>\n<blockquote>\n<p><strong>分布式环境下 Session 怎么处理呢？</strong></p>\n</blockquote>\n<p>分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的 Session。</p>\n<p>这时候怎么办呢？</p>\n<p>可以使用 <code>Redis</code> 等分布式缓存来存储 <code>Session</code>，在多台服务器之间共享。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715105908.png\" alt=\"20250715105908\"></p>\n<blockquote>\n<p><strong>客户端无法使用 Cookie 怎么办？</strong></p>\n</blockquote>\n<p>有可能客户端无法使用 Cookie，比如浏览器禁用 Cookie，或者客户端是安卓、IOS 等等。</p>\n<p>这时候怎么办？<code>SessionID</code> 怎么存？怎么传给服务端呢？</p>\n<p>首先是 <code>SessionID</code> 的存储，可以使用客户端的本地存储，比如浏览器的 <code>sessionStorage</code>。</p>\n<p>接下来怎么传呢？</p>\n<ul>\n<li>拼接到 URL 里：直接把 <code>SessionID</code> 作为 URL 的请求参数</li>\n<li>放到请求头里：把 <code>SessionID</code> 放到请求的 Header 里，比较常用。</li>\n</ul>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><h3 id=\"24-详细说一下-TCP-的三次握手机制\"><a href=\"#24-详细说一下-TCP-的三次握手机制\" class=\"headerlink\" title=\"24.详细说一下 TCP 的三次握手机制\"></a>24.详细说一下 TCP 的三次握手机制</h3><p>TCP（传输控制协议）的<strong>三次握手机制</strong>是一种用于在两个 TCP 主机之间建立一个可靠连接的过程。这个机制确保了两端的通信是同步的，并且在数据传输开始前，双方都准备好了进行通信。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715110041.png\" alt=\"20250715110041\"></p>\n<p>①、第一次握手：SYN（最开始都是 CLOSE，之后服务器进入 LISTEN）</p>\n<ul>\n<li><strong>发起连接</strong>：客户端发送一个 TCP 报文段到服务器。这个报文段的头部中，SYN 位被设置为 1，表明这是一个连接请求。同时，客户端会随机选择一个序列号（Sequence Number），假设为 x，发送给服务器。</li>\n<li><strong>目的</strong>：客户端通知服务器它希望建立连接，并告知服务器自己的初始序列号。</li>\n<li><strong>状态</strong>：客户端进入 SYN_SENT 状态。</li>\n</ul>\n<p>②、第二次握手：SYN + ACK</p>\n<ul>\n<li><strong>确认并应答</strong>：服务器收到客户端的连接请求后，如果同意建立连接，它会发送一个应答 TCP 报文段给客户端。在这个报文段中，SYN 位和 ACK 位都被设置为 1。服务器也会选择自己的一个随机序列号，假设为 y，并将客户端的序列号加 1（即 x+1）作为确认号（Acknowledgment Number），发送给客户端。</li>\n<li><strong>目的</strong>：服务器告诉客户端，它的连接请求被接受了，并通知客户端自己的初始序列号。</li>\n<li><strong>状态</strong>：服务器进入 SYN_RCVD 状态。</li>\n</ul>\n<p>③、第三次握手：ACK</p>\n<ul>\n<li><strong>最终确认</strong>：客户端收到服务器的应答后，还需要向服务器发送一个确认。这个 TCP 报文段的 ACK 位被设置为 1，确认号被设置为服务器序列号加 1（即 y+1），而自己的序列号是 x+1。</li>\n<li><strong>目的</strong>：客户端确认收到了服务器的同步应答，完成三次握手，建立连接。</li>\n<li><strong>状态</strong>：客户端进入 ESTABLISHED 状态，当服务器接收到这个包时，也进入 ESTABLISHED 状态</li>\n</ul>\n<p>用大白话讲 TCP 三次握手就是：</p>\n<p>三十年前的农村，电话还没有普及，所以，通信基本靠吼。</p>\n<p>老张和老王是邻居，这天老张下地了，结果家里有事，热心的邻居老王赶紧跑到村口，开始叫唤老王。</p>\n<ul>\n<li>老王：老张唉！我是老王，你能听得到吗？</li>\n<li>老张一听，是老王的声音：老王老王，我是老张，我能听得到，你能听得到吗？</li>\n<li>老王一听，嗯，没错，是老张：老张，我听到了，我有事要跟你说。</li>\n</ul>\n<p>“你老婆要生了，赶紧回去吧！”</p>\n<p>老张风风火火地赶回家，老婆顺利地生了个带把的大胖小子。握手的故事充满了幸福和美满。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715110431.png\" alt=\"20250715110431\"></p>\n<h4 id=\"可以再举一个例子说明-TCP-三次握手吗？\"><a href=\"#可以再举一个例子说明-TCP-三次握手吗？\" class=\"headerlink\" title=\"可以再举一个例子说明 TCP 三次握手吗？\"></a>可以再举一个例子说明 TCP 三次握手吗？</h4><p>当然可以，你（客户端）在一个拥挤的聚会上遇到了你想交谈的美女（服务器）。因为周围很吵，你们需要确认对方都准备好交流，并清楚地听到对方说的每一句话。</p>\n<p><strong>①、第一次握手：打招呼</strong></p>\n<ul>\n<li>你走向那个美女，大声说：“嘿，我是小二，我们可以聊聊吗？”（你发送了一个连接请求，告诉服务器你想深入交流，并提供了你的微信号<code>x</code>，也就是你们交谈的起点）</li>\n</ul>\n<p><strong>②、第二次握手：对方回应</strong></p>\n<ul>\n<li>美女一看你挺帅挺有气质，回答说：“嗨，我是小青，可以聊聊。”（服务器接受你的请求，同样愿意深入交流，告诉你它的微信号<code>y</code>，并确认了你的微信号<code>x+1</code>，表示它准备好了）</li>\n</ul>\n<p><strong>③、第三次握手：确认准备就绪</strong></p>\n<ul>\n<li>你听到美女的回答后，对她说：“太好了，我们以后就微信上聊吧。”（你确认了美女的回答，也告诉她你准备好开始了，通过发送确认号<code>y+1</code>）</li>\n</ul>\n<p><strong>④、聊天开始</strong></p>\n<p>这时候，你们两个就确认彼此都准备好深入交流了，可以开始你们的对话了。</p>\n<h4 id=\"说说-SYN-的概念？\"><a href=\"#说说-SYN-的概念？\" class=\"headerlink\" title=\"说说 SYN 的概念？\"></a>说说 SYN 的概念？</h4><p><code>SYN</code> 是 TCP 协议中用来建立连接的一个标志位，全称为 <code>Synchronize Sequence Numbers</code>，也就是同步序列编号。</p>\n<p>SYN 不仅确保了序列号的同步，使得后续的数据能够有序传输，还能防止旧的报文段被误认为是新连接。</p>\n<h3 id=\"25-TCP-握手为什么是三次，为什么不能是两次？不能是四次？\"><a href=\"#25-TCP-握手为什么是三次，为什么不能是两次？不能是四次？\" class=\"headerlink\" title=\"25.TCP 握手为什么是三次，为什么不能是两次？不能是四次？\"></a>25.TCP 握手为什么是三次，为什么不能是两次？不能是四次？</h3><p>使用<strong>三次握手可以建立一个可靠的连接</strong>。这一过程的目的是确保双方都知道对方已准备好进行通信，并同步双方的序列号，从而保持数据包的顺序和完整性。</p>\n<h4 id=\"为什么-TCP-握手不能是两次？\"><a href=\"#为什么-TCP-握手不能是两次？\" class=\"headerlink\" title=\"为什么 TCP 握手不能是两次？\"></a>为什么 TCP 握手不能是两次？</h4><ul>\n<li>为了<strong>防止服务器一直等，等到黄花菜都凉了</strong>。</li>\n<li>为了<strong>防止客户端已经失效的连接请求突然又传送到了服务器</strong>。</li>\n</ul>\n<p>要知道，网络传输是有延时的（要通过网络光纤、WIFI、卫星信号传输等）。</p>\n<p>假如说客户端发起了 SYN&#x3D;1 的第一次握手。服务器也及时回复了 SYN&#x3D;2 和 ACK&#x3D;1 的第二次握手，但是这个 ACK&#x3D;1 的确认报文段因为某些原因在传输过程中丢失了。</p>\n<p>如果没有第三次握手告诉服务器，客户端收到了服务器的回应，那服务器是不知道客户端有没有接收到的。</p>\n<p>于是服务器就一直干巴巴地开着端口在等着客户端发消息呢，但其实客户端并没有收到服务器的回应，心灰意冷地跑了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715112316.png\" alt=\"20250715112316\"></p>\n<p>还有一种情况是，一个旧的、延迟的连接请求（SYN&#x3D;1）被服务器接受，导致服务器错误地开启一个不再需要的连接。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250715112359.png\" alt=\"20250715112359\"></p>\n<p>举个例子：假设你（客户端）给你的朋友（服务器）发送了一个邮件（连接请求）。因为某些原因，这封邮件迟迟没有到达朋友那里，可能是因为邮局的延误。于是你决定再发一封新的邮件。朋友收到了第二封邮件，你们成功地建立了连接并开始通信。</p>\n<p>但是，过了很久，那封延误的旧邮件突然也到了你朋友那里。如果没有一种机制来识别和处理这种延误的邮件，你的朋友可能会以为这是一个新的连接请求，并尝试响应它，但其实你已经重新发了请求，原来的不需要了。这就导致了不必要的混乱和资源浪费。</p>\n<p>所以我们需要“三次握手”来确认这个过程：</p>\n<p>第一次握手：客户端发送 SYN 包（连接请求）给服务器，如果这个包延迟了，客户端不会一直等待，它<strong>可能会重试并发送一个新的连接请求</strong>。<br>第二次握手：服务器收到 SYN 包后，发送一个 SYN-ACK 包（确认接收到连接请求）回客户端。<br>第三次握手：客户端收到 SYN-ACK 包后，再发送一个 ACK 包给服务器，确认收到了服务器的响应。</p>\n<h4 id=\"为什么不是四次？\"><a href=\"#为什么不是四次？\" class=\"headerlink\" title=\"为什么不是四次？\"></a>为什么不是四次？</h4><p>三次握手已经足够创建可靠的连接了，没有必要再多一次握手。</p>\n<h4 id=\"什么是泛洪攻击？\"><a href=\"#什么是泛洪攻击？\" class=\"headerlink\" title=\"什么是泛洪攻击？\"></a>什么是泛洪攻击？</h4><p>泛洪攻击（SYN Flood Attack）是一种常见的 DoS（拒绝服务）攻击，攻击者会发送大量的伪造的 TCP 连接请求，导致服务器资源耗尽，无法处理正常的连接请求。</p>\n<p>半连接服务拒绝，也称为 SYN 洪泛攻击或 SYN Flood。</p>\n<p>所谓的半连接就是指在 TCP 的三次握手过程中，当服务器接收到来自客户端的第一个 SYN 包后，它会回复一个 SYN-ACK 包，此时连接处于“半开”状态，因为连接的建立还需要客户端发送最后一个 ACK 包。</p>\n<p>在收到最后的 ACK 包之前，服务器会为这个尚未完成的连接分配一定的资源，并在它的队列中保留这个连接的位置。</p>\n<h4 id=\"如果让你重新设计，怎么设计？\"><a href=\"#如果让你重新设计，怎么设计？\" class=\"headerlink\" title=\"如果让你重新设计，怎么设计？\"></a>如果让你重新设计，怎么设计？</h4><p>如果重新设计 TCP 的连接建立过程，可以考虑引入 <code>SYN cookies</code>，这种技术通过在 <code>SYN-ACK</code> 响应中编码连接信息，从而在不占用大量资源的情况下验证客户端。</p>\n<h3 id=\"26-三次握手中每一次没收到报文会发生什么情况？\"><a href=\"#26-三次握手中每一次没收到报文会发生什么情况？\" class=\"headerlink\" title=\"26.三次握手中每一次没收到报文会发生什么情况？\"></a>26.三次握手中每一次没收到报文会发生什么情况？</h3><ul>\n<li><strong>第一次握手</strong>服务端未收到 SYN 报文</li>\n</ul>\n<p>服务端不会进行任何的动作，而客户端由于一段时间内没有收到服务端发来的确认报文，等待一段时间后会<strong>重新发送 SYN 报文</strong>，如果仍然没有回应，会重复这个过程，直到发送次数超过最大重传次数限制，就会返回连接建立失败。</p>\n<ul>\n<li><strong>第二次握手</strong>客户端未收到服务端响应的 ACK 报文</li>\n</ul>\n<p>客户端会继续重传，直到次数限制；而服务端此时<strong>会阻塞在 accept()处</strong>，等待客户端发送 ACK 报文</p>\n<ul>\n<li><strong>第三次握手</strong>服务端为收到客户端发送过来的 ACK 报文</li>\n</ul>\n<p>服务端同样会采用类似客户端的<strong>超时重传机制</strong>，如果重试次数超过限制，则 accept()调用返回-1，服务端建立连接失败；而此时客户端认为自己已经建立连接成功，因此开始向服务端发送数据，但是服务端的 accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送来的数据时会发送 <code>RST</code> 报文给客户端，消除客户端单方面建立连接的状态。</p>\n<h3 id=\"27-第二次握手传回了-ACK，为什么还要传回-SYN？\"><a href=\"#27-第二次握手传回了-ACK，为什么还要传回-SYN？\" class=\"headerlink\" title=\"27.第二次握手传回了 ACK，为什么还要传回 SYN？\"></a>27.第二次握手传回了 ACK，为什么还要传回 SYN？</h3><p><code>ACK</code> 是为了告诉客户端传来的数据<strong>已经接收无误</strong>。</p>\n<p>而传回 <code>SYN</code> 是为了告诉客户端，<strong>服务端响应的确实是客户端发送的报文</strong>。</p>\n<h3 id=\"28-第-3-次握手可以携带数据吗？\"><a href=\"#28-第-3-次握手可以携带数据吗？\" class=\"headerlink\" title=\"28.第 3 次握手可以携带数据吗？\"></a>28.第 3 次握手可以携带数据吗？</h3><p>第 3 次握手是可以携带数据的。</p>\n<p>此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。</p>\n<p>第一次握手不能携带数据是<strong>出于安全的考虑</strong>，因为如果允许携带数据，攻击者每次在 SYN 报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成 CPU 和内存的消耗。</p>\n<h3 id=\"29-了解-TCP-半连接状态吗？\"><a href=\"#29-了解-TCP-半连接状态吗？\" class=\"headerlink\" title=\"29.了解 TCP 半连接状态吗？\"></a>29.了解 TCP 半连接状态吗？</h3><p>TCP 半连接指的是在 TCP 三次握手过程中，服务器接收到了客户端的 SYN 包，但还没有完成第三次握手，此时的连接处于一种<strong>未完全建立的状态</strong>。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716103538.png\" alt=\"20250716103538\"></p>\n<p>如果服务器回复了 <code>SYN-ACK</code>，但客户端还没有回复 <code>ACK</code>，该连接将一直保留在半连接队列中，直到超时或被拒绝。</p>\n<h4 id=\"说说半连接队列？\"><a href=\"#说说半连接队列？\" class=\"headerlink\" title=\"说说半连接队列？\"></a>说说半连接队列？</h4><p>TCP 进入三次握手前，服务端会从 CLOSED 状态变为 LISTEN 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716103635.png\" alt=\"20250716103635\"></p>\n<p>顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。</p>\n<ul>\n<li>TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 SYN 队列，即<code>半连接队列</code>。</li>\n<li>当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即<code>全连接队列</code>。</li>\n</ul>\n<h4 id=\"什么是-SYN-Flood-？\"><a href=\"#什么是-SYN-Flood-？\" class=\"headerlink\" title=\"什么是 SYN Flood ？\"></a>什么是 SYN Flood ？</h4><p>SYN Flood 是一种典型的 <code>DDos</code> 攻击，它在短时间内，伪造不存在的 IP 地址, 向服务器发送大量 SYN 报文。当服务器回复 <code>SYN+ACK</code> 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 SYN 接收队列（半连接队列），使得服务器不能为正常⽤户服务。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716105715.png\" alt=\"20250716105715\"></p>\n<h4 id=\"那有什么应对方案呢？\"><a href=\"#那有什么应对方案呢？\" class=\"headerlink\" title=\"那有什么应对方案呢？\"></a>那有什么应对方案呢？</h4><p>主要有 <code>syn cookie</code> 和 <code>SYN Proxy</code> 防火墙等。</p>\n<ul>\n<li><code>syn cookie</code>：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。</li>\n<li><code>SYN Proxy</code> 防火墙：服务器防火墙会对收到的每一个 SYN 报文进行<strong>代理和回应</strong>，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。</li>\n</ul>\n<h3 id=\"30-说说-TCP-四次挥手的过程？\"><a href=\"#30-说说-TCP-四次挥手的过程？\" class=\"headerlink\" title=\"30.说说 TCP 四次挥手的过程？\"></a>30.说说 TCP 四次挥手的过程？</h3><p>TCP 连接的断开过程被形象地概括为<strong>四次挥手</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716105801.png\" alt=\"20250716105801\"></p>\n<p><strong>第一次挥手</strong>：客户端向服务器发送一个 <code>FIN</code> 结束报文，表示客户端没有数据要发送了，但仍然可以接收数据。客户端进入 <code>FIN-WAIT-1</code> 状态。</p>\n<p><strong>第二次挥手</strong>：服务器接收到 <code>FIN</code> 报文后，向客户端发送一个 <code>ACK</code> 报文，确认已接收到客户端的 <code>FIN</code> 请求。服务器进入 <code>CLOSE-WAIT</code> 状态，客户端进入 <code>FIN-WAIT-2</code> 状态。</p>\n<p><strong>第三次挥手</strong>：服务器向客户端发送一个 <code>FIN</code> 报文，表示服务器也没有数据要发送了。服务器进入 <code>LAST-ACK </code>状态。</p>\n<p><strong>第四次挥手</strong>：客户端接收到 <code>FIN</code> 报文后，向服务器发送一个 <code>ACK</code> 报文，确认已接收到服务器的 <code>FIN</code> 请求。客户端进入 <code>TIME-WAIT</code> 状态，等待一段时间以确保服务器接收到 <code>ACK</code> 报文。服务器接收到 <code>ACK</code> 报文后进入 <code>CLOSED</code> 状态。客户端在等待一段时间后也进入 <code>CLOSED</code> 状态。</p>\n<h3 id=\"31-TCP-挥手为什么需要四次呢？\"><a href=\"#31-TCP-挥手为什么需要四次呢？\" class=\"headerlink\" title=\"31.TCP 挥手为什么需要四次呢？\"></a>31.TCP 挥手为什么需要四次呢？</h3><p>因为 <strong>TCP 是全双工通信协议</strong>，数据的发送和接收需要两次一来一回，也就是四次，来确保双方都能正确关闭连接。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716110915.png\" alt=\"20250716110915\"></p>\n<ol>\n<li>第一次挥手：客户端表示数据发送完成了，准备关闭，你确认一下。</li>\n<li>第二次挥手：服务端回话说 ok，我马上处理完数据，稍等。</li>\n<li>第三次挥手：服务端表示处理完了，可以关闭了。</li>\n<li>第四次挥手：客户端说好，进入 TIME_WAIT 状态，确保服务端关闭连接后，自己再关闭连接。</li>\n</ol>\n<h3 id=\"32-TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？\"><a href=\"#32-TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？\" class=\"headerlink\" title=\"32.TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？\"></a>32.TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</h3><blockquote>\n<p><strong>为什么需要等待？</strong></p>\n</blockquote>\n<p><strong>1. 为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN + ACK</strong> 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。</p>\n<p><strong>2. 防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p>\n<blockquote>\n<p><strong>为什么等待的时间是 2MSL？</strong></p>\n</blockquote>\n<p><code>MSL</code> 是 <code>Maximum Segment Lifetime</code>，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。</p>\n<p><code>TIME_WAIT</code> 等待 2 倍的 MSL，⽐较合理的解释是：⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250716112349.png\" alt=\"20250716112349\"></p>\n<p>⽐如如果被动关闭⽅没有收到断开连接的最后的 <code>ACK</code> 报⽂，就会触发超时重发 <code>Fin</code> 报⽂，另⼀⽅接收到 <code>FIN</code> 后，会重发 <code>ACK</code> 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。</p>\n<h3 id=\"33-保活计时器有什么用？\"><a href=\"#33-保活计时器有什么用？\" class=\"headerlink\" title=\"33.保活计时器有什么用？\"></a>33.保活计时器有什么用？</h3><p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。</p>\n<p>设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用<code>保活计时器</code>了。</p>\n<p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>\n<h3 id=\"34-CLOSE-WAIT-和-TIME-WAIT-的状态和意义？\"><a href=\"#34-CLOSE-WAIT-和-TIME-WAIT-的状态和意义？\" class=\"headerlink\" title=\"34.CLOSE-WAIT 和 TIME-WAIT 的状态和意义？\"></a>34.CLOSE-WAIT 和 TIME-WAIT 的状态和意义？</h3><h4 id=\"CLOSE-WAIT-状态有什么意义？\"><a href=\"#CLOSE-WAIT-状态有什么意义？\" class=\"headerlink\" title=\"CLOSE-WAIT 状态有什么意义？\"></a>CLOSE-WAIT 状态有什么意义？</h4><p>服务端收到客户端关闭连接的请求并确认之后，就会进入 <code>CLOSE-WAIT</code> 状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而 <code>CLOSE-WAIT</code> 状态就是为了<strong>保证服务端在关闭连接之前将待发送的数据处理完</strong>。</p>\n<h4 id=\"TIME-WAIT-有什么意义？\"><a href=\"#TIME-WAIT-有什么意义？\" class=\"headerlink\" title=\"TIME-WAIT 有什么意义？\"></a>TIME-WAIT 有什么意义？</h4><p><code>TIME-WAIT</code> 发生在第四次挥手，当客户端在发送 <code>ACK</code> 确认对方的 <code>FIN</code> 报文后，会进入 <code>TIME_WAIT</code> 状态。</p>\n<p>它存在的意义主要有两个：</p>\n<ul>\n<li>在 <code>TIME_WAIT</code> 状态中，客户端可以重新发送 <code>ACK</code> 确保对方正常关闭连接。</li>\n<li>在 <code>TIME_WAIT</code> 持续的 <code>2MSL</code> 时间后，确保旧数据包完全消失，避免它们干扰未来建立的新连接。</li>\n</ul>\n<blockquote>\n<p>补充：MSL（Maximum Segment Lifetime）：TCP 报文段在网络中的最大存活时间，通常为 30 秒到 2 分钟</p>\n</blockquote>\n<h3 id=\"35-TIME-WAIT-状态过多会导致什么问题？怎么解决？\"><a href=\"#35-TIME-WAIT-状态过多会导致什么问题？怎么解决？\" class=\"headerlink\" title=\"35.TIME_WAIT 状态过多会导致什么问题？怎么解决？\"></a>35.TIME_WAIT 状态过多会导致什么问题？怎么解决？</h3><blockquote>\n<p><strong>TIME_WAIT 状态过多会导致什么问题?</strong></p>\n</blockquote>\n<p>如果服务器有处于 <code>TIME-WAIT</code> 状态的 TCP，则说明是由服务器⽅主动发起的断开请求。</p>\n<p>过多的 <code>TIME-WAIT</code> 状态主要的危害有两种：</p>\n<p>第⼀是<strong>内存资源占⽤</strong>；</p>\n<p>第⼆是<strong>对端⼝资源的占⽤</strong>，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；</p>\n<blockquote>\n<p><strong>怎么解决 TIME_WAIT 状态过多？</strong></p>\n</blockquote>\n<ul>\n<li>服务器可以设置 SO_REUSEADDR 套接字来通知内核，如果端口被占用，但是 TCP 连接位于 TIME_WAIT 状态时可以重用端口。</li>\n<li>还可以使用长连接的方式来减少 TCP 的连接和断开，在长连接的业务里往往不需要考虑 TIME_WAIT 状态。</li>\n</ul>\n<h3 id=\"36-说说-TCP-报文头部的格式？\"><a href=\"#36-说说-TCP-报文头部的格式？\" class=\"headerlink\" title=\"36.说说 TCP 报文头部的格式？\"></a>36.说说 TCP 报文头部的格式？</h3><p>一个 TCP 报文段主要由<code>报文段头部（Header）</code>和<code>数据</code>两部分组成。头部包含了确保数据可靠传输所需的各种控制信息，比如说序列号、确认号、窗口大小等。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717092859.png\" alt=\"20250717092859\"></p>\n<ul>\n<li><strong>源端口号</strong>（Source Port）：16 位（2 个字节），用于标识发送端的应用程序。</li>\n<li><strong>目标端口号</strong>（Destination Port）：也是 16 位，用于标识接收端的应用程序。</li>\n<li><strong>序列号</strong>（Sequence Number）：32 位，用于标识从 TCP 发送者发送的数据字节流中的第一个字节的顺序号。确保数据按顺序接收。</li>\n<li><strong>确认号</strong>（Acknowledgment Number）：32 位，如果 ACK 标志被设置，则该字段包含发送确认的序列号，即接收 TCP 希望收到的下一个序列号。</li>\n<li><strong>数据偏移</strong>（Data Offset）：4 位，表示 TCP 报文头部的长度，用于指示数据开始的位置。</li>\n<li><strong>保留</strong>（Reserved）：6 位，为将来使用预留，目前必须置为 0。</li>\n<li><strong>控制位</strong>（Flags）：共 6 位，包括 URG（紧急指针字段是否有效）、ACK（确认字段是否有效）、PSH（提示接收端应该尽快将这个报文段交给应用层）、RST（重置连接）、SYN（同步序号，用于建立连接）、FIN（结束发送数据）。</li>\n<li><strong>窗口大小</strong>（Window）：16 位，用于流量控制，表示接收端还能接收的数据的字节数（基于接收缓冲区的大小）。</li>\n<li><strong>校验和</strong>（Checksum）：16 位，覆盖整个 TCP 报文段（包括 TCP 头部、数据和一个伪头部）的校验和，用于检测数据在传输过程中的任何变化。</li>\n<li><strong>紧急指针</strong>（Urgent Pointer）：16 位，只有当 URG 控制位被设置时才有效，指出在报文段中有紧急数据的位置。</li>\n</ul>\n<h3 id=\"37-TCP-为什么可靠？\"><a href=\"#37-TCP-为什么可靠？\" class=\"headerlink\" title=\"37.TCP 为什么可靠？\"></a>37.TCP 为什么可靠？</h3><p>TCP 首先通过三次握手和四次挥手来<strong>保证连接的可靠性</strong>，然后通过校验和、序列号、确认应答、超时重传、滑动窗口等机制来<strong>保证数据的可靠传输</strong>。</p>\n<p><a href=\"https://www.noction.com/blog/tcp-header\">推荐阅读：TCP 校验和计算方法</a></p>\n<p>①、校验和：TCP 报文段包括一个<code>校验和</code>字段，用于检测报文段在传输过程中的变化。如果接收方检测到校验和错误，就会丢弃这个报文段。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717093709.png\" alt=\"20250717093709\"></p>\n<p>②、<strong>序列号&#x2F;确认机制</strong>：TCP 将数据分成多个小段，每段数据都有唯一的序列号，以确保数据包的顺序传输和完整性。同时，发送方如果没有收到接收方的确认应答，会重传数据。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095429.png\" alt=\"20250717095429\"></p>\n<p>③、<strong>流量控制</strong>：接收方会发送窗口大小告诉发送方它的接收能力。发送方会根据窗口大小调整发送速度，避免网络拥塞。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095450.png\" alt=\"20250717095450\"></p>\n<p>④、<strong>超时重传</strong>：如果发送方发送的数据包超过了最大生存时间，接收方还没有收到，发送方会重传数据包以保证丢失数据重新传输。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095514.png\" alt=\"20250717095514\"></p>\n<p>⑤、<strong>拥塞控制</strong>：TCP 会采用慢启动的策略，一开始发的少，然后逐步增加，当检测到网络拥塞时，会降低发送速率。在网络拥塞缓解后，传输速率也会自动恢复。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717095532.png\" alt=\"20250717095532\"></p>\n<h3 id=\"38-说说-TCP-的流量控制？\"><a href=\"#38-说说-TCP-的流量控制？\" class=\"headerlink\" title=\"38.说说 TCP 的流量控制？\"></a>38.说说 TCP 的流量控制？</h3><p>TCP 提供了一种机制，可以<strong>让发送端根据接收端的实际接收能力控制发送的数据量</strong>，这就是流量控制。<br>TCP 通过滑动窗口来控制流量，我们看下简要流程：</p>\n<ul>\n<li>首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717100157.png\" alt=\"20250717100157\"></li>\n<li>假如当前发送方给接收方发送了 200 个字节，那么，发送方的SND.NXT会右移 200 个字节，也就是说当前的可用窗口减少了 200 个字节。</li>\n<li>接受方收到后，放到缓冲队列里面，REV.WND &#x3D;400-200&#x3D;200 字节，所以 win&#x3D;200 字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节</li>\n<li>发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND &#x3D; 400-200-100&#x3D;100 字节，即 win&#x3D;100 返回发送方。</li>\n<li>发送方继续发送 100 字节过来，这时候，接收窗口 win 变为 0。</li>\n<li>发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送。</li>\n</ul>\n<h3 id=\"39-详细说说-TCP-的滑动窗口？\"><a href=\"#39-详细说说-TCP-的滑动窗口？\" class=\"headerlink\" title=\"39.详细说说 TCP 的滑动窗口？\"></a>39.详细说说 TCP 的滑动窗口？</h3><p>TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。</p>\n<p>“用一个比喻，我们在微信上聊天，你打完一句话，我回复一句之后，你才能打下一句。假如我没有及时回复呢？你是把话憋着不说吗？然后傻傻等到我回复之后再接着发下一句？”</p>\n<p>为了解决这个问题，TCP 引入了<strong>窗口</strong>，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。</p>\n<p>TCP 头部有个字段叫 <code>win</code>，也即那个 <strong>16 位的窗口大小</strong>，它告诉对方本端的 <code>TCP</code> 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到<strong>流量控制</strong>的目的。</p>\n<p>“通俗点讲，就是接受方每次收到数据包，在<strong>发送确认报文的时候</strong>，同时告诉发送方，<strong>自己的缓存区还有多少空余空间</strong>，缓冲区的空余空间，我们就称之为<code>接受窗口大小</code>。这就是 <code>win</code>。”</p>\n<p>TCP 滑动窗口分为两种: <code>发送窗口</code>和<code>接收窗口</code>。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p>\n<ul>\n<li>已发送且已收到 ACK 确认</li>\n<li>已发送但未收到 ACK 确认</li>\n<li>未发送但可以发送</li>\n<li>未发送也不可以发送</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717101303.png\" alt=\"20250717101303\"></p>\n<ul>\n<li>深蓝色框里就是发送窗口。</li>\n<li><code>SND.WND</code>: 表示发送窗口的大小, 上图虚线框的格子数是 10 个，即发送窗口大小是 10。</li>\n<li><code>SND.NXT</code>：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。</li>\n<li><code>SND.UNA</code>: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</li>\n</ul>\n<p>接收方的滑动窗口包含三大部分，如下：</p>\n<ul>\n<li>已成功接收并确认</li>\n<li>未收到数据但可以接收</li>\n<li>未收到数据并不可以接收的数据</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717101631.png\" alt=\"20250717101631\"></p>\n<ul>\n<li>蓝色框内，就是接收窗口。</li>\n<li>REV.WND: 表示接收窗口的大小, 上图虚线框的格子就是 9 个。</li>\n<li>REV.NXT: 下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</li>\n</ul>\n<h3 id=\"40-了解-Nagle-算法和延迟确认吗？\"><a href=\"#40-了解-Nagle-算法和延迟确认吗？\" class=\"headerlink\" title=\"40.了解 Nagle 算法和延迟确认吗？\"></a>40.了解 Nagle 算法和延迟确认吗？</h3><blockquote>\n<p><strong>Nagle 算法和延迟确认是干什么的？</strong></p>\n</blockquote>\n<p>当我们 TCP 报⽂的承载的数据⾮常⼩的时候，例如⼏个字节，那么整个⽹络的效率是很低的，因为每个 TCP 报⽂中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，⽽数据只有⼏个字节，所以在整个报⽂中有效数据占有的比例就会⾮常低。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717101740.png\" alt=\"20250717101740\"></p>\n<p>这就好像快递员开着⼤货⻋送⼀个⼩包裹⼀样浪费。</p>\n<p>那么就出现了常⻅的两种策略，来减少⼩报⽂的传输，分别是：</p>\n<ul>\n<li><code>Nagle 算法</code></li>\n<li><code>延迟确认</code></li>\n</ul>\n<blockquote>\n<p><strong>Nagle 算法</strong></p>\n</blockquote>\n<p>Nagle 算法：<strong>任意时刻，最多只能有一个未被确认的小段</strong>。所谓 “小段”，指的是小于 <code>MSS</code> 尺寸的数据块，所谓 “未被确认”，是指一个数据块发送出去后，没有收到对方发送的 ACK 确认该数据已收到。</p>\n<p>Nagle 算法的策略：</p>\n<ul>\n<li>没有已发送未确认报⽂时，⽴刻发送数据。</li>\n<li>存在未确认报⽂时，直到「没有已发送未确认报⽂」或「数据⻓度达到 MSS ⼤⼩」时，再发送数据。</li>\n</ul>\n<p>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件。</p>\n<blockquote>\n<p><strong>延迟确认</strong></p>\n</blockquote>\n<p>事实上当没有携带数据的 ACK，它的⽹络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报⽂。</p>\n<p>为了解决 ACK 传输效率低问题，所以就衍⽣出了 <strong>TCP</strong> 延迟确认。</p>\n<p>TCP 延迟确认的策略：</p>\n<ul>\n<li>当有响应数据要发送时，ACK 会随着响应数据⼀起⽴刻发送给对⽅</li>\n<li>当没有响应数据要发送时，ACK 将会延迟⼀段时间，以等待是否有响应数据可以⼀起发送</li>\n<li>如果在延迟等待发送 ACK 期间，对⽅的第⼆个数据报⽂⼜到达了，这时就会⽴刻发送 ACK</li>\n</ul>\n<p>一般情况下，<strong>Nagle 算法和延迟确认</strong>不能一起使用，Nagle 算法意味着延迟发，<strong>延迟确认</strong>意味着延迟接收，两个凑在一起就会造成更大的延迟，会产生性能问题。</p>\n<h3 id=\"41-说说-TCP-的拥塞控制？\"><a href=\"#41-说说-TCP-的拥塞控制？\" class=\"headerlink\" title=\"41.说说 TCP 的拥塞控制？\"></a><a href=\"https://javabetter.cn/sidebar/sanfene/network.html#_41-%E8%AF%B4%E8%AF%B4-tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6\">41.说说 TCP 的拥塞控制？</a></h3><h4 id=\"什么是拥塞控制？\"><a href=\"#什么是拥塞控制？\" class=\"headerlink\" title=\"什么是拥塞控制？\"></a>什么是拥塞控制？</h4><p>流量控制是为了<strong>避免发送⽅的数据填满接收⽅的缓存</strong>，但并不能控制整个⽹络。</p>\n<p>⼀般来说，计算机⽹络会处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p>\n<p>当⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包延时、丢失等，这时 <strong>TCP</strong> 就会重传数据，但重传会增加⽹络负担，于是会导致更⼤的延迟以及更多的丢包，就进⼊了恶性循环….</p>\n<p>所以，TCP 被设计成了⼀个非常⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据流。</p>\n<p>拥塞控制的⽬的就是避免发送⽅的数据填满整个⽹络。</p>\n<p>就像是一个水管，不能让太多的水（数据流）流入水管，如果超过水管的承受能力，水管会被撑爆（丢包）。</p>\n<p>发送方会维护一个<strong>拥塞窗口 cwnd</strong> 的变量，调节所要发送数据的量。</p>\n<h4 id=\"什么是拥塞窗⼝？和发送窗⼝有什么关系呢？\"><a href=\"#什么是拥塞窗⼝？和发送窗⼝有什么关系呢？\" class=\"headerlink\" title=\"什么是拥塞窗⼝？和发送窗⼝有什么关系呢？\"></a>什么是拥塞窗⼝？和发送窗⼝有什么关系呢？</h4><p>拥塞窗⼝ <strong>cwnd</strong>是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。</p>\n<p>发送窗⼝ <code>swnd</code> 和接收窗⼝ <code>rwnd</code> 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是 <code>swnd = min(cwnd, rwnd)</code>，也就是拥塞窗⼝和接收窗⼝中的<strong>最⼩值</strong>。</p>\n<p>拥塞窗⼝ <code>cwnd</code> 变化的规则：</p>\n<ul>\n<li>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</li>\n<li>但⽹络中出现了拥塞， cwnd 就减少；</li>\n</ul>\n<h4 id=\"拥塞控制有哪些常用算法？\"><a href=\"#拥塞控制有哪些常用算法？\" class=\"headerlink\" title=\"拥塞控制有哪些常用算法？\"></a>拥塞控制有哪些常用算法？</h4><p>拥塞控制主要有这几种常用算法：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717102823.png\" alt=\"20250717102823\"></p>\n<ul>\n<li>慢启动</li>\n<li>拥塞避免</li>\n<li>拥塞发生</li>\n<li>快速恢复</li>\n</ul>\n<p>①、慢启动算法</p>\n<p>慢启动算法，慢慢启动。</p>\n<p>它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，<strong>每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）</strong>。<strong>每轮次</strong>发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。</p>\n<p>举个例子：</p>\n<ul>\n<li>连接建⽴完成后，⼀开始初始化 cwnd &#x3D; 1 ，表示可以传⼀个 MSS ⼤⼩的数据。</li>\n<li>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个</li>\n<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发 2 个，所以这⼀次能够发送 4 个</li>\n<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发 4 个，所以这⼀次能够发送 8 个。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717102916.png\" alt=\"20250717102916\"></li>\n</ul>\n<p>发包的个数是指数性的增⻓。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103327.png\" alt=\"20250717103327\"></p>\n<p>为了防止 <code>cwnd</code> 增长过大引起网络拥塞，还需设置一个慢启动阀值 <code>ssthresh（slow start threshold）</code>状态变量。当<code>cwnd</code>到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当 <code>cwnd &gt;ssthresh</code> 时，进入了拥塞避免算法。</p>\n<p>②、拥塞避免算法<br>一般来说，慢启动阀值 <code>ssthresh</code> 是 65535 字节，cwnd到达慢启动阀值后</p>\n<ul>\n<li>每收到一个 <code>ACK</code> 时，cwnd &#x3D; cwnd + 1&#x2F;cwnd</li>\n<li>当每过一个 <code>RTT</code> 时，cwnd &#x3D; cwnd + 1</li>\n</ul>\n<p>显然这是一个<strong>线性上升的算法</strong>，避免过快导致网络拥塞问题。<br>接着上面慢启动的例子，假定 ssthresh 为 8 ：</p>\n<ul>\n<li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9 个 MSS ⼤⼩的数据，变成了线性增⻓。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103500.png\" alt=\"20250717103500\"></p>\n<p>③、拥塞发生</p>\n<p>当网络拥塞发生<strong>丢包</strong>时，会有两种情况：</p>\n<ul>\n<li>RTO 超时重传</li>\n<li>快速重传</li>\n</ul>\n<p>如果是发生了 <strong>RTO 超时重传</strong>，就会使用拥塞发生算法</p>\n<ul>\n<li>慢启动阀值 sshthresh &#x3D; cwnd &#x2F;2</li>\n<li>cwnd 重置为 1</li>\n<li>进入新的慢启动过程</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103608.png\" alt=\"20250717103608\"></p>\n<p>这种方式就像是飙车的时候急刹车，还飞速倒车，这。。。</p>\n<p>其实还有更好的处理方式，就是<code>快速重传</code>。发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待 RTO 超时再重传。</p>\n<p>发⽣快速重传的拥塞发⽣算法：</p>\n<p>拥塞窗口大小 <code>cwnd = cwnd/2</code><br>慢启动阀值 <code>ssthresh = cwnd</code><br>进入快速恢复算法</p>\n<p>④、快速恢复</p>\n<p>快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。</p>\n<p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>sshthresh</code> 已被更新：</p>\n<ul>\n<li>cwnd &#x3D; cwnd &#x2F;2</li>\n<li>sshthresh &#x3D; cwnd</li>\n</ul>\n<p>然后，进⼊快速恢复算法如下：</p>\n<ul>\n<li>cwnd &#x3D; sshthresh + 3</li>\n<li>重传重复的那几个 ACK（即丢失的那几个数据包）</li>\n<li>如果再收到重复的 ACK，那么 cwnd &#x3D; cwnd +1</li>\n<li>如果收到新数据的 ACK 后, cwnd &#x3D; sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717103856.png\" alt=\"20250717103856\"></p>\n<h3 id=\"42-说说-TCP-的重传机制？\"><a href=\"#42-说说-TCP-的重传机制？\" class=\"headerlink\" title=\"42.说说 TCP 的重传机制？\"></a>42.说说 TCP 的重传机制？</h3><p>超时重传机制是 <code>TCP</code> 的核心之一，它能确保在网络传输中如果某些数据包丢失或没有及时到达的话，TCP 能够重新发送这些数据包，以保证数据完整性。</p>\n<p>其原理是在发送某个数据后开启一个计时器，如果在一定时间内没有得到发送数据报的 <code>ACK</code> 报文，就重新发送数据，直到发送成功为止。</p>\n<p>重传包括<code>超时重传</code>、<code>快速重传</code>、<code>带选择确认的重传（SACK）</code>和<code>重复 SACK</code> 四种。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104021.png\" alt=\"20250717104021\"></p>\n<h4 id=\"超时时间应该设置为多少呢？\"><a href=\"#超时时间应该设置为多少呢？\" class=\"headerlink\" title=\"超时时间应该设置为多少呢？\"></a>超时时间应该设置为多少呢？</h4><p><code>TCP</code> 中的重传超时时间（RTO，Retransmission Timeout）不是一个固定的值，而是动态计算的，目的是为了适应不同的网络条件。</p>\n<p><code>RTO</code> 有个标准方法的计算公式，叫 <strong>Jacobson &#x2F; Karels 算法</strong>。</p>\n<p>①、计算 SRTT（Smoothed RTT，平滑往返时间），以避免单次测量中的抖动影响重传时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRTT = (<span class=\"number\">1</span> - α) * SRTT + α * RTT</span><br></pre></td></tr></table></figure>\n\n<p>其中，α 是一个常量，通常取值为 0.125（即1&#x2F;8），表示新测量值对平滑RTT的影响比例。</p>\n<p><code>RTT</code>，也就是 <code>Round-Trip Time</code>，往返时间，即数据包从发送到接收到确认的时间。TCP 会对每个数据包的 RTT 进行测量，并不断更新这个值。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104143.png\" alt=\"20250717104143\"></p>\n<p>②、计算 RTTVAR (RTT Variation，表示RTT的变化量，用于衡量RTT的波动)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RTTVAR = (<span class=\"number\">1</span> - β) * RTTVAR + β * (|RTT - SRTT|)</span><br></pre></td></tr></table></figure>\n<p>β 通常取值为 0.25（即1&#x2F;4），表示对RTTVAR更新的权重。</p>\n<p>③、最后，得出最终的 RTO</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RTO = SRTT + max(G, <span class=\"number\">4</span> x RTTVAR)</span><br></pre></td></tr></table></figure>\n\n<p>G 是一个小的常量偏移量，用来防止RTO过小。一般来说，G 的值通常是1毫秒。</p>\n<p>一般来说，RTO 略微大于 RTT，效果是最佳的。</p>\n<ul>\n<li>如果 RTO 设置很大，可能等了很久都没有重发。</li>\n<li>如果 RTO 设置很小，那很可能数据还没有丢失，就开始重发了。</li>\n</ul>\n<p>超时重传不是十分完美的重传方案，它有这些缺点：</p>\n<ul>\n<li>当报文丢失时，需要等待一定的超时周期，才开始重传。</li>\n<li>当报文丢失时，在等待超时的过程中，可能会出现这种情况：后面的报文已经被接收端接收了但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传。</li>\n<li>并且，对于 TCP 来说，如果发生一次超时重传，下次的时间间隔就会加倍。</li>\n</ul>\n<h4 id=\"什么是快速重传？\"><a href=\"#什么是快速重传？\" class=\"headerlink\" title=\"什么是快速重传？\"></a>什么是快速重传？</h4><p>TCP 还有另外⼀种快速重传（<strong>Fast Retransmit</strong>）机制，它不以时间为驱动，⽽是以数据驱动重传。</p>\n<p>它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。</p>\n<p>可以用它来解决超时重发的时间等待问题，快速重传流程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104352.png\" alt=\"20250717104352\"></p>\n<p>在上图，发送⽅发出了 1，2，3，4，5 份数据：</p>\n<ul>\n<li>第⼀份 Seq1 先送到了，于是就 Ack 回 2；</li>\n<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>\n<li>后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>\n<li>发送端收到了三个 <strong>Ack &#x3D; 2</strong> 的确认，知道了 <strong>Seq2</strong> 还没有收到，就会在定时器过期之前，重传丢失的 <strong>Seq2</strong>。</li>\n<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>\n</ul>\n<p>快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题。</p>\n<p>⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>\n<p>根据 TCP 不同的实现，以上两种情况都是有可能的。可⻅，这是⼀把双刃剑。</p>\n<p>为了解决不知道该重传哪些 TCP 报⽂，于是就有 SACK ⽅法。</p>\n<h4 id=\"什么是带选择确认的重传-SACK\"><a href=\"#什么是带选择确认的重传-SACK\" class=\"headerlink\" title=\"什么是带选择确认的重传(SACK)\"></a>什么是带选择确认的重传(SACK)</h4><p>为了解决应该重传多少个包的问题? TCP 提供了<strong>带选择确认的重传</strong>（即 SACK，Selective Acknowledgment）。</p>\n<p><strong>SACK 机制</strong>就是，在快速重传的基础上，<strong>接收方返回最近收到报文段的序列号范围</strong>，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104711.png\" alt=\"20250717104711\"></p>\n<p>如上图中，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重发。</p>\n<h4 id=\"什么是重复-SACK（D-SACK）\"><a href=\"#什么是重复-SACK（D-SACK）\" class=\"headerlink\" title=\"什么是重复 SACK（D-SACK）\"></a>什么是重复 SACK（D-SACK）</h4><p><code>D-SACK</code>，英文是 Duplicate SACK，是在 SACK 的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。</p>\n<p>DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</p>\n<p>例如 <code>ACK</code> 丢包导致的数据包重复：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104804.png\" alt=\"20250717104804\"></p>\n<ul>\n<li><p>接收⽅发给发送⽅的两个 ACK 确认应答都丢失了，所以发送⽅超时后，重传第⼀个数据包（3000 ~<br>3499）</p>\n</li>\n<li><p>于是接收⽅发现数据是重复收到的，于是回了⼀个 SACK &#x3D; 3000<del>3500，告诉「发送⽅」 3000</del>3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK 。这样发送⽅就知道了，数据没有丢，是接收⽅的 ACK 确认报⽂丢了。</p>\n</li>\n</ul>\n<h3 id=\"43-说说-TCP-的粘包和拆包？\"><a href=\"#43-说说-TCP-的粘包和拆包？\" class=\"headerlink\" title=\"43.说说 TCP 的粘包和拆包？\"></a>43.说说 TCP 的粘包和拆包？</h3><p>TCP 的粘包和拆包更多的是业务上的概念！</p>\n<blockquote>\n<p><strong>什么是 TCP 粘包和拆包？</strong></p>\n</blockquote>\n<p>TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一<strong>个完整的包可能会被 TCP 拆分成多个包进行发送</strong>，<strong>也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是所谓的 TCP 粘包和拆包问题。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250717104919.png\" alt=\"20250717104919\"></p>\n<blockquote>\n<p><strong>为什么会产生粘包和拆包呢?</strong></p>\n</blockquote>\n<ul>\n<li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li>\n<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li>\n<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；</li>\n<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li>\n</ul>\n<blockquote>\n<p><strong>那怎么解决呢？</strong></p>\n</blockquote>\n<ul>\n<li>发送端将每个数据包封装为固定长度</li>\n<li>在数据尾部增加特殊字符进行分割</li>\n<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li>\n</ul>\n<h3 id=\"63-一个TCP连接可以发送多少次HTTP请求-（补充）\"><a href=\"#63-一个TCP连接可以发送多少次HTTP请求-（补充）\" class=\"headerlink\" title=\"63.一个TCP连接可以发送多少次HTTP请求?（补充）\"></a>63.一个TCP连接可以发送多少次HTTP请求?（补充）</h3><p>一个 TCP 连接可以发送多少次 HTTP 请求，取决于 HTTP 协议的版本。</p>\n<p>在 HTTP&#x2F;1.0 中，每个 HTTP 请求-响应使用一个单独的 TCP 连接。这意味着每次发送 HTTP 请求都需要建立一个新的 TCP 连接。</p>\n<p><code>HTTP/1.1</code> 引入了持久连接（Persistent Connection），默认情况下允许在一个 TCP 连接上发送多个 HTTP 请求。</p>\n<p>通过使用 <code>Connection: keep-alive</code> 头部实现，保持连接打开状态，直到明确关闭为止。这极大地提高了效率，因为无需为每个请求都建立新的连接。</p>\n<p>此外，<code>HTTP/1.1</code> 支持请求管道化（Pipelining），允许客户端在收到前一个响应之前发送多个请求。</p>\n<p>HTTP&#x2F;2 进一步优化了连接复用，允许在单个 TCP 连接上同时发送多个请求和响应，这些请求和响应被分割成帧并通过流传输。HTTP&#x2F;2 的多路复用（Multiplexing）机制显著提高了并发性能和资源利用效率。</p>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><h3 id=\"44-说说-TCP-和-UDP-的区别？\"><a href=\"#44-说说-TCP-和-UDP-的区别？\" class=\"headerlink\" title=\"44.说说 TCP 和 UDP 的区别？\"></a>44.说说 TCP 和 UDP 的区别？</h3><p><code>TCP</code> 是<strong>面向连接</strong>的，而 <code>UDP</code> 是<strong>无连接的</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718095307.png\" alt=\"20250718095307\"></p>\n<p>TCP 就像是打电话一对一私聊，UDP 就像是拿个大喇叭在广播。</p>\n<p>在数据传输开始之前，TCP 需要先建立连接，数据传输完成后，再断开连接。这个过程通常被称为“三次握手”、“四次挥手”。</p>\n<p>UDP 是无连接的，发送数据之前不需要建立连接，发送完毕也不需要断开，数据以数据报形式发送。</p>\n<p>换句话说：TCP 是可靠的，它通过确认机制、重发机制等来保证数据的可靠传输。而 UDP 是不可靠的，数据包可能会丢失、重复、乱序。</p>\n<h4 id=\"说说-TCP-和-UDP-的应用场景？\"><a href=\"#说说-TCP-和-UDP-的应用场景？\" class=\"headerlink\" title=\"说说 TCP 和 UDP 的应用场景？\"></a>说说 TCP 和 UDP 的应用场景？</h4><ul>\n<li><strong>TCP：</strong> 适用于那些<strong>对数据准确性要求高于数据传输速度</strong>的场合。例如：网页浏览、电子邮件、文件传输（FTP）、远程控制、数据库链接。</li>\n<li><strong>UDP：</strong> 适用于<strong>对速度要求高、可以容忍一定数据丢失</strong>的场合。例如：QQ 聊天、在线视频、网络语音电话、广播通信。容忍一定的数据丢失。</li>\n</ul>\n<h4 id=\"你会如何设计-QQ-中的网络协议？\"><a href=\"#你会如何设计-QQ-中的网络协议？\" class=\"headerlink\" title=\"你会如何设计 QQ 中的网络协议？\"></a>你会如何设计 QQ 中的网络协议？</h4><p>首先，我们要实现登录功能，这是使用 QQ 的第一步，为了保证账号和密码的安全性，我们可以选择 <code>TCP + SSL/TLS</code> 协议来<strong>进行登录</strong>。</p>\n<p>因为 TCP 协议是一种可靠的传输协议，能够保证数据的完整性，而 <code>SSL/TLS</code> 能够对通信进行加密，保证数据的安全性。</p>\n<p>接下来，我们需要考虑消息传递的实时性，如语音视频通话等，这时候我们可以选择 <code>UDP</code> 协议。UDP 的传输速度更快，对于实时性服务来说，速度是最重要的。</p>\n<h4 id=\"如何保证消息的不丢失？\"><a href=\"#如何保证消息的不丢失？\" class=\"headerlink\" title=\"如何保证消息的不丢失？\"></a>如何保证消息的不丢失？</h4><p>对于 TCP 协议来说，如果数据包在传输过程中丢失，TCP 协议会自动进行重传。</p>\n<p>而对于 UDP 协议来说，我们可以通过<strong>应用层的重传机制</strong>来保证消息的不丢失。当接收方收到消息后，返回一个确认信息给发送方，如果发送方在一定时间内没有收到确认信息，就重新发送消息。</p>\n<p>同时，每个消息都附带一个<strong>唯一的序列号</strong>，接收方根据序列号判断是否有消息丢失，如果发现序列号不连续，就可以要求发送方重新发送。这样还可以防止消息重复。</p>\n<p>当然了，<strong>消息持久化</strong>也很重要，可以将消息<strong>保存在服务器或者本地的数据库</strong>中，即使在网络中断或者其他异常情况下，也能从数据库中恢复消息。</p>\n<h3 id=\"45-为什么-QQ-采用-UDP-协议？\"><a href=\"#45-为什么-QQ-采用-UDP-协议？\" class=\"headerlink\" title=\"45.为什么 QQ 采用 UDP 协议？\"></a>45.为什么 QQ 采用 UDP 协议？</h3><p>PS：这是多年前的老题了，拉出来怀怀旧。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718100733.png\" alt=\"20250718100733\"></p>\n<ul>\n<li>首先，QQ 并不是完全基于 UDP 实现。比如在使用 QQ 进行<strong>文件传输等活动的时</strong>候，就会使用 <strong>TCP</strong> 作为可靠传输的保证。</li>\n<li>使用 <code>UDP</code> 进行交互通信的好处在于，<strong>延迟较短</strong>，对数据丢失的处理比较简单。同时，TCP 是一个全双工协议，需要建立连接，所以<strong>网络开销也会相对大</strong>。</li>\n<li>如果使用 QQ 语音和 QQ 视频的话，UDP 的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。</li>\n<li>由于 QQ 的服务器<strong>设计容量是海量级的应用</strong>，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用 UDP 协议与客户端进行通讯才能保证这种超大规模的服务</li>\n</ul>\n<p>简单总结一下：UDP 协议<strong>是无连接方式的协议</strong>，它的<strong>效率高</strong>，<strong>速度快</strong>，<strong>占资源少</strong>，对服务器的压力比较小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。QQ 采用的通信协议以 UDP 为主，辅以 TCP 协议。</p>\n<h3 id=\"46-UDP-协议为什么不可靠？\"><a href=\"#46-UDP-协议为什么不可靠？\" class=\"headerlink\" title=\"46.UDP 协议为什么不可靠？\"></a>46.UDP 协议为什么不可靠？</h3><p>UDP 在传输数据之前<strong>不需要先建立连接</strong>，远地主机的运输层在接收到 <code>UDP</code> 报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>\n<ul>\n<li>不保证消息交付：不确认，不重传，无超时</li>\n<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>\n<li>不跟踪连接状态：不必建立连接或重启状态机</li>\n<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>\n</ul>\n<h3 id=\"47-DNS-为什么要用-UDP\"><a href=\"#47-DNS-为什么要用-UDP\" class=\"headerlink\" title=\"47.DNS 为什么要用 UDP?\"></a>47.DNS 为什么要用 UDP?</h3><p>更准确地说，<strong>DNS 既使用 TCP 又使用 UDP</strong>。</p>\n<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为<strong>数据同步传送的数据量比一个请求和应答的数据量要多</strong>，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p>\n<p>当客户端想 DNS 服务器查询域名（域名解析）的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节，用 UDP 传输时，不需要创建连接，从而大大提高了响应速度，但这要求域名解析服务器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>\n<h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><h3 id=\"48-IP-协议的定义和作用？\"><a href=\"#48-IP-协议的定义和作用？\" class=\"headerlink\" title=\"48.IP 协议的定义和作用？\"></a>48.IP 协议的定义和作用？</h3><p><code>IP</code> 协议（Internet Protocol）用于在计算机网络之间传输数据包，它定义了数据包的格式和处理规则，确保数据能够从一个设备传输到另一个设备，可能跨越多个中间网络设备（如路由器）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718103720.png\" alt=\"20250718103720\"></p>\n<h4 id=\"IP-协议有哪些作用？\"><a href=\"#IP-协议有哪些作用？\" class=\"headerlink\" title=\"IP 协议有哪些作用？\"></a>IP 协议有哪些作用？</h4><p>①、<strong>寻址</strong>：每个<strong>连接到网络的设备都有一个唯一的 IP 地址</strong>。IP 协议使用这些地址来标识数据包的源地址和目的地址，确保数据包能够准确地传输到目标设备。</p>\n<p>②、<strong>路由</strong>：IP 协议负责决定数据包在网络传输中的路径。比如说路由器使用路由表和 IP 地址信息来确定数据包的最佳传输路径。</p>\n<p>③、<strong>分片和重组</strong>：当数据包过大无法在某个网络上传输时，IP 协议会将数据包分成更小的片段进行传输。接收端会根据头部信息将这些片段重新组装成完整的数据包。</p>\n<h4 id=\"举一个实际的例子来说明？\"><a href=\"#举一个实际的例子来说明？\" class=\"headerlink\" title=\"举一个实际的例子来说明？\"></a>举一个实际的例子来说明？</h4><p>假设有两个设备 A 和 B 通过互联网通信，A 的 IP 地址是 <code>192.168.1.1</code>，B 的 IP 地址是 <code>203.0.113.5</code>。数据包的传输过程如下：</p>\n<p>①、设备 A 发送数据包：</p>\n<ul>\n<li>设备 A 创建一个 IP 数据包，设置源地址为 <code>192.168.1.1</code>，目的地址为 <code>203.0.113.5</code>，将要传输的数据放入数据部分。</li>\n<li>数据包封装后，通过本地网络发送到路由器。</li>\n</ul>\n<p>②、路由器转发数据包：</p>\n<ul>\n<li>路由器根据路由表查找目的地址 <code>203.0.113.5</code>，确定数据包的传输路径。</li>\n<li>数据包可能经过多个中间路由器，每个路由器都根据路由表选择下一跳，最终到达目标设备的网络。</li>\n</ul>\n<p>③、设备 B 接收数据包：</p>\n<ul>\n<li>设备 B 接收数据包，读取 <code>IP</code> 头部信息，验证数据包的完整性。</li>\n<li>并数据部分取出，交给上层协议处理（如 TCP 或 UDP）。</li>\n</ul>\n<h3 id=\"49-IP-地址有哪些分类？\"><a href=\"#49-IP-地址有哪些分类？\" class=\"headerlink\" title=\"49.IP 地址有哪些分类？\"></a>49.IP 地址有哪些分类？</h3><p>一个 <code>IP</code> 地址在这个互联网范围内是唯一的，一般可以这么认为，<code>IP 地址 = &#123;&lt;网络号&gt;，&lt;主机号&gt;&#125;</code>。</p>\n<ol>\n<li><strong>网络号</strong>：它标志主机所连接的网络地址表示<strong>属于互联网的哪一个网络</strong>。</li>\n<li><strong>主机号</strong>：它标志主机地址表示其属于该<strong>网络中的哪一台主机</strong>。</li>\n</ol>\n<p>IP 地址分为 A，B，C，D，E 五大类：</p>\n<ul>\n<li>A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位。</li>\n<li>B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位。</li>\n<li>C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位。</li>\n<li>D 类地址 (224~239)：以 1110 开头，保留为多播地址。</li>\n<li>E 类地址 (240~255)：以 1111 开头，保留位为将来使用</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718104718.png\" alt=\"20250718104718\"></p>\n<h3 id=\"50-域名和-IP-的关系？一个-IP-可以对应多个域名吗？\"><a href=\"#50-域名和-IP-的关系？一个-IP-可以对应多个域名吗？\" class=\"headerlink\" title=\"50.域名和 IP 的关系？一个 IP 可以对应多个域名吗？\"></a>50.域名和 IP 的关系？一个 IP 可以对应多个域名吗？</h3><ul>\n<li><code>IP</code> 地址在同一个网络中是唯一的，用来标识每一个网络上的设备，其相当于一个人的身份证号</li>\n<li>域名在同一个网络中也是唯一的，就像是一个人的名字、绰号</li>\n</ul>\n<p>假如你有多个不用的绰号，你的朋友可以用其中任何一个绰号叫你，但你的身份证号码却是唯一的。但同时你的绰号也可能和别人重复，假如你不在，有人叫你的绰号，其它人可能就答应了。</p>\n<p>一个域名可以对应多个 IP，但这种情况 DNS 做负载均衡的，在用户访问过程中，<strong>一个域名只能对应一个 IP</strong>。</p>\n<p>而一个 <strong>IP 却可以对应多个域名</strong>，是一对多的关系。</p>\n<h3 id=\"51-IPV4-地址不够如何解决？\"><a href=\"#51-IPV4-地址不够如何解决？\" class=\"headerlink\" title=\"51.IPV4 地址不够如何解决？\"></a>51.IPV4 地址不够如何解决？</h3><p>我们知道，IP 地址有 <code>32</code> 位，可以标记 2 的 32 次方个地址，听起来很多，但是全球的网络设备数量已经远远超过这个数字，所以 IPV4 地址已经不够用了，那怎么解决呢？</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718105151.png\" alt=\"20250718105151\"></p>\n<ul>\n<li>DHCP：动态主机配置协议，动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用。</li>\n<li>CIDR：无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效地分配 IPv4 的地址空间，但无法从根本上解决地址耗尽的问题。</li>\n<li>NAT：网络地址转换协议，我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题，然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网主机进行通信时，NAT 方法可以将该主机 IP 地址转换为全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</li>\n<li>IPv6：作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使给地球上每一粒沙子都分配一个 IP 地址也够用，该协议能够从根本上解决 IPv4 地址不够用的问题。</li>\n</ul>\n<h3 id=\"52-说下-ARP-协议的工作过程？\"><a href=\"#52-说下-ARP-协议的工作过程？\" class=\"headerlink\" title=\"52.说下 ARP 协议的工作过程？\"></a>52.说下 ARP 协议的工作过程？</h3><p>ARP（Address Resolution Protocol，地址解析协议）是网络通信中的一种协议，主要目的是将网络层的 <code>IP</code> 地址解析为链路层的 <code>MAC</code> 地址。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718105938.png\" alt=\"20250718105938\"></p>\n<p>①、ARP 请求</p>\n<p>当主机 A 要发送数据给主机 B 时，首先会在自己的 ARP 缓存中查找主机 B 的 MAC 地址。</p>\n<p>如果没有找到，主机 A 会向网络中广播一个 ARP 请求数据包，请求网络中的所有主机告诉它们的 MAC 地址；这个请求包含了请求设备和目标设备的 IP 和 MAC 地址。</p>\n<p>②、ARP 应答</p>\n<p>网络中的所有主机都会收到这个 ARP 请求，但只有主机 B 会回复 ARP 应答，告诉主机 A 自己的 MAC 地址。</p>\n<p>并且主机 B 会将主机 A 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中，以便下次通信时直接使用。</p>\n<p>③、更新 ARP 缓存</p>\n<p>主机 A 收到主机 B 的 ARP 应答后，也会将主机 B 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中。</p>\n<h3 id=\"53-为什么既有-IP-地址，又有-MAC-地址？\"><a href=\"#53-为什么既有-IP-地址，又有-MAC-地址？\" class=\"headerlink\" title=\"53.为什么既有 IP 地址，又有 MAC 地址？\"></a>53.为什么既有 IP 地址，又有 MAC 地址？</h3><blockquote>\n<p><strong>MAC 地址和 IP 地址都有什么作用？</strong></p>\n</blockquote>\n<ul>\n<li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址，用来定义网络设备的位置，不可变更。</li>\n<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</li>\n</ul>\n<blockquote>\n<p><strong>为什么有了 MAC 地址还需要 IP 地址？</strong></p>\n</blockquote>\n<p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪个子网，不然一次路由器收到数据包都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是最多共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256T 的内存，显然是不现实的。</p>\n<p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p>\n<blockquote>\n<p><strong>为什么有了 IP 地址还需要 MAC 地址？</strong></p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250718110409.png\" alt=\"20250718110409\"></p>\n<ul>\n<li>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候，或者在分配 IP 的过程中。我们需要 MAC 地址来区分不同的设备。</li>\n<li>IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。</li>\n</ul>\n<h3 id=\"54-ICMP-协议的功能？\"><a href=\"#54-ICMP-协议的功能？\" class=\"headerlink\" title=\"54.ICMP 协议的功能？\"></a>54.ICMP 协议的功能？</h3><p>ICMP（Internet Control Message Protocol） ，网际控制报文协议。</p>\n<ul>\n<li>ICMP 协议是一种面向<code>无连接</code>的协议，用于传输出错报告控制信息。</li>\n<li>它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括<strong>报告错误、交换受限控制和状态信息</strong>等。</li>\n<li>当遇到 <code>IP</code> 数据无法访问目标、<code>IP</code> 路由器无法按当前的传输速率转发数据包等情况时，会自动发送 <code>ICMP</code> 消息。</li>\n</ul>\n<p>比如我们日常使用得比较多的 <strong>ping</strong>，就是基于 <code>ICMP</code> 的。</p>\n<h3 id=\"55-说下-ping-的原理？\"><a href=\"#55-说下-ping-的原理？\" class=\"headerlink\" title=\"55.说下 ping 的原理？\"></a>55.说下 ping 的原理？</h3><p>ping，<strong>Packet Internet Groper</strong>，一个网络工具，主要用来测试网络连接的可达性和延迟。</p>\n<p>Ping 的过程主要基于 ICMP（Internet Control Message Protocol，互联网控制消息协议）实现，其基本过程包括：</p>\n<p>①、当执行 Ping 命令，如<code>ping javabetter.cn</code>，Ping 首先解析域名获取 IP 地址，然后向目标 IP 发送一个 ICMP Echo Request 消息。</p>\n<p>②、当目标 IP 收到 ICMP Echo Request 消息后，它会生成一个 ICMP Echo Reply 消息并返回，即 Ping 响应消息。</p>\n<p>③、发起 Ping 命令的设备接收到 <code>ICMP Echo Reply</code> 消息后，计算并显示从发送 <code>Echo Request</code> 到接收到 <code>Echo Reply</code>的时间（通常称为往返时间 RTT，Round-Trip Time），以及可能的丢包情况。</p>\n<p><code>Ping</code> 通常会发送多个请求，以便提供平均响应时间和丢包率等信息，以便我们了解网络连接的质量。</p>\n"},{"title":"2025.7.14学习日记","path":"2025/07/14/学习日记25年7月/2025.7.14学习笔记/","excerpt":"","date":"2025-07-13T16:00:00.000Z","tags":["日记","leetcode","项目"],"content":"<h2 id=\"今日学习内容\"><a href=\"#今日学习内容\" class=\"headerlink\" title=\"今日学习内容\"></a>今日学习内容</h2><h3 id=\"3DGS\"><a href=\"#3DGS\" class=\"headerlink\" title=\"3DGS\"></a>3DGS</h3><h3 id=\"力扣每日一题\"><a href=\"#力扣每日一题\" class=\"headerlink\" title=\"力扣每日一题:\"></a>力扣每日一题:</h3><p>一道简单的遍历链表的题目.</p>\n<h3 id=\"上午学习计算机网络\"><a href=\"#上午学习计算机网络\" class=\"headerlink\" title=\"上午学习计算机网络\"></a>上午学习计算机网络</h3><p>记了笔记 12&#x2F;62</p>\n<h3 id=\"代码随想录\"><a href=\"#代码随想录\" class=\"headerlink\" title=\"代码随想录\"></a>代码随想录</h3><p>完成了01背包的题,看了完全背包的讲义</p>\n<h3 id=\"项目相关\"><a href=\"#项目相关\" class=\"headerlink\" title=\"项目相关\"></a>项目相关</h3><p>实现了数据后台接口.</p>\n<h2 id=\"生活篇\"><a href=\"#生活篇\" class=\"headerlink\" title=\"生活篇\"></a>生活篇</h2><h3 id=\"晚上健身\"><a href=\"#晚上健身\" class=\"headerlink\" title=\"晚上健身\"></a>晚上健身</h3><p>今天主要练的核心,核心抗旋训练和核心抗屈训练,强度非常高,顺带练了一组肩和一组引体.</p>\n"},{"title":"程序员养生指南","path":"2025/07/14/杂项笔记/程序员养生指南/","excerpt":"","date":"2025-07-13T16:00:00.000Z","tags":["杂项"],"content":"<h1 id=\"程序员养生指南\"><a href=\"#程序员养生指南\" class=\"headerlink\" title=\"程序员养生指南\"></a>程序员养生指南</h1><p><a href=\"README.md\"><img src=\"https://img.shields.io/badge/%E6%96%87%E6%A1%A3-%E4%B8%AD%E6%96%87%E7%89%88-blue.svg\" alt=\"CN doc\"></a><br><a href=\"README_en.md\"><img src=\"https://img.shields.io/badge/document-English-blue.svg\" alt=\"EN doc\"></a><br><a href=\"https://github.com/geekan/MetaGPT\"><img src=\"https://img.shields.io/badge/%E5%87%8F%E5%B0%91%E5%B7%A5%E4%BD%9C%E6%97%B6%E9%97%B4-MetaGPT-blue\" alt=\"MetaGPT\"></a></p>\n<ul>\n<li><a href=\"#%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%BB%E7%94%9F%E6%8C%87%E5%8D%97\">程序员养生指南</a><ul>\n<li><a href=\"#1-%E6%9C%AF%E8%AF%AD\">1. 术语</a></li>\n<li><a href=\"#2-%E7%9B%AE%E6%A0%87\">2. 目标</a></li>\n<li><a href=\"#3-%E5%85%B3%E9%94%AE%E7%BB%93%E6%9E%9C\">3. 关键结果</a></li>\n<li><a href=\"#4-%E5%88%86%E6%9E%90\">4. 分析</a></li>\n<li><a href=\"#5-%E8%A1%8C%E5%8A%A8\">5. 行动</a></li>\n<li><a href=\"#6-%E8%AF%81%E6%8D%AE\">6. 证据</a><ul>\n<li><a href=\"#61-%E8%BE%93%E5%85%A5\">6.1. 输入</a><ul>\n<li><a href=\"#611-%E5%9B%BA%E4%BD%93\">6.1.1. 固体</a></li>\n<li><a href=\"#612-%E6%B6%B2%E4%BD%93\">6.1.2. 液体</a></li>\n<li><a href=\"#613-%E6%B0%94%E4%BD%93\">6.1.3. 气体</a></li>\n<li><a href=\"#614-%E5%85%89%E7%85%A7\">6.1.4. 光照</a></li>\n<li><a href=\"#615-%E8%8D%AF%E7%89%A9\">6.1.5. 药物</a></li>\n</ul>\n</li>\n<li><a href=\"#62-%E8%BE%93%E5%87%BA\">6.2. 输出</a><ul>\n<li><a href=\"#621-%E6%8C%A5%E6%8B%8D%E8%BF%90%E5%8A%A8\">6.2.1. 挥拍运动</a></li>\n<li><a href=\"#622-%E5%89%A7%E7%83%88%E8%BF%90%E5%8A%A8\">6.2.2. 剧烈运动</a></li>\n<li><a href=\"#623-%E8%B5%B0%E8%B7%AF\">6.2.3. 走路</a></li>\n<li><a href=\"#624-%E5%88%B7%E7%89%99\">6.2.4. 刷牙</a></li>\n<li><a href=\"#625-%E6%B3%A1%E6%BE%A1\">6.2.5. 泡澡</a></li>\n<li><a href=\"#626-%E5%81%9A%E5%AE%B6%E5%8A%A1%E8%80%81%E5%B9%B4%E7%94%B7%E6%80%A7\">6.2.6. 做家务（老年男性）</a></li>\n<li><a href=\"#627-%E7%9D%A1%E7%9C%A0\">6.2.7. 睡眠</a></li>\n<li><a href=\"#628-%E4%B9%85%E5%9D%90\">6.2.8. 久坐</a></li>\n</ul>\n</li>\n<li><a href=\"#63-%E4%B8%8A%E4%B8%8B%E6%96%87\">6.3. 上下文</a><ul>\n<li><a href=\"#631-%E6%83%85%E7%BB%AA\">6.3.1. 情绪</a></li>\n<li><a href=\"#632-%E8%B4%AB%E5%AF%8C\">6.3.2. 贫富</a></li>\n<li><a href=\"#633-%E4%BD%93%E9%87%8D\">6.3.3. 体重</a></li>\n<li><a href=\"#634-%E6%96%B0%E5%86%A0\">6.3.4. 新冠</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"1-术语\"><a href=\"#1-术语\" class=\"headerlink\" title=\"1. 术语\"></a>1. 术语</h3><ul>\n<li>ACM: All-Cause Mortality &#x2F; 全因死亡率</li>\n</ul>\n<h3 id=\"2-目标\"><a href=\"#2-目标\" class=\"headerlink\" title=\"2. 目标\"></a>2. 目标</h3><ul>\n<li>稳健的活得更久</li>\n<li>花更少时间工作：见<a href=\"https://github.com/geekan/MetaGPT\">MetaGPT</a></li>\n</ul>\n<h3 id=\"3-关键结果\"><a href=\"#3-关键结果\" class=\"headerlink\" title=\"3. 关键结果\"></a>3. 关键结果</h3><ul>\n<li>降低66.67%全因死亡率</li>\n<li>增加~20年预期寿命</li>\n<li><del>维持多巴胺于中轴</del></li>\n</ul>\n<h3 id=\"4-分析\"><a href=\"#4-分析\" class=\"headerlink\" title=\"4. 分析\"></a>4. 分析</h3><ul>\n<li>主要参考：对ACM的学术文献相对较多，可以作为主要参考</li>\n<li>增加寿命与ACM关系非线性：显然增加寿命与ACM关系是非线性函数，这里假设 <code>ΔLifeSpan=(1/(1+ΔACM)-1)*10</code>（ΔACM为ACM变化值；公式欢迎优化）</li>\n<li>变量无法简单叠加：显然各个变量之间并不符合独立同分布假设，变量之间的实际影响也并不明确</li>\n<li>存在矛盾观点：所有的证据都有文献&#x2F;研究对应，但注意到：有些文献之间有显著矛盾的观点（如对于碳水摄入比例的矛盾）；有些文献存在较大争议（如认为22点前睡觉会提升43%全因死亡率）</li>\n<li>研究仅表达相关：所有文献表明的更多是相关而非因果，在阅读时要考虑文献是否充分证明了因果 —— 如某文献表明了日均&gt;&#x3D;7000步的人有显著低的全因死亡率。但步数少的人可能包含更多长期病患，如果没有合理的排除这块数据，那此文献调查失真</li>\n</ul>\n<h3 id=\"5-行动\"><a href=\"#5-行动\" class=\"headerlink\" title=\"5. 行动\"></a>5. 行动</h3><ul>\n<li>输入<ul>\n<li>固体：吃白肉（-11%~-3% ACM）、蔬果为主（-26%~-17% ACM），多吃辣（-23% ACM），多吃坚果（-27%~-4% ACM），中量碳水、多吃植物蛋白（-10% ACM），少吃超加工食物（-62%~-18%）</li>\n<li>液体：喝咖啡（-22%~-12% ACM），喝牛奶（-17%~-10% ACM），喝茶（-15%~-8% ACM），少喝或不喝甜味饮料（否则每天一杯+7% ACM，+多巴胺），戒酒（否则+~50% ACM，无上限）</li>\n<li>气体：不吸烟（否则+<del>50% ACM，-12\\</del>-11年寿命）</li>\n<li>光照：晒太阳（-~40% ACM）</li>\n<li>药物：二甲双胍（糖尿病人相比正常人可以+3年）、复合维生素（-8%癌症风险）、亚精胺（-60%~-30% ACM）、葡萄糖胺（-39% ACM）</li>\n</ul>\n</li>\n<li>输出<ul>\n<li>运动：每周3次45分钟挥拍运动（-47% ACM）</li>\n<li>日常：刷牙（-25% ACM）</li>\n<li>睡眠：每天睡7小时全因死亡率最低；且22-24点间最好，<em>早睡+43% ACM，晚睡+15% ACM（存在争议）</em></li>\n</ul>\n</li>\n<li>上下文<ul>\n<li>体重：减肥（-54% ACM）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-证据\"><a href=\"#6-证据\" class=\"headerlink\" title=\"6. 证据\"></a>6. 证据</h3><h4 id=\"6-1-输入\"><a href=\"#6-1-输入\" class=\"headerlink\" title=\"6.1. 输入\"></a>6.1. 输入</h4><h5 id=\"6-1-1-固体\"><a href=\"#6-1-1-固体\" class=\"headerlink\" title=\"6.1.1. 固体\"></a>6.1.1. 固体</h5><ul>\n<li>白肉<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/268401670\">JAMA子刊：食用红肉和加工肉类会增加心脏病和死亡风险！鱼肉和家禽肉则不会</a><ul>\n<li>出处：<a href=\"https://jamanetwork.com/journals/jamainternalmedicine/articlepdf/2759737/jamainternal_zhong_2020_oi_190112.pdf\">Associations of Processed Meat, Unprocessed Red Meat, Poultry, or Fish Intake With Incident Cardiovascular Disease and All-Cause Mortality</a></li>\n<li>增加红肉摄入与死亡风险相关。八年内平均每天增加至少半份红肉摄入（半份红肉相当于14g加工红肉或40g非加工红肉）的调查对象，在接下来八年内全因死亡风险增加10％（HR, 1.10; 95%CI, 1.04-1.17）；每周吃两份红肉或加工肉类（但不包括家禽或鱼类）会使全因死亡风险增加3%</li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163703960-6f321de5-4daa-4ea5-95b9-af9c96f1c1bc.jpg\" alt=\"红肉\"></li>\n</ul>\n</li>\n<li><a href=\"https://www.zhihu.com/question/67223570/answer/809785380\">红肉和白肉最大的区别是什么？为啥要这么分呢？</a></li>\n</ul>\n</li>\n<li>蔬果<ul>\n<li><a href=\"https://www.sohu.com/a/322360740_164924\">每年54万人死亡，竟是因为水果吃得少！？这已成十大死亡因素之一！</a><ul>\n<li>出处：<a href=\"https://academic.oup.com/cdn/article-abstract/3/Supplement_1/nzz028.FS01-01-19/5516583\">Estimated Global, Regional, and National Cardiovascular Disease Burdens Related to Fruit and Vegetable Consumption: An Analysis from the Global Dietary Database (FS01-01-19) </a></li>\n<li>每天摄入200克新鲜水果可使死亡率降低17%，糖尿病大血管并发症（如中风、缺血性心脏病等）风险降低13%，及糖尿病小血管并发症（如糖尿病肾病、糖尿病眼病、糖尿病足病等）风险降低28%</li>\n</ul>\n</li>\n<li><a href=\"https://mp.weixin.qq.com/s/E6BAi-Vnhr1jXBm0Pys2ZQ\">《自然》子刊：每天二两西兰花，健康长寿都有啦！分析近6万人23年的数据发现，吃含黄酮类食物与死亡风险降低20%相关丨临床大发现</a><ul>\n<li>出处：<a href=\"https://www.nature.com/articles/s41467-019-11622-x\">Flavonoid intake is associated with lower mortality in the Danish Diet Cancer and Health Cohort</a></li>\n<li>吃含黄酮类食物与死亡风险降低20%相关</li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163703969-42e64f88-e727-4e7d-85f2-07a92e29b613.jpg\" alt=\"黄酮\"></li>\n<li>Bondonno博士说道“吃不同蔬菜、水果补充，不同种类的黄酮类化合物是很重要的，这很容易通过饮食实现：一杯茶、一个苹果、一个橘子、100克蓝莓，或100克西兰花，就能提供各种黄酮类化合物，并且总含量超过500毫克。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>辣椒<ul>\n<li><a href=\"https://3g.163.com/dy/article/F6Q7I1ME053228ZU.html\">辣椒成死亡克星？据调研，常吃辣患病死亡风险可降低61%</a><ul>\n<li>出处1：<a href=\"https://www.sciencedirect.com/science/article/pii/S0735109719382063\">Chili pepper consumption and mortality in Italian adults</a></li>\n<li>出处2：<a href=\"https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0169876\">The Association of Hot Red Chili Pepper Consumption and Mortality: A Large Population-Based Cohort Study</a></li>\n<li>2017年Plos One 的另一项来自美国的研究以16179名，年龄在18岁以上的人群为对象，并对其进行了高达19年的随访，发现在4946例死亡患者中，食用辣椒的参与者的全因死亡率为21.6％，而未食用辣椒的参与者的全因死亡率为33.6％。相较于不吃辣或很少吃（少于每周两次）的人群，每周吃辣＞4次的人群总死亡风险降低23%，心血管死亡风险降低34%。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>鸡蛋<ul>\n<li><a href=\"https://m.thepaper.cn/baijiahao_11540780\">每天多吃半个蛋，增加7%的全因和心血管死亡风险？</a><ul>\n<li>出处：<a href=\"https://dietandhealth.cancer.gov/\">NIH-AARP工作主页</a>、<a href=\"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7872242/\">Egg and cholesterol consumption and mortality from cardiovascular and different causes in the United States: A population-based cohort study</a></li>\n<li>每天多吃半个蛋，增加7%的全因和心血管死亡风险？在假设性替代分析中，研究者发现，用等量的蛋清&#x2F;鸡蛋替代物、家禽、鱼、乳制品、坚果和豆类分别替代半只全蛋（25克&#x2F;天）可以降低6%、8%、9%、7%、13%和10%的全因死亡率。<br>*<a href=\"https://raw.githubusercontent.com/qhy040404/Image-Resources-Repo/master/pmed.1003508.g002.jpg\">鸡蛋</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>坚果<ul>\n<li><a href=\"https://www.163.com/dy/article/GKVOMMMF05148PF4.html\">哈佛20年研究：吃核桃的人更长寿，显著减少全因死亡，延长寿命</a><ul>\n<li>出处：<a href=\"https://www.mdpi.com/2072-6643/13/8/2699/pdf\">Association of Walnut Consumption with Total and Cause-Specific Mortality and Life Expectancy in US Adults</a></li>\n<li>通过分析发现，经常食用核桃可以延长寿命，降低心血管疾病死亡风险。比起不吃核桃，每周食用核桃5份以上（1份28克）的健康预期寿命延长1.3岁，全因死亡风险降低14%，心血管疾病死亡率降低25%。</li>\n</ul>\n</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/44454030\">研究：每日食生坚果，死亡率降20%</a><ul>\n<li>出处1：<a href=\"https://www.nejm.org/doi/full/10.1056/NEJMoa1307352\">Association of nut consumption with total and cause-specific mortality</a></li>\n<li>出处2：<a href=\"https://americanpistachios.cn/sites/china/files/inline-files/APG_Health-%26-Nutrition-Research-Brochure_DEC-19-18.pdf\">APG_Health-&amp;-Nutrition-Research-Brochure_DEC-19-18</a></li>\n<li>研究人员发现，每周吃树坚果低于1盎司份量的人，死亡率降低7％。而每周吃了1盎司份量的人，减少11％的死亡率；每周吃2份量的人，减低13％；每周5至6份量者，减少了15％；一周7份以上的人，死亡率则减少20％。</li>\n<li>另外两篇发表在《公共科学图书馆在线期刊》(Public Library of Science Online Journal)和《生物医学中心》(BioMed Central)上的医学预科研究论文，展示了试验开始时的横断面数据。这两项研究都评估了7,216名对象，以及他们食用坚果的频率和数量之间的关系。那些每周食用三份以上坚果(包括开心果)的研究对象的死亡率降低39%。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>钠（存有大量争议）<ul>\n<li><a href=\"https://nursing.medsci.cn/article/show_article.do;jsessionid=A34E8A33918A152CB55BDD2E5FB1798D?id=afe720486ee7\">Eur Heart J：钠摄入量与预期寿命、全因死亡率的关系</a><ul>\n<li>出处：<a href=\"https://europepmc.org/backend/ptpmcrender.fcgi?accid=PMC8169157&blobtype=pdf\">Messerli F H, Hofstetter L, Syrogiannouli L, et al. Sodium intake, life expectancy, and all-cause mortality[J]. European heart journal, 2021, 42(21): 2103-2112.</a></li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/164894778-9710f18d-e055-4f62-bdcb-618687771d77.jpeg\" alt=\"ehaa947f6\"></li>\n<li>在该分析所包含的181个国家中，研究人员发现钠摄入量与出生时的健康预期寿命（β&#x3D;2.6年&#x2F;克每日钠摄入量，R<sup>2</sup>&#x3D;0.66，P&lt;0.001）和60岁时的健康预期寿命（β&#x3D;0.3年&#x2F;克每日钠摄入量，R<sup>2</sup>&#x3D;0.60，P&#x3D;0.048）之间存在正相关关系，但与非传染性疾病死亡（β&#x3D;17次事件&#x2F;克每日钠摄入量，R<sup>2</sup>&#x3D;0.43，P&#x3D;0.100）无关。相反，全因死亡率与钠摄入量成负相关（β&#x3D;−131次事件&#x2F;克每日钠摄入量，R<sup>2</sup>&#x3D;0.60，P&lt;0.001）。在仅限于46个收入最高国家的敏感性分析中，钠摄入量与出生时的健康预期寿命呈正相关（β&#x3D;3.4年&#x2F;克每日钠摄入量，R<sup>2</sup>&#x3D;0.53，P&lt;0.001），而与全因死亡率（β&#x3D;−168次事件&#x2F;克每日钠摄入量，R<sup>2</sup>&#x3D;0.50，P&lt;0.001）呈负相关。</li>\n<li>该（大范围）研究认为更多的钠摄入与显著更低的全因死亡率有关</li>\n<li><a href=\"https://www.tctmd.com/news/fresh-foray-salt-wars-life-expectancy-higher-greater-sodium-intake\">针对该论文的延伸解读和讨论：A Fresh Foray in the Salt Wars: Life Expectancy Higher With Greater Sodium Intake</a></li>\n</ul>\n</li>\n<li><a href=\"https://ibook.antpedia.com/x/669028.html\">NEJM&#x2F;Lancet：不要吃太多盐，中国饮食所致心血管病和癌症死亡全球第一，吃低钠盐可降低全因死亡率</a><ul>\n<li>但也有多项研究认为用低钠盐可以降低一系列疾病的发生概率，对全因死亡率的减少有积极影响</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>碳水（存有大量争议）<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/137815934\">低碳生酮饮食（四）碳水化合物与长期死亡率</a><ul>\n<li>出处：The Lancet Public Health - <a href=\"https://www.sciencedirect.com/science/article/pii/S246826671830135X\">Dietary carbohydrate intake and mortality: a prospective cohort study and meta-analysis</a></li>\n<li>碳水越低，寿命越短；碳水越高，寿命也轻微缩短；碳水50%左右（其实按照一般的说法，这也算高碳水）是最长寿命区间 </li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163703985-a2e2f8ac-101a-4f3c-903b-6850507f144b.jpg\" alt=\"碳水\"></li>\n</ul>\n</li>\n<li><a href=\"https://www.chinacdc.cn/gwxx/202003/t20200323_214639.html\">最强营养搭配！BMJ：这么吃，心血管疾病和死亡风险更低</a></li>\n</ul>\n</li>\n<li>槟榔<ul>\n<li><a href=\"https://www.zhihu.com/question/312784161/answer/603370131\">如何看待槟榔嚼出来的癌症？槟榔致癌风险究竟有多大？ - 丁香医生的回答 - 知乎</a><ul>\n<li>出处：Chewing Betel Quid and the Risk of Metabolic Disease, Cardiovascular Disease, and All-Cause Mortality: A Meta-Analysis(<a href=\"https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0070679\">https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0070679</a>)</li>\n<li>嚼槟榔会增加21%的全因死亡率</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>热量限制<ul>\n<li><a href=\"https://www.zhihu.com/question/31395511\">怎么看待BBC《进食、断食与长寿》？</a><ul>\n<li>限制卡路里动物实验：CR（热量限制，即少吃）延迟了恒河猴的多种疾病发病和死亡率，与CR动物相比，正常喂养的猴子的各种疾病患病风险增加2.9倍，死亡风险增加3.0倍。</li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163703988-8767185b-326a-4783-b2e2-f190322bb7d6.jpg\" alt=\"热量限制-恒河猴\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>综合<ul>\n<li><a href=\"https://www.chinacdc.cn/gwxx/202003/t20200323_214639.html\">最强营养搭配！BMJ：这么吃，心血管疾病和死亡风险更低</a></li>\n<li><a href=\"https://doi.org/10.1136/bmj.m688\">Associations of fat and carbohydrate intake with cardiovascular disease and mortality: prospective cohort study of UK Biobank participants</a><ul>\n<li>通过对这些参与者的数据进行分析，研究人员发现碳水化合物（糖、淀粉和纤维）和蛋白质的摄入与全因死亡率呈非线性关系，而脂肪则与全因死亡率呈线性相关。其中，较高的糖分摄入与全因死亡风险和患心血管疾病的风险较高均有关联，而较高的饱和脂肪酸摄入与全因死亡风险较高有关。</li>\n<li>图1：各种营养元素与全因死亡之间的关系</li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163702022-8c2bfea9-ed5d-4fe0-8ead-e8740014b92b.jpg\" alt=\"各种营养元素与全因死亡之间的关系\"></li>\n<li>图2：各种营养元素与心血管疾病之间的关系</li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163702084-97fb4a03-707c-475d-b88e-6fe2f8e87f92.jpg\" alt=\"各种营养元素与心血管疾病之间的关系\"></li>\n<li><strong>进一步研究表明，在所有的饮食模式中，全因死亡率风险最低的饮食方式为：10-30g高纤维、14-30%蛋白质、10-25%单不饱和脂肪酸、5%-7%多不饱和脂肪酸以及20%-30%淀粉摄入。</strong></li>\n<li><strong>最优能量来源配比：&lt;24%淀粉，15%-17%蛋白质，&gt;15%单不饱和脂肪酸，&lt;15%糖，6%饱和脂肪酸，6%多不饱和脂肪酸，30g+高纤维</strong></li>\n</ul>\n</li>\n<li><a href=\"https://med.ckcest.cn/details.html?id=5183272274855936&classesEn=news\">BMJ | 常吃薯片汉堡巧克力等食品，平均死亡年龄仅仅为58岁，死亡风险剧增</a><ul>\n<li><a href=\"https://www.bmj.com/content/365/bmj.l1949.full\">Rico-Campà A, Martínez-González M A, Alvarez-Alvarez I, et al. Association between consumption of ultra-processed foods and all cause mortality: SUN prospective cohort study[J]. bmj, 2019, 365.</a></li>\n<li><a href=\"https://www.bmj.com/content/365/bmj.l1451\">Srour B, Fezeu L K, Kesse-Guyot E, et al. Ultra-processed food intake and risk of cardiovascular disease: prospective cohort study (NutriNet-Santé)[J]. bmj, 2019, 365.</a></li>\n<li><a href=\"https://www.researchgate.net/profile/Phillip-Baker-5/publication/333483796_Ultra-processed_food_and_adverse_health_outcomes/links/5f0c646ca6fdcc2f32336a95/Ultra-processed-food-and-adverse-health-outcomes.pdf\">Lawrence M A, Baker P I. Ultra-processed food and adverse health outcomes[J]. bmj, 2019, 365.</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-1-2-液体\"><a href=\"#6-1-2-液体\" class=\"headerlink\" title=\"6.1.2. 液体\"></a>6.1.2. 液体</h5><ul>\n<li>牛奶<ul>\n<li><a href=\"https://www.sohu.com/a/253940257_419768\">《柳叶刀》调研21个国家13万人：每天1斤牛奶或酸奶，心血管死亡风险下降23%</a></li>\n<li>出处：<a href=\"http://mdrf-eprints.in/1114/1/Association_of_dietary_patterns_and_dietary_diversity_with_cardiometabolic_disease_risk_factors.pdf\">Association of dairy intake with cardiovascular disease and mortality in 21 countries from five continents (PURE): a prospective cohort study</a></li>\n<li>与不食用乳制品的人相比，每天摄入两份乳制品（一份指244克牛奶&#x2F;酸奶，15克奶酪或5克黄油）的人，**全因死亡风险下降了17%**，心血管死亡风险下降23%，中风风险下降33%</li>\n</ul>\n</li>\n<li>茶<ul>\n<li><a href=\"https://www.jianshu.com/p/5461a205cf95?utm_campaign=hugo\">10万中国人随访7年发现，每周喝三次茶与全因死亡风险降低15%，预期寿命增加1.26年相关 </a></li>\n<li>出处：<a href=\"https://www.researchgate.net/profile/Fangchao-Liu-4/publication/338483323_Tea_consumption_and_the_risk_of_atherosclerotic_cardiovascular_disease_and_all-cause_mortality_The_China-PAR_project/links/5e55e5e94585152ce8efe511/Tea-consumption-and-the-risk-of-atherosclerotic-cardiovascular-disease-and-all-cause-mortality-The-China-PAR-project.pdf\">Tea consumption and the risk of atherosclerotic cardiovascular disease and all-cause mortality: The China-PAR project</a></li>\n<li><a href=\"http://rs.yiigle.com/CN112338202202/1351516.htm\">中国成年人饮茶与死亡风险的前瞻性关联研究</a></li>\n<li>纳入分析的438 443例研究对象随访11.1年共发生死亡34 661例。与从不饮茶者相比，当前非每日饮茶者和每日饮茶者全因死亡HR值（95%CI）依次为0.89（0.86-0.91）和0.92（0.88-0.95）。分性别分析显示，饮茶对全因死亡风险的保护作用主要见于男性（交互P&lt;0.05）</li>\n</ul>\n</li>\n<li>无糖（甜味）饮料<ul>\n<li><a href=\"https://www.zhihu.com/question/418598272/answer/1450648364\">「无糖饮料使死亡风险增加 26 %」，是真的吗？</a><ul>\n<li>相比于软饮料摄入量＜1杯&#x2F;月的参与者，混合软饮料摄入≥1杯&#x2F;天的参与者死亡风险增加18%，而<strong>摄入含糖软饮料或无糖软饮料会令死亡风险分别增加11%和27%。</strong></li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163704346-e7d92e7f-eba5-4673-8f15-3a96782c2e32.png\" alt=\"饮料\"></li>\n</ul>\n</li>\n<li><a href=\"https://jamanetwork.com/journals/jamainternalmedicine/fullarticle/2749350\">Association Between Soft Drink Consumption and Mortality in 10 European Countries</a></li>\n</ul>\n</li>\n<li>有糖饮料<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/400746073\">可乐和奶茶，增加全因死亡率高达62%！果汁降低免疫力，影响肝代谢！含糖饮料那些事</a><ul>\n<li>每天1杯含糖饮料增加7%全因死亡率，2杯21%</li>\n<li>在34年的随访中，研究人员发现，相比那些一个月喝1杯或者更少含糖饮料的人，每天喝2杯的人总体死亡风险升高了21%，心血管疾病死亡风险升高了31%，癌症死亡风险上升了16%。</li>\n<li>只要每天多喝一杯含糖饮料，总体死亡风险将增加7%，心血管疾病的风险将增加10%，癌症相关的死亡风险将16%。</li>\n<li>发表在国际顶级期刊《BMJ》上的一篇论文就证明了含糖饮料会在增加患癌风险，当然这篇文章验证的不仅仅是果汁，奶茶也有份——和含糖饮料相关的总体患癌风险要高出通常值18%，100%的鲜榨果汁也会使得整体的患癌风险上升12%。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>果汁<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/66513350\">JAMA子刊：100%纯果汁可能比含糖饮料更危险</a><ul>\n<li>每天多摄入一份12盎司的含糖饮料，全因死亡率风险增加11%；</li>\n<li>每天多摄入一份12盎司的果汁，全因死亡率风险增加24%。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>咖啡<ul>\n<li><a href=\"https://news.bioon.com/article/6725420.html\">重磅！多篇研究证实喝咖啡与人群全因死亡率降低直接相关</a></li>\n<li><a href=\"https://www.sohu.com/a/439412995_100003595\">科普 | 喝咖啡又多了一个新理由：降低死亡率！ </a></li>\n<li><a href=\"https://fanyi.pdf365.cn/help/249\">地中海成年人咖啡消耗量及全因，心血管疾病和癌症的死亡率</a><ul>\n<li>在最近的荟萃分析中，该研究包括来自不同国家的40项研究和3,852,651名受试者。在这项荟萃分析显示，咖啡摄入量与各种原因的死亡率，CVD和癌症死亡率之间存在非线性关系，每天摄入两杯咖啡的癌症死亡率最低(RR &#x3D; 0.96)，CVD最低的死亡率，每天2.5杯(RR&#x3D; 0.83)，全天最低死亡率为每天3.5杯(RR&#x3D; 0.85)，并且随着咖啡消费量的增加，死亡率没有进一步降低或增加</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>亚精胺<ul>\n<li><a href=\"https://www.medsci.cn/article/show_article.do?id=420d12904103\">Science：科学背书！从精液中发现的亚精胺，竟然有着抗衰老、抗癌、保护心血管和神经、改善肥胖和2型糖尿病等逆天神效</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/388942219\">饮食中亚精胺摄入量高会降低死亡率</a></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-1-3-气体\"><a href=\"#6-1-3-气体\" class=\"headerlink\" title=\"6.1.3. 气体\"></a>6.1.3. 气体</h5><ul>\n<li>吸烟<ul>\n<li><a href=\"https://www.medsci.cn/article/show_article.do?id=02ca2083319b\">即使是低强度吸烟，也增加死亡风险！</a><ul>\n<li>研究发现：在42 416名男性和86 735名女性（年龄在35-89岁之间，以前没有患病）中，18 985名男性（45%）和18 072名女性（21%）目前吸烟，其中33%的男性吸烟者和39%的女性吸烟者并不每天吸烟。8866名男性（21%）和53 912名女性（62%）从不吸烟。在随访期间，与从不吸烟相比，每天&lt;10支烟或每天≥10支烟的全因死亡率危险比分别为1.17（95%置信区间1.10-1.25）和1.54（1.42-1.67）。无论年龄或性别，危险比相似。与每日吸烟关系最密切的疾病是呼吸道癌症、慢性阻塞性肺病和胃肠道及血管疾病。在招募时已经戒烟的人的死亡率低于现在每天吸烟者。</li>\n<li>吸烟者平均减少寿命11-12年</li>\n</ul>\n</li>\n<li><a href=\"https://www.zhihu.com/question/24846224/answer/1719798177\">吸烟让人过瘾是什么原理？有节制的吸烟依旧有害吗？</a></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-1-4-光照\"><a href=\"#6-1-4-光照\" class=\"headerlink\" title=\"6.1.4. 光照\"></a>6.1.4. 光照</h5><ul>\n<li>晒太阳<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/76301306\">晒太阳和死亡率的关系，如何科学，安全的晒太阳？\n</a><ul>\n<li>丹麦一项长达26年的研究发现，多晒太阳能显著延长寿命，即使是由于过度暴晒诱发皮肤癌的患者，平均寿命也比普通人长了6岁。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-1-5-药物\"><a href=\"#6-1-5-药物\" class=\"headerlink\" title=\"6.1.5. 药物\"></a>6.1.5. 药物</h5><ul>\n<li>NMN</li>\n<li>二甲双胍<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/419202902\">“胍”吹必看 丨我就是神药——二甲双胍</a><ul>\n<li>二甲双胍不仅在多种肿瘤、心血管疾病及糖尿病中发挥保护作用，而且在肥胖、肝病、肾病及衰老方面也大放异彩。</li>\n</ul>\n</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/357807109\">二甲双胍2020最值得了解的“吃瓜”大新闻——护胃、健脑、抗衰、防癌还是致癌？</a></li>\n<li><a href=\"https://baijiahao.baidu.com/s?id=1729999374705305768\">二甲双胍真的那么神吗？美研究：父亲服用二甲双胍或致子女有缺陷</a></li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163702325-5d427542-9ae5-4311-8979-d0d326a9832f.jpg\" alt=\"二甲双胍\"></li>\n<li>不良反应<ul>\n<li>作为一种使用近百年的药物，二甲双胍的不良反应已经非常明确，常见的有：维生素B12缺乏（7%-17.4%），胃肠道不良反应（最高53%），疲倦（9%），头痛（6%）；严重但不常见的不良反应包括乳酸酸中毒、肝损伤；也有研究表明可能对胎儿致畸</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>复合维生素<ul>\n<li><a href=\"https://health.qq.com/a/20121023/000026.htm\">服用复合维生素可降低癌症危险8%，其他效果并不显著</a></li>\n</ul>\n</li>\n<li>葡萄糖胺<ul>\n<li><a href=\"https://www.sohu.com/a/436372221_120873241\">神奇！氨糖降低心血管死亡率65%，与定期运动效果相当</a></li>\n<li>美国西弗吉尼亚大学最新研究发现 氨糖（软骨素） 可以降低心血管死亡率65%，降低总体死亡率39%，效果与坚持定期运动相对</li>\n<li>该研究使用1999年至2010年，16,686名成年人的国家健康和营养检查(NHANES)数据，参与者的中位追踪时间为107个月，而其中有648位参与者定期且每服用日500-1000毫克的葡萄糖胺&#x2F;软骨素一年以上。</li>\n</ul>\n</li>\n<li>亚精胺<ul>\n<li><a href=\"https://www.medsci.cn/article/show_article.do?id=420d12904103\">Science：科学背书！从精液中发现的亚精胺，竟然有着抗衰老、抗癌、保护心血管和神经、改善肥胖和2型糖尿病等逆天神效</a></li>\n<li>亚精胺是最容易从人体肠道吸收的多胺。许多的食物中都含有大量的亚精胺，例如新鲜的青椒、小麦胚芽、花椰菜、西兰花、蘑菇和各种奶酪，尤其在纳豆等大豆制品、香菇和榴莲中含量更高。在本实验中，研究人员选择了829位年龄在45-84岁之间的参与者进行了为期20年的随访，分析了饮食中亚精胺摄入量与人类死亡率之间的潜在关联。</li>\n<li>研究发现，女性的亚精胺摄入量高于男性，并且摄入量都会随着年龄的增长而下降。亚精胺的主要来源是全谷物（占13.4%）、苹果和梨（占13.3%）、沙拉（占9.8%）、芽菜（占7.3%）和马铃薯（占6.4%）。研究根据亚精胺摄入量将人群分为三组，低摄入量组（&lt;62.2 µmol &#x2F; d）、中摄入量组（62.2–79.8 µmol &#x2F; d）和高摄入量组（&gt; 79.8 µmol &#x2F; d）。随访期间共记录了341例死亡，其中血管疾病137例，癌症94例，其他原因110例。经计算低中高三组的粗略死亡率分别为40.5%、23.7%和15.1%，这些数据表明亚精胺摄入量与全因死亡率之间的负相关关系显著。随着逐步对年龄、性别和热量的比例进行调整，这种相关关系依然显著。</li>\n</ul>\n</li>\n<li>综合<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/145495570\">《自然》子刊深度综述：如何开发抗衰老药</a></li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163702474-205baeec-f0ce-4e8d-96a4-36efe47534de.jpg\" alt=\"如何开发抗衰老药\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-2-输出\"><a href=\"#6-2-输出\" class=\"headerlink\" title=\"6.2. 输出\"></a>6.2. 输出</h4><h5 id=\"6-2-1-挥拍运动\"><a href=\"#6-2-1-挥拍运动\" class=\"headerlink\" title=\"6.2.1. 挥拍运动\"></a>6.2.1. 挥拍运动</h5><ul>\n<li><a href=\"https://www.sohu.com/a/535581770_121124216\">哪种运动性价比最高？权威医学杂志“柳叶刀”给出答案了 </a><ul>\n<li>一周三次，每次45-60分钟，挥拍运动，降低~47%全因死亡率</li>\n<li>羽毛球、乒乓球、网球等都算挥拍运动，但由于西化研究背景，可能指网球更多。这隐式的表达了全身锻炼更为重要</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-2-2-剧烈运动\"><a href=\"#6-2-2-剧烈运动\" class=\"headerlink\" title=\"6.2.2. 剧烈运动\"></a>6.2.2. 剧烈运动</h5><ul>\n<li><a href=\"https://academic.oup.com/eurheartj/advance-article/doi/10.1093/eurheartj/ehac572/6771381\">新研究：每天剧烈运动8分钟，可降低全因死亡和心脏病风险</a><ul>\n<li>每周15-20分钟的剧烈运动，降低16-40%的全因死亡率，剧烈运动时间达到50-57分钟&#x2F;周，可以进一步降低全因死亡率。这些发现表明，通过在一周的短时间内累积相对少量的剧烈运动可以降低健康风险。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-2-3-走路\"><a href=\"#6-2-3-走路\" class=\"headerlink\" title=\"6.2.3. 走路\"></a>6.2.3. 走路</h5><ul>\n<li><a href=\"http://www.shcell.org/219/3571.html\">走路降低全因死亡率超过50%！每天走多少步最合适？《JAMA》子刊超10年研究告诉你答案</a><ul>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163704147-afec1c79-799b-4db8-b547-1a2431d504c9.jpg\" alt=\"走路降低全因死亡率\"></li>\n<li>注1：这项研究参与者的平均年龄为45.2岁</li>\n<li>注2：平均步数的多少与职业有关，此项研究仅表明相关性，还没有更深度的因果分析</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-2-4-刷牙\"><a href=\"#6-2-4-刷牙\" class=\"headerlink\" title=\"6.2.4. 刷牙\"></a>6.2.4. 刷牙</h5><ul>\n<li><a href=\"https://www.cn-healthcare.com/articlewm/20211209/content-1293760.html\">50万国人研究证实：不好好刷牙，致癌！血管疾病也会增多！</a><ul>\n<li>经常不刷牙的人：癌症、慢性阻塞性肺病及肝硬化风险分别增加了9%、12%和25%，过早死亡风险增加25%。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-2-5-泡澡\"><a href=\"#6-2-5-泡澡\" class=\"headerlink\" title=\"6.2.5. 泡澡\"></a>6.2.5. 泡澡</h5><ul>\n<li><a href=\"https://www.cn-healthcare.com/article/20200326/content-533379.html\">定期洗澡降低心血管疾病发作风险</a><ul>\n<li>与每周一至两次泡澡或根本不泡澡相比，每天洗热水澡可以降低28%的心血管疾病总风险，降低26%的中风总风险，脑出血风险下降46%。而浴缸浴的频率与心源性猝死的风险增加无关。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-2-6-做家务（老年男性）\"><a href=\"#6-2-6-做家务（老年男性）\" class=\"headerlink\" title=\"6.2.6. 做家务（老年男性）\"></a>6.2.6. 做家务（老年男性）</h5><ul>\n<li><a href=\"https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0061529\">Housework Reduces All-Cause and Cancer Mortality in Chinese Men</a><ul>\n<li>72岁之后男性每周做重型家务可以减少29%平均死亡率</li>\n<li>重型家务：吸尘、擦地板、拖地、擦洗窗户、洗车、搬动家具、搬煤气罐等等。</li>\n<li>轻型家务：掸灰尘、洗碗、手洗衣服、熨烫、晾衣服、做饭、买日用品等等。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-2-7-睡眠\"><a href=\"#6-2-7-睡眠\" class=\"headerlink\" title=\"6.2.7. 睡眠\"></a>6.2.7. 睡眠</h5><ul>\n<li><a href=\"https://med.sina.com/article_detail_103_1_105491.html\">超30万亚洲人数据：每天睡几个小时最有益长寿？</a><ul>\n<li>在男性中，与睡眠时长为7小时相比：睡眠持续时间≥10小时与全因死亡风险增加34%相关；</li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163704166-226b7ebb-92ce-4753-a3e7-77a87652a104.jpg\" alt=\"睡眠-男\"></li>\n<li>在女性中，与睡眠持续时间7小时相比：睡眠持续时间≥10小时与全因死亡风险增加48%相关；</li>\n<li><img src=\"https://user-images.githubusercontent.com/2707039/163704169-c5c715aa-7130-403b-b0d1-ec34fab094d8.png\" alt=\"睡眠-女\"></li>\n</ul>\n</li>\n<li><a href=\"https://www.thepaper.cn/newsDetail_forward_14461799\">颠覆认知！加拿大研究发现：早睡比熬夜或许更伤身，几点睡才好？</a><ul>\n<li>其中一个结论为，就寝时间与全因死亡率的关联性强，过早睡觉和过晚睡觉都会影响健康，但是早睡增加的全因死亡率比晚睡增加的死亡率高，早睡增加了43%的死亡风险，而晚睡增加了15%的死亡风险。</li>\n<li>这项调查研究，还存在很多局限性，比如没有直接证明就寝时间与死亡的关系，仅仅说明相关性，通过参与人群自我报告统计睡眠时间，数据不够客观</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-2-8-久坐\"><a href=\"#6-2-8-久坐\" class=\"headerlink\" title=\"6.2.8. 久坐\"></a>6.2.8. 久坐</h5><ul>\n<li><a href=\"https://www.chinanutri.cn/yyjkzxpt/yyjkkpzx/yytsg/zgjm/202103/P020210311486742870527.pdf\">中国居民膳食指南科学研究报告（2021年）</a><ul>\n<li>久坐和看电视时间与全因死亡、心血管疾病、癌症和2型糖尿病发病高风险相关，是独立风险因素。久坐时间每天每增加1小时，心血管疾病发生风险增加4%，癌症增加1%，全因死亡风险增加3%。全因死亡和CVD死亡风险增加的久坐时间阈值是6~8h&#x2F;d，看电视时间阈值是3~4h&#x2F;d。</li>\n</ul>\n</li>\n<li><a href=\"https://apps.who.int/iris/bitstream/handle/10665/337001/9789240014947-chi.pdf\">世卫组织关于身体活动和久坐行为的指南</a></li>\n</ul>\n<h4 id=\"6-3-上下文\"><a href=\"#6-3-上下文\" class=\"headerlink\" title=\"6.3. 上下文\"></a>6.3. 上下文</h4><h5 id=\"6-3-1-情绪\"><a href=\"#6-3-1-情绪\" class=\"headerlink\" title=\"6.3.1. 情绪\"></a>6.3.1. 情绪</h5><ul>\n<li><a href=\"https://www.x-mol.com/paper/1288184397379059712/t?recommendPaper=1263704526086578176\">悲观情绪与更高的全因死亡率和心血管疾病死亡率有关，但乐观情绪并不能起到保护作用</a></li>\n<li><a href=\"https://www.nature.com/articles/s41598-020-69388-y?utm_source=xmol&utm_medium=affiliate&utm_content=meta&utm_campaign=DDCN_1_GL01_metadata_scirep\">Pessimism is associated with greater all-cause and cardiovascular mortality, but optimism is not protective</a><ul>\n<li>在1993-1995年间，一项针对50岁以上澳大利亚人健康的双胞胎研究中包括了生活取向测试（LOT），其中包含乐观和悲观的项目。平均20年后，参与者与来自澳大利亚国家死亡指数的死亡信息相匹配。在2,978名具有很多可用分数的参与者中，有1,068人死亡。生存分析测试了各种乐观因素和悲观情绪分数与任何原因，癌症，心血管疾病或其他已知原因的死亡率之间的关联。年龄调整后的悲观量表上的核心与全因和心血管疾病死亡率相关（每1个标准差单位的危险比，95％置信区间和p值1.134、1.065–1.207、8.85×10 –5和1.196、1.045–1.368、0.0093 ），但不会因癌症死亡。乐观得分与悲观得分之间的相关性很弱（年龄调整后的等级相关系数&#x3D; − 0.176），但与总死亡率或特定原因死亡率没有显着相关性。反向因果关系（引起悲观情绪的疾病）是不可能的，因为在那种情况下，心血管疾病和癌症都会导致悲观情绪。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-3-2-贫富\"><a href=\"#6-3-2-贫富\" class=\"headerlink\" title=\"6.3.2. 贫富\"></a>6.3.2. 贫富</h5><ul>\n<li><a href=\"https://www.cn-healthcare.com/articlewm/20210727/content-1246348.html\">JAMA子刊：贫富差距真能影响寿命？这可能是真的！</a><ul>\n<li>该研究使用1994-1996年第一次收集的数据，并通过生存模型来分析净资产和长寿之间的关联。结果显示，共收纳5414 名参与者，平均年龄为 46.7岁，包括 2766 名女性。较高的净资产与较低的死亡风险相关。特别是在兄弟姐妹和双胞胎中（n &#x3D; 2490），在较高的净资产和较低的死亡率之间观察到类似的关联，表明拥有更多财富的兄弟姐妹或双胞胎比拥有更少财富的兄弟姐妹&#x2F;双胞胎活得更久。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-3-3-体重\"><a href=\"#6-3-3-体重\" class=\"headerlink\" title=\"6.3.3. 体重\"></a>6.3.3. 体重</h5><ul>\n<li><a href=\"https://www.chinacdc.cn/gwxx/202009/t20200904_218959.html\">JAMA子刊：减肥要趁早，才能有效降低死亡率风险</a><ul>\n<li>对体重减轻的死亡率风险评估发现，体重从肥胖减轻到超重的成年人与稳定肥胖人群相比，全因死亡率降低了54％（危险比为0.46），然而从成年初期的超重减轻到中年以前的正常体重的人群的死亡率风险并未降低（风险比为1.12）。</li>\n<li><img src=\"https://raw.githubusercontent.com/qhy040404/Image-Resources-Repo/master/zoi200509t3_1596761185.02415.png\" alt=\"Table3\"></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-3-4-新冠\"><a href=\"#6-3-4-新冠\" class=\"headerlink\" title=\"6.3.4. 新冠\"></a>6.3.4. 新冠</h5><ul>\n<li><a href=\"https://www.nature.com/articles/s41591-020-1112-0.pdf\">Magnitude, demographics and dynamics of the effect of the first wave of the COVID-19 pandemic on all-cause mortality in 21 industrialized countries</a><ul>\n<li>目前来看，新冠死亡率（美国）在1.5%左右，人均预期寿命减少了2年</li>\n</ul>\n</li>\n<li><a href=\"https://www.zhihu.com/question/510943670/answer/2308499719\">如何看待美国CDC宣称新冠死亡人数被高估？</a></li>\n<li><a href=\"https://www.cdc.gov/nchs/nvss/deaths.htm\">NVSS deaths</a></li>\n</ul>\n"}]}