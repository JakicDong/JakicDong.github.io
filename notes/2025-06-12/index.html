{"layout":"notes","date":"2025-06-12T00:00:00.000Z","posts":[{"title":"2025.6.12学习日记","path":"2025/06/12/学习日记25年6月/2025.6.12学习笔记/","excerpt":"","date":"2025-06-11T16:00:00.000Z","tags":["3DGS","日记","leetcode","mysql","spring"],"content":"<h2 id=\"今日学习内容\"><a href=\"#今日学习内容\" class=\"headerlink\" title=\"今日学习内容\"></a>今日学习内容</h2><h3 id=\"3DGS\"><a href=\"#3DGS\" class=\"headerlink\" title=\"3DGS:\"></a>3DGS:</h3><h4 id=\"今日工作总结\"><a href=\"#今日工作总结\" class=\"headerlink\" title=\"今日工作总结\"></a>今日工作总结</h4><p>今天对开源数据集train,truck,drjohnson进行训练和测试.<br>结果主要用于之后跑不同改进版本3DGS的参考。<br>结果在飞书文档中<br>在训练drjohnson数据集过程中,训练速度明显变慢.<br>分析原因：<br>可能是drjohnson数据集中，图像分辨率相比train和truck数据集更高,点云数量更大，并且<br>在train.py训练过程中，高斯球克隆更加激进，导致显存交换更加频繁，IO时间变长或者<br>缓存碎片化，导致训练时间成倍增加。</p>\n<h4 id=\"明日工作计划\"><a href=\"#明日工作计划\" class=\"headerlink\" title=\"明日工作计划\"></a>明日工作计划</h4><p>继续将drjohnson数据集与playroom数据集进行训练和测试作为参考.<br>部署EfficientGS方法进行测试,该方法主要针对室外大场景,对原版3DGS进行性能优化.</p>\n<h3 id=\"力扣每日一题\"><a href=\"#力扣每日一题\" class=\"headerlink\" title=\"力扣每日一题:\"></a>力扣每日一题:</h3><p>循环数组简单题.</p>\n<h3 id=\"上午看mysql\"><a href=\"#上午看mysql\" class=\"headerlink\" title=\"上午看mysql\"></a>上午看mysql</h3><p>看到24题.</p>\n<h3 id=\"下午看项目\"><a href=\"#下午看项目\" class=\"headerlink\" title=\"下午看项目\"></a>下午看项目</h3><p>看了一篇Servlet的文章.</p>\n<h3 id=\"Spring学习\"><a href=\"#Spring学习\" class=\"headerlink\" title=\"Spring学习\"></a>Spring学习</h3><p>写了四条,开个头.</p>\n<h3 id=\"晚上学代码随想录\"><a href=\"#晚上学代码随想录\" class=\"headerlink\" title=\"晚上学代码随想录\"></a>晚上学代码随想录</h3><p>继续二叉树.</p>\n<p>做了一道数组模拟环形链表找入口的题,挺有意思的.<br> <a href=\"https://leetcode.cn/problems/find-the-duplicate-number\">https://leetcode.cn/problems/find-the-duplicate-number</a></p>\n<h2 id=\"生活记录\"><a href=\"#生活记录\" class=\"headerlink\" title=\"生活记录\"></a>生活记录</h2><h3 id=\"晚上健身\"><a href=\"#晚上健身\" class=\"headerlink\" title=\"晚上健身\"></a>晚上健身</h3><p>今天主要练的背.</p>\n"},{"title":"Spring学习笔记","path":"2025/06/12/基础笔记/Spring学习笔记/","excerpt":"","date":"2025-06-11T16:00:00.000Z","tags":["基础","spring"],"content":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"1-Spring-是什么？特性？有哪些模块？\"><a href=\"#1-Spring-是什么？特性？有哪些模块？\" class=\"headerlink\" title=\"1.Spring 是什么？特性？有哪些模块？\"></a>1.Spring 是什么？特性？有哪些模块？</h2><p>一句话概括：Spring 是一个轻量级、非入侵式的<strong>控制反转 (IoC)<strong>和</strong>面向切面 (AOP)</strong> 的框架。</p>\n<p>2003 年，一个音乐家 Rod Johnson 决定发展一个轻量级的 Java 开发框架，Spring作为 Java 战场的龙骑兵渐渐崛起，并淘汰了EJB这个传统的重装骑兵。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612163224.png\" alt=\"20250612163224\"></p>\n<p>到了现在，企业级开发的标配基本就是 <code>Spring5</code>+ <code>Spring Boot 2</code> + <code>JDK 8</code></p>\n<p><strong>Spring 有哪些特性呢？</strong><br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612163334.png\" alt=\"20250612163334\"></p>\n<p><strong>1. IoC 和 DI 的支持</strong><br>Spring 的核心就是一个大的<strong>工厂容器</strong>，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现<strong>高内聚低耦合</strong>的设计理念。</p>\n<p><strong>2. AOP 编程的支持</strong><br>Spring 提供了面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p>\n<p><strong>3. 声明式事务的支持</strong><br>支持通过<strong>配置</strong>就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的 JDBC 代码，都可以不用自己写了。</p>\n<p><strong>4. 快捷测试的支持</strong><br>Spring 对 <strong>Junit</strong> 提供支持，可以通过注解快捷地测试 Spring 程序。</p>\n<p><strong>5. 快速集成功能</strong><br>方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p>\n<p><strong>6. 复杂 API 模板封装</strong><br>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。</p>\n<p><strong>简单说一下什么是AOP 和 IoC？</strong><br><strong>AOP</strong>：面向切面编程，是一种编程范式，它的主要作用是将那些与核心业务逻辑无关，但是对多个对象产生影响的公共行为封装起来，如日志记录、性能统计、事务等。<br><strong>IoC</strong>：控制反转，是一种设计思想，它的主要作用是将对象的创建和对象之间的调用过程交给 Spring 容器来管理。</p>\n<p><strong>Spring源码看过吗？</strong><br>看过一些，主要就是针对 <strong>Spring 循环依赖</strong>、<strong>Bean 声明周期</strong>、<strong>AOP</strong>、<strong>事务</strong>、<strong>IOC</strong> 这五部分。<br>详情看笔记,Spring源码笔记.<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612163946.png\" alt=\"20250612163946\"></p>\n<h2 id=\"2-Spring-有哪些模块呢？\"><a href=\"#2-Spring-有哪些模块呢？\" class=\"headerlink\" title=\"2.Spring 有哪些模块呢？\"></a>2.Spring 有哪些模块呢？</h2><p>Spring 框架是分模块存在，除了最核心的<code>Spring Core Container</code>是必要模块之外，其他模块都是可选，大约有 20 多个模块。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612164053.png\" alt=\"20250612164053\"></p>\n<p><strong>最主要的七大模块：</strong></p>\n<ol>\n<li><strong>Spring Core</strong>：Spring 核心，它是框架最基础的部分，提供 IoC 和依赖注入 DI 特性。</li>\n<li><strong>Spring Context</strong>：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。</li>\n<li><strong>Spring Web</strong>：它提供 Web 应用开发的支持。</li>\n<li><strong>Spring MVC</strong>：它针对 Web 应用中 MVC 思想的实现。</li>\n<li><strong>Spring DAO</strong>：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。</li>\n<li><strong>Spring ORM</strong>：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。</li>\n<li><strong>Spring AOP</strong>：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。</li>\n</ol>\n<h2 id=\"3-Spring-有哪些常用注解呢？\"><a href=\"#3-Spring-有哪些常用注解呢？\" class=\"headerlink\" title=\"3.Spring 有哪些常用注解呢？\"></a>3.Spring 有哪些常用注解呢？</h2><p>Spring 提供了大量的注解来简化 Java 应用的开发和配置，主要用于 Web 开发、往容器注入 Bean、AOP、事务控制等。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612164625.png\" alt=\"20250612164625\"></p>\n<p><strong>Web 开发方面有哪些注解呢？</strong><br>①、<code>@Controller</code>：用于标注控制层组件。<br>②、<code>@RestController</code>：是<code>@Controller</code> 和 <code>@ResponseBody</code> 的结合体，返回 JSON 数据时使用。<br>③、<code>@RequestMapping</code>：用于映射请求 URL 到具体的方法上，还可以细分为：<br><code>@GetMapping</code>：只能用于处理 GET 请求<br><code>@PostMapping</code>：只能用于处理 POST 请求<br><code>@DeleteMapping</code>：只能用于处理 DELETE 请求<br>④、<code>@ResponseBody</code>：直接将返回的数据放入 HTTP 响应正文中，一般用于返回 JSON 数据。<br>⑤、<code>@RequestBody</code>：表示一个方法参数应该绑定到 Web 请求体。<br>⑥、<code>@PathVariable</code>：用于接收路径参数，比如 @RequestMapping(“&#x2F;hello&#x2F;{name}”)，这里的 name 就是路径参数。<br>⑦、<code>@RequestParam</code>：用于接收请求参数。比如 @RequestParam(name &#x3D; “key”) String key，这里的 key 就是请求参数。</p>\n<p><strong>容器类注解有哪些呢？</strong><br><code>@Component</code>：标识一个类为 Spring 组件，使其能够被 Spring 容器自动扫描和管理。<br><code>@Service</code>：标识一个业务逻辑组件（服务层）。比如 <code>@Service</code>(“userService”)，这里的 userService 就是 Bean 的名称。<br><code>@Repository</code>：标识一个数据访问组件（持久层）。<br><code>@Autowired</code>：按类型自动注入依赖。<br><code>@Configuration</code>：用于定义配置类，可替换 XML 配置文件。<br><code>@Value</code>：用于将 Spring Boot 中 application.properties 配置的属性值赋值给变量。</p>\n<p><strong>AOP 方面有哪些注解呢？</strong><br><code>@Aspect</code> 用于声明一个切面，可以配合其他注解一起使用，比如：<br><code>@After</code>：在方法执行之后执行。<br><code>@Before</code>：在方法执行之前执行。<br><code>@Around</code>：方法前后均执行。<br><code>@PointCut</code>：定义切点，指定需要拦截的方法。<br>事务注解有哪些？<br>主要就是 <code>@Transactional</code>，用于声明一个方法需要事务支持。</p>\n<h2 id=\"4-Spring-中应用了哪些设计模式呢？\"><a href=\"#4-Spring-中应用了哪些设计模式呢？\" class=\"headerlink\" title=\"4.Spring 中应用了哪些设计模式呢？\"></a>4.Spring 中应用了哪些设计模式呢？</h2><p>Spring 框架中用了蛮多设计模式的：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613163904.png\" alt=\"20250613163904\"></p>\n<p>①、比如说工厂模式用于 BeanFactory 和 ApplicationContext，实现 Bean 的创建和管理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;applicationContext.xml&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">MyBean</span> <span class=\"variable\">myBean</span> <span class=\"operator\">=</span> context.getBean(MyBean.class);</span><br></pre></td></tr></table></figure>\n<p>②、比如说单例模式，这样可以保证 Bean 的唯一性，减少系统开销。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=\"line\"><span class=\"type\">MyService</span> <span class=\"variable\">myService1</span> <span class=\"operator\">=</span> context.getBean(MyService.class);</span><br><span class=\"line\"><span class=\"type\">MyService</span> <span class=\"variable\">myService2</span> <span class=\"operator\">=</span> context.getBean(MyService.class);</span><br><span class=\"line\"><span class=\"comment\">// This will print &quot;true&quot; because both references point to the same instance</span></span><br><span class=\"line\">System.out.println(myService1 == myService2);</span><br></pre></td></tr></table></figure>\n<p>③、比如说 AOP 使用了代理模式来实现横切关注点（如事务管理、日志记录、权限控制等）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myTransactionalMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 方法实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Spring如何实现单例模式？\"><a href=\"#Spring如何实现单例模式？\" class=\"headerlink\" title=\"Spring如何实现单例模式？\"></a>Spring如何实现单例模式？</h3><p>Spring 通过 IOC 容器(控制反转)实现单例模式，具体步骤是：</p>\n<p>单例 Bean 在容器初始化时创建并使用 <code>DefaultSingletonBeanRegistry</code> 提供的 <code>singletonObjects</code>进行缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单例缓存</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">getSingleton</span><span class=\"params\">(String beanName)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.singletonObjects.get(beanName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addSingleton</span><span class=\"params\">(String beanName, Object singletonObject)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在请求 Bean 时，Spring 会先从缓存中获取。</p>\n<h2 id=\"39-Spring-容器、Web-容器之间的区别？（补充）\"><a href=\"#39-Spring-容器、Web-容器之间的区别？（补充）\" class=\"headerlink\" title=\"39.Spring 容器、Web 容器之间的区别？（补充）\"></a>39.Spring 容器、Web 容器之间的区别？（补充）</h2><p>Spring 容器是 Spring 框架的核心部分，负责<strong>管理应用程序中的对象生命周期</strong>和<strong>依赖注入</strong>。<br>Web 容器（也称 Servlet 容器），是用于<strong>运行 Java Web 应用程序的服务器环境</strong>，支持 Servlet、JSP 等 Web 组件。常见的 Web 容器包括 Apache Tomcat、Jetty等。<br><strong>Spring MVC</strong> 是 Spring 框架的一部分，专门用于处理 Web 请求，基于 <code>MVC</code>（Model-View-Controller）设计模式。</p>\n<h1 id=\"IoC\"><a href=\"#IoC\" class=\"headerlink\" title=\"IoC\"></a>IoC</h1><h2 id=\"5-说一说什么是-IoC、DI？\"><a href=\"#5-说一说什么是-IoC、DI？\" class=\"headerlink\" title=\"5.说一说什么是 IoC、DI？\"></a>5.说一说什么是 IoC、DI？</h2><p>所谓的IoC，就是<strong>由容器来控制对象的生命周期</strong>和<strong>对象之间的关系</strong>。控制对象生命周期的不再是引用它的对象，而是容器，这就叫控制反转（Inversion of Control）。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613182942.png\" alt=\"20250613182942\"></p>\n<p><strong>没有 IoC 之前：</strong></p>\n<p>我需要一个女朋友，刚好大街上突然看到了一个小姐姐，人很好看，于是我就自己主动上去搭讪，要她的微信号，找机会聊天关心她，然后约她出来吃饭，打听她的爱好，三观。。。</p>\n<p><strong>有了 IoC 之后：</strong></p>\n<p>我需要一个女朋友，于是我就去找婚介所，告诉婚介所，我需要一个长的像赵露思的，会打 Dota2 的，于是婚介所在它的人才库里开始找，找不到它就直接说没有，找到它就直接介绍给我。</p>\n<p>婚介所就相当于一个 IoC 容器，我就是一个对象，我需要的女朋友就是另一个对象，我不用关心女朋友是怎么来的，我只需要告诉婚介所我需要什么样的女朋友，婚介所就帮我去找。</p>\n<p>Spring 倡导的开发方式就是这样，所有类的创建和销毁都通过 Spring 容器来，不再是开发者去 new，去 &#x3D; null，这样就实现了对象的解耦。</p>\n<p>于是，对于某个对象来说，以前是它控制它依赖的对象，现在是所有对象都被 Spring 控制。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613183456.png\" alt=\"20250613183456\"></p>\n<h3 id=\"说说什么是DI\"><a href=\"#说说什么是DI\" class=\"headerlink\" title=\"说说什么是DI?\"></a>说说什么是DI?</h3><p>IOC 是一种思想，DI 是实<strong>现 IOC 的具体方式</strong>，比如说利用注入机制（如构造器注入、Setter 注入）将依赖传递给目标对象。</p>\n<pre><code>2004 年，Martin Fowler 在他的文章《控制反转容器&amp;依赖注入模式》首次提出了 DI（依赖注入，Dependency Injection） 这个名词。\n</code></pre>\n<p>打个比方，你现在想吃韭菜馅的饺子，这时候就有人用针管往你吃的饺子里注入韭菜鸡蛋馅。就好像 A 类需要 B 类，以前是 A 类自己 new 一个 B 类，现在是有人把 B 类注入到 A 类里。</p>\n<h3 id=\"为什么要使用-IoC-呢？\"><a href=\"#为什么要使用-IoC-呢？\" class=\"headerlink\" title=\"为什么要使用 IoC 呢？\"></a>为什么要使用 IoC 呢？</h3><p>在平时的 Java 开发中，如果我们要实现某一个功能，可能<strong>至少需要两个以上的对象</strong>来协助完成，在没有 Spring 之前，每个对象在需要它的合作对象时，需要自己 new 一个，比如说 A 要使用 B，A 就对 B 产生了依赖，也就是 <strong>A 和 B 之间存在了一种耦合关系</strong>。</p>\n<p>有了 Spring 之后，就不一样了，创建 B 的工作交给了 Spring 来完成，Spring 创建好了 B 对象后就放到容器中，A 告诉 Spring 我需要 B，Spring 就从容器中取出 B 交给 A 来使用。</p>\n<p><strong>至于 B 是怎么来的，A 就不再关心了</strong>，Spring 容器想通过 newnew 创建 B 还是 new 创建 B，无所谓。</p>\n<p>这就是 IoC 的好处，它<strong>降低了对象之间的耦合度，使得程序更加灵活，更加易于维护</strong>。</p>\n<h2 id=\"6-能简单说一下-Spring-IoC-的实现机制吗？\"><a href=\"#6-能简单说一下-Spring-IoC-的实现机制吗？\" class=\"headerlink\" title=\"6.能简单说一下 Spring IoC 的实现机制吗？\"></a>6.能简单说一下 Spring IoC 的实现机制吗？</h2><p>Spring 的 IoC 本质就是一个大工厂，我们想想一个工厂是怎么运行的呢？<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250614152628.png\" alt=\"20250614152628\"></p>\n<ul>\n<li>生产产品：一个工厂最核心的功能就是生产产品。在 Spring 里，不用 Bean 自己来实例化，而是交给 Spring，应该怎么实现呢？——答案毫无疑问，反射。<br>那么这个厂子的生产管理是怎么做的？你应该也知道——工厂模式。</li>\n<li>库存产品：工厂一般都是有库房的，用来库存产品，毕竟生产的产品不能立马就拉走。Spring 我们都知道是一个容器，这个容器里存的就是对象，不能每次来取对象，都得现场来反射创建对象，得把创建出的对象存起来。</li>\n<li>订单处理：还有最重要的一点，工厂根据什么来提供产品呢？订单。这些订单可能五花八门，有线上签签的、有到工厂签的、还有工厂销售上门签的……最后经过处理，指导工厂的出货。<br>在 Spring 里，也有这样的订单，它就是我们 bean 的定义和依赖关系，可以是 xml 形式，也可以是我们最熟悉的注解形式。</li>\n</ul>\n<p>我们简单地实现一个 mini 版的 Spring IoC：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250614153024.png\" alt=\"20250614153024\"></p>\n<h2 id=\"7-说说-BeanFactory-和-ApplicantContext\"><a href=\"#7-说说-BeanFactory-和-ApplicantContext\" class=\"headerlink\" title=\"7.说说 BeanFactory 和 ApplicantContext?\"></a>7.说说 BeanFactory 和 ApplicantContext?</h2><p>可以这么比喻，BeanFactory 是 Spring 的“心脏”，而 ApplicantContext 是 Spring 的完整“身躯”。</p>\n<p>BeanFactory 主要<strong>负责配置、创建和管理 bean</strong>，为 Spring 提供了基本的依赖注入（DI）支持。<br>ApplicationContext 是 BeanFactory 的子接口，在 BeanFactory 的基础上<strong>添加了企业级的功能支持</strong>。</p>\n<h3 id=\"详细说说-BeanFactory\"><a href=\"#详细说说-BeanFactory\" class=\"headerlink\" title=\"详细说说 BeanFactory\"></a>详细说说 BeanFactory</h3><p>BeanFactory 位于整个 Spring IoC 容器的顶端，ApplicationContext 算是 BeanFactory 的子接口。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250617160008.png\" alt=\"20250617160008\"></p>\n<p>它最主要的方法就是 getBean()，这个方法负责从容器中返回特定名称或者类型的 Bean 实例。</p>\n<p>来看一个 XMLBeanFactory（已过时） 获取 bean 的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldApp</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">BeanFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XmlBeanFactory</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathResource</span>(<span class=\"string\">&quot;beans.xml&quot;</span>));</span><br><span class=\"line\">      <span class=\"type\">HelloWorld</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> (HelloWorld) factory.getBean(<span class=\"string\">&quot;itwanger&quot;</span>);</span><br><span class=\"line\">      obj.getMessage();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请详细说说-ApplicationContext\"><a href=\"#请详细说说-ApplicationContext\" class=\"headerlink\" title=\"请详细说说 ApplicationContext\"></a>请详细说说 ApplicationContext</h3><p><code>ApplicationContext</code> 继承了 <code>HierachicalBeanFactory</code> 和 <code>ListableBeanFactory</code> 接口，算是 BeanFactory 的自动挡版本，是 Spring 应用的默认方式。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250617160312.png\" alt=\"20250617160312\"></p>\n<p>ApplicationContext 会在启动时预先创建和配置所有的单例 bean，并支持如 JDBC、ORM 框架的集成，内置面向切面编程（AOP）的支持，可以配置声明式事务管理等。</p>\n<p>这是 ApplicationContext 的使用例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainApp</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 AppConfig 配置类初始化 ApplicationContext</span></span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从 ApplicationContext 获取 messageService 的 bean</span></span><br><span class=\"line\">        <span class=\"type\">MessageService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> context.getBean(MessageService.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 bean</span></span><br><span class=\"line\">        service.printMessage();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 AnnotationConfigApplicationContext 类，我们可以使用 Java 配置类来初始化 ApplicationContext，这样就可以使用 Java 代码来配置 Spring 容器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;com.github.paicoding.forum.test.javabetter.spring1&quot;)</span> <span class=\"comment\">// 替换为你的包名</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-你知道-Spring-容器启动阶段会干什么吗？\"><a href=\"#8-你知道-Spring-容器启动阶段会干什么吗？\" class=\"headerlink\" title=\"8.你知道 Spring 容器启动阶段会干什么吗？\"></a>8.你知道 Spring 容器启动阶段会干什么吗？</h2><p>Spring 的 IoC 容器工作的过程，可以划分为两个阶段：<strong>容器启动阶段</strong>和<strong>Bean 实例化阶段</strong>。<br>其中容器启动阶段主要做的工作是<strong>加载和解析配置文件，保存到对应的 Bean 定义中。</strong><br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250617161955.png\" alt=\"20250617161955\"></p>\n<p>容器启动开始，首先会通过<strong>某种途径加载 Configuration MetaData</strong>，在大部分情况下，容器需要依赖某些工具类（<code>BeanDefinitionReader</code>）对加载的 <code>Configuration MetaData </code>进行解析和分析，并将分析后的信息组为相应的 <code>BeanDefinition</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250617162037.png\" alt=\"20250617162037\"></p>\n<p>最后把这些保存了 Bean 定义必要信息的 <code>BeanDefinition</code>，注册到相应的 <code>BeanDefinitionRegistry</code>，这样容器启动就完成了。</p>\n<h3 id=\"说说-Spring-的-Bean-实例化方式\"><a href=\"#说说-Spring-的-Bean-实例化方式\" class=\"headerlink\" title=\"说说 Spring 的 Bean 实例化方式\"></a>说说 Spring 的 Bean 实例化方式</h3><p>Spring 提供了 4 种不同的方式来实例化 Bean，以满足不同场景下的需求。</p>\n<h4 id=\"说说构造方法的方式\"><a href=\"#说说构造方法的方式\" class=\"headerlink\" title=\"说说构造方法的方式\"></a>说说构造方法的方式</h4><p>在类上使用@Component（或@Service、@Repository 等特定于场景的注解）标注类，然后通过构造方法注入依赖。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExampleBean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DependencyBean dependency;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ExampleBean</span><span class=\"params\">(DependencyBean dependency)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dependency = dependency;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"说说静态工厂的方式\"><a href=\"#说说静态工厂的方式\" class=\"headerlink\" title=\"说说静态工厂的方式\"></a>说说静态工厂的方式</h4><p>在这种方式中，Bean 是由一个静态方法创建的，而不是直接通过构造方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ClientService</span> <span class=\"variable\">clientService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClientService</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">ClientService</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ClientService <span class=\"title function_\">createInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clientService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"说说实例工厂方法实例化的方式\"><a href=\"#说说实例工厂方法实例化的方式\" class=\"headerlink\" title=\"说说实例工厂方法实例化的方式\"></a>说说实例工厂方法实例化的方式</h4><p>与静态工厂方法相比，实例工厂方法依赖于某个类的实例来创建 Bean。这通常用在需要通过工厂对象的非静态方法来创建 Bean 的场景。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceLocator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ClientService <span class=\"title function_\">createClientServiceInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClientService</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"说说-FactoryBean-接口实例化方式\"><a href=\"#说说-FactoryBean-接口实例化方式\" class=\"headerlink\" title=\"说说 FactoryBean 接口实例化方式\"></a>说说 FactoryBean 接口实例化方式</h4><p>FactoryBean 是一个特殊的 Bean 类型，可以在 Spring 容器中返回其他对象的实例。通过实现 FactoryBean 接口，可以自定义实例化逻辑，这对于构建复杂的初始化逻辑非常有用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ToolFactoryBean</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">FactoryBean</span>&lt;Tool&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> factoryId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> toolId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Tool <span class=\"title function_\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Tool</span>(toolId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Tool.class;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSingleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setter and getter methods for factoryId and toolId</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-你是怎么理解-Bean-的？\"><a href=\"#9-你是怎么理解-Bean-的？\" class=\"headerlink\" title=\"9.你是怎么理解 Bean 的？\"></a>9.你是怎么理解 Bean 的？</h2><p>Bean 是指由 Spring 容器管理的对象，它的生命周期由容器控制，包括创建、初始化、使用和销毁。以通过三种方式声明：<strong>注解方式、XML 配置、Java 配置</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250617165329.png\" alt=\"20250617165329\"></p>\n<p>①、使用 @Component、@Service、@Repository、@Controller 等注解定义，主流。</p>\n<p>②、基于 XML 配置，Spring Boot 项目已经不怎么用了。</p>\n<p>③、使用 Java 配置类创建 Bean：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> UserService <span class=\"title function_\">userService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserService</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Component-和-Bean-的区别\"><a href=\"#Component-和-Bean-的区别\" class=\"headerlink\" title=\"@Component 和 @Bean 的区别\"></a>@Component 和 @Bean 的区别</h3><p><code>@Component</code> 是 Spring 提供的一个类级别注解，由 Spring 自动扫描并注册到 Spring 容器中。<br><code>@Bean</code> 是一个方法级别的注解，用于显式地声明一个 Bean，当我们需要第三方库或者无法使用 @Component 注解类时，可以使用 @Bean 来将其实例注册到容器中。</p>\n<h2 id=\"10-能说一下-Bean-的生命周期吗？\"><a href=\"#10-能说一下-Bean-的生命周期吗？\" class=\"headerlink\" title=\"10.能说一下 Bean 的生命周期吗？\"></a>10.能说一下 Bean 的生命周期吗？</h2><p>推荐阅读:<a href=\"https://mp.weixin.qq.com/s/zb6eA3Se0gQoqL8PylCPLw\">https://mp.weixin.qq.com/s/zb6eA3Se0gQoqL8PylCPLw</a></p>\n<p>Bean的生命周期大致分为五个阶段：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618155721.png\" alt=\"20250618155721\"></p>\n<ul>\n<li><strong>实例化</strong>：Spring 首先使用构造方法或者工厂方法创建一个 Bean 的实例。在这个阶段，Bean 只是一个空的 Java 对象，还未设置任何属性。</li>\n<li><strong>属性赋值</strong>：Spring 将配置文件中的属性值或依赖的 Bean 注入到该 Bean 中。这个过程称为<strong>依赖注入</strong>，确保 Bean 所需的所有依赖都被注入。</li>\n<li><strong>初始化</strong>：Spring 调用 afterPropertiesSet 方法，或通过配置文件指定的 init-method 方法，完成初始化。</li>\n<li><strong>使用中</strong>：Bean 准备好可以使用了。</li>\n<li><strong>销毁</strong>：在容器关闭时，Spring 会调用 destroy 方法，完成 Bean 的清理工作。</li>\n</ul>\n<h3 id=\"可以从源码角度讲一下吗？\"><a href=\"#可以从源码角度讲一下吗？\" class=\"headerlink\" title=\"可以从源码角度讲一下吗？\"></a>可以从源码角度讲一下吗？</h3><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618160141.png\" alt=\"20250618160141\"></p>\n<ul>\n<li>实例化：Spring 容器根据 Bean 的定义创建 Bean 的实例，相当于执行构造方法，也就是 new 一个对象。</li>\n<li>属性赋值：相当于执行 setter 方法为字段赋值。</li>\n<li>初始化：初始化阶段允许执行自定义的逻辑，比如设置某些必要的属性值、开启资源、执行预加载操作等，以确保 Bean 在使用之前是完全配置好的。</li>\n<li>销毁：相当于执行 &#x3D; null，释放资源。<br>可以在源码 AbstractAutowireCapableBeanFactory 中的 doCreateBean 方法中，看到 Bean 的前三个生命周期：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">doCreateBean</span><span class=\"params\">(String beanName, RootBeanDefinition mbd, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> BeanCreationException &#123;</span><br><span class=\"line\">    <span class=\"type\">BeanWrapper</span> <span class=\"variable\">instanceWrapper</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mbd.isSingleton()) &#123;</span><br><span class=\"line\">        instanceWrapper = (BeanWrapper)<span class=\"built_in\">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instanceWrapper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化阶段</span></span><br><span class=\"line\">        instanceWrapper = <span class=\"built_in\">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">exposedObject</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 属性赋值阶段</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">        <span class=\"comment\">// 初始化阶段</span></span><br><span class=\"line\">        exposedObject = <span class=\"built_in\">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable var18) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618160906.png\" alt=\"20250618160906\"><br>源码位置,如下图:<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/pic.png\" alt=\"pic\"></li>\n</ul>\n<p>至于销毁，是在容器关闭的时候调用的，详见 ConfigurableApplicationContext 的 close 方法。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/ConfigurableApplicationContext-close%E6%96%B9%E6%B3%95.png\" alt=\"ConfigurableApplicationContext-close方法\"></p>\n<h3 id=\"请在一个已有的-Spring-Boot-项目中通过单元测试的形式来展示-Spring-Bean-的生命周期？\"><a href=\"#请在一个已有的-Spring-Boot-项目中通过单元测试的形式来展示-Spring-Bean-的生命周期？\" class=\"headerlink\" title=\"请在一个已有的 Spring Boot 项目中通过单元测试的形式来展示 Spring Bean 的生命周期？\"></a>请在一个已有的 Spring Boot 项目中通过单元测试的形式来展示 Spring Bean 的生命周期？</h3><p>第一步，创建一个 LifecycleDemoBean 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LifecycleDemoBean</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InitializingBean</span>, DisposableBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用@Value注解注入属性值，这里演示了如何从配置文件中读取值</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果配置文件中没有定义lifecycle.demo.bean.name，则使用默认值&quot;default name&quot;</span></span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;lifecycle.demo.bean.name:default name&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造方法：在Bean实例化时调用</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LifecycleDemoBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: 实例化&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 属性赋值：Spring通过反射调用setter方法为Bean的属性注入值</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: 属性赋值&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用@PostConstruct注解的方法：在Bean的属性赋值完成后调用，用于执行初始化逻辑</span></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postConstruct</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: @PostConstruct（初始化）&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现InitializingBean接口：afterPropertiesSet方法在@PostConstruct注解的方法之后调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于执行更多的初始化逻辑</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: afterPropertiesSet（InitializingBean）&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义初始化方法：在XML配置或Java配置中指定，执行特定的初始化逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">customInit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: customInit（自定义初始化方法）&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用@PreDestroy注解的方法：在容器销毁Bean之前调用，用于执行清理工作</span></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preDestroy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: @PreDestroy（销毁前）&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现DisposableBean接口：destroy方法在@PreDestroy注解的方法之后调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于执行清理资源等销毁逻辑</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: destroy（DisposableBean）&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义销毁方法：在XML配置或Java配置中指定，执行特定的清理逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">customDestroy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: customDestroy（自定义销毁方法）&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>①、实例化</p>\n<p>实例化是创建 Bean 实例的过程，即在内存中为 Bean 对象分配空间。这一步是通过调用 Bean 的构造方法完成的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LifecycleDemoBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: 实例化&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，当 Spring 创建 LifecycleDemoBean 的实例时，会调用其无参数的构造方法，这个过程就是实例化。</p>\n<p>②、属性赋值</p>\n<p>在实例化之后，Spring 将根据 Bean 定义中的配置信息，通过反射机制为 Bean 的属性赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Value(&quot;$&#123;lifecycle.demo.bean.name:default name&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: 属性赋值&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@Value注解和 setter 方法体现了属性赋值的过程。@Value注解让 Spring 注入配置值（或默认值），setter 方法则是属性赋值的具体操作。</p>\n<p>③、初始化</p>\n<p>初始化阶段允许执行自定义的初始化逻辑，比如检查必要的属性是否已经设置、开启资源等。Spring 提供了多种方式来配置初始化逻辑。</p>\n<p>1、使用 @PostConstruct 注解的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postConstruct</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: @PostConstruct（初始化）&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@PostConstruct</span>注解的方法在 Bean 的所有属性都被赋值后，且用户自定义的初始化方法之前调用。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、实现 InitializingBean 接口的 afterPropertiesSet 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: afterPropertiesSet（InitializingBean）&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>afterPropertiesSet 方法提供了另一种初始化 Bean 的方式，也是在所有属性赋值后调用。</p>\n<p>3、自定义初始化方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">customInit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: customInit（自定义初始化方法）&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要在配置类中指定初始化方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean(initMethod = &quot;customInit&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> LifecycleDemoBean <span class=\"title function_\">lifecycleDemoBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LifecycleDemoBean</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>④、销毁</p>\n<p>销毁阶段允许执行自定义的销毁逻辑，比如释放资源。类似于初始化阶段，Spring 也提供了多种方式来配置销毁逻辑。</p>\n<p>1、使用 @PreDestroy 注解的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preDestroy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: @PreDestroy（销毁前）&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@PreDestroy注解的方法在 Bean 被销毁前调用。</p>\n<p>2、实现 DisposableBean 接口的 destroy 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: destroy（DisposableBean）&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>destroy 方法提供了另一种销毁 Bean 的方式，也是在 Bean 被销毁前调用。</p>\n<p>3、自定义销毁方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">customDestroy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;LifecycleDemoBean: customDestroy（自定义销毁方法）&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要在配置类中指定销毁方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean(destroyMethod = &quot;customDestroy&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> LifecycleDemoBean <span class=\"title function_\">lifecycleDemoBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LifecycleDemoBean</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二步，注册 Bean 并指定自定义初始化方法和销毁方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LifecycleDemoConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(initMethod = &quot;customInit&quot;, destroyMethod = &quot;customDestroy&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LifecycleDemoBean <span class=\"title function_\">lifecycleDemoBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LifecycleDemoBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三步，编写单元测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LifecycleDemoTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApplicationContext context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testBeanLifecycle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取LifecycleDemoBean实例...&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">LifecycleDemoBean</span> <span class=\"variable\">bean</span> <span class=\"operator\">=</span> context.getBean(LifecycleDemoBean.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行单元测试，查看控制台输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">LifecycleDemoBean: 实例化</span><br><span class=\"line\">LifecycleDemoBean: <span class=\"meta\">@PostConstruct</span>（初始化）</span><br><span class=\"line\">LifecycleDemoBean: afterPropertiesSet（InitializingBean）</span><br><span class=\"line\">LifecycleDemoBean: customInit（自定义初始化方法）</span><br><span class=\"line\">获取LifecycleDemoBean实例...</span><br><span class=\"line\">LifecycleDemoBean: <span class=\"meta\">@PreDestroy</span>（销毁前）</span><br><span class=\"line\">LifecycleDemoBean: destroy（DisposableBean）</span><br><span class=\"line\">LifecycleDemoBean: customDestroy（自定义销毁方法）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Aware-类型的接口有什么作用？\"><a href=\"#Aware-类型的接口有什么作用？\" class=\"headerlink\" title=\"Aware 类型的接口有什么作用？\"></a>Aware 类型的接口有什么作用？</h3><p>通过实现 Aware 接口，Bean 可以获取 Spring 容器的相关信息，如 BeanFactory、ApplicationContext 等。<br>常见 Aware 接口有：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618165359.png\" alt=\"20250618165359\"></p>\n<h3 id=\"如果配置了-init-method-和-destroy-method，Spring-会在什么时候调用其配置的方法？\"><a href=\"#如果配置了-init-method-和-destroy-method，Spring-会在什么时候调用其配置的方法？\" class=\"headerlink\" title=\"如果配置了 init-method 和 destroy-method，Spring 会在什么时候调用其配置的方法？\"></a>如果配置了 init-method 和 destroy-method，Spring 会在什么时候调用其配置的方法？</h3><p><code>init-method</code> 在 Bean 初始化阶段调用，依赖注入完成后且 <code>postProcessBeforeInitialization</code> 调用之后执行。<br><code>destroy-method </code>在 Bean 销毁阶段调用，容器关闭时调用。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619145811.png\" alt=\"20250619145811\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618170251.png\" alt=\"20250618170251\"></p>\n<h2 id=\"11-为什么-IDEA-不推荐使用-Autowired-注解注入-Bean？\"><a href=\"#11-为什么-IDEA-不推荐使用-Autowired-注解注入-Bean？\" class=\"headerlink\" title=\"11.为什么 IDEA 不推荐使用 @Autowired 注解注入 Bean？\"></a>11.为什么 IDEA 不推荐使用 @Autowired 注解注入 Bean？</h2><p>当使用 @Autowired 注解注入 Bean 时，IDEA 会提示“Field injection is not recommended”。</p>\n<p>这是因为字段注入的方式：</p>\n<ul>\n<li>不能像构造方法那样使用 final 注入不可变对象</li>\n<li>隐藏了依赖关系，调用者可以看到构造方法注入或者 setter 注入，但无法看到私有字段的注入</li>\n</ul>\n<p>在 Spring 4.3 及更高版本中，如果一个类只有一个构造方法，Spring 会自动使用该构造方法进行依赖注入，无需使用 @Autowired 注解。</p>\n<h3 id=\"Autowired-和-Resource-注解的区别？\"><a href=\"#Autowired-和-Resource-注解的区别？\" class=\"headerlink\" title=\"@Autowired 和 @Resource 注解的区别？\"></a>@Autowired 和 @Resource 注解的区别？</h3><ul>\n<li>@Autowired 是 Spring 提供的注解，按类型（byType）注入。</li>\n<li>@Resource 是 Java EE 提供的注解，按名称（byName）注入。</li>\n</ul>\n<p>虽然 IDEA 不推荐使用 <code>@Autowired</code>，但对 <code>@Resource</code> 注解却没有任何提示。<br>这是因为 @Resource 属于 Java EE 标准的注解，如果使用其他 IOC 容器而不是 Spring 也是可以兼容的。</p>\n<h3 id=\"提到了byType，如果两个类型一致的发生了冲突，应该怎么处理\"><a href=\"#提到了byType，如果两个类型一致的发生了冲突，应该怎么处理\" class=\"headerlink\" title=\"提到了byType，如果两个类型一致的发生了冲突，应该怎么处理\"></a>提到了byType，如果两个类型一致的发生了冲突，应该怎么处理</h3><p>当容器中存在多个相同类型的 bean，编译器会提示 <code>Could not autowire. There is more than one bean of &#39;UserRepository2&#39; type.</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepository21</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserRepository2</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepository22</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserRepository2</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository2 userRepository; <span class=\"comment\">// 冲突</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候，就可以配合 @Qualifier 注解来指定具体的 bean 名称：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component(&quot;userRepository21&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepository21</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserRepository2</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Component(&quot;userRepository22&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserRepository22</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserRepository2</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;userRepository22&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserRepository2 userRepository22;</span><br></pre></td></tr></table></figure>\n<p>或者使用 @Resource 注解按名称进行注入，指定 name 属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Resource(name = &quot;userRepository21&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserRepository2 userRepository21;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-Spring-有哪些自动装配的方式？\"><a href=\"#12-Spring-有哪些自动装配的方式？\" class=\"headerlink\" title=\"12.Spring 有哪些自动装配的方式？\"></a>12.Spring 有哪些自动装配的方式？</h2><pre><code>什么是自动装配？\n</code></pre>\n<p>Spring IoC 容器知道所有 Bean 的配置信息，此外，<strong>通过 Java 反射机制</strong>还可以获知<strong>实现类的结构信息</strong>，如构造方法的结构、属性等信息。掌握所有 Bean 的这些信息后，Spring IoC 容器就可以按照某种规则对容器中的 Bean 进行自动装配，而无须通过显式的方式进行依赖配置。</p>\n<p>Spring 提供的这种方式，可以按照某些规则进行 Bean 的自动装配，<code>&lt;bean&gt;</code>元素提供了一个指定自动装配类型的属性：<code>autowire=&quot;&lt;自动装配类型&gt;&quot;</code></p>\n<pre><code>Spring 提供了哪几种自动装配类型？\n</code></pre>\n<p>Spring 提供了 4 种自动装配类型：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619150853.png\" alt=\"20250619150853\"></p>\n<ul>\n<li>byName：根据<strong>名称</strong>进行自动匹配，假设 Boss 有一个名为 <code>car</code> 的属性，如果容器中刚好有一个名为 <code>car</code> 的 bean，Spring 就会自动将其装配给 Boss 的 <code>car</code> 属性</li>\n<li>byType：根据<strong>类型</strong>进行自动匹配，假设 Boss 有一个 <code>Car</code> 类型的属性，如果容器中刚好有一个 <code>Car</code> 类型的 Bean，Spring 就会自动将其装配给 Boss 这个属性</li>\n<li>constructor：与 byType 类似， 只不过它是<strong>针对构造函数注入</strong>而言的。如果 Boss 有一个构造函数，构造函数包含一个 Car 类型的入参，如果容器中有一个 Car 类型的 Bean，则 Spring 将自动把这个 Bean 作为 Boss 构造函数的<strong>入参</strong>；如果容器中没有找到和构造函数入参匹配类型的 Bean，则 Spring 将抛出异常。</li>\n<li>autodetect：根据 Bean 的自省机制决定采用 byType 还是 constructor 进行自动装配，如果 Bean 提供了默认的构造函数，则采用 byType，否则采用 constructor。</li>\n</ul>\n<h2 id=\"13-Bean-的作用域有哪些\"><a href=\"#13-Bean-的作用域有哪些\" class=\"headerlink\" title=\"13.Bean 的作用域有哪些?\"></a>13.Bean 的作用域有哪些?</h2><p>在 Spring 中，Bean 默认是单例的，即在整个 Spring 容器中，每个 Bean 只有一个实例。<br>可以通过在配置中指定 scope 属性，将 Bean 改为多例（Prototype）模式，这样每次获取的都是新的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span>  <span class=\"comment\">// 每次获取都是新的实例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> MyBean <span class=\"title function_\">myBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBean</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了单例和多例，Spring 还支持其他作用域，如<strong>请求作用域（Request）</strong>、<strong>会话作用域（Session）</strong>等，适合 Web 应用中特定的使用场景。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/Spring%E6%94%AF%E6%8C%81%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.png\" alt=\"Spring支持的作用域\"></p>\n<ul>\n<li><code>request</code>：每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP Request 内有效。</li>\n<li><code>session</code>：同一个 Session 共享一个 Bean，不同的 Session 使用不同的 Bean。</li>\n<li><code>globalSession</code>：同一个全局 Session 共享一个 Bean，只用于基于 Protlet 的 Web 应用，Spring5 中已经移除。</li>\n</ul>\n<h2 id=\"14-Spring-中的单例-Bean-会存在线程安全问题吗？\"><a href=\"#14-Spring-中的单例-Bean-会存在线程安全问题吗？\" class=\"headerlink\" title=\"14.Spring 中的单例 Bean 会存在线程安全问题吗？\"></a>14.Spring 中的单例 Bean 会存在线程安全问题吗？</h2><p>Spring Bean 的默认作用域是<strong>单例（Singleton）</strong>，这意味着 Spring 容器中只会存在一个 Bean 实例，并且该实例会<strong>被多个线程共享</strong>。</p>\n<p>如果单例 Bean 是无状态的，也就是<strong>没有成员变量</strong>，那么这个单例 Bean <strong>是线程安全的</strong>。比如 Spring MVC 中的 <code>Controller</code>、<code>Service</code>、<code>Dao</code> 等，基本上都是无状态的。</p>\n<p>但如果 Bean 的<strong>内部状态是可变的</strong>，且没有进行适当的同步处理，就<strong>可能出现线程安全问题</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/Spring%E5%8D%95%E4%BE%8BBean%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.png\" alt=\"Spring单例Bean的线程安全问题\"></p>\n<h3 id=\"单例-Bean-线程安全问题怎么解决呢？\"><a href=\"#单例-Bean-线程安全问题怎么解决呢？\" class=\"headerlink\" title=\"单例 Bean 线程安全问题怎么解决呢？\"></a>单例 Bean 线程安全问题怎么解决呢？</h3><p>第一，使用<strong>局部变量</strong>。局部变量是线程安全的，因为每个线程都有自己的局部变量副本。<strong>尽量使用局部变量而不是共享的成员变量。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">localVar</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用局部变量进行操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二，<strong>尽量使用无状态的 Bean</strong>，即<strong>不在 Bean 中保存任何可变的状态信息</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyStatelessService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 无状态处理</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三，同步访问。如果 Bean 中确实需要保存可变状态，可以通过 <code>synchronized</code> 关键字或者 <code>Lock</code> 接口来保证线程安全。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> sharedVar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">increment</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        sharedVar++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者将 Bean 中的成员变量保存到 <code>ThreadLocal</code> 中，<code>ThreadLocal</code> 可以保证多线程环境下变量的隔离。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ThreadLocal&lt;Integer&gt; localVar = ThreadLocal.withInitial(() -&gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        localVar.set(localVar.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再或者使用线程安全的工具类，比如说 <code>AtomicInteger</code>、<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">putValue</span><span class=\"params\">(String key, String value)</span> &#123;</span><br><span class=\"line\">        map.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第四，将 Bean 定义为原型作用域（Prototype）。原型作用域的 Bean 每次请求都会创建一个新的实例，因此不存在线程安全问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实例变量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-说说循环依赖\"><a href=\"#15-说说循环依赖\" class=\"headerlink\" title=\"15.说说循环依赖?\"></a>15.说说循环依赖?</h2><p>A 依赖 B，B 依赖 A，或者 C 依赖 C，就成了循环依赖。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/Spring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png\" alt=\"Spring的循环依赖\"></p>\n<p>循环依赖只发生在 <code>Singleton</code> 作用域的 Bean 之间，因为如果是 <code>Prototype</code> 作用域的 Bean，Spring 会直接抛出异常。</p>\n<p>原因很简单，AB 循环依赖，A 实例化的时候，发现依赖 B，创建 B 实例，创建 B 的时候发现需要 A，创建 A1 实例……无限套娃。。。。</p>\n<p>我们来看一个实例，先是 PrototypeBeanA：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PrototypeBeanA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PrototypeBeanB prototypeBeanB;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">PrototypeBeanA</span><span class=\"params\">(PrototypeBeanB prototypeBeanB)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.prototypeBeanB = prototypeBeanB;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是 PrototypeBeanB：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PrototypeBeanB</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PrototypeBeanA prototypeBeanA;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">PrototypeBeanB</span><span class=\"params\">(PrototypeBeanA prototypeBeanA)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.prototypeBeanA = prototypeBeanA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再然后是测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoApplication</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(DemoApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    CommandLineRunner <span class=\"title function_\">commandLineRunner</span><span class=\"params\">(ApplicationContext ctx)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> args -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 尝试获取PrototypeBeanA的实例</span></span><br><span class=\"line\">            <span class=\"type\">PrototypeBeanA</span> <span class=\"variable\">beanA</span> <span class=\"operator\">=</span> ctx.getBean(PrototypeBeanA.class);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-可以解决哪些情况的循环依赖？\"><a href=\"#Spring-可以解决哪些情况的循环依赖？\" class=\"headerlink\" title=\"Spring 可以解决哪些情况的循环依赖？\"></a>Spring 可以解决哪些情况的循环依赖？</h3><p>看看这几种情形（AB 循环依赖）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%BD%A2.png\" alt=\"循环依赖的几种情形\"></p>\n<p>也就是说：</p>\n<ul>\n<li>AB 均采用构造器注入，不支持</li>\n<li>AB <strong>均采用 setter 注入，支持</strong></li>\n<li>AB <strong>均采用属性自动注入，支持</strong></li>\n<li>A 中注入的 B 为 setter 注入，B 中注入的 A 为构造器注入，支持</li>\n<li>B 中注入的 A 为 setter 注入，A 中注入的 B 为构造器注入，不支持<br>第四种可以，第五种不可以的原因是 Spring 在创建 Bean 时<strong>默认会根据自然排序进行创建</strong>，所以 A 会先于 B 进行创建。</li>\n</ul>\n<p>简单总结下，当循环依赖的实例都采用 setter 方法注入时，Spring 支持，都采用构造器注入的时候，不支持；构造器注入和 setter 注入同时存在的时候，看天（😂）。</p>\n<h2 id=\"16-Spring-怎么解决循环依赖呢？\"><a href=\"#16-Spring-怎么解决循环依赖呢？\" class=\"headerlink\" title=\"16.Spring 怎么解决循环依赖呢？\"></a>16.Spring 怎么解决循环依赖呢？</h2><p>Spring 通过<strong>三级缓存机制</strong>来解决循环依赖：</p>\n<ul>\n<li>一级缓存：存放<strong>完全初始化好</strong>的单例 Bean。</li>\n<li>二级缓存：存放正在创建但未完全初始化的 Bean 实例。</li>\n<li>三级缓存：存放 Bean 工厂对象，用于提前暴露 Bean。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621152139.png\" alt=\"20250621152139\"></p>\n<h3 id=\"三级缓存解决循环依赖的过程是什么样的？\"><a href=\"#三级缓存解决循环依赖的过程是什么样的？\" class=\"headerlink\" title=\"三级缓存解决循环依赖的过程是什么样的？\"></a>三级缓存解决循环依赖的过程是什么样的？</h3><ol>\n<li>实例化 Bean 时，将其早期引用放入三级缓存。</li>\n<li>其他依赖该 Bean 的对象，可以从缓存中获取其引用。</li>\n<li>初始化完成后，将 Bean 移入一级缓存。</li>\n</ol>\n<p>假如 A、B 两个类发生循环依赖.</p>\n<p><strong>A 实例的初始化过程：</strong><br>①、创建 A 实例，实例化的时候把 A 的对象⼯⼚放⼊三级缓存，表示 A 开始实例化了，虽然这个对象还不完整，但是先曝光出来让大家知道。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621153257.png\" alt=\"20250621153257\"><br>②、A 注⼊属性时，发现依赖 B，此时 B 还没有被创建出来，所以去实例化 B。</p>\n<p>③、同样，B 注⼊属性时发现依赖 A，它就从缓存里找 A 对象。依次从⼀级到三级缓存查询 A。</p>\n<p>发现可以从三级缓存中通过对象⼯⼚拿到 A，虽然 A 不太完善，但是存在，就把 A 放⼊⼆级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成了，把 B 放入⼀级缓存。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621153335.png\" alt=\"20250621153335\"></p>\n<p>④、接着 A 继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除⼆级缓存中的 A，同时把 A 放⼊⼀级缓存</p>\n<p>⑤、最后，⼀级缓存中保存着实例化、初始化都完成的 A、B 对象。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621153405.png\" alt=\"20250621153405\"></p>\n<h2 id=\"17-为什么要三级缓存？⼆级不⾏吗？\"><a href=\"#17-为什么要三级缓存？⼆级不⾏吗？\" class=\"headerlink\" title=\"17.为什么要三级缓存？⼆级不⾏吗？\"></a>17.为什么要三级缓存？⼆级不⾏吗？</h2><p>不行，主要是为了 <strong>⽣成代理对象</strong>。如果是没有代理的情况下，使用二级缓存解决循环依赖也是 OK 的。但是如果存在代理，三级没有问题，二级就不行了。</p>\n<p>因为<strong>三级缓存中放的是⽣成具体对象的匿名内部类</strong>，获取 Object 的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。</p>\n<p>假设只有⼆级缓存的情况，往⼆级缓存中放的显示⼀个普通的 Bean 对象，Bean 初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉⼆级缓存中的普通 Bean 对象，那么可能就导致取到的 Bean 对象不一致了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621154701.png\" alt=\"20250621154701\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/f0d11e613327c.png\" alt=\"f0d11e613327c\"></p>\n<h3 id=\"如果缺少第二级缓存会有什么问题？\"><a href=\"#如果缺少第二级缓存会有什么问题？\" class=\"headerlink\" title=\"如果缺少第二级缓存会有什么问题？\"></a>如果缺少第二级缓存会有什么问题？</h3><p>如果没有二级缓存，Spring 无法在未完成初始化的情况下暴露 Bean。会导致代理 Bean 的循环依赖问题，因为某些代理逻辑无法在三级缓存中提前暴露。最终可能抛出 <code>BeanCurrentlyInCreationException</code>。</p>\n<h2 id=\"18-Autowired-的实现原理？\"><a href=\"#18-Autowired-的实现原理？\" class=\"headerlink\" title=\"18.@Autowired 的实现原理？\"></a>18.@Autowired 的实现原理？</h2><p>实现@Autowired 的关键是：<code>AutowiredAnnotationBeanPostProcessor</code></p>\n<p>在 Bean 的初始化阶段，会通过 Bean 后置处理器来进行一些前置和后置的处理。</p>\n<p>实现<code>@Autowired</code> 的功能，也是通过<strong>后置处理器</strong>来完成的。这个后置处理器就是 <code>AutowiredAnnotationBeanPostProcessor</code>。</p>\n<ul>\n<li><p>Spring 在创建 bean 的过程中，最终会调用到 doCreateBean()方法，在 doCreateBean()方法中会调用 populateBean()方法，来为 bean 进行属性填充，完成自动装配等工作。</p>\n</li>\n<li><p>在 populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行 return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到 <code>AutowiredAnnotationBeanPostProcessor</code> 的 <code>postProcessPropertyValues()</code>方法，在该方法中就会进行<code>@Autowired</code> 注解的解析，然后实现自动装配。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 属性赋值</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">populateBean</span><span class=\"params\">(String beanName, RootBeanDefinition mbd, <span class=\"meta\">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">//…………</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (hasInstAwareBpps) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (pvs == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                  pvs = mbd.getPropertyValues();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              PropertyValues pvsToUse;</span><br><span class=\"line\">              <span class=\"keyword\">for</span>(<span class=\"type\">Iterator</span> <span class=\"variable\">var9</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) &#123;</span><br><span class=\"line\">                  <span class=\"type\">InstantiationAwareBeanPostProcessor</span> <span class=\"variable\">bp</span> <span class=\"operator\">=</span> (InstantiationAwareBeanPostProcessor)var9.next();</span><br><span class=\"line\">                  pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (pvsToUse == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (filteredPds == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                          filteredPds = <span class=\"built_in\">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      <span class=\"comment\">//执行后处理器，填充属性，完成自动装配</span></span><br><span class=\"line\">                      <span class=\"comment\">//调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法</span></span><br><span class=\"line\">                      pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (pvsToUse == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">         <span class=\"comment\">//…………</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>postProcessorPropertyValues()</code>方法的源码如下，在该方法中，会先调用 findAutowiringMetadata()方法解析出 bean 中带有@Autowired 注解、@Inject 和@Value 注解的属性和方法。然后调用 metadata.inject()方法，进行属性填充。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> PropertyValues <span class=\"title function_\">postProcessProperties</span><span class=\"params\">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//@Autowired注解、@Inject和@Value注解的属性和方法</span></span><br><span class=\"line\">    <span class=\"type\">InjectionMetadata</span> <span class=\"variable\">metadata</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//属性填充</span></span><br><span class=\"line\">        metadata.inject(bean, beanName, pvs);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pvs;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (BeanCreationException var6) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> var6;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable var7) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeanCreationException</span>(beanName, <span class=\"string\">&quot;Injection of autowired dependencies failed&quot;</span>, var7);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h1><h2 id=\"19-说说什么是-AOP？\"><a href=\"#19-说说什么是-AOP？\" class=\"headerlink\" title=\"19.说说什么是 AOP？\"></a>19.说说什么是 AOP？</h2><p>AOP，也就是面向切面编程，简单点说，AOP 就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加清爽。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623143109.png\" alt=\"20250623143109\"></p>\n<p>举个例子，假如我们现在需要在<strong>业务代码开始前</strong>进行参数校验，在<strong>结束后</strong>打印日志，该怎么办呢？</p>\n<p>我们可以把<code>日志记录</code>和<code>数据校验</code>这两个功能抽取出来，形成一个切面，然后在业务代码中引入这个切面，这样就可以<strong>实现业务逻辑和通用逻辑的分离</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623143413.png\" alt=\"20250623143413\"></p>\n<p>业务代码不再关心这些通用逻辑，只需要关心自己的业务实现，这样就实现了业务逻辑和通用逻辑的分离。</p>\n<h3 id=\"AOP-有哪些核心概念？\"><a href=\"#AOP-有哪些核心概念？\" class=\"headerlink\" title=\"AOP 有哪些核心概念？\"></a>AOP 有哪些核心概念？</h3><ul>\n<li>切面（Aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象</li>\n<li>连接点（Join Point）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中，连接点指的是被拦截到的方法，实际上连接点还可以是字段或者构造方法</li>\n<li>切点（Pointcut）：对连接点进行拦截的定位</li>\n<li>通知（Advice）：指拦截到连接点之后要执行的代码，也可以称作增强</li>\n<li>目标对象 （Target）：代理的目标对象</li>\n<li>引介（introduction）：一种特殊的增强，可以动态地为类添加一些属性和方法</li>\n<li>织入（Weabing）：织入是将增强添加到目标类的具体连接点上的过程。</li>\n</ul>\n<h3 id=\"织入有哪几种方式？\"><a href=\"#织入有哪几种方式？\" class=\"headerlink\" title=\"织入有哪几种方式？\"></a>织入有哪几种方式？</h3><p>①、编译期织入：切面在目标类编译时被织入。</p>\n<p>②、类加载期织入：切面在目标类加载到 JVM 时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。</p>\n<p>③、运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，<strong>AOP 容器会为目标对象动态地创建一个代理对象</strong>。</p>\n<p><code>Spring AOP</code> 采用<strong>运行期织入</strong>，而 <code>AspectJ</code> 可以<strong>在编译期织入和类加载时织入</strong>。</p>\n<h3 id=\"AspectJ-是什么？\"><a href=\"#AspectJ-是什么？\" class=\"headerlink\" title=\"AspectJ 是什么？\"></a>AspectJ 是什么？</h3><p>AspectJ 是一个 AOP 框架，它可以做很多 Spring AOP 干不了的事情，比如说支持编译时、编译后和类加载时织入切面。并且提供更复杂的切点表达式和通知类型。</p>\n<p>下面是一个简单的 AspectJ 示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个切面</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义一个切点，匹配 com.example 包下的所有方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* com.example..*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">selectAll</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义一个前置通知，在匹配的方法执行之前执行</span></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;selectAll()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">beforeAdvice</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;A method is about to be executed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"AOP-有哪些环绕方式？\"><a href=\"#AOP-有哪些环绕方式？\" class=\"headerlink\" title=\"AOP 有哪些环绕方式？\"></a>AOP 有哪些环绕方式？</h3><p>AOP 一般有 5 种环绕方式：</p>\n<ul>\n<li>前置通知 (@Before)</li>\n<li>返回通知 (@AfterReturning)</li>\n<li>异常通知 (@AfterThrowing)</li>\n<li>后置通知 (@After)</li>\n<li>环绕通知 (@Around)</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623143949.png\" alt=\"20250623143949\"></p>\n<p>多个切面的情况下，可以通过 <code>@Order</code> 指定<strong>先后顺序，数字越小，优先级越高</strong>。代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebLogAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">webLog</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开始打印请求日志</span></span><br><span class=\"line\">        <span class=\"type\">ServletRequestAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">        <span class=\"type\">HttpServletRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> attributes.getRequest();</span><br><span class=\"line\">        <span class=\"comment\">// 打印请求相关参数</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;========================================== Start ==========================================&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 打印请求 url</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;URL            : &#123;&#125;&quot;</span>, request.getRequestURL().toString());</span><br><span class=\"line\">        <span class=\"comment\">// 打印 Http method</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;HTTP Method    : &#123;&#125;&quot;</span>, request.getMethod());</span><br><span class=\"line\">        <span class=\"comment\">// 打印调用 controller 的全路径以及执行方法</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());</span><br><span class=\"line\">        <span class=\"comment\">// 打印请求的 IP</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;IP             : &#123;&#125;&quot;</span>, request.getRemoteAddr());</span><br><span class=\"line\">        <span class=\"comment\">// 打印请求入参</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;Request Args   : &#123;&#125;&quot;</span>,<span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>().writeValueAsString(joinPoint.getArgs()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@After(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doAfter</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束后打个分隔线，方便查看</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;=========================================== End ===========================================&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">doAround</span><span class=\"params\">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> proceedingJoinPoint.proceed();</span><br><span class=\"line\">        <span class=\"comment\">// 打印出参</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;Response Args  : &#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>().writeValueAsString(result));</span><br><span class=\"line\">        <span class=\"comment\">// 执行耗时</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - startTime);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-AOP-发生在什么时候？\"><a href=\"#Spring-AOP-发生在什么时候？\" class=\"headerlink\" title=\"Spring AOP 发生在什么时候？\"></a>Spring AOP 发生在什么时候？</h3><p>Spring AOP 基于<strong>运行时代理机制</strong>，这意味着 Spring AOP 是在<strong>运行时通过动态代理生成的</strong>，而不是在编译时或类加载时生成的。</p>\n<p>在 Spring 容器<strong>初始化 Bean 的过程中</strong>，Spring AOP 会<strong>检查 Bean 是否需要应用切面</strong>。如果需要，Spring 会为该 Bean <strong>创建一个代理对象</strong>，<strong>并在代理对象中织入切面逻辑</strong>。这一过程发生在 Spring 容器的后处理器（BeanPostProcessor）阶段。</p>\n<h3 id=\"简单总结一下-AOP\"><a href=\"#简单总结一下-AOP\" class=\"headerlink\" title=\"简单总结一下 AOP\"></a>简单总结一下 AOP</h3><p>AOP，也就是<strong>面向切面编程，是一种编程范式，旨在提高代码的模块化</strong>。比如说<strong>可以将日志记录、事务管理等分离出来</strong>，来<strong>提高代码的可重用性</strong>。</p>\n<p>AOP 的核心概念包括<strong>切面（Aspect）、连接点（Join Point）、通知（Advice）、切点（Pointcut）和织入（Weaving）等</strong>。</p>\n<p>① 像日志打印、事务管理等都可以抽离为切面，可以声明在类的方法上。像 @Transactional 注解，就是一个典型的 AOP 应用，它就是通过 AOP 来实现事务管理的。我们只需要在方法上添加 @Transactional 注解，Spring 就会在方法执行前后添加事务管理的逻辑。</p>\n<p>② Spring AOP 是基于代理的，它默认使用 JDK 动态代理和 CGLIB 代理来实现 AOP。</p>\n<p>③ Spring AOP 的织入方式是运行时织入，而 AspectJ 支持编译时织入、类加载时织入。</p>\n<h3 id=\"AOP和-OOP-的关系？\"><a href=\"#AOP和-OOP-的关系？\" class=\"headerlink\" title=\"AOP和 OOP 的关系？\"></a>AOP和 OOP 的关系？</h3><p>AOP 和 OOP 是互补的编程思想：</p>\n<ol>\n<li>OOP 通过类和对象封装数据和行为，专注于核心业务逻辑。</li>\n<li>AOP 提供了解决横切关注点（如日志、权限、事务等）的机制，将这些逻辑集中管理。</li>\n</ol>\n<h2 id=\"20-AOP的使用场景有哪些？\"><a href=\"#20-AOP的使用场景有哪些？\" class=\"headerlink\" title=\"20.AOP的使用场景有哪些？\"></a>20.AOP的使用场景有哪些？</h2><p>AOP 的使用场景有很多，比如说<strong>日志记录、事务管理、权限控制、性能监控</strong>等。<br>我们在技术派实战项目中主要利用 AOP 来打印接口的入参和出参日志、执行时间，方便后期 bug 溯源和性能调优。</p>\n<ul>\n<li><p>第一步，自定义注解作为切点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MdcDot &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">bizCode</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>第二步，配置 AOP 切面：<br><code>@Aspect</code>：标识切面<br><code>@Pointcut</code>：设置切点，这里以自定义注解为切点<br><code>@Around</code>：环绕切点，打印方法签名和执行时间<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623144656.png\" alt=\"20250623144656\"></p>\n</li>\n<li><p>第三步，在使用的地方加上自定义注解<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623144705.png\" alt=\"20250623144705\"></p>\n</li>\n<li><p>第四步，当接口被调用时，就可以看到对应的执行日志。</p>\n</li>\n</ul>\n<h2 id=\"21-说说-JDK-动态代理和-CGLIB-代理？\"><a href=\"#21-说说-JDK-动态代理和-CGLIB-代理？\" class=\"headerlink\" title=\"21.说说 JDK 动态代理和 CGLIB 代理？\"></a>21.说说 JDK 动态代理和 CGLIB 代理？</h2><p>AOP 是通过<strong>动态代理</strong>实现的，代理方式有两种：<strong>JDK 动态代理和 CGLIB 代理</strong>。</p>\n<p>①、JDK 动态代理是基于接口的代理，只能代理实现了接口的类。</p>\n<p>使用 JDK 动态代理时，Spring AOP 会创建一个代理对象，<strong>该代理对象实现了目标对象所实现的接口，并在方法调用前后插入横切逻辑</strong>。</p>\n<p>优点：<strong>只需依赖 JDK 自带的 java.lang.reflect.Proxy 类</strong>，不需要额外的库；<br>缺点：<strong>只能代理接口，不能代理类本身</strong>。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">perform</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">perform</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Performing service...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceInvocationHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before method&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After method&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceImpl</span>();</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (Service) Proxy.newProxyInstance(</span><br><span class=\"line\">            service.getClass().getClassLoader(),</span><br><span class=\"line\">            service.getClass().getInterfaces(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInvocationHandler</span>(service)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        proxy.perform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>②、CGLIB 动态代理是<strong>基于继承的代理</strong>，<strong>可以代理没有实现接口的类</strong>。</p>\n<p>使用 CGLIB 动态代理时，<strong>Spring AOP 会生成目标类的子类，并在方法调用前后插入横切逻辑</strong>。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623145646.png\" alt=\"20250623145646\"></p>\n<p>优点：<strong>可以代理没有实现接口的类，灵活性更高</strong>；<br>缺点：<strong>需要依赖 CGLIB 库，创建代理对象的开销相对较大</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">perform</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Performing service...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before method&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> proxy.invokeSuper(obj, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After method&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">        enhancer.setSuperclass(Service.class);</span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInterceptor</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (Service) enhancer.create();</span><br><span class=\"line\">        proxy.perform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择-CGLIB-还是-JDK-动态代理？\"><a href=\"#选择-CGLIB-还是-JDK-动态代理？\" class=\"headerlink\" title=\"选择 CGLIB 还是 JDK 动态代理？\"></a>选择 CGLIB 还是 JDK 动态代理？</h3><p>如果目标对象<strong>没有实现任何接口</strong>，则<strong>只能使用 CGLIB 代理</strong>。如果目标对象实现了接口，通常<strong>首选 JDK 动态代理</strong>。<br><strong>虽然 CGLIB 在代理类的生成过程中可能消耗更多资源，但在运行时具有较高的性能</strong>。对于<strong>性能敏感且代理对象创建频率不高</strong>的场景，可以考虑使用 CGLIB。<br><strong>JDK 动态代理是 Java 原生支持的，不需要额外引入库</strong>。而 CGLIB 需要将 <code>CGLIB</code> 库作为依赖加入项目中。</p>\n<h3 id=\"你会用-JDK-动态代理和-CGLIB-吗？\"><a href=\"#你会用-JDK-动态代理和-CGLIB-吗？\" class=\"headerlink\" title=\"你会用 JDK 动态代理和 CGLIB 吗？\"></a>你会用 JDK 动态代理和 CGLIB 吗？</h3><p>假设我们有这样一个小场景，客服中转，解决用户问题：</p>\n<p><strong>①、JDK 动态代理实现：</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623150511.png\" alt=\"20250623150511\"></p>\n<ul>\n<li>第一步，创建接口<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ISolver</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>第二步，实现对应接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solver</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ISolver</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;疯狂掉头发解决问题……&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第三步，动态代理工厂:ProxyFactory，直接用反射方式生成一个目标对象的代理，这里用了一个匿名内部类方式重写 InvocationHandler 方法。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 维护一个目标对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyFactory</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 为目标对象生成代理对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getProxyInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;请问有什么可以帮到您？&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// 调用目标对象方法</span></span><br><span class=\"line\">                        <span class=\"type\">Object</span> <span class=\"variable\">returnValue</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\"></span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;问题已经解决啦！&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>第四步，客户端：Client，生成一个代理对象实例，通过代理对象调用目标对象方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//目标对象:程序员</span></span><br><span class=\"line\">        <span class=\"type\">ISolver</span> <span class=\"variable\">developer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Solver</span>();</span><br><span class=\"line\">        <span class=\"comment\">//代理：客服小姐姐</span></span><br><span class=\"line\">        <span class=\"type\">ISolver</span> <span class=\"variable\">csProxy</span> <span class=\"operator\">=</span> (ISolver) <span class=\"keyword\">new</span> <span class=\"title class_\">ProxyFactory</span>(developer).getProxyInstance();</span><br><span class=\"line\">        <span class=\"comment\">//目标方法：解决问题</span></span><br><span class=\"line\">        csProxy.solve();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>②、CGLIB 动态代理实现：</strong><br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623151021.png\" alt=\"20250623151021\"></p>\n<ul>\n<li>第一步：定义目标类（Solver），目标类 Solver 定义了一个 solve 方法，模拟了解决问题的行为。目标类不需要实现任何接口，这与 JDK 动态代理的要求不同。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solver</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;疯狂掉头发解决问题……&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第二步：动态代理工厂（ProxyFactory），ProxyFactory 类实现了 MethodInterceptor 接口，这是 CGLIB 提供的一个方法拦截接口，用于定义方法的拦截逻辑。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//维护一个目标对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyFactory</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为目标对象生成代理对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getProxyInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//工具类</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">en</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">        <span class=\"comment\">//设置父类</span></span><br><span class=\"line\">        en.setSuperclass(target.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//设置回调函数</span></span><br><span class=\"line\">        en.setCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//创建子类对象代理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> en.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请问有什么可以帮到您？&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 执行目标对象的方法</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">returnValue</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;问题已经解决啦！&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol>\n<li>ProxyFactory 接收一个 Object 类型的 target，即目标对象的实例。</li>\n<li>使用 CGLIB 的 Enhancer 类来生成目标类的子类（代理对象）。通过 setSuperclass 设置代理对象的父类为目标对象的类，setCallback 设置方法拦截器为当前对象（this），最后调用 create 方法生成并返回代理对象。</li>\n<li>重写 MethodInterceptor 接口的 intercept 方法以提供方法拦截逻辑。在目标方法执行前后添加自定义逻辑，然后通过 method.invoke 调用目标对象的方法。</li>\n</ol>\n<ul>\n<li>第三步：客户端使用代理，首先创建目标对象（Solver 的实例），然后使用 ProxyFactory 创建该目标对象的代理。通过代理对象调用 solve 方法时，会先执行 intercept 方法中定义的逻辑，然后执行目标方法，最后再执行 intercept 方法中的后续逻辑。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//目标对象:程序员</span></span><br><span class=\"line\">        <span class=\"type\">Solver</span> <span class=\"variable\">developer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Solver</span>();</span><br><span class=\"line\">        <span class=\"comment\">//代理：客服小姐姐</span></span><br><span class=\"line\">        <span class=\"type\">Solver</span> <span class=\"variable\">csProxy</span> <span class=\"operator\">=</span> (Solver) <span class=\"keyword\">new</span> <span class=\"title class_\">ProxyFactory</span>(developer).getProxyInstance();</span><br><span class=\"line\">        <span class=\"comment\">//目标方法：解决问题</span></span><br><span class=\"line\">        csProxy.solve();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"22-说说-Spring-AOP-和-AspectJ-AOP-区别\"><a href=\"#22-说说-Spring-AOP-和-AspectJ-AOP-区别\" class=\"headerlink\" title=\"22.说说 Spring AOP 和 AspectJ AOP 区别?\"></a>22.说说 Spring AOP 和 AspectJ AOP 区别?</h2><p>Spring AOP 属于<code>运行时增强</code>，主要具有如下特点：</p>\n<ol>\n<li><p>基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现</p>\n</li>\n<li><p>Spring AOP 需要依赖 IoC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现</p>\n</li>\n<li><p>在性能上，由于 Spring AOP 是基于<strong>动态代理</strong>来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。</p>\n</li>\n<li><p>Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。</p>\n</li>\n</ol>\n<p>AspectJ 是一个易用的功能强大的 AOP 框架，属于<code>编译时增强</code>， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。</p>\n<p>AspectJ 属于<code>静态织入</code>，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：</p>\n<ol>\n<li><p>编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</p>\n</li>\n<li><p>编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</p>\n</li>\n<li><p>类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法</p>\n</li>\n</ol>\n<p>整体对比如下：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624103307.png\" alt=\"20250624103307\"></p>\n<h2 id=\"40-说说-AOP-和反射的区别？（补充）\"><a href=\"#40-说说-AOP-和反射的区别？（补充）\" class=\"headerlink\" title=\"40.说说 AOP 和反射的区别？（补充）\"></a>40.说说 AOP 和反射的区别？（补充）</h2><p><strong>反射</strong>：用于<strong>检查和操作类的方法和字段</strong>，<strong>动态调用方法或访问字段</strong>。反射是 Java 提供的内置机制，直接操作类对象。<br><strong>动态代理</strong>：通过<strong>生成代理类来拦截方法调用</strong>，通常用于 AOP 实现。动态代理使用反射来调用被代理的方法。</p>\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><p>Spring 事务的<strong>本质其实就是数据库对事务的支持</strong>，没有数据库的事务支持，Spring 是无法提供事务功能的。<strong>Spring 只提供统一事务管理接口</strong>，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p>\n<h2 id=\"23-Spring-事务的种类？\"><a href=\"#23-Spring-事务的种类？\" class=\"headerlink\" title=\"23.Spring 事务的种类？\"></a>23.Spring 事务的种类？</h2><p>在 Spring 中，事务管理可以分为两大类：<strong>声明式事务管理</strong>和<strong>编程式事务管理</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624103946.png\" alt=\"20250624103946\"></p>\n<h3 id=\"介绍一下编程式事务管理？\"><a href=\"#介绍一下编程式事务管理？\" class=\"headerlink\" title=\"介绍一下编程式事务管理？\"></a>介绍一下编程式事务管理？</h3><p>编程式事务可以使用 <code>TransactionTemplate</code> 和 <code>PlatformTransactionManager</code> 来实现，需要显式执行事务。允许我们在代码中直接控制事务的边界，通过编程方式明确指定事务的开始、提交和回滚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AccountService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TransactionTemplate transactionTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setTransactionTemplate</span><span class=\"params\">(TransactionTemplate transactionTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.transactionTemplate = transactionTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">transfer</span><span class=\"params\">(<span class=\"keyword\">final</span> String out, <span class=\"keyword\">final</span> String in, <span class=\"keyword\">final</span> Double money)</span> &#123;</span><br><span class=\"line\">        transactionTemplate.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doInTransactionWithoutResult</span><span class=\"params\">(TransactionStatus status)</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 转出</span></span><br><span class=\"line\">                accountDao.outMoney(out, money);</span><br><span class=\"line\">                <span class=\"comment\">// 转入</span></span><br><span class=\"line\">                accountDao.inMoney(in, money);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们使用了 <code>TransactionTemplate</code> 来实现编程式事务，通过 <code>execute</code> 方法来执行事务，这样就可以在方法内部实现事务的控制。</p>\n<h3 id=\"介绍一下声明式事务管理？\"><a href=\"#介绍一下声明式事务管理？\" class=\"headerlink\" title=\"介绍一下声明式事务管理？\"></a>介绍一下声明式事务管理？</h3><p>声明式事务是建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在目标方法执行完之后根据执行情况提交或者回滚事务。</p>\n<p>相比较编程式事务，优点是不需要在业务逻辑代码中掺杂事务管理的代码，Spring 推荐通过 <code>@Transactional</code> 注解的方式来实现声明式事务管理，也是日常开发中最常用的。</p>\n<p>不足的地方是，<strong>声明式事务管理最细粒度只能作用到方法级别</strong>，无法像编程式事务那样可以作用到代码块级别。</p>\n<p><strong>说说两者的区别？</strong></p>\n<ul>\n<li><strong>编程式事务管理</strong>：需要在代码中显式调用事务管理的 API 来控制事务的边界，比较灵活，但是代码侵入性较强，不够优雅。</li>\n<li><strong>声明式事务管理</strong>：这种方式使用 Spring 的 AOP 来声明事务，将事务管理代码从业务代码中分离出来。优点是代码简洁，易于维护。但缺点是不够灵活，只能在预定义的方法上使用事务。</li>\n</ul>\n<h2 id=\"24-说说-Spring-的事务隔离级别？\"><a href=\"#24-说说-Spring-的事务隔离级别？\" class=\"headerlink\" title=\"24.说说 Spring 的事务隔离级别？\"></a>24.说说 Spring 的事务隔离级别？</h2><p><strong>事务的隔离级别定义了一个事务可能受其他并发事务影响的程度</strong>。SQL 标准定义了四个隔离级别，Spring 都支持，并且提供了对应的机制来配置它们，定义在 TransactionDefinition 接口中。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624104723.png\" alt=\"20250624104723\"></p>\n<p>①、ISOLATION_DEFAULT：使用数据库默认的隔离级别（你们爱咋咋滴 😁），MySQL 默认的是可重复读，Oracle 默认的读已提交。</p>\n<p>②、ISOLATION_READ_UNCOMMITTED：读未提交，允许事务读取未被其他事务提交的更改。这是隔离级别最低的设置，可能会导致“脏读”问题。</p>\n<p>③、ISOLATION_READ_COMMITTED：读已提交，确保事务只能读取已经被其他事务提交的更改。这可以防止“脏读”，但仍然可能发生“不可重复读”和“幻读”问题。</p>\n<p>④、ISOLATION_REPEATABLE_READ：可重复读，确保事务可以多次从一个字段中读取相同的值，即在这个事务内，其他事务无法更改这个字段，从而避免了“不可重复读”，但仍可能发生“幻读”问题。</p>\n<p>⑤、ISOLATION_SERIALIZABLE：串行化，这是最高的隔离级别，它完全隔离了事务，确保事务序列化执行，以此来避免“脏读”、“不可重复读”和“幻读”问题，但性能影响也最大。</p>\n<h2 id=\"25-Spring-的事务传播机制？\"><a href=\"#25-Spring-的事务传播机制？\" class=\"headerlink\" title=\"25.Spring 的事务传播机制？\"></a>25.Spring 的事务传播机制？</h2><p>事务的传播机制定义了方法在被另一个事务方法调用时的事务行为，这些行为定义了事务的边界和事务上下文如何在方法调用链中传播。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624104933.png\" alt=\"20250624104933\"></p>\n<p>Spring 的默认传播行为是 PROPAGATION_REQUIRED，即如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>\n<p>事务传播机制是使用 <code>ThreadLocal</code> 实现的，所以，如果调用的方法是在新线程中，事务传播会失效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">parentMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; childMethod()).start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">childMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的操作将不会在 parentMethod 的事务范围内执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Spring 默认的事务传播行为是 PROPAFATION_REQUIRED，即如果多个 <code>ServiceX#methodX()</code> 都工作在事务环境下，且程序中存在这样的调用链 <code>Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()</code>，那么这 3 个服务类的 3 个方法都通过 Spring 的事务传播机制工作在同一个事务中。</p>\n<h3 id=\"protected-和-private-加事务会生效吗\"><a href=\"#protected-和-private-加事务会生效吗\" class=\"headerlink\" title=\"protected 和 private 加事务会生效吗\"></a>protected 和 private 加事务会生效吗</h3><p>在 Spring 中，只有通过 Spring 容器的 AOP 代理调用的<strong>公开方法</strong>（public method）上的<code>@Transactional</code>注解才会生效。</p>\n<p>如果在 protected、private 方法上使用@Transactional，这些事务注解将不会生效，原因：Spring 默认使用基于 JDK 的动态代理（当接口存在时）或基于 CGLIB 的代理（当只有类时）来实现事务。<strong>这两种代理机制都只能代理公开的方法</strong>。</p>\n<h2 id=\"26-声明式事务实现原理了解吗？\"><a href=\"#26-声明式事务实现原理了解吗？\" class=\"headerlink\" title=\"26.声明式事务实现原理了解吗？\"></a>26.声明式事务实现原理了解吗？</h2><p>Spring 的声明式事务管理是通过 <strong>AOP（面向切面编程）和代理机制</strong>实现的。</p>\n<p>第一步，<strong>在 Bean 初始化阶段创建代理对象</strong>：</p>\n<p>Spring 容器在初始化单例 Bean 的时候，会遍历所有的 <code>BeanPostProcessor</code> 实现类，并执行其 <code>postProcessAfterInitialization</code> 方法。</p>\n<p>在执行 <code>postProcessAfterInitialization</code> 方法时会遍历容器中所有的切面，查找与当前 Bean 匹配的切面，这里会获取事务的属性切面，也就是 <code>@Transactional</code> 注解及其属性值。</p>\n<p>然后根据得到的切面创建一个代理对象，默认使用 JDK 动态代理创建代理，如果目标类是接口，则使用 <code>JDK 动态代理</code>，否则使用 <code>Cglib</code>。</p>\n<p>第二步，<strong>在执行目标方法时进行事务增强操作</strong>：</p>\n<p>当通过代理对象调用 Bean 方法的时候，会触发对应的 AOP 增强拦截器，声明式事务是一种环绕增强，对应接口为<code>MethodInterceptor</code>，事务增强对该接口的实现为<code>TransactionInterceptor</code>，类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624105744.png\" alt=\"20250624105744\"></p>\n<p>事务拦截器<code>TransactionInterceptor</code>在<code>invoke</code>方法中，通过调用父类<code>TransactionAspectSupport</code>的<code>invokeWithinTransaction</code>方法进行事务处理，包括开启事务、事务提交、异常回滚等。</p>\n<h2 id=\"27-声明式事务在哪些情况下会失效？\"><a href=\"#27-声明式事务在哪些情况下会失效？\" class=\"headerlink\" title=\"27.声明式事务在哪些情况下会失效？\"></a>27.声明式事务在哪些情况下会失效？</h2><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624105915.png\" alt=\"20250624105915\"></p>\n<p><strong>1、@Transactional 应用在非 public 修饰的方法上</strong></p>\n<p>如果 <code>Transactional</code> 注解应用在<strong>非 public</strong> 修饰的方法上，Transactional 将会失效。</p>\n<p>是因为在 <code>Spring AOP</code> 代理时，<code>TransactionInterceptor</code> （事务拦截器）在目标方法执行前后进行拦截，<code>DynamicAdvisedInterceptor</code>（CglibAopProxy 的内部类）的 <code>intercept</code> 方法或 <code>JdkDynamicAopProxy</code> 的 <code>invoke</code> 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code> 的 <code>computeTransactionAttribute方法，获取</code> Transactional 注解的事务配置信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> TransactionAttribute <span class=\"title function_\">computeTransactionAttribute</span><span class=\"params\">(Method method,</span></span><br><span class=\"line\"><span class=\"params\">    Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Don&#x27;t allow no-public methods as required.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法会检查目标方法的修饰符是否为 <code>public</code>，不是 <code>public</code> 则不会获取 <code>@Transactional</code> 的属性配置信息。</p>\n<p><strong>2、@Transactional 注解属性 propagation 设置错误</strong></p>\n<ul>\n<li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行；错误使用场景：在业务逻辑必须运行在事务环境下以确保数据一致性的情况下使用 SUPPORTS。</li>\n<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：总是以非事务方式执行，如果当前存在事务，则挂起该事务。错误使用场景：在需要事务支持的操作中使用 NOT_SUPPORTED。</li>\n<li>TransactionDefinition.PROPAGATION_NEVER：总是以非事务方式执行，如果当前存在事务，则抛出异常。错误使用场景：在应该在事务环境下执行的操作中使用 NEVER。</li>\n</ul>\n<p><strong>3、@Transactional 注解属性 rollbackFor 设置错误</strong></p>\n<p><code>rollbackFor</code> 用来指定能够触发事务回滚的异常类型。Spring 默认抛出未检查 unchecked 异常（继承自 RuntimeException 的异常）或者 Error 才回滚事务，其他异常不会触发回滚事务。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624110335.png\" alt=\"20250624110335\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 希望自定义的异常可以进行回滚</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)</span></span><br></pre></td></tr></table></figure>\n<p>若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</p>\n<p><strong>4、同一个类中方法调用，导致@Transactional 失效</strong></p>\n<p>开发中避免不了会对同一个类里面的方法调用，比如有一个类 Test，它的一个方法 A，A 调用本类的方法 B（不论方法 B 是用 public 还是 private 修饰），但方法 A 没有声明注解事务，而 B 方法有。</p>\n<p>则<strong>外部调用方法 A 之后，方法 B 的事务是不会起作用的</strong>。这也是经常犯错误的一个地方。</p>\n<p>那为啥会出现这种情况呢？其实还是由 Spring AOP 代理造成的，因为只有事务方法被当前类以外的代码调用时，才会由 Spring 生成的代理对象来管理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//@Transactional</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/test&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Integer <span class=\"title function_\">A</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">CityInfoDict</span> <span class=\"variable\">cityInfoDict</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CityInfoDict</span>();</span><br><span class=\"line\">    cityInfoDict.setCityName(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * B 插入字段为 3的数据</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.insertB();</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * A 插入字段为 2的数据</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">insert</span> <span class=\"operator\">=</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> insert;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional()</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Integer <span class=\"title function_\">insertB</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">CityInfoDict</span> <span class=\"variable\">cityInfoDict</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CityInfoDict</span>();</span><br><span class=\"line\">    cityInfoDict.setCityName(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    cityInfoDict.setParentCityId(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种情况是最常见的一种@Transactional 注解失效场景。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Integer <span class=\"title function_\">A</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">insert</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">CityInfoDict</span> <span class=\"variable\">cityInfoDict</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CityInfoDict</span>();</span><br><span class=\"line\">        cityInfoDict.setCityName(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">        cityInfoDict.setParentCityId(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * A 插入字段为 2的数据</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * B 插入字段为 3的数据</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        b.insertB();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 B 方法内部抛了异常，而 A 方法此时 try catch 了 B 方法的异常，那这个事务就不能正常回滚了，会抛出异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h1><h2 id=\"28-Spring-MVC-的核心组件？\"><a href=\"#28-Spring-MVC-的核心组件？\" class=\"headerlink\" title=\"28.Spring MVC 的核心组件？\"></a>28.Spring MVC 的核心组件？</h2><ol>\n<li><strong>DispatcherServlet</strong>：前置控制器，是整个流程控制的<strong>核心</strong>，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</li>\n<li><strong>Handler</strong>：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</li>\n<li><strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</li>\n<li><strong>HandlerInterceptor</strong>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li>\n<li><strong>HandlerExecutionChain</strong>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li>\n<li><strong>HandlerAdapter</strong>：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li>\n<li><strong>ModelAndView</strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li>\n<li><strong>ViewResolver</strong>：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</li>\n</ol>\n<h2 id=\"29-Spring-MVC-的工作流程？\"><a href=\"#29-Spring-MVC-的工作流程？\" class=\"headerlink\" title=\"29.Spring MVC 的工作流程？\"></a>29.Spring MVC 的工作流程？</h2><p>首先，客户端发送请求，<code>DispatcherServlet</code> 拦截并通过 <code>HandlerMapping</code> 找到对应的控制器。</p>\n<p><code>DispatcherServlet</code> 使用 <code>HandlerAdapter</code> 调用控制器方法，执行具体的业务逻辑，返回一个 <code>ModelAndView</code> 对象。</p>\n<p>然后 <code>DispatcherServlet</code> 通过 <code>ViewResolver</code> 解析视图。</p>\n<p>最后，<code>DispatcherServlet</code> 渲染视图并将响应返回给客户端。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624110918.png\" alt=\"20250624110918\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624111031.png\" alt=\"20250624111031\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624111043.png\" alt=\"20250624111043\"></p>\n<p>①、<strong>发起请求</strong>：客户端通过 HTTP 协议向服务器发起请求。</p>\n<p>②、<strong>前端控制器</strong>：这个请求会先到前端控制器 DispatcherServlet，它是整个流程的入口点，负责接收请求并将其分发给相应的处理器。</p>\n<p>③、<strong>处理器映射</strong>：DispatcherServlet 调用 HandlerMapping 来确定哪个 Controller 应该处理这个请求。通常会根据请求的 URL 来确定。</p>\n<p>④、<strong>处理器适配器</strong>：一旦找到目标 Controller，DispatcherServlet 会使用 HandlerAdapter 来调用 Controller 的处理方法。</p>\n<p>⑤、<strong>执行处理器</strong>：Controller 处理请求，处理完后返回一个 ModelAndView 对象，其中包含模型数据和逻辑视图名。</p>\n<p>⑥、<strong>视图解析器</strong>：DispatcherServlet 接收到 ModelAndView 后，会使用 ViewResolver 来解析视图名称，找到具体的视图页面。</p>\n<p>⑦、<strong>渲染视图</strong>：视图使用模型数据渲染页面，生成最终的页面内容。</p>\n<p>⑧、<strong>响应结果</strong>：DispatcherServlet 将视图结果返回给客户端。</p>\n<p><strong>Spring MVC</strong> 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要我们开发人员创建和管理，真正需要处理的只有 <strong>Controller</strong> 、<strong>View</strong> 、<strong>Model</strong>。</p>\n<p>在前后端分离的情况下，步骤 ⑥、⑦、⑧ 会略有不同，后端通常只需要处理数据，并将 JSON 格式的数据返回给前端就可以了，而不是返回完整的视图页面。</p>\n<h3 id=\"这个-Handler-是什么东西啊？为什么还需要-HandlerAdapter\"><a href=\"#这个-Handler-是什么东西啊？为什么还需要-HandlerAdapter\" class=\"headerlink\" title=\"这个 Handler 是什么东西啊？为什么还需要 HandlerAdapter\"></a>这个 Handler 是什么东西啊？为什么还需要 HandlerAdapter</h3><p>Handler 一般就是指 Controller，Controller 是 Spring MVC 的核心组件，负责处理请求，返回响应。</p>\n<p>Spring MVC 允许使用多种类型的处理器。不仅仅是标准的@Controller注解的类，还可以是实现了特定接口的其他类（如 <code>HttpRequestHandler</code> 或 <code>SimpleControllerHandlerAdapter</code> 等）。这些处理器可能有不同的方法签名和交互方式。</p>\n<p><code>HandlerAdapter</code> 的主要职责就是调用 <code>Handler</code> 的方法来处理请求，并且适配不同类型的处理器。<code>HandlerAdapter</code> 确保 <code>DispatcherServlet</code> 可以以统一的方式调用不同类型的处理器，无需关心具体的执行细节。</p>\n<h2 id=\"30-SpringMVC-Restful-风格的接口的流程是什么样的呢？\"><a href=\"#30-SpringMVC-Restful-风格的接口的流程是什么样的呢？\" class=\"headerlink\" title=\"30.SpringMVC Restful 风格的接口的流程是什么样的呢？\"></a>30.SpringMVC Restful 风格的接口的流程是什么样的呢？</h2><p>PS:这是一道全新的八股，毕竟 <code>ModelAndView</code> 这种方式应该没人用了吧？现在都是前后端分离接口，八股也该更新换代了。<br>我们都知道 <code>Restful</code> 接口，响应格式是 json，这就用到了一个常用注解：<code>@ResponseBody</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/user&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">user</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"number\">1</span>,<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>加入了这个注解后，整体的流程上和使用 <code>ModelAndView</code> 大体上相同，但是细节上有一些不同：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624111354.png\" alt=\"20250624111354\"></p>\n<p>1. 客户端向服务端发送一次请求，这个请求会先到前端控制器 <code>DispatcherServlet</code></p>\n<p>2. <code>DispatcherServlet</code> 接收到请求后会调用 <code>HandlerMapping</code> 处理器映射器。由此得知，该请求该由哪个 <code>Controller</code> 来处理</p>\n<p>3. <code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code> 处理器适配器，告诉处理器适配器应该要去执行哪个 <code>Controller</code></p>\n<p>4. <code>Controller</code> 被封装成了 <code>ServletInvocableHandlerMethod</code>，<code>HandlerAdapter</code> 处理器适配器去执行 <code>invokeAndHandle</code> 方法，完成对 <code>Controller</code> 的请求处理</p>\n<p>5. <code>HandlerAdapter</code> 执行完对 <code>Controller</code> 的请求，会调用 <code>HandlerMethodReturnValueHandler</code> 去处理返回值，主要的过程：</p>\n<ul>\n<li><p>5.1. 调用 <code>RequestResponseBodyMethodProcessor</code>，创建 <code>ServletServerHttpResponse</code>（Spring 对原生 <code>ServerHttpResponse</code> 的封装）实例</p>\n</li>\n<li><p>5.2.使用 <code>HttpMessageConverter</code> 的 <code>write</code> 方法，将返回值写入 <code>ServletServerHttpResponse</code> 的 <code>OutputStream</code> 输出流中</p>\n</li>\n<li><p>5.3.在写入的过程中，会使用 <code>JsonGenerator</code>（默认使用 Jackson 框架）对返回值进行 Json 序列化</p>\n</li>\n</ul>\n<p>6. 执行完请求后，返回的 <code>ModealAndView</code> 为 null，<code>ServletServerHttpResponse</code> 里也已经写入了响应，所以不用关心 View 的处理</p>\n<h1 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h1><h2 id=\"31-介绍一下-SpringBoot，有哪些优点？\"><a href=\"#31-介绍一下-SpringBoot，有哪些优点？\" class=\"headerlink\" title=\"31.介绍一下 SpringBoot，有哪些优点？\"></a>31.介绍一下 SpringBoot，有哪些优点？</h2><p>Spring Boot 提供了一套默认配置，它通过约定大于配置的理念，来帮助我们快速搭建 Spring 项目骨架。</p>\n<p>以前的 Spring 开发需要配置大量的 xml 文件，并且需要引入大量的第三方 jar 包，还需要手动放到 classpath 下。现在只需要引入一个 Starter，或者一个注解，就可以轻松搞定。</p>\n<p>Spring Boot 的优点非常多，比如说：</p>\n<ol>\n<li>Spring Boot 内嵌了 Tomcat、Jetty、Undertow 等容器，直接运行 jar 包就可以启动项目。</li>\n<li>Spring Boot 内置了 Starter 和自动装配，避免繁琐的手动配置。例如，如果项目中添加了 spring-boot-starter-web，Spring Boot 会自动配置 Tomcat 和 Spring MVC。</li>\n<li>Spring Boot 内置了 Actuator 和 DevTools，便于调试和监控。</li>\n</ol>\n<h3 id=\"Spring-Boot常用注解有哪些？\"><a href=\"#Spring-Boot常用注解有哪些？\" class=\"headerlink\" title=\"Spring Boot常用注解有哪些？\"></a>Spring Boot常用注解有哪些？</h3><ol>\n<li><strong>@SpringBootApplication</strong>：Spring Boot 应用的入口，用在启动类上。</li>\n<li>还有一些 Spring 框架本身的注解，比如 <strong>@Component</strong>、**@RestController<strong>、</strong>@Service<strong>、</strong>@ConfigurationProperties<strong>、</strong>@Transactional** 等。</li>\n</ol>\n<h2 id=\"32-SpringBoot-自动配置原理了解吗？\"><a href=\"#32-SpringBoot-自动配置原理了解吗？\" class=\"headerlink\" title=\"32.SpringBoot 自动配置原理了解吗？\"></a>32.SpringBoot 自动配置原理了解吗？</h2><p>在 Spring 中，自动装配是指容器<strong>利用反射技术</strong>，根据 Bean 的<strong>类型、名称</strong>等自动注入所需的依赖。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250626103606.png\" alt=\"20250626103606\"></p>\n<p>在 Spring Boot 中，开启自动装配的注解是<code>@EnableAutoConfiguration</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250626104308.png\" alt=\"20250626104308\"></p>\n<p>Spring Boot 为了进一步简化，直接通过<code> @SpringBootApplication</code> 注解一步搞定，该注解包含了 <code>@EnableAutoConfiguration</code> 注解。</p>\n<p>main 类启动的时候，Spring Boot 会通过底层的<code>AutoConfigurationImportSelector</code> 类加载自动装配类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span> <span class=\"comment\">//将main同级的包下的所有组件注册到容器中</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class=\"comment\">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ENABLED_OVERRIDE_PROPERTY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>AutoConfigurationImportSelector</code>实现了<code>ImportSelector</code>接口，该接口的作用是收集需要导入的配置类，配合 <code>@Import()</code> 将相应的类导入到 Spring 容器中。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250626104540.png\" alt=\"20250626104540\"></p>\n<p>获取注入类的方法是 <code>selectImports()</code>，它实际调用的是<code>getAutoConfigurationEntry()</code>，这个方法是获取自动装配类的关键。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> AutoConfigurationEntry <span class=\"title function_\">getAutoConfigurationEntry</span><span class=\"params\">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查自动配置是否启用。如果@ConditionalOnClass等条件注解使得自动配置不适用于当前环境，则返回一个空的配置条目。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EMPTY_ENTRY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取启动类上的@EnableAutoConfiguration注解的属性，这可能包括对特定自动配置类的排除。</span></span><br><span class=\"line\">    <span class=\"type\">AnnotationAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span> getAttributes(annotationMetadata);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从spring.factories中获取所有候选的自动配置类。这是通过加载META-INF/spring.factories文件中对应的条目来实现的。</span></span><br><span class=\"line\">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移除配置列表中的重复项，确保每个自动配置类只被考虑一次。</span></span><br><span class=\"line\">    configurations = removeDuplicates(configurations);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据注解属性解析出需要排除的自动配置类。</span></span><br><span class=\"line\">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检查排除的类是否存在于候选配置中，如果存在，则抛出异常。</span></span><br><span class=\"line\">    checkExcludedClasses(configurations, exclusions);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从候选配置中移除排除的类。</span></span><br><span class=\"line\">    configurations.removeAll(exclusions);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 应用过滤器进一步筛选自动配置类。过滤器可能基于条件注解如@ConditionalOnBean等来排除特定的配置类。</span></span><br><span class=\"line\">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 触发自动配置导入事件，允许监听器对自动配置过程进行干预。</span></span><br><span class=\"line\">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建并返回一个包含最终确定的自动配置类和排除的配置类的AutoConfigurationEntry对象。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：Spring Boot 的自动装配原理依赖于 Spring 框架的依赖注入和条件注册，通过这种方式，Spring Boot 能够智能地配置 bean，并且只有当这些 bean 实际需要时才会被创建和配置。</p>\n<h2 id=\"33-如何自定义一个-SpringBoot-Starter\"><a href=\"#33-如何自定义一个-SpringBoot-Starter\" class=\"headerlink\" title=\"33.如何自定义一个 SpringBoot Starter?\"></a>33.如何自定义一个 SpringBoot Starter?</h2><p>创建一个自定义的 Spring Boot Starter，需要这几步：</p>\n<ul>\n<li><p>第一步，创建一个新的 Maven 项目，例如命名为 my-spring-boot-starter。在 pom.xml 文件中添加必要的依赖和配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">spring.boot.version</span>&gt;</span>2.3.1.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">spring.boot.version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二步，在 src&#x2F;main&#x2F;java 下创建一个自动配置类，比如 MyServiceAutoConfiguration.java：（通常是 autoconfigure 包下）。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(MyStarterProperties.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyServiceAutoConfiguration</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyService <span class=\"title function_\">myService</span><span class=\"params\">(MyStarterProperties properties)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyService</span>(properties.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>第三步，创建一个配置属性类 MyStarterProperties.java：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix = &quot;mystarter&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyStarterProperties</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;二哥的 Java 进阶之路不错啊!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMessage</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.message = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第四步，创建一个简单的服务类 MyService.java：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String message;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyService</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.message = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第五步，配置 spring.factories，在 src&#x2F;main&#x2F;resources&#x2F;META-INF 目录下创建 spring.factories 文件，并添加：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class=\"line\">com.itwanger.mystarter.autoconfigure.MyServiceAutoConfiguration</span><br></pre></td></tr></table></figure></li>\n<li>第六步，使用 Maven 打包这个项目：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean install</span><br></pre></td></tr></table></figure></li>\n<li>第七步，在其他的 Spring Boot 项目中，通过 Maven 来添加这个自定义的 Starter 依赖，并通过 application.properties 配置欢迎消息：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mystarter.message=javabetter.cn</span><br></pre></td></tr></table></figure>\n然后就可以在 Spring Boot 项目中注入 <code>MyStarterProperties</code> 来使用它。</li>\n</ul>\n<p>-启动项目，然后在浏览器中输入 localhost:8081&#x2F;hello，就可以看到欢迎消息了。</p>\n<h3 id=\"Spring-Boot-Starter-的原理了解吗？\"><a href=\"#Spring-Boot-Starter-的原理了解吗？\" class=\"headerlink\" title=\"Spring Boot Starter 的原理了解吗？\"></a>Spring Boot Starter 的原理了解吗？</h3><p><code>Spring Boot Starter</code> 主要通过起步依赖和自动配置机制来简化项目的构建和配置过程。</p>\n<p>起步依赖是 Spring Boot 提供的一组预定义依赖项，它们将一组相关的库和模块打包在一起。比如 spring-boot-starter-web 就包含了 Spring MVC、Tomcat 和 Jackson 等依赖。</p>\n<p>自动配置机制是 Spring Boot 的核心特性，通过自动扫描类路径下的类、资源文件和配置文件，自动创建和配置应用程序所需的 Bean 和组件。</p>\n<p>比如有了 spring-boot-starter-web，我们开发者就不需要再手动配置 Tomcat、Spring MVC 等，Spring Boot 会自动帮我们完成这些工作。</p>\n<h2 id=\"34-Spring-Boot-启动原理了解吗？\"><a href=\"#34-Spring-Boot-启动原理了解吗？\" class=\"headerlink\" title=\"34.Spring Boot 启动原理了解吗？\"></a>34.Spring Boot 启动原理了解吗？</h2><p>Spring Boot 的启动由 SpringApplication 类负责：</p>\n<ul>\n<li>第一步，创建 SpringApplication 实例，负责应用的启动和初始化；</li>\n<li>第二步，从 application.yml 中加载配置文件和环境变量；</li>\n<li>第三步，创建上下文环境 ApplicationContext，并加载 Bean，完成依赖注入；</li>\n<li>第四步，启动内嵌的 Web 容器。</li>\n<li>第五步，发布启动完成事件 ApplicationReadyEvent，并调用 ApplicationRunner 的 run 方法完成启动后的逻辑。</li>\n</ul>\n<p>关键的代码逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建启动时的监听器并触发启动事件</span></span><br><span class=\"line\">    <span class=\"type\">SpringApplicationRunListeners</span> <span class=\"variable\">listeners</span> <span class=\"operator\">=</span> getRunListeners(args);</span><br><span class=\"line\">    listeners.starting();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 准备运行环境</span></span><br><span class=\"line\">    <span class=\"type\">ConfigurableEnvironment</span> <span class=\"variable\">environment</span> <span class=\"operator\">=</span> prepareEnvironment(listeners);</span><br><span class=\"line\">    configureIgnoreBeanInfo(environment);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 创建上下文</span></span><br><span class=\"line\">    <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> createApplicationContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 准备上下文</span></span><br><span class=\"line\">        prepareContext(context, environment, listeners, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5. 刷新上下文，完成 Bean 初始化和装配</span></span><br><span class=\"line\">        refreshContext(context);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 6. 调用运行器</span></span><br><span class=\"line\">        afterRefresh(context, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 7. 触发启动完成事件</span></span><br><span class=\"line\">        listeners.started(context);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">        handleRunFailure(context, ex, listeners);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250628094408.png\" alt=\"20250628094408\"><br>以TecHub实战项目为例。在启动类 QuickForumApplication 中，main 方法会调用 SpringApplication.run() 启动项目。</p>\n<p>该方法负责 Spring 应用的上下文环境（ApplicationContext）准备，包括：</p>\n<ul>\n<li>扫描配置文件，添加依赖项</li>\n<li>初始化和加载 Bean 定义</li>\n<li>启动内嵌的 Web 容器等</li>\n<li>发布启动完成事件</li>\n</ul>\n<h3 id=\"了解-SpringBootApplication-注解吗？\"><a href=\"#了解-SpringBootApplication-注解吗？\" class=\"headerlink\" title=\"了解@SpringBootApplication 注解吗？\"></a>了解@SpringBootApplication 注解吗？</h3><p><code>@SpringBootApplication</code>是 Spring Boot 的核心注解，经常用于主类上，作为项目启动入口的标识。它是一个组合注解：</p>\n<ul>\n<li><code>@SpringBootConfiguration</code>：继承自 <code>@Configuration</code>，标注该类是一个<strong>配置类</strong>，相当于一个 Spring 配置文件。</li>\n<li><code>@EnableAutoConfiguration</code>：告诉 Spring Boot 根据 pom.xml 中添加的依赖自动配置项目。例如，如果 spring-boot-starter-web 依赖被添加到项目中，Spring Boot 会自动配置 Tomcat 和 Spring MVC。</li>\n<li><code>@ComponentScan</code>：扫描当前包及其子包下被<code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code> 注解标记的类，并注册为 Spring Bean。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Application</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(Application.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"为什么-Spring-Boot-在启动的时候能够找到-main-方法上的-SpringBootApplication-注解？\"><a href=\"#为什么-Spring-Boot-在启动的时候能够找到-main-方法上的-SpringBootApplication-注解？\" class=\"headerlink\" title=\"为什么 Spring Boot 在启动的时候能够找到 main 方法上的@SpringBootApplication 注解？\"></a>为什么 Spring Boot 在启动的时候能够找到 main 方法上的@SpringBootApplication 注解？</h3><p>Spring Boot 在启动时能够找到主类上的<code>@SpringBootApplication</code>注解，是因为它利用了 Java 的反射机制和类加载机制，结合 Spring 框架内部的一系列处理流程。</p>\n<p>当运行一个 Spring Boot 程序时，通常会调用主类中的main方法，这个方法会执行<code>SpringApplication.run()</code>，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(MyApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>SpringApplication.run(Class&lt;?&gt; primarySource, String... args)</code>方法接收两个参数：第一个是主应用类（即包含main方法的类），第二个是命令行参数。primarySource参数提供了一个起点，Spring Boot 通过它来加载应用上下文。</p>\n<p>Spring Boot 利用 Java 反射机制来读取传递给run方法的类（MyApplication.class）。它会检查这个类上的注解，包括<code>@SpringBootApplication</code>。</p>\n<h3 id=\"Spring-Boot-默认的包扫描路径是什么？\"><a href=\"#Spring-Boot-默认的包扫描路径是什么？\" class=\"headerlink\" title=\"Spring Boot 默认的包扫描路径是什么？\"></a>Spring Boot 默认的包扫描路径是什么？</h3><p>Spring Boot 的默认包扫描路径是以启动类 <code>@SpringBootApplication</code> 注解所在的包为根目录的，即默认情况下，Spring Boot 会扫描启动类所在包及其子包下的所有组件。</p>\n<p>比如说在技术派实战项目中，启动类<code>QuickForumApplication</code>所在的包是<code>com.github.paicoding.forum.web</code>，那么 Spring Boot 默认会扫描<code>com.github.paicoding.forum.web</code>包及其子包下的所有组件。</p>\n<p><code>@SpringBootApplication</code> 是一个组合注解，它里面的<code>@ComponentScan</code>注解可以指定要扫描的包路径，默认扫描启动类所在包及其子包下的所有组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如说带有 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code> 等注解的类都会被 Spring Boot 扫描到，并注册到 Spring 容器中。</p>\n<p>如果需要自定义包扫描路径，可以在<code>@SpringBootApplication</code>注解上添加<code>@ComponentScan</code>注解，指定要扫描的包路径。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &#123;&quot;com.github.paicoding.forum&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">QuickForumApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(QuickForumApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式会覆盖默认的包扫描路径，只扫描com.github.paicoding.forum包及其子包下的所有组件。</p>\n<h2 id=\"36-SpringBoot-和-SpringMVC-的区别？（补充）\"><a href=\"#36-SpringBoot-和-SpringMVC-的区别？（补充）\" class=\"headerlink\" title=\"36.SpringBoot 和 SpringMVC 的区别？（补充）\"></a>36.SpringBoot 和 SpringMVC 的区别？（补充）</h2><p>Spring MVC 是基于 Spring 框架的一个模块，提供了一种 <code>Model-View-Controller</code>（模型-视图-控制器）的<strong>开发模式</strong>。</p>\n<p>Spring Boot 旨在简化 Spring 应用的<strong>配置和部署过程</strong>，提供了大量的自动配置选项，以及运行时环境的内嵌 Web 服务器，这样就可以更快速地开发一个 SpringMVC 的 Web 项目。</p>\n<h2 id=\"38-Spring-Boot-和-Spring-有什么区别？（补充）\"><a href=\"#38-Spring-Boot-和-Spring-有什么区别？（补充）\" class=\"headerlink\" title=\"38.Spring Boot 和 Spring 有什么区别？（补充）\"></a>38.Spring Boot 和 Spring 有什么区别？（补充）</h2><p><code>Spring Boot</code> 是 <code>Spring Framework</code> 的一个扩展，提供了一套<strong>快速配置和开发的机制</strong>，可以帮助我们快速搭建 Spring 项目的骨架，提高生产效率。</p>\n<p>特性:<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250628111310.png\" alt=\"20250628111310\"></p>\n<h1 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h1><h2 id=\"35-对-SpringCloud-了解多少？\"><a href=\"#35-对-SpringCloud-了解多少？\" class=\"headerlink\" title=\"35.对 SpringCloud 了解多少？\"></a>35.对 SpringCloud 了解多少？</h2><p><code>Spring Cloud</code> 是一个基于 <code>Spring Boot</code>，提供<strong>构建分布式系统</strong>和<strong>微服务架构</strong>的工具集。用于解决分布式系统中的一些常见问题，如配置管理、服务发现、负载均衡等等。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250628111452.png\" alt=\"20250628111452\"></p>\n<h3 id=\"什么是微服务？\"><a href=\"#什么是微服务？\" class=\"headerlink\" title=\"什么是微服务？\"></a>什么是微服务？</h3><ol>\n<li>2014 年 Martin Fowler 提出的一种新的架构形式。微服务架构是一种架构模式，提倡将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制(如 HTTP 或 Dubbo)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如 Maven)对其进行构建。</li>\n<li>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</li>\n</ol>\n<h3 id=\"微服务架构主要要解决哪些问题？\"><a href=\"#微服务架构主要要解决哪些问题？\" class=\"headerlink\" title=\"微服务架构主要要解决哪些问题？\"></a>微服务架构主要要解决哪些问题？</h3><ol>\n<li>服务很多，客户端怎么访问，如何提供对外网关?</li>\n<li>这么多服务，服务之间如何通信? HTTP 还是 RPC?</li>\n<li>这么多服务，如何治理? 服务的注册和发现。</li>\n<li>服务挂了怎么办？熔断机制。</li>\n</ol>\n<h3 id=\"有哪些主流微服务框架？\"><a href=\"#有哪些主流微服务框架？\" class=\"headerlink\" title=\"有哪些主流微服务框架？\"></a>有哪些主流微服务框架？</h3><ol>\n<li>Spring Cloud Netflix</li>\n<li>Spring Cloud Alibaba</li>\n<li>SpringBoot + Dubbo + ZooKeeper</li>\n</ol>\n<h3 id=\"SpringCloud-有哪些核心组件？\"><a href=\"#SpringCloud-有哪些核心组件？\" class=\"headerlink\" title=\"SpringCloud 有哪些核心组件？\"></a>SpringCloud 有哪些核心组件？</h3><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250628111549.png\" alt=\"20250628111549\"></p>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><h2 id=\"37-SpringTask-了解吗？\"><a href=\"#37-SpringTask-了解吗？\" class=\"headerlink\" title=\"37.SpringTask 了解吗？\"></a>37.SpringTask 了解吗？</h2><p><code>SpringTask</code> 是 Spring 框架提供的一个轻量级的任务调度框架，它允许我们开发者通过简单的注解来配置和管理定时任务。</p>\n<p>①、<code>@Scheduled</code>：最常用的注解，用于标记方法为计划任务的执行点。技术派实战项目中，就使用该注解来定时刷新 sitemap.xml：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;0 15 5 * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">autoRefreshCache</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;开始刷新sitemap.xml的url地址，避免出现数据不一致问题!&quot;</span>);</span><br><span class=\"line\">    refreshSitemap();</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;刷新完成！&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Scheduled</code> 注解支持多种调度选项，如 fixedRate、fixedDelay 和 cron 表达式。</p>\n<p>②、<code>@EnableScheduling</code>：用于开启定时任务的支持。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250628111747.png\" alt=\"20250628111747\"></p>\n<h3 id=\"用SpringTask资源占用太高，有什么其他的方式解决？（补充）\"><a href=\"#用SpringTask资源占用太高，有什么其他的方式解决？（补充）\" class=\"headerlink\" title=\"用SpringTask资源占用太高，有什么其他的方式解决？（补充）\"></a>用SpringTask资源占用太高，有什么其他的方式解决？（补充）</h3><ul>\n<li>第一，<strong>使用消息队列</strong>，如 RabbitMQ、Kafka、RocketMQ 等，将任务放到消息队列中，然后由消费者异步处理这些任务。</li>\n</ul>\n<p>①、在订单创建时，将订单超时检查任务放入消息队列，并设置延迟时间（即订单超时时间）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createOrder</span><span class=\"params\">(Order order)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建订单逻辑</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 发送延迟消息</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;orderExchange&quot;</span>, <span class=\"string\">&quot;orderTimeoutQueue&quot;</span>, order, message -&gt; &#123;</span><br><span class=\"line\">            message.getMessageProperties().setExpiration(<span class=\"string\">&quot;600000&quot;</span>); <span class=\"comment\">// 设置延迟时间（10分钟）</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>②、使用消费者从队列中消费消息，当消费到超时任务时，执行订单超时处理逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderTimeoutConsumer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;orderTimeoutQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleOrderTimeout</span><span class=\"params\">(Order order)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理订单超时逻辑</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二，使用数据库调度器（如 Quartz）。</li>\n</ul>\n<p>①、创建一个 Quartz 任务类，处理订单超时逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderTimeoutJob</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Job</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(JobExecutionContext context)</span> <span class=\"keyword\">throws</span> JobExecutionException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取订单信息</span></span><br><span class=\"line\">        <span class=\"type\">Order</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> (Order) context.getJobDetail().getJobDataMap().get(<span class=\"string\">&quot;order&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 处理订单超时逻辑</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>②、在订单创建时，调度一个 Quartz 任务，设置任务的触发时间为订单超时时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Scheduler scheduler;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createOrder</span><span class=\"params\">(Order order)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建订单逻辑</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调度 Quartz 任务</span></span><br><span class=\"line\">        <span class=\"type\">JobDetail</span> <span class=\"variable\">jobDetail</span> <span class=\"operator\">=</span> JobBuilder.newJob(OrderTimeoutJob.class)</span><br><span class=\"line\">                .usingJobData(<span class=\"string\">&quot;order&quot;</span>, order)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Trigger</span> <span class=\"variable\">trigger</span> <span class=\"operator\">=</span> TriggerBuilder.newTrigger()</span><br><span class=\"line\">                .startAt(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(System.currentTimeMillis() + <span class=\"number\">600000</span>)) <span class=\"comment\">// 设置触发时间（10分钟后）</span></span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SchedulerException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"41-Spring-Cache-了解吗？\"><a href=\"#41-Spring-Cache-了解吗？\" class=\"headerlink\" title=\"41.Spring Cache 了解吗？\"></a>41.Spring Cache 了解吗？</h2><p>Spring Cache 是 Spring 框架提供的一个缓存抽象，它通过统一的接口来支持多种缓存实现（如 Redis、Caffeine 等）。</p>\n<p>它通过注解（如 @Cacheable、@CachePut、@CacheEvict）来实现缓存管理，极大简化了代码实现。</p>\n<ul>\n<li><code>@Cacheable</code>：缓存方法的返回值。</li>\n<li><code>@CachePut</code>：用于更新缓存，每次调用方法都会将结果重新写入缓存。</li>\n<li><code>@CacheEvict</code>：用于删除缓存。<br>使用示例：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250628111949.png\" alt=\"20250628111949\"></li>\n</ul>\n<h3 id=\"Spring-Cache-和-Redis-有什么区别？\"><a href=\"#Spring-Cache-和-Redis-有什么区别？\" class=\"headerlink\" title=\"Spring Cache 和 Redis 有什么区别？\"></a>Spring Cache 和 Redis 有什么区别？</h3><ol>\n<li>Spring Cache 是 Spring 框架提供的一个缓存抽象，它通过注解来实现缓存管理，支持多种缓存实现（如 Redis、Caffeine 等）。</li>\n<li>Redis 是一个分布式的缓存中间件，支持多种数据类型（如 String、Hash、List、Set、ZSet），还支持持久化、集群、主从复制等。</li>\n</ol>\n<p>Spring Cache <strong>适合用于单机、轻量级和短时缓存场景</strong>，能够<strong>通过注解轻松控制缓存管理</strong>。</p>\n<p>Redis 是一种<strong>分布式缓存解决方案</strong>，支持多种数据结构和高并发访问，适合<strong>分布式系统和高并发场景</strong>，可以提供数据持久化和多种淘汰策略。</p>\n<p>在实际开发中，Spring Cache 和 Redis 可以结合使用，Spring Cache 提供管理缓存的注解，而 Redis 则作为分布式缓存的实现，提供共享缓存支持。</p>\n<h3 id=\"有了-Redis-为什么还需要-Spring-Cache？\"><a href=\"#有了-Redis-为什么还需要-Spring-Cache？\" class=\"headerlink\" title=\"有了 Redis 为什么还需要 Spring Cache？\"></a>有了 Redis 为什么还需要 Spring Cache？</h3><p>虽然 Redis 非常强大，但 Spring Cache 提供了一层缓存抽象，简化了缓存的管理。我们可以直接在方法上通过注解来实现缓存逻辑，减少了手动操作 Redis 的代码量。</p>\n<p>Spring Cache 还能灵活切换底层缓存实现。此外，Spring Cache 支持事务性缓存和条件缓存，便于在复杂场景中确保数据一致性。</p>\n<h3 id=\"说说Spring-Cache-的底层原理？\"><a href=\"#说说Spring-Cache-的底层原理？\" class=\"headerlink\" title=\"说说Spring Cache 的底层原理？\"></a>说说Spring Cache 的底层原理？</h3><p>Spring Cache 是基于 AOP 和缓存抽象层实现的。它通过 AOP 拦截被 @Cacheable、@CachePut 和 @CacheEvict 注解的方法，在方法调用前后自动执行缓存逻辑。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250628112031.png\" alt=\"20250628112031\"></p>\n<p>其提供的 CacheManager 和 Cache 等接口，不依赖具体的缓存实现，因此可以灵活地集成 Redis、Caffeine 等多种缓存。</p>\n<ul>\n<li>ConcurrentMapCacheManager：基于 Java ConcurrentMap 的本地缓存实现。</li>\n<li>RedisCacheManager：基于 Redis 的分布式缓存实现。</li>\n<li>CaffeineCacheManager：基于 Caffeine 的缓存实现。</li>\n</ul>\n"}]}