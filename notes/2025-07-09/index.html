{"layout":"notes","date":"2025-07-09T00:00:00.000Z","posts":[{"title":"MybatisPlus笔记","path":"2025/07/09/基础笔记/MybatisPlus笔记/","excerpt":"","date":"2025-07-08T16:00:00.000Z","tags":["基础","MybatisPlus"],"content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>MyBatis-Plus （简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>\n<h2 id=\"1快速入门\"><a href=\"#1快速入门\" class=\"headerlink\" title=\"1快速入门\"></a>1快速入门</h2><h3 id=\"1-1-基本步骤\"><a href=\"#1-1-基本步骤\" class=\"headerlink\" title=\"1.1 基本步骤\"></a>1.1 基本步骤</h3><p>引入mybatis-plus-boot-starter依赖:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.baomidou<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>最新版本<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>定义Mapper接口并继承BaseMapper:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserMapper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-定义Mapper\"><a href=\"#1-2-定义Mapper\" class=\"headerlink\" title=\"1.2 定义Mapper\"></a>1.2 定义Mapper</h3><p>为了简化单表CRUD，MybatisPlus提供了一个基础的<code>BaseMapper</code>接口，其中已经实现了单表的CRUD：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709155511.png\" alt=\"20250709155511\"><br>因此我们自定义的Mapper只要继承了这个<code>BaseMapper</code>，就无需自己实现单表CRUD了。</p>\n<h2 id=\"2-常见注解\"><a href=\"#2-常见注解\" class=\"headerlink\" title=\"2 常见注解\"></a>2 常见注解</h2><p>MybatisPlus中比较常用的几个注解如下:</p>\n<ul>\n<li><code>@TableName</code>: 用于指定表名</li>\n<li><code>@Tabled</code>: 用于指定表中的主键字段信息</li>\n<li><code>@TableField</code>: 用于指定表中的普通字段信息</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@TableName(&quot;sys_user&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@TableId(&quot;id&quot;,type=IdType.AUTO)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"meta\">@TableField(&quot;nickname&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-TableName\"><a href=\"#2-1-TableName\" class=\"headerlink\" title=\"2.1 @TableName\"></a>2.1 @TableName</h3><p>TableName注解除了指定表名以外，还可以指定很多其它属性：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709155749.png\" alt=\"20250709155749\"></p>\n<h3 id=\"2-2-TableId\"><a href=\"#2-2-TableId\" class=\"headerlink\" title=\"2.2 @TableId\"></a>2.2 @TableId</h3><p><code>TableId</code>注解支持两个属性：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709155858.png\" alt=\"20250709155858\"></p>\n<p><code>IdType</code>支持的类型有：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709160228.png\" alt=\"20250709160228\"></p>\n<p>这里比较常见的有三种：</p>\n<ul>\n<li>AUTO： 利用数据库的id自增长</li>\n<li>INPUT： 手动生成id</li>\n<li>ASSIGN_ID： 雪花算法生成Long类型的全局唯一id，这是默认的ID策略</li>\n</ul>\n<h3 id=\"2-3-TableField\"><a href=\"#2-3-TableField\" class=\"headerlink\" title=\"2.3 @TableField\"></a>2.3 @TableField</h3><p>一般情况下我们并不需要给字段添加<code>@TableField</code>注解，一些特殊情况除外：</p>\n<ul>\n<li>成员变量名与数据库字段名不一致</li>\n<li>成员变量是以isXXX命名，按照JavaBean的规范，MybatisPlus识别字段时会把is去除，这就导致与数据库不符。</li>\n<li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用@TableField注解给字段名添加转义字符：<code>``</code></li>\n</ul>\n<p>支持的其它属性如下：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709160448.png\" alt=\"20250709160448\"></p>\n<h2 id=\"3-常见配置\"><a href=\"#3-常见配置\" class=\"headerlink\" title=\"3 常见配置\"></a>3 常见配置</h2><p>大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:</p>\n<ul>\n<li>实体类的别名扫描包</li>\n<li>全局id类型</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mybatis-plus:</span></span><br><span class=\"line\">  <span class=\"attr\">type-aliases-package:</span> <span class=\"string\">com.itheima.mp.domain.po</span></span><br><span class=\"line\">  <span class=\"attr\">global-config:</span></span><br><span class=\"line\">    <span class=\"attr\">db-config:</span></span><br><span class=\"line\">      <span class=\"attr\">id-type:</span> <span class=\"string\">auto</span> <span class=\"comment\"># 全局id类型为自增长</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mybatis<span class=\"operator\">-</span>plus:</span><br><span class=\"line\">  mapper<span class=\"operator\">-</span>locations: &quot;classpath*:/mapper/**/*.xml&quot; # Mapper.xml文件地址，当前这个是默认值。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-核心功能\"><a href=\"#4-核心功能\" class=\"headerlink\" title=\"4 核心功能\"></a>4 核心功能</h2><h3 id=\"4-1-条件构造器\"><a href=\"#4-1-条件构造器\" class=\"headerlink\" title=\"4.1 条件构造器\"></a>4.1 条件构造器</h3><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此<code>BaseMapper</code>中提供的相关方法除了以<code>id</code>作为where条件以外，还支持更加复杂的where条件。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709162157.png\" alt=\"20250709162157\"></p>\n<p>参数中的<code>Wrapper</code>就是条件构造的抽象类，其下有很多默认实现，继承关系如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709162220.png\" alt=\"20250709162220\"></p>\n<p><code>Wrapper</code>的子类<code>AbstractWrapper</code>提供了where中包含的所有条件构造方法：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709162243.png\" alt=\"20250709162243\"></p>\n<h4 id=\"4-1-1-QueryWrapper\"><a href=\"#4-1-1-QueryWrapper\" class=\"headerlink\" title=\"4.1.1 QueryWrapper\"></a>4.1.1 QueryWrapper</h4><p>QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709162311.png\" alt=\"20250709162311\"></p>\n<p>无论是修改、删除、查询，都可以使用QueryWrapper来构建查询条件。接下来看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testQueryWrapper</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class=\"line\">    QueryWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;User&gt;()</span><br><span class=\"line\">            .select(<span class=\"string\">&quot;id&quot;</span>, <span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;info&quot;</span>, <span class=\"string\">&quot;balance&quot;</span>)</span><br><span class=\"line\">            .like(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;o&quot;</span>)</span><br><span class=\"line\">            .ge(<span class=\"string\">&quot;balance&quot;</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2.查询数据</span></span><br><span class=\"line\">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class=\"line\">    users.forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-2-UpdateWrapper\"><a href=\"#4-1-2-UpdateWrapper\" class=\"headerlink\" title=\"4.1.2 UpdateWrapper\"></a>4.1.2 UpdateWrapper</h4><p><code>UpdateWrapper</code>在<code>AbstractWrapper</code>的基础上拓展了一个set方法，允许指定SQL中的SET部分：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709163917.png\" alt=\"20250709163917\"></p>\n<p>基于<code>BaseMapper</code>中的<code>update</code>方法更新时只能直接赋值，对于一些复杂的需求就难以实现。<br>例如：更新id为1,2,4的用户的余额，扣200，对应的SQL应该是：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">SET</span> balance <span class=\"operator\">=</span> balance <span class=\"operator\">-</span> <span class=\"number\">200</span> <span class=\"keyword\">WHERE</span> id <span class=\"keyword\">in</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>SET的赋值结果是基于字段现有值的，这个时候就要利用<code>UpdateWrapper</code>中的<code>setSql</code>功能了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testUpdateWrapper</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    List&lt;Long&gt; ids = List.of(<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">4L</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 1.生成SQL</span></span><br><span class=\"line\">    UpdateWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">UpdateWrapper</span>&lt;User&gt;()</span><br><span class=\"line\">            .setSql(<span class=\"string\">&quot;balance = balance - 200&quot;</span>) <span class=\"comment\">// SET balance = balance - 200</span></span><br><span class=\"line\">            .in(<span class=\"string\">&quot;id&quot;</span>, ids); <span class=\"comment\">// WHERE id in (1, 2, 4)</span></span><br><span class=\"line\">        <span class=\"comment\">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span></span><br><span class=\"line\">    <span class=\"comment\">// 而是基于UpdateWrapper中的setSQL来更新</span></span><br><span class=\"line\">    userMapper.update(<span class=\"literal\">null</span>, wrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-3-4-1-3-LambdaQueryWrapper\"><a href=\"#4-1-3-4-1-3-LambdaQueryWrapper\" class=\"headerlink\" title=\"4.1.3 4.1.3.LambdaQueryWrapper\"></a>4.1.3 4.1.3.LambdaQueryWrapper</h4><p>无论是<code>QueryWrapper</code>还是<code>UpdateWrapper</code>在构造条件的时候都需要写死字段名称，会出现字符串魔法值。这在编程规范中显然是不推荐的。<br>那怎么样才能不写字段名，又能知道字段名呢？</p>\n<p>其中一种办法是基于变量的<code>gettter</code>方法结合反射技术。因此我们只要将条件对应的字段的<code>getter</code>方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的方法引用和Lambda表达式。<br>因此MybatisPlus又提供了一套基于<code>Lambda</code>的<code>Wrapper</code>，包含两个：</p>\n<ul>\n<li><code>LambdaQueryWrapper</code></li>\n<li><code>LambdaUpdateWrapper</code><br>分别对应<code>QueryWrapper</code>和<code>UpdateWrapper</code>其使用方式如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testLambdaQueryWrapper</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class=\"line\">    QueryWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;&gt;();</span><br><span class=\"line\">    wrapper.lambda()</span><br><span class=\"line\">            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class=\"line\">            .like(User::getUsername, <span class=\"string\">&quot;o&quot;</span>)</span><br><span class=\"line\">            .ge(User::getBalance, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2.查询</span></span><br><span class=\"line\">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class=\"line\">    users.forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-自定义SQL\"><a href=\"#4-2-自定义SQL\" class=\"headerlink\" title=\"4.2 自定义SQL\"></a>4.2 自定义SQL</h3><p>MybatisPlus提供了自定义SQL功能，可以让我们利用<code>Wrapper</code>生成查询条件，再结合<code>Mapper.xml</code>编写SQL</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testCustomWrapper</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.准备自定义查询条件</span></span><br><span class=\"line\">    List&lt;Long&gt; ids = List.of(<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">4L</span>);</span><br><span class=\"line\">    QueryWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;User&gt;().in(<span class=\"string\">&quot;id&quot;</span>, ids);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class=\"line\">    userMapper.deductBalanceByIds(<span class=\"number\">200</span>, wrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在<code>UserMapper</code>中自定义SQL：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.itheima.mp.mapper;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class=\"line\">import com.itheima.mp.domain.po.User;</span><br><span class=\"line\">import org.apache.ibatis.annotations.Param;</span><br><span class=\"line\">import org.apache.ibatis.annotations.Update;</span><br><span class=\"line\">import org.apache.ibatis.annotations.Param;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface UserMapper extends BaseMapper<span class=\"operator\">&lt;</span><span class=\"keyword\">User</span><span class=\"operator\">&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Select</span>(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span><br><span class=\"line\">    void deductBalanceByIds(<span class=\"variable\">@Param</span>(&quot;money&quot;) <span class=\"type\">int</span> money, <span class=\"variable\">@Param</span>(&quot;ew&quot;) QueryWrapper<span class=\"operator\">&lt;</span><span class=\"keyword\">User</span><span class=\"operator\">&gt;</span> wrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-Service接口\"><a href=\"#5-Service接口\" class=\"headerlink\" title=\"5 Service接口\"></a>5 Service接口</h2><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。<br>通用接口为<code>IService</code>，默认实现为<code>ServiceImpl</code>，其中封装的方法可以分为以下几类：</p>\n<ul>\n<li>save：新增</li>\n<li>remove：删除</li>\n<li>update：更新</li>\n<li>get：查询单个结果</li>\n<li>list：查询集合结果</li>\n<li>count：计数</li>\n<li>page：分页查询</li>\n</ul>\n<h3 id=\"5-1-CRUD\"><a href=\"#5-1-CRUD\" class=\"headerlink\" title=\"5.1 CRUD\"></a>5.1 CRUD</h3><p>我们先俩看下基本的CRUD接口。<br><strong>新增：</strong><br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709164628.png\" alt=\"20250709164628\"></p>\n<ul>\n<li>save是新增单个元素</li>\n<li>saveBatch是批量新增</li>\n<li>saveOrUpdate是根据id判断，如果数据存在就更新，不存在则新增</li>\n<li>saveOrUpdateBatch是批量的新增或修改</li>\n</ul>\n<p><strong>删除:</strong><br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709164721.png\" alt=\"20250709164721\"></p>\n<ul>\n<li>removeById：根据id删除</li>\n<li>removeByIds：根据id批量删除</li>\n<li>removeByMap：根据Map中的键值对为条件删除</li>\n<li>remove(Wrapper<T>)：根据Wrapper条件删除</li>\n</ul>\n<p><strong>Get:</strong><br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709164749.png\" alt=\"20250709164749\"></p>\n<p><strong>List:</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250709164804.png\" alt=\"20250709164804\"></p>\n"},{"title":"跨域支持笔记","path":"2025/07/09/基础笔记/跨域支持笔记/","excerpt":"","date":"2025-07-08T16:00:00.000Z","tags":["基础","跨域支持"],"content":"<h2 id=\"JAVA后端解决跨域问题的几种方法\"><a href=\"#JAVA后端解决跨域问题的几种方法\" class=\"headerlink\" title=\"JAVA后端解决跨域问题的几种方法\"></a>JAVA后端解决跨域问题的几种方法</h2><p>前后端分离大势所趋，跨域问题更是老生常谈，随便用标题去google或百度一下，能搜出一大片解决方案，那么为啥又要写一遍呢，不急往下看。</p>\n<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p><code>Same Origin Policy</code>，译为“同源策略”<code>SOP</code>。它是对于客户端脚本（尤其是<code>JavaScript</code>）的重要安全度量标准，其目的在于防止某个文档或者脚本从多个不同“origin”（源）装载。它认为自任何站点装载的信赖内容是不安全的。</p>\n<p>当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。</p>\n<p>注：具有相同的Origin，也即是拥有<strong>相同的协议</strong>、<strong>主机地址</strong>以及<strong>端口</strong>。一旦这三项数据中有一项不同，那么该资源就将被认为是从不同的Origin得来的，进而不被允许访问。</p>\n<p><code>CORS</code>就是为了解决SOP问题而生的，当然<code>CORS</code>不是唯一的解决方案，不过这里不赘述其他解决办法了。</p>\n<h2 id=\"CORS简介\"><a href=\"#CORS简介\" class=\"headerlink\" title=\"CORS简介\"></a>CORS简介</h2><p><code>CORS</code>是一个<code>W3C</code>标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能同源使用的限制。CORS需要<strong>浏览器和服务器同时支持</strong>。它的通信过程，都是浏览器自动完成，不需要用户参与。</p>\n<p>对于开发者来说，CORS通信与同源的AJAX&#x2F;Fetch通信没有差别，代码完全一样。浏览器一旦发现请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>\n<p><strong>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</strong></p>\n<ul>\n<li><p>浏览器发出CORS简单请求，只需要在头信息之中增加一个<code>Origin</code>字段。</p>\n</li>\n<li><p>浏览器发出CORS非简单请求，会在正式通信之前，增加一次OPTIONS查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>\n</li>\n</ul>\n<p>简单请求就是<code>HEAD</code>、<code>GET</code>、<code>POST</code>请求，并且HTTP的头信息不超出以下几种字段 <code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Last-Event-ID</code>、<code>Content-Type</code><br>注：<code>Content-Type</code>：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code><br>反之，就是非简单请求。</p>\n<p>其实实现CORS很简单，就是在服务端加一些响应头，并且这样做对前端来说是无感知的，很方便。</p>\n<p>反之，就是非简单请求。</p>\n<p>其实实现CORS很简单，就是在服务端加一些响应头，并且这样做对前端来说是无感知的，很方便。</p>\n<h3 id=\"详解响应头\"><a href=\"#详解响应头\" class=\"headerlink\" title=\"详解响应头\"></a>详解响应头</h3><ul>\n<li><code>Access-Control-Allow-Origin</code> 该字段<strong>必填</strong>。它的值要么是请求时Origin字段的具体值，要么是一个*，表示接受任意域名的请求。</li>\n<li><code>Access-Control-Allow-Methods</code> 该字段<strong>必填</strong>。它的值是逗号分隔的一个具体的字符串或者*，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</li>\n<li><code>Access-Control-Expose-Headers</code> 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</li>\n<li><code>Access-Control-Allow-Credentials</code> 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie.默认情况下，不发生Cookie，即：false。对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application&#x2F;json，这个值只能设为true。如果服务器不要浏览器发送Cookie，删除该字段即可。</li>\n<li><code>Access-Control-Max-Age</code> 该字段可选，用来指定本次预检请求的有效期，单位为秒。在有效期间，不用发出另一条预检请求。</li>\n</ul>\n<p>顺便提一下，如果在开发中，发现每次发起请求都是两条，一次OPTIONS，一次正常请求，注意是每次，那么就需要配置Access-Control-Max-Age，避免每次都发出预检请求。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><h4 id=\"第一种办法\"><a href=\"#第一种办法\" class=\"headerlink\" title=\"第一种办法\"></a>第一种办法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CorsConfig</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">WebMvcConfigurer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addCorsMappings</span><span class=\"params\">(CorsRegistry registry)</span> &#123;</span><br><span class=\"line\">        registry.addMapping(<span class=\"string\">&quot;/**&quot;</span>)</span><br><span class=\"line\">                .allowedOrigins(<span class=\"string\">&quot;*&quot;</span>)</span><br><span class=\"line\">                .allowedMethods(<span class=\"string\">&quot;GET&quot;</span>, <span class=\"string\">&quot;HEAD&quot;</span>, <span class=\"string\">&quot;POST&quot;</span>, <span class=\"string\">&quot;PUT&quot;</span>, <span class=\"string\">&quot;DELETE&quot;</span>, <span class=\"string\">&quot;OPTIONS&quot;</span>)</span><br><span class=\"line\">                .allowCredentials(<span class=\"literal\">true</span>)</span><br><span class=\"line\">                .maxAge(<span class=\"number\">3600</span>)</span><br><span class=\"line\">                .allowedHeaders(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式是全局配置的，网上也大都是这种解决办法，但是很多都是基于旧的spring版本，比如 <code>WebMvcConfigurerAdapter</code> 在spring5.0已经被标记为Deprecated，点开源码可以看到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * An implementation of &#123;<span class=\"doctag\">@link</span> WebMvcConfigurer&#125; with empty methods allowing</span></span><br><span class=\"line\"><span class=\"comment\"> * subclasses to override only the methods they&#x27;re interested in.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Rossen Stoyanchev</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 3.1</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@deprecated</span> as of 5.0 &#123;<span class=\"doctag\">@link</span> WebMvcConfigurer&#125; has default methods (made</span></span><br><span class=\"line\"><span class=\"comment\"> * possible by a Java 8 baseline) and can be implemented directly without the</span></span><br><span class=\"line\"><span class=\"comment\"> * need for this adapter</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Deprecated</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebMvcConfigurerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">WebMvcConfigurer</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>像这种过时的类或者方法，spring的作者们一定会在注解上面说明原因，并告诉你新的该用哪个，这是非常优秀的编码习惯，点赞！</p>\n<p>spring5最低支持到jdk1.8，所以注释中明确表明，你可以直接实现WebMvcConfigurer接口，无需再用这个适配器，因为jdk1.8支持接口中存在default-method。</p>\n<p>Spring Boot 基础就不介绍了，看下这个教程太全了：</p>\n<p><a href=\"https://github.com/javastacks/spring-boot-best-practice\">https://github.com/javastacks/spring-boot-best-practice</a></p>\n<h4 id=\"第二种办法\"><a href=\"#第二种办法\" class=\"headerlink\" title=\"第二种办法\"></a>第二种办法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.annotation.WebFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"meta\">@WebFilter(filterName = &quot;CorsFilter &quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CorsFilter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Filter</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFilter</span><span class=\"params\">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class=\"keyword\">throws</span> IOException, ServletException &#123;</span><br><span class=\"line\">        <span class=\"type\">HttpServletResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> (HttpServletResponse) res;</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>,<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Methods&quot;</span>, <span class=\"string\">&quot;POST, GET, PATCH, DELETE, PUT&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Max-Age&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Headers&quot;</span>, <span class=\"string\">&quot;Origin, X-Requested-With, Content-Type, Accept&quot;</span>);</span><br><span class=\"line\">        chain.doFilter(req, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种办法，是基于<code>过滤器</code>的方式，方式简单明了，就是在response中写入这些响应头，好多文章都是第一种和第二种方式都叫你配置，其实这是没有必要的，只需要一种即可。</p>\n<p>这里也吐槽一下，大家不求甚解的精神。</p>\n<h4 id=\"第三种办法\"><a href=\"#第三种办法\" class=\"headerlink\" title=\"第三种办法\"></a>第三种办法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GoodsController</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">@CrossOrigin(origins = &quot;http://localhost:4000&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;goods-url&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Response <span class=\"title function_\">queryGoodsWithGoodsUrl</span><span class=\"params\">(<span class=\"meta\">@RequestParam</span> String goodsUrl)</span> <span class=\"keyword\">throws</span> Exception &#123;&#125;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>没错就是<code>@CrossOrigin</code>注解，点开注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CrossOrigin &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从元注解<code>@Target</code>可以看出，注解可以放在method、class等上面，类似RequestMapping，也就是说，整个controller下面的方法可以都受控制，也可以单个方法受控制。</p>\n<p>也可以得知，这个是<code>最小粒度的cors控制办法</code>了，精确到单个请求级别。</p>\n<p>以上三种方法都可以解决问题，最常用的应该是第一种、第二种，控制在自家几个域名范围下足以，一般没必要搞得太细。</p>\n<p>这三种配置方式都用了的话，谁生效呢，类似css中样式，<code>就近原则</code>，懂了吧。</p>\n"},{"title":"2025.7.9学习日记","path":"2025/07/09/学习日记25年7月/2025.7.9学习笔记/","excerpt":"","date":"2025-07-08T16:00:00.000Z","tags":["日记","leetcode","项目"],"content":"<h2 id=\"今日学习内容\"><a href=\"#今日学习内容\" class=\"headerlink\" title=\"今日学习内容\"></a>今日学习内容</h2><h3 id=\"3DGS\"><a href=\"#3DGS\" class=\"headerlink\" title=\"3DGS\"></a>3DGS</h3><h3 id=\"力扣每日一题\"><a href=\"#力扣每日一题\" class=\"headerlink\" title=\"力扣每日一题:\"></a>力扣每日一题:</h3><p>今天的每日是一个最大移动k次会议,使得最大连续空闲时间最长.抽象成功,和灵神的题解做的一样.<br>转换成了对n+1个空闲时间区间滑窗求定长滑窗的最大和.</p>\n<h3 id=\"代码随想录\"><a href=\"#代码随想录\" class=\"headerlink\" title=\"代码随想录\"></a>代码随想录</h3><h3 id=\"项目相关\"><a href=\"#项目相关\" class=\"headerlink\" title=\"项目相关\"></a>项目相关</h3><p>实现注册接口</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><h3 id=\"晚上健身\"><a href=\"#晚上健身\" class=\"headerlink\" title=\"晚上健身\"></a>晚上健身</h3><p>练的胸 三头 核心 ,强度适中.</p>\n"}]}