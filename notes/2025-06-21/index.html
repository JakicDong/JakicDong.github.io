{"layout":"notes","date":"2025-06-21T00:00:00.000Z","posts":[{"title":"2025.6.21学习日记","path":"2025/06/21/学习日记25年6月/2025.6.21学习笔记/","excerpt":"","date":"2025-06-20T16:00:00.000Z","tags":["日记","leetcode","mysql","spring","二叉树"],"content":"<h2 id=\"今日学习内容\"><a href=\"#今日学习内容\" class=\"headerlink\" title=\"今日学习内容\"></a>今日学习内容</h2><h3 id=\"力扣每日一题\"><a href=\"#力扣每日一题\" class=\"headerlink\" title=\"力扣每日一题:\"></a>力扣每日一题:</h3><p>今天的每日是一个哈希计数＋排序＋贪心的中等题,比较简单.</p>\n<h3 id=\"Mysql学习\"><a href=\"#Mysql学习\" class=\"headerlink\" title=\"Mysql学习\"></a>Mysql学习</h3><p>37-&gt;41</p>\n<h3 id=\"B树学习\"><a href=\"#B树学习\" class=\"headerlink\" title=\"B树学习\"></a>B树学习</h3><p>记了一篇笔记.</p>\n<h3 id=\"晚上学代码随想录\"><a href=\"#晚上学代码随想录\" class=\"headerlink\" title=\"晚上学代码随想录\"></a>晚上学代码随想录</h3><h2 id=\"生活记录\"><a href=\"#生活记录\" class=\"headerlink\" title=\"生活记录\"></a>生活记录</h2><h3 id=\"晚上健身\"><a href=\"#晚上健身\" class=\"headerlink\" title=\"晚上健身\"></a>晚上健身</h3><p>练背和二头</p>\n"},{"title":"一次性搞懂B树","path":"2025/06/21/算法笔记/一次性搞懂B树/","excerpt":"","date":"2025-06-20T16:00:00.000Z","tags":["基础","算法","B树"],"content":"<h1 id=\"可视化网站\"><a href=\"#可视化网站\" class=\"headerlink\" title=\"可视化网站\"></a>可视化网站</h1><p><a href=\"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\">算法可视化网站</a></p>\n<h1 id=\"B-Tree的引入\"><a href=\"#B-Tree的引入\" class=\"headerlink\" title=\"B-Tree的引入\"></a>B-Tree的引入</h1><h2 id=\"从磁盘查找数据效率低的原因\"><a href=\"#从磁盘查找数据效率低的原因\" class=\"headerlink\" title=\"从磁盘查找数据效率低的原因\"></a>从磁盘查找数据效率低的原因</h2><ul>\n<li><p>读写数据越大速度越慢</p>\n</li>\n<li><p>读写次数越多速度越慢</p>\n</li>\n</ul>\n<h2 id=\"设计文件查找系统\"><a href=\"#设计文件查找系统\" class=\"headerlink\" title=\"设计文件查找系统\"></a>设计文件查找系统</h2><p>索引可以提供更快的查询.</p>\n<h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p>优点:等值查询比较快<br>缺点:</p>\n<ol>\n<li>hash冲突后,数据散列不均匀,产生大量线性查询,效率低</li>\n<li>等值查询可以,但是遇到范围查询,需要遍历,hash不合适</li>\n</ol>\n<h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><h4 id=\"树的种类\"><a href=\"#树的种类\" class=\"headerlink\" title=\"树的种类\"></a>树的种类</h4><p>树 二叉树 BST二叉查找树 AVL平衡二叉树 红黑树 B树 B+树</p>\n<h4 id=\"二叉排序树-BST\"><a href=\"#二叉排序树-BST\" class=\"headerlink\" title=\"二叉排序树 BST\"></a>二叉排序树 BST</h4><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621110904.png\" alt=\"20250621110904\"><br>插入数据的时候得有序,必须保证:</p>\n<ol>\n<li>若左子树不为空,则左子树的所有节点的值小于根节点的值</li>\n<li>若右子树不为空,则右子树的所有节点的值大于根节点的值</li>\n</ol>\n<p>问题:<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621111023.png\" alt=\"20250621111023\"><br>会退化为链表,查询效率降低为O(n).</p>\n<h4 id=\"平衡二叉树-AVL\"><a href=\"#平衡二叉树-AVL\" class=\"headerlink\" title=\"平衡二叉树 AVL\"></a>平衡二叉树 AVL</h4><p>插入数据的时候保持二叉排序树平衡<br>左子树和右子树的高度差不能超过1.<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621111524.png\" alt=\"20250621111524\"> </p>\n<p>问题:用插入的成本来弥补查询的成本,插入效率降低为O(logn),但是查询效率还是O(logn).一旦出现插入操作比查询操作多的情况就不合适了.</p>\n<h4 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h4><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621111731.png\" alt=\"20250621111731\"><br>最长子树不超过最短子树的2倍.</p>\n<ul>\n<li>性质1 :根节点是黑色的.</li>\n<li>性质2 :每个红色的节点的两个子节点都是黑色.(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>\n<li>性质3 :从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点.</li>\n</ul>\n<p>相当于不让AVL做大量的旋转操作.<br>红黑树口诀:左根右 , 根叶黑 . 不红红 , 黑路同.</p>\n<p>问题: 当数据特别多的时候,树的深度会很大,就意味着IO的次数会变多,影响读取的效率.</p>\n<h4 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h4><p>B树就是一个有序的多路查询树.</p>\n<p>满足下列要求的m叉树:</p>\n<ol>\n<li>书中每个节点只多有m个孩子节点(至多有m-1个关键字)</li>\n<li>每个节节点的结构为:<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621142935.png\" alt=\"20250621142935\"><br><code>n</code>代表这个节点有几个关键字.<br><code>P0</code>第一个子树的地址.<br><code>k1</code>关键字</li>\n</ol>\n<p>例子:m&#x3D;4的4阶B树<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621143215.png\" alt=\"20250621143215\"><br>阶数代表单个节点最多有的子节点数量</p>\n"}]}