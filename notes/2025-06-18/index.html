{"layout":"notes","date":"2025-06-18T00:00:00.000Z","posts":[{"title":"2025.6.18学习日记","path":"2025/06/18/学习日记25年6月/2025.6.18学习笔记/","excerpt":"","date":"2025-06-17T16:00:00.000Z","tags":["3DGS","日记","leetcode","mysql","spring","二叉树"],"content":"<h2 id=\"今日学习内容\"><a href=\"#今日学习内容\" class=\"headerlink\" title=\"今日学习内容\"></a>今日学习内容</h2><h3 id=\"3DGS\"><a href=\"#3DGS\" class=\"headerlink\" title=\"3DGS\"></a>3DGS</h3><p>训练DashGaussian.<br>昨天DashGaussian训练过程会出现报错,排查后发现是子模块版本问题导致,重新安装子模块后消除报错.<br>并且在昨天的训练过程中,在对于复杂的场景会出现爆显存的问题:<br>通过修改scene&#x2F;cameras.py中图片预先加载到显存的逻辑,把图片加载到内存,解决了爆显存的问题,<br>虽然会因IO时间增加,训练变慢,但是可以接受.</p>\n<h3 id=\"力扣每日一题\"><a href=\"#力扣每日一题\" class=\"headerlink\" title=\"力扣每日一题:\"></a>力扣每日一题:</h3><p>排序加贪心的中等题.</p>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>通过中序和后序构造二叉树.<br>通过对中序做一个索引,找到左右树的分割位置,然后递归.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    Map&lt;Integer,Integer&gt; in_idx = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">buildTree</span><span class=\"params\">(<span class=\"type\">int</span>[] inorder, <span class=\"type\">int</span>[] postorder)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span> ; i&lt;inorder.length ; ++i)&#123;</span><br><span class=\"line\">            in_idx.put(inorder[i],i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> inorder.length;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(inorder,postorder,<span class=\"number\">0</span>,n-<span class=\"number\">1</span>,<span class=\"number\">0</span>,n-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeNode <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span>[] inorder,<span class=\"type\">int</span>[] postorder , <span class=\"type\">int</span> beg_in , <span class=\"type\">int</span> end_in,<span class=\"type\">int</span> beg_pos , <span class=\"type\">int</span> end_pos)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//全部闭区间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(beg_in &gt; end_in ||beg_pos &gt; end_pos )<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rootIndex</span> <span class=\"operator\">=</span> in_idx.get(postorder[end_pos]);</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(inorder[rootIndex]);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lenOfLeft</span> <span class=\"operator\">=</span> rootIndex - beg_in;<span class=\"comment\">//左子树个数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> n=inorder.length;</span><br><span class=\"line\">        root.left = dfs(inorder,postorder,beg_in,beg_in+lenOfLeft-<span class=\"number\">1</span>,beg_pos,beg_pos+lenOfLeft-<span class=\"number\">1</span>);</span><br><span class=\"line\">        root.right = dfs(inorder,postorder,rootIndex+<span class=\"number\">1</span>,end_in,beg_pos+lenOfLeft,end_pos-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过前序和后序构造二叉树.<br>对应二叉树不唯一,找前序根节点的下一个位置在后序中的位置,然后找左右子树,剩下做法差不多了.</p>\n<h3 id=\"Mysql学习\"><a href=\"#Mysql学习\" class=\"headerlink\" title=\"Mysql学习\"></a>Mysql学习</h3><h3 id=\"Spring学习\"><a href=\"#Spring学习\" class=\"headerlink\" title=\"Spring学习\"></a>Spring学习</h3><h3 id=\"晚上学代码随想录\"><a href=\"#晚上学代码随想录\" class=\"headerlink\" title=\"晚上学代码随想录\"></a>晚上学代码随想录</h3><h2 id=\"生活记录\"><a href=\"#生活记录\" class=\"headerlink\" title=\"生活记录\"></a>生活记录</h2><h3 id=\"晚上健身\"><a href=\"#晚上健身\" class=\"headerlink\" title=\"晚上健身\"></a>晚上健身</h3><p>今天练的后侧链 背 手臂</p>\n"}]}