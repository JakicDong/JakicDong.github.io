{"layout":"notes","date":"2025-06-10T00:00:00.000Z","posts":[{"title":"2025.6.10学习日记","path":"2025/06/10/学习日记25年6月/2025.6.10学习笔记/","excerpt":"","date":"2025-06-09T16:00:00.000Z","tags":["日记","leetcode","基础","项目"],"content":"<h2 id=\"学习内容\"><a href=\"#学习内容\" class=\"headerlink\" title=\"学习内容\"></a>学习内容</h2><p>最近学习重心想转到算法相关,把随想录和题单刷一遍之后做力扣周赛,太长时间没做需要复健一下.</p>\n<h3 id=\"1-打卡力扣每日\"><a href=\"#1-打卡力扣每日\" class=\"headerlink\" title=\"1. 打卡力扣每日\"></a>1. 打卡力扣每日</h3><p>简单的字符串计数找最大最小.</p>\n<h3 id=\"2-看Mysql基础\"><a href=\"#2-看Mysql基础\" class=\"headerlink\" title=\"2. 看Mysql基础\"></a>2. 看Mysql基础</h3><p>笔记同步在了Mysql学习笔记中.</p>\n<h3 id=\"3-代码随想录\"><a href=\"#3-代码随想录\" class=\"headerlink\" title=\"3. 代码随想录\"></a>3. 代码随想录</h3><p>二叉树的三种遍历和迭代遍历.<br>今天踩了一个小坑:在实现迭代调用的统一写法时,需要在Deque中插入一个null元素作为是否遍历过的标志,但是实现Deque时用的<code>ArrayDeque</code>,这个实现方式不能插入null元素,需要使用<code>LinkedList</code>实现才可以.<br>感觉这几个集合框架还是有必要学的深入一些的,不管是算法还是写项目都有很大帮助.</p>\n<h3 id=\"明天开始跑项目ply\"><a href=\"#明天开始跑项目ply\" class=\"headerlink\" title=\"明天开始跑项目ply\"></a>明天开始跑项目ply</h3><h2 id=\"生活记录\"><a href=\"#生活记录\" class=\"headerlink\" title=\"生活记录\"></a>生活记录</h2><h3 id=\"1-健身\"><a href=\"#1-健身\" class=\"headerlink\" title=\"1. 健身\"></a>1. 健身</h3><p>今天健身房练上肢 肩 胸 核心</p>\n"},{"title":"Java集合框架笔记","path":"2025/06/10/基础笔记/Java集合框架笔记/","excerpt":"","date":"2025-06-09T16:00:00.000Z","tags":["基础","Java","集合"],"content":"<h2 id=\"框架图\"><a href=\"#框架图\" class=\"headerlink\" title=\"框架图\"></a>框架图</h2><p>先贴一个Java集合框架图<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250610094039.png\" alt=\"20250610094039\"></p>\n<p>可以看出,集合主要分成两大部分:</p>\n<ul>\n<li>Collection:<br>主要由 List、Set、Queue 组成，List 代表有序、可复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；Set 代表⽆序、不可复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列ArrayDeque，以及优先级队列 PriorityQueue。</li>\n<li>Map:<br>代表键值对的集合，典型代表就是 HashMap。</li>\n</ul>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p>List 的特点是存取有序，可以存放复的元素，可以⽤下标对元素进⾏操作。</p>\n<h4 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h4><p>ArrayList的增删改查:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建⼀个集合</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">list.add(<span class=\"string\">&quot;王⼆&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;沉默&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;陈清扬&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 遍历集合 for 循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> list.get(i);</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 遍历集合 for each</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String s : list) &#123;</span><br><span class=\"line\">    stem.out.println(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 删除元素</span></span><br><span class=\"line\">list.remove(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 遍历集合</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String s : list) &#123;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 修改元素</span></span><br><span class=\"line\">list.set(<span class=\"number\">1</span>,<span class=\"string\">&quot;王⼆狗&quot;</span>);<span class=\"comment\">// 遍历集合</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String s : list) &#123;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Mysql学习笔记","path":"2025/06/10/基础笔记/Mysql学习笔记/","excerpt":"","date":"2025-06-09T16:00:00.000Z","tags":["基础","Mysql"],"content":"<h2 id=\"Mysql基础\"><a href=\"#Mysql基础\" class=\"headerlink\" title=\"Mysql基础\"></a>Mysql基础</h2><h3 id=\"🌟0-什么是MYSQL\"><a href=\"#🌟0-什么是MYSQL\" class=\"headerlink\" title=\"🌟0.什么是MYSQL\"></a>🌟0.什么是MYSQL</h3><p>MySQL 是⼀个开源的关系型数据库，现在⾪属于 Oracle 公司。</p>\n<h4 id=\"删除-创建一张表\"><a href=\"#删除-创建一张表\" class=\"headerlink\" title=\"删除&#x2F;创建一张表\"></a>删除&#x2F;创建一张表</h4><p><code>DROP TABLE</code> 删除表<br><code>CREATE TABLE</code> 创建表<br>创建表的时候，可以通过 <code>PRIMARY KEY</code> 设定主键。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> users (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> AUTO_INCREMENT,</span><br><span class=\"line\">    name <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT NULL</span>,</span><br><span class=\"line\">    email <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>),</span><br><span class=\"line\">    <span class=\"keyword\">PRIMARY KEY</span> (id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"写一个升序-降序的SQL语句\"><a href=\"#写一个升序-降序的SQL语句\" class=\"headerlink\" title=\"写一个升序&#x2F;降序的SQL语句\"></a>写一个升序&#x2F;降序的SQL语句</h4><p>可以使用<code>ORDER BY</code>字句对查询结果进行排序.<br>默认情况下是升序排序.如需要降序,使用关键字<code>DESC</code><br>例子:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> id, name, salary</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如若对多个字段进行排序:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> id, name, salary</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>, name <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n<p>优先级从左到右,相当于先按工资降序,工资相同再按照姓名升序.</p>\n<h4 id=\"MYSQL出现性能差的原因\"><a href=\"#MYSQL出现性能差的原因\" class=\"headerlink\" title=\"MYSQL出现性能差的原因\"></a>MYSQL出现性能差的原因</h4><p>可能是 SQL 查询使⽤了<strong>全表扫描</strong>，也可能是<strong>查询语句过于复杂</strong>，如多表<code>JOIN</code>或嵌套⼦查询。<br>也有可能是单表数据量过⼤。</p>\n<p>通常情况下,增加索引就可以解决大部分的性能问题.对于热点数据,增加redis缓存,减轻对数据库的压力.</p>\n<h3 id=\"1-两张表怎么进行连接\"><a href=\"#1-两张表怎么进行连接\" class=\"headerlink\" title=\"1.两张表怎么进行连接\"></a>1.两张表怎么进行连接</h3><p>可以通过内连接<code>inner join</code>、外连接 <code>outer join</code> 、交叉连接 <code>cross join</code> 等方式来进行连接.</p>\n<h4 id=\"什么是内连接\"><a href=\"#什么是内连接\" class=\"headerlink\" title=\"什么是内连接\"></a>什么是内连接</h4><p>内连接⽤于返回两个表中有匹配关系的⾏。假设有两张表，⽤户表和订单表，想查询有订单的⽤户，就可以使⽤内连接 <code>users INNER JOIN orders</code>，按照⽤户 ID 关联就⾏了。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> users.name, orders.order_id</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> orders <span class=\"keyword\">ON</span> users.id <span class=\"operator\">=</span> orders.user_id;</span><br></pre></td></tr></table></figure>\n<p>两表匹配的行才会输出.</p>\n<h4 id=\"什么是外连接\"><a href=\"#什么是外连接\" class=\"headerlink\" title=\"什么是外连接\"></a>什么是外连接</h4><p>和内连接不同，外连接不仅返回两个表中匹配的⾏，<strong>还返回没有匹配的⾏</strong>，⽤ <code>null</code> 来填充。<br>外连接⼜分为左外连接 <code>left join</code> 和右外连接 <code>right join</code>。</p>\n<p><code>left join</code> 会保留左表中符合条件的所有记录，如果右表中有匹配的记录，就返回匹配的记录，否则就⽤<code>null</code> 填充，常⽤于某表中有，但另外⼀张表中可能没有的数据的查询场景。假设要查询所有⽤户及他们的订单，即使⽤户没有下单，就可以使⽤左连接：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> users.id, users.name, orders.order_id</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> orders <span class=\"keyword\">ON</span> users.id <span class=\"operator\">=</span> orders.user_id;</span><br></pre></td></tr></table></figure>\n<p>(这里面左表就是users,users所有行都会输出)<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250610102903.png\" alt=\"20250610102903\"></p>\n<p>右连接就是左连接的镜像，<code>right join</code> 会保留右表中符合条件的所有记录，如果左表中有匹配的记录，就返回匹配的记录，否则就⽤ null 填充。</p>\n<h4 id=\"什么是交叉连接\"><a href=\"#什么是交叉连接\" class=\"headerlink\" title=\"什么是交叉连接\"></a>什么是交叉连接</h4><p>交叉连接会返回两张表的笛卡尔积，也就是将左表的每⼀⾏与右表的每⼀⾏进⾏组合，返回的⾏数是两张表⾏数的乘积。<br>假设有 A 表和 B 表，A 表有 2 ⾏数据，B 表有 3 ⾏数据，那么交叉连接的结果就是 2 * 3 &#x3D; 6 ⾏。<br>笛卡尔积是数学中的⼀个概念，例如集合 A&#x3D;{a,b}，集合 B&#x3D;{0,1,2} ，那么 A x B&#x3D; {&lt;a,0&gt;,&lt;a,1&gt;,&lt;a,2&gt;,&lt;b,0&gt;,&lt;b,1&gt;,&lt;b,2&gt;,}。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> A.id, B.id</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> A</span><br><span class=\"line\"><span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> B;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-内连接-左连接-右连接有什么区别\"><a href=\"#2-内连接-左连接-右连接有什么区别\" class=\"headerlink\" title=\"2.内连接 左连接 右连接有什么区别\"></a>2.内连接 左连接 右连接有什么区别</h3><p>左连接 FROM 表a join 表b 相当于 a在左 b在右<br>MySQL 的连接主要分为<strong>内连接</strong>和<strong>外连接</strong>，<strong>外连接</strong>⼜可以分为<strong>左连接</strong>和<strong>右连接</strong>。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250610103406.png\" alt=\"20250610103406\"></p>\n<p><strong>内连接</strong>相当于找两表的<strong>交集</strong>.<br>左连接和右连接可以⽤来找出两个表中不同的记录，相当于两个数据集的<strong>并集</strong>。两者的区别是，左连接会保留左表中符合条件的所有记录，右连接则刚好相反。</p>\n<p>例子:<br>有三张表，⼀张⽂章表 <code>article</code>，主要存⽂章标题 title.<br>⼀张⽂章详情表 <code>article_detail</code>，主要存⽂章的内容 content.<br>⼀张⽂章评论表<code> comment</code>，主要存评论 content.<br>三个表通过⽂章 id关联。<br>内连接:<br>返回至少有评论的文章标题和评论内容</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">LEFT</span>(a.title, <span class=\"number\">20</span>) <span class=\"keyword\">AS</span> ArticleTitle, <span class=\"keyword\">LEFT</span>(c.content, <span class=\"number\">20</span>) <span class=\"keyword\">AS</span> CommentContent </span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>返回<span class=\"keyword\">LEFT</span>左数前<span class=\"number\">20</span>字符 <span class=\"keyword\">AS</span>为列或表起临时别名</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> article a  <span class=\"operator\">/</span><span class=\"operator\">/</span>article起别名 a</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> comment c <span class=\"keyword\">ON</span> a.id <span class=\"operator\">=</span> c.article_id <span class=\"operator\">/</span><span class=\"operator\">/</span>内连接 id相同 起别名c</span><br><span class=\"line\">LIMIT <span class=\"number\">2</span>; <span class=\"operator\">/</span><span class=\"operator\">/</span>只返回两条</span><br></pre></td></tr></table></figure>\n<p>左连接:<br>返回所有⽂章的标题和⽂章评论，即使某些⽂章没有评论（填充为 NULL）。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">LEFT</span>(a.title, <span class=\"number\">20</span>) <span class=\"keyword\">AS</span> ArticleTitle, <span class=\"keyword\">LEFT</span>(c.content, <span class=\"number\">20</span>) <span class=\"keyword\">AS</span></span><br><span class=\"line\">CommentContent</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> article a</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> comment c <span class=\"keyword\">ON</span> a.id <span class=\"operator\">=</span> c.article_id</span><br><span class=\"line\">LIMIT <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>右连接:<br>调换了位置</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">LEFT</span>(a.title, <span class=\"number\">20</span>) <span class=\"keyword\">AS</span> ArticleTitle, <span class=\"keyword\">LEFT</span>(c.content, <span class=\"number\">20</span>) <span class=\"keyword\">AS</span></span><br><span class=\"line\">CommentContent</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> comment c</span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> article a <span class=\"keyword\">ON</span> a.id <span class=\"operator\">=</span> c.article_id</span><br><span class=\"line\">LIMIT <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-数据库的三大范式\"><a href=\"#3-数据库的三大范式\" class=\"headerlink\" title=\"3.数据库的三大范式\"></a>3.数据库的三大范式</h3><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250610104927.png\" alt=\"20250610104927\"></p>\n<p><strong>- 第⼀范式:</strong><br>确保表的每⼀列都是<strong>不可分割的基本数据单元</strong>.<br>⽐如说⽤户地址，应该拆分成省、市、区、详细地址等 4 个字段。<br>相当于保持列的原子性.</p>\n<p><strong>- 第⼆范式:</strong><br>要求表中的<strong>每⼀列</strong>都和<strong>主键直接相关</strong>。<br>⽐如在订单表中，商品名称、单位、商品价格等字段应该拆分到商品表中。然后再创建一个订单商品关联表.不能出现部分依赖的情况.<br><strong>相当于让解决复合主键的部分依赖问题.</strong><br>订单明细(订单ID, 产品ID, 产品名称, 数量)<br>↑ 复合主键是(订单ID, 产品ID)，但”产品名称”只依赖”产品ID”（部分依赖）<br>修改为:<br>订单明细(订单ID, 产品ID, 数量)<br>产品(产品ID, 产品名称)  </p>\n<p><strong>- 第三范式:</strong><br><strong>⾮主键列</strong>应该只依赖于<strong>主键列</strong>。<br>⽐如说在设计订单信息表的时候，可以把客户名称、所属公司、联系⽅式等信息拆分到客户信息表中，然后在订单信息表中⽤客户编号进⾏关联。<br>**相当于消除传递依赖.**将​​传递依赖​​的字段（A→B→C，其中A是主键）拆分到新表中。<br>学生(学号, 姓名, 宿舍号, 宿舍费用)<br>↑ “宿舍费用”依赖”宿舍号”，而”宿舍号”依赖”学号”（传递依赖）<br>修改为:<br>学生(学号, 姓名, 宿舍号)<br>宿舍(宿舍号, 宿舍费用)  </p>\n<h4 id=\"建表时需要考虑哪些问题\"><a href=\"#建表时需要考虑哪些问题\" class=\"headerlink\" title=\"建表时需要考虑哪些问题\"></a>建表时需要考虑哪些问题</h4><p>⾸先需要考虑表是否符合数据库的三⼤范式，<strong>确保字段不可再分</strong>，<strong>消除⾮主键依赖</strong>，<strong>确保字段仅依赖于主键</strong>等。<br>然后在选择字段类型时，应该尽量<strong>选择合适的数据类型</strong>。<br>在字符集上，<strong>尽量选择 utf8mb4</strong>，这样不仅可以⽀持中⽂和英⽂，还可以⽀持表情符号等。<br>当数据量较⼤时，⽐如上千万⾏数据，需要<strong>考虑分表</strong>。⽐如订单表，可以采⽤⽔平分表的⽅式来分散单表存储压⼒。</p>\n<p><strong>水平分表(按行拆分):</strong><br>水平分表是将​​同一张表中的数据按行拆分到<strong>多个结构相同的表</strong>中</p>\n<ol>\n<li>按照id范围分表</li>\n<li>按照时间范围分表</li>\n<li>按照hash分表</li>\n<li>按照地域分表</li>\n</ol>\n<p><strong>垂直分表(按列拆分):</strong><br>不同分表包含<strong>不同字段</strong>,表字段过多或冷热数据分离时使用.</p>\n<h3 id=\"4-varchar-与-char-的区别\"><a href=\"#4-varchar-与-char-的区别\" class=\"headerlink\" title=\"4.varchar 与 char 的区别\"></a>4.varchar 与 char 的区别</h3><pre><code>latin1 字符集，且列属性定义为 NOT NULL。\n</code></pre>\n<p><code>varchar</code> 是可变⻓度的字符类型，原则上最多可以容纳 65535 个字符，但考虑字符集，以及MySQL 需要 1 到 2 个字节来表示字符串⻓度，所以实际上最⼤可以设置到 65533。<br><code>char</code> 是固定⻓度的字符类型，当定义⼀个 CHAR(10) 字段时，不管实际存储的字符⻓度是多少，都只会占⽤ 10 个字符的空间。如果插⼊的数据⼩于 10 个字符，剩余的部分会⽤空格填充。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250610112110.png\" alt=\"20250610112110\"><br>varchar在输入过长时也会截断.</p>\n<h3 id=\"5-blob-和-text-有什么区别\"><a href=\"#5-blob-和-text-有什么区别\" class=\"headerlink\" title=\"5.blob 和 text 有什么区别\"></a>5.blob 和 text 有什么区别</h3><p><code>blob</code> ⽤于存储⼆进制数据，⽐如图⽚、⾳频、视频、⽂件等；但实际开发中，我们都会把这些⽂件存储到 OSS 或者⽂件服务器上，然后在数据库中存储⽂件的 URL。</p>\n<p><code>text</code> ⽤于存储⽂本数据，⽐如⽂章、评论、⽇志等。</p>\n<h3 id=\"6-DATETIME-和-TIMESTAMP-有什么区别\"><a href=\"#6-DATETIME-和-TIMESTAMP-有什么区别\" class=\"headerlink\" title=\"6.DATETIME 和 TIMESTAMP 有什么区别\"></a>6.DATETIME 和 TIMESTAMP 有什么区别</h3><p><code>DATETIME</code> 直接存储⽇期和时间的完整值，与时区⽆关。<br><code>TIMESTAMP</code> 存储的是 Unix 时间戳，1970-01-01 00:00:01 UTC 以来的秒数，受时区影响。</p>\n<p>另外，<code>DATETIME</code> 的默认值为 <code>null</code>，占⽤ 8 个字节；<code>TIMESTAMP</code> 的默认值为当前时间——<code>CURRENT_TIMESTAMP</code>，占 4 个字节，实际开发中更常⽤，因为可以⾃动更新。</p>\n<h3 id=\"7-in-和-exists-的区别\"><a href=\"#7-in-和-exists-的区别\" class=\"headerlink\" title=\"7. in 和 exists 的区别\"></a>7. in 和 exists 的区别</h3><p>当使⽤ <code>IN</code> 时，MySQL 会⾸先执⾏⼦查询，然后将⼦查询的结果集⽤于外部查询的条件。这意味着⼦查询的结果集需要全部加载到内存中。</p>\n<p>⽽ <code>EXISTS</code> 会对外部查询的每⼀⾏，执⾏⼀次⼦查询。如果⼦查询返回任何⾏，则<code>EXISTS</code>条件为真。<code>EXISTS</code> 关注的是⼦查询是否返回⾏，⽽不是返回的具体值。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- IN 的临时表可能成为性能瓶颈</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> user_id <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> amount <span class=\"operator\">&gt;</span> <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>查询所有下过&quot;单笔订单金额超过100&quot;的用户（完整信息）</span><br><span class=\"line\"><span class=\"comment\">-- EXISTS 可以利⽤关联索引</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users u</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">EXISTS</span> (<span class=\"keyword\">SELECT</span> <span class=\"number\">1</span> <span class=\"keyword\">FROM</span> orders o</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> o.user_id <span class=\"operator\">=</span> u.id <span class=\"keyword\">AND</span> o.amount <span class=\"operator\">&gt;</span> <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>IN</code> 适⽤于⼦查询结果集较⼩的情况。如果⼦查询返回⼤量数据,<code>IN</code>的查询效率会下降,因为他会<strong>把整个结果存到内存当中</strong>.</p>\n<p>⽽ <code>EXISTS</code> 适⽤于⼦查询结果集可能很⼤的情况。由于 <code>EXISTS</code> <strong>只需要判断⼦查询是否返回⾏</strong>，⽽<strong>不需要加载整个结果集</strong>，因此在某些情况下性能更好，特别是当⼦查询可以使⽤索引时。</p>\n<h4 id=\"NULL值\"><a href=\"#NULL值\" class=\"headerlink\" title=\"NULL值\"></a>NULL值</h4><p>IN的返回结果中如果有NULL值,可能会出现意料外的情况:<br>比如WHERE column IN ((subquery))，如果subquery为NULL,这个条件永远不会为真,除非column也为NULL.</p>\n<p><code>EXISTS</code>如果有NULL值的话,因为<code>EXISTS</code>只关心是否有⾏,所以不会出现NULL值的影响.</p>\n<h3 id=\"8-记录货币⽤什么类型⽐较好\"><a href=\"#8-记录货币⽤什么类型⽐较好\" class=\"headerlink\" title=\"8.记录货币⽤什么类型⽐较好?\"></a>8.记录货币⽤什么类型⽐较好?</h3><p>如果是电商、交易、账单等<strong>涉及货币</strong>的场景，建议使⽤ <code>DECIMAL</code> 类型，因为 <code>DECIMAL</code> 类型是精确数值类型，不会出现浮点数计算误差。</p>\n<p>如果是银⾏,涉及到<strong>⽀付</strong>的场景，建议使⽤ <code>BIGINT</code> 类型。可以将货币⾦额乘以⼀个固定因⼦，⽐如 100，表示以“分”为单位，然后存储为 <code>BIGINT</code> 。这种⽅式既避免了浮点数问题，同时也提供了不错的性能。但在展示的时候需要除以相应的因⼦。</p>\n<h4 id=\"为什么不推荐使⽤-FLOAT-或-DOUBLE？\"><a href=\"#为什么不推荐使⽤-FLOAT-或-DOUBLE？\" class=\"headerlink\" title=\"为什么不推荐使⽤ FLOAT 或 DOUBLE？\"></a>为什么不推荐使⽤ FLOAT 或 DOUBLE？</h4><p>因为 FLOAT 和 DOUBLE 都是浮点数类型，会存在精度问题。<br>在许多编程语⾔中， 0.1 + 0.2 的结果会是类似 0.30000000000000004 的值，⽽不是预期的 0.3 。</p>\n<h3 id=\"9-如何存储emoji\"><a href=\"#9-如何存储emoji\" class=\"headerlink\" title=\"9.如何存储emoji?\"></a>9.如何存储emoji?</h3><p>因为 emoji是 4 个字节的 UTF-8 字符，⽽ MySQL 的 utf8 字符集只⽀持最多 3 个字节的 UTF-8 字符，所以在 MySQL 中存储 emoji 时，需要使⽤ utf8mb4 字符集。</p>\n<p>MySQL 8.0 已经默认⽀持 utf8mb4 字符集，可以通过 <code>SHOW VARIABLES WHERE Variable_name LIKE &#39;character\\_set\\_%&#39; OR Variable_name LIKE &#39;collation%&#39;;</code> 查看。</p>\n<h3 id=\"10-drop、delete-与-truncate-的区别？\"><a href=\"#10-drop、delete-与-truncate-的区别？\" class=\"headerlink\" title=\"10.drop、delete 与 truncate 的区别？\"></a>10.drop、delete 与 truncate 的区别？</h3><ul>\n<li><code>DROP</code> 是物理删除，⽤来删除<strong>整张表</strong>，包括表结构，且不能回滚。</li>\n<li><code>DELETE</code> <strong>⽀持⾏级删除</strong>，可以带 WHERE 条件，<strong>可以回滚</strong>。</li>\n<li><code>TRUNCATE</code> ⽤于<strong>清空表中的所有数据</strong>，但会保留表结构，不能回滚。</li>\n</ul>\n<h3 id=\"11-UNION-与-UNION-ALL-的区别？\"><a href=\"#11-UNION-与-UNION-ALL-的区别？\" class=\"headerlink\" title=\"11.UNION 与 UNION ALL 的区别？\"></a>11.UNION 与 UNION ALL 的区别？</h3><p><code>UNION</code> 会⾃动去除合并后结果集中的重复⾏。<code>UNION ALL</code> 不会去重，会将所有结果集合并起来。</p>\n<h3 id=\"12-count-1-、count-与-count-列名-的区别？\"><a href=\"#12-count-1-、count-与-count-列名-的区别？\" class=\"headerlink\" title=\"12.count(1)、count(*) 与 count(列名) 的区别？\"></a>12.count(1)、count(*) 与 count(列名) 的区别？</h3><p>在InnoDB引擎里面,<code>count(1)</code>和<code>count(*)</code>没有任何区别,都用来统计所有行,包括NULL.<br>如果有索引,那么<code>count(1)</code>和<code>count(*)</code>都会走索引,而<code>count(列名)</code>会走主键索引.</p>\n<p>COUNT(列名) 只统计列名不为 NULL 的⾏数。</p>\n<h3 id=\"13-SQL-查询语句的执⾏顺序了解吗？\"><a href=\"#13-SQL-查询语句的执⾏顺序了解吗？\" class=\"headerlink\" title=\"13.SQL 查询语句的执⾏顺序了解吗？\"></a>13.SQL 查询语句的执⾏顺序了解吗？</h3><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250610145235.png\" alt=\"20250610145235\"><br>了解,先执行<code>FROM</code>确定主表,，再执⾏<code>JOIN</code>连接，然后 <code>WHERE</code> 进⾏过滤，接着 <code>GROUP BY</code> 进⾏分组，<code>HAVING</code> 过滤聚合结果，<code>SELECT</code> 选择最终列，<code>ORDER BY</code> 排序，最后 <code>LIMIT</code> 限制返回⾏数。</p>\n<p><code>WHERE</code> 先执⾏是为了减少数据量，<code>HAVING</code> 只能过滤聚合数据，ORDER BY 必须在<code>SELECT</code> 之后排序最终结果，<code>LIMIT</code> 最后执⾏以减少数据传输。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250610145406.png\" alt=\"20250610145406\"><br>这个执⾏顺序与编写 SQL 语句的顺序不同，这也是为什么有时候在 SELECT ⼦句中定义的别名不能在 WHERE ⼦句中使⽤得原因，因为 <code>WHERE</code> 是在 <code>SELECT</code> 之前执⾏的。</p>\n<h4 id=\"LIMIT-为什么在最后执⾏？\"><a href=\"#LIMIT-为什么在最后执⾏？\" class=\"headerlink\" title=\"LIMIT 为什么在最后执⾏？\"></a>LIMIT 为什么在最后执⾏？</h4><p>因为 <code>LIMIT</code> 是在最终结果集上执⾏的，如果在 WHERE 之前执⾏ <code>LIMIT</code>，那么就会先返回所有⾏，然后再进⾏ <code>LIMIT</code> 限制，这样会增加数据传输的开销。</p>\n<h4 id=\"ORDER-BY-为什么在-SELECT-之后执⾏？\"><a href=\"#ORDER-BY-为什么在-SELECT-之后执⾏？\" class=\"headerlink\" title=\"ORDER BY 为什么在 SELECT 之后执⾏？\"></a>ORDER BY 为什么在 SELECT 之后执⾏？</h4><p>因为排序需要基于最终返回的列，如果 ORDER BY 早于 SELECT 执⾏，计算 类的聚合函数就会出问题。<br>比如说如果要按照所选的平均值排序,order by先执行,还没有计算平均值.</p>\n<h3 id=\"14-介绍⼀下-MySQL-的常⽤命令\"><a href=\"#14-介绍⼀下-MySQL-的常⽤命令\" class=\"headerlink\" title=\"14.介绍⼀下 MySQL 的常⽤命令\"></a>14.介绍⼀下 MySQL 的常⽤命令</h3><p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250610150150.png\" alt=\"20250610150150\"><br>MySQL 的常⽤命令主要包括数据库操作命令、表操作命令、⾏数据 CRUD 命令、索引和约束的创建修改命令、⽤户和权限管理的命令、事务控制的命令等。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 数据库操作</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> DATABASE db_name;                    <span class=\"comment\">-- 创建数据库</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> DATABASE db_name;                      <span class=\"comment\">-- 删除数据库</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> DATABASES;                             <span class=\"comment\">-- 查看所有数据库</span></span><br><span class=\"line\">USE db_name;                                <span class=\"comment\">-- 切换数据库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 表操作</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> table_name (                    <span class=\"comment\">-- 创建表</span></span><br><span class=\"line\">    id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class=\"line\">    name <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>) <span class=\"keyword\">NOT NULL</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> table_name;                      <span class=\"comment\">-- 删除表</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> table_name <span class=\"keyword\">ADD</span> <span class=\"keyword\">COLUMN</span> col_name <span class=\"type\">INT</span>; <span class=\"comment\">-- 添加列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> table_name <span class=\"keyword\">DROP</span> <span class=\"keyword\">COLUMN</span> col_name; <span class=\"comment\">-- 删除列</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TABLES;                                <span class=\"comment\">-- 查看所有表</span></span><br><span class=\"line\"><span class=\"keyword\">DESC</span> table_name;                            <span class=\"comment\">-- 查看表结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 数据CRUD</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT INTO</span> table_name <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"string\">&#x27;test&#x27;</span>);   <span class=\"comment\">-- 插入数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> table_name;                   <span class=\"comment\">-- 查询数据</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> table_name <span class=\"keyword\">SET</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;new&#x27;</span> <span class=\"keyword\">WHERE</span> id<span class=\"operator\">=</span><span class=\"number\">1</span>;<span class=\"comment\">-- 更新数据</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> table_name <span class=\"keyword\">WHERE</span> id<span class=\"operator\">=</span><span class=\"number\">1</span>;           <span class=\"comment\">-- 删除数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 索引和约束</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_name <span class=\"keyword\">ON</span> table_name(col);    <span class=\"comment\">-- 创建索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> table_name <span class=\"keyword\">ADD</span> <span class=\"keyword\">PRIMARY KEY</span>(id); <span class=\"comment\">-- 添加主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> table_name <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span>(col_name); <span class=\"comment\">-- 添加唯一约束</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> table_name <span class=\"keyword\">ADD</span> <span class=\"keyword\">FOREIGN KEY</span>(col) <span class=\"keyword\">REFERENCES</span> other_table(col); <span class=\"comment\">-- 外键</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 用户权限</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> <span class=\"string\">&#x27;user&#x27;</span>@<span class=\"string\">&#x27;host&#x27;</span> IDENTIFIED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;pwd&#x27;</span>; <span class=\"comment\">-- 创建用户</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">ALL</span> <span class=\"keyword\">ON</span> db_name.<span class=\"operator\">*</span> <span class=\"keyword\">TO</span> <span class=\"string\">&#x27;user&#x27;</span>@<span class=\"string\">&#x27;host&#x27;</span>;     <span class=\"comment\">-- 授权</span></span><br><span class=\"line\"><span class=\"keyword\">REVOKE</span> <span class=\"keyword\">ALL</span> <span class=\"keyword\">ON</span> db_name.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;user&#x27;</span>@<span class=\"string\">&#x27;host&#x27;</span>;  <span class=\"comment\">-- 撤销权限</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">USER</span> <span class=\"string\">&#x27;user&#x27;</span>@<span class=\"string\">&#x27;host&#x27;</span>;                     <span class=\"comment\">-- 删除用户</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务控制</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;                          <span class=\"comment\">-- 开始事务</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;                                     <span class=\"comment\">-- 提交事务</span></span><br><span class=\"line\"><span class=\"keyword\">ROLLBACK</span>;                                   <span class=\"comment\">-- 回滚事务</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> autocommit<span class=\"operator\">=</span><span class=\"number\">0</span>;                           <span class=\"comment\">-- 关闭自动提交</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"说说数据库操作命令\"><a href=\"#说说数据库操作命令\" class=\"headerlink\" title=\"说说数据库操作命令?\"></a>说说数据库操作命令?</h4><p><code>CREATE DATABASE database_name;</code> ⽤于创建数据库;<br><code>USE database_name;</code>⽤于显示所有数据库;<br><code>DROP DATABASE database_name;</code>⽤于删除数据库;<br><code>SHOW DATABASES;</code> 换数据库。</p>\n<h4 id=\"说说表操作命令？\"><a href=\"#说说表操作命令？\" class=\"headerlink\" title=\"说说表操作命令？\"></a>说说表操作命令？</h4><p><code>CREATE TABLE table_name (列名1 数据类型1, 列名2 数据类型2,...);</code> 用于创建表；<br><code>DROP TABLE table_name;</code> 用于删除表；<br><code>SHOW TABLES;</code> 用于显示所有表；<br><code>DESCRIBE table_name;</code> 用于查看表结构；<br><code>ALTER TABLE table_name ADD column_name datatype;</code> 用于修改表。</p>\n<h4 id=\"说说行数据的-CRUD-命令？\"><a href=\"#说说行数据的-CRUD-命令？\" class=\"headerlink\" title=\"说说行数据的 CRUD 命令？\"></a>说说行数据的 CRUD 命令？</h4><p><code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);</code> 用于插入数据；<br><code>SELECT column_names FROM table_name WHERE condition;</code> 用于查询数据；<br><code>UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;</code> 用于更新数据；<br><code>DELETE FROM table_name WHERE condition;</code> 用于删除数据。</p>\n<h4 id=\"说说索引和约束的创建修改命令？\"><a href=\"#说说索引和约束的创建修改命令？\" class=\"headerlink\" title=\"说说索引和约束的创建修改命令？\"></a>说说索引和约束的创建修改命令？</h4><p><code>CREATE INDEX index_name ON table_name (column_name); </code>用于创建索引；<br><code>ALTER TABLE table_name ADD PRIMARY KEY (column_name); </code>用于添加主键；<br><code>ALTER TABLE table_name ADD CONSTRAINT fk_name FOREIGN KEY (column_name) REFERENCES parent_table (parent_column_name);</code> 用于添加外键。</p>\n<h4 id=\"说说用户和权限管理的命令？\"><a href=\"#说说用户和权限管理的命令？\" class=\"headerlink\" title=\"说说用户和权限管理的命令？\"></a>说说用户和权限管理的命令？</h4><p><code>CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</code> 用于创建用户；<br><code>GRANT ALL PRIVILEGES ON database_name.table_name TO &#39;username&#39;@&#39;host&#39;;</code> 用于授予权限；<br><code>REVOKE ALL PRIVILEGES ON database_name.table_name FROM &#39;username&#39;@&#39;host&#39;;</code> 用于撤销权限；<br><code>DROP USER &#39;username&#39;@&#39;host&#39;;</code> 用于删除用户。</p>\n<h4 id=\"说说事务控制的命令？\"><a href=\"#说说事务控制的命令？\" class=\"headerlink\" title=\"说说事务控制的命令？\"></a>说说事务控制的命令？</h4><p><code>START TRANSACTION;</code> 用于开始事务；<br><code>COMMIT; </code>用于提交事务；<br><code>ROLLBACK;</code> 用于回滚事务。</p>\n<h3 id=\"15-MySQL-bin-目录下的可执行文件了解吗\"><a href=\"#15-MySQL-bin-目录下的可执行文件了解吗\" class=\"headerlink\" title=\"15.MySQL bin 目录下的可执行文件了解吗\"></a>15.MySQL bin 目录下的可执行文件了解吗</h3><p>MySQL 的 bin 目录下有很多可执行文件，主要用于管理 MySQL 服务器、数据库、表、数据等。<br>比如说：<br><code>mysql</code>：用于连接 MySQL 服务器<br><code>mysqldump</code>：用于数据库<strong>备份</strong>，对数据备份、<strong>迁移或恢复</strong>时非常有用<br><code>mysqladmin</code>：用来执行一些<strong>管理操作</strong>，比如说创建数据库、删除数据库、查看 MySQL 服务器的状态等。<br><code>mysqlcheck</code>：用于<strong>检查、修复、分析和优化</strong>数据库表，对数据库的维护和性能优化非常有用。<br><code>mysqlimport</code>：用于从文本文件中<strong>导入</strong>数据到数据库表中，适合批量数据导入。<br><code>mysqlshow</code>：用于<strong>显示 <strong>MySQL 数据库服务器中的数据库、表、列等信息。<br><code>mysqlbinlog</code>：用于</strong>查看 MySQL 二进制日志文件</strong>的内容，可以用于恢复数据、查看数据变更等。</p>\n<h3 id=\"16-MySQL-第-3-10-条记录怎么查？\"><a href=\"#16-MySQL-第-3-10-条记录怎么查？\" class=\"headerlink\" title=\"16.MySQL 第 3-10 条记录怎么查？\"></a>16.MySQL 第 3-10 条记录怎么查？</h3><p>可以使用 <code>limit</code> 语句，结合偏移量和行数来实现。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> table_name LIMIT <span class=\"number\">2</span>, <span class=\"number\">8</span>;</span><br></pre></td></tr></table></figure>\n<p><code>limit</code> 语句用于限制查询结果的数量，偏移量表示从哪条记录开始，行数表示返回的记录数量。<br>2：偏移量，表示跳过前两条记录，从第三条记录开始。<br>8：行数，表示从偏移量开始，返回 8 条记录。<br>偏移量是从 0 开始的，即第一条记录的偏移量是 0；如果想从第 3 条记录开始，偏移量就应该是 2。</p>\n<h3 id=\"17-用过哪些-MySQL-函数？\"><a href=\"#17-用过哪些-MySQL-函数？\" class=\"headerlink\" title=\"17.用过哪些 MySQL 函数？\"></a>17.用过哪些 MySQL 函数？</h3><p>用过挺多的，比如说<strong>处理字符串</strong>的函数：<br><code>CONCAT()</code>: 用于连接两个或多个字符串。<br><code>LENGTH()</code>: 用于返回字符串的长度。<br><code>SUBSTRING()</code>: 从字符串中提取子字符串。<br><code>REPLACE()</code>: 替换字符串中的某部分。<br><code>TRIM()</code>: 去除字符串两侧的空格或其他指定字符。</p>\n<p>处理<strong>数字</strong>的函数：<br><code>ABS()</code>: 返回一个数的绝对值。<br><code>ROUND()</code>: 四舍五入到指定的小数位数。<br><code>MOD()</code>: 返回除法操作的余数。</p>\n<p><strong>日期和时间</strong>处理函数：<br><code>NOW()</code>: 返回当前的日期和时间。<br><code>CURDATE()</code>: 返回当前的日期。</p>\n<p><strong>汇总函数：</strong><br><code>SUM()</code>: 计算数值列的总和。<br><code>AVG()</code>: 计算数值列的平均值。<br><code>COUNT()</code>: 计算某列的行数。</p>\n<p><strong>逻辑函数：</strong><br><code>IF()</code>: 如果条件为真，则返回一个值；否则返回另一个值。<br><code>CASE</code>: 根据一系列条件返回值。</p>\n<h3 id=\"18-说说-SQL-的隐式数据类型转换？\"><a href=\"#18-说说-SQL-的隐式数据类型转换？\" class=\"headerlink\" title=\"18.说说 SQL 的隐式数据类型转换？\"></a>18.说说 SQL 的隐式数据类型转换？</h3><p>当一个整数和一个浮点数相加时，整数会被转换为浮点数。<br><code>SELECT 1 + 1.0;</code> – 结果为 2.0<br>当一个字符串和一个整数相加时，字符串会被转换为整数。<br><code>SELECT &#39;1&#39; + 1;</code> – 结果为 2<br>隐式转换会导致意想不到的结果，最好通过显式转换来规避。<br><code>SELECT CAST(&#39;1&#39; AS SIGNED INTEGER) + 1;</code> – 结果为 2</p>\n<h3 id=\"19-说说-SQL-的语法树解析？\"><a href=\"#19-说说-SQL-的语法树解析？\" class=\"headerlink\" title=\"19. 说说 SQL 的语法树解析？\"></a>19. 说说 SQL 的语法树解析？</h3><p>SQL 语法树解析是将 SQL 查询语句转换成抽象语法树 —— AST 的过程，是<strong>数据库引擎处理查询</strong>的第一步，也是<strong>防止 SQL 注入</strong>的重要手段。<br>通常分为 3 个阶段。</p>\n<p><strong>第一个阶段</strong>，词法分析：<strong>拆解 SQL 语句</strong>，识别关键字、表名、列名等。</p>\n<p>—start—<br>比如说：<br>SELECT id, name FROM users WHERE age &gt; 18;<br>将会被拆解为：<br>[SELECT] [id] [,] [name] [FROM] [users] [WHERE] [age] [&gt;] [18] [;]<br>—end—</p>\n<p><strong>第二个阶段</strong>，语法分析：检查 SQL 是否符合语法规则，并构建抽象语法树。</p>\n<p>—start—<br>比如说上面的语句会被构建成如下的语法树：</p>\n<pre><code>      SELECT\n     /      \\\n Columns     FROM\n/      \\      |\n</code></pre>\n<p>  id      name  users<br>               |<br>             WHERE<br>               |<br>            age &gt; 18<br>或者这样表示：<br>SELECT<br> ├── COLUMNS: id, name<br> ├── FROM: users<br> ├── WHERE<br> │    ├── CONDITION: age &gt; 18<br>—end—</p>\n<p>第三个阶段，语义分析：检查表、列是否存在，进行权限验证等。</p>\n<p>—start—<br>比如说执行：<br>SELECT id, name FROM users WHERE age &gt; ‘eighteen’;<br>会报错：<br>ERROR: Column ‘age’ is INT, but ‘eighteen’ is STRING.<br>—end—</p>\n<h2 id=\"数据库架构\"><a href=\"#数据库架构\" class=\"headerlink\" title=\"数据库架构\"></a>数据库架构</h2><h3 id=\"20-说说-MySQL-的基础架构？\"><a href=\"#20-说说-MySQL-的基础架构？\" class=\"headerlink\" title=\"20.说说 MySQL 的基础架构？\"></a>20.说说 MySQL 的基础架构？</h3><p>MySQL 采用<strong>分层架构</strong>，主要包括<strong>连接层</strong>、<strong>服务层</strong>、和<strong>存储引擎层</strong>。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612103330.png\" alt=\"20250612103330\"><br>①、连接层主要负责<strong>客户端连接的管理</strong>，包括验证用户身份、权限校验、连接管理等。可以通过数据库连接池来提升连接的处理效率。<br>②、服务层是 MySQL 的核心，<strong>主要负责查询解析、优化、执行等操作</strong>。在这一层，SQL 语句会经过解析、优化器优化，然后转发到存储引擎执行，并返回结果。这一层包含查询解析器、优化器、执行计划生成器、日志模块等。<br>③、存储引擎层负责数据的<strong>实际存储和提取</strong>。MySQL 支持多种存储引擎，如 InnoDB、MyISAM、Memory 等。<br><strong>binlog写入在哪一层？</strong><br>binlog 在服务层，<strong>负责记录 SQL 语句的变化</strong>。它记录了所有对数据库进行更改的操作，用于数据恢复、主从复制等。</p>\n<h3 id=\"21-一条查询语句SELECT是如何执行的？\"><a href=\"#21-一条查询语句SELECT是如何执行的？\" class=\"headerlink\" title=\"21.一条查询语句SELECT是如何执行的？\"></a>21.一条查询语句SELECT是如何执行的？</h3><p>当我们执行一条 SELECT 语句时，MySQL 并不会直接去磁盘读取数据，而是经过 6 个步骤来解析、优化、执行，然后再返回结果。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612103550.png\" alt=\"20250612103550\"><br>第一步，客户端<strong>发送 SQL 查询语句到 MySQL 服务器</strong>。</p>\n<p>第二步，MySQL 服务器的<strong>连接器开始处理这个请求</strong>，跟客户端建立连接、获取权限、管理连接。</p>\n<p>第三步，<strong>解析器对 SQL 语句进行解析</strong>，检查语句是否符合 SQL 语法规则，确保数据库、表和列都是存在的，并处理 SQL 语句中的名称解析和权限验证。</p>\n<p>第四步，<strong>优化器负责确定 SQL 语句的执行计划</strong>，这包括选择使用哪些索引，以及决定表之间的连接顺序等。</p>\n<p>第五步，<strong>执行器会调用存储引擎的 API</strong>来进行数据的读写。</p>\n<p>第六步，<strong>存储引擎负责查询数据，并将执行结果返回给客户端</strong>。客户端接收到查询结果，完成这次查询请求。</p>\n<h3 id=\"22-一条更新语句UPDATE是如何执行的？\"><a href=\"#22-一条更新语句UPDATE是如何执行的？\" class=\"headerlink\" title=\"22.一条更新语句UPDATE是如何执行的？\"></a>22.一条更新语句UPDATE是如何执行的？</h3><p>undo log 回滚日志: 用于事务的回滚操作.<br>redo log 重做日志: 用于实现事务的持久性,保持数据一致性.<br>总的来说，一条 UPDATE 语句的执行过程包括<strong>读取数据页</strong>、<strong>加锁解锁</strong>、<strong>事务提交</strong>、<strong>日志记录</strong>等多个步骤。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612104235.png\" alt=\"20250612104235\"><br>拿 <code>update test set a=1 where id=2</code> 举例来说：<br>在事务开始前，MySQL 需要记录<code>undo log</code>，用于事务回滚。</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>id</th>\n<th>旧值</th>\n<th>新值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>update</td>\n<td>2</td>\n<td>N</td>\n<td>1</td>\n</tr>\n</tbody></table>\n<p>除了记录 <code>undo log</code>，存储引擎还会将更新操作写入 <code>redo log</code>，状态标记为 prepare，并确保 <code>redo log</code> 持久化到磁盘。这一步可以保证即使系统崩溃，数据也能通过 <code>redo log</code> 恢复到一致状态。</p>\n<p>写完<code>redo log</code> 后，MySQL 会获取行锁，将 a 的值修改为 1，标记为脏页，此时数据仍然在内存的 <code>buffer pool</code> 中，不会立即写入磁盘。后台线程会在适当的时候将脏页刷盘，以提高性能。</p>\n<p>最后提交事务，<code>redo log</code> 中的记录被标记为 <code>committed</code>，行锁释放。</p>\n<p>如果 MySQL 开启了 <code>binlog</code>，还会将更新操作记录到 <code>binlog</code> 中，主要用于主从复制。</p>\n<p>以及数据恢复，可以结合 <code>redo log</code> 进行点对点的恢复。<code>binlog</code> 的写入通常发生在事务提交时，与 <code>redo log</code> 共同构成“两阶段提交”，确保两者的一致性。</p>\n<p>注意，<code>redo log</code> 的写入有两个阶段的提交，一是 <code>binlog</code> 写入之前<code>prepare</code> 状态的写入，二是<code>binlog</code>写入之后 <code>commit </code>状态的写入。</p>\n<h3 id=\"23-说说-MySQL-的段区页行\"><a href=\"#23-说说-MySQL-的段区页行\" class=\"headerlink\" title=\"23.说说 MySQL 的段区页行\"></a>23.说说 MySQL 的段区页行</h3><p>MySQL 是以<strong>表的形式存储数据的</strong>，而表空间的结构则由<strong>段、区、页、行</strong>组成。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612111023.png\" alt=\"20250612111023\"></p>\n<p>①、段：<strong>表空间由多个段组成</strong>，常见的段有数据段、索引段、回滚段等。<br>创建索引时会创建两个段，数据段和索引段，数据段用来存储叶子节点中的数据；索引段用来存储非叶子节点的数据。<br>回滚段包含了事务执行过程中用于数据回滚的旧数据。</p>\n<p>②、区：<strong>段由一个或多个区组成</strong>，区是一组连续的页，通常包含 64 个连续的页，也就是 1M 的数据。<br>使用区而非单独的页进行数据分配可以优化磁盘操作，减少磁盘寻道时间，特别是在大量数据进行读写时。</p>\n<p>③、页：<strong>页是 InnoDB 存储数据的基本单元</strong>，标准大小为 16 KB，索引树上的一个节点就是一个页。<br>也就意味着数据库每次读写都是以 16 KB 为单位的，一次最少从磁盘中读取 16KB 的数据到内存，一次最少写入 16KB 的数据到磁盘。</p>\n<p>④、行：<strong>InnoDB 采用行存储方式</strong>，意味着数据按照行进行组织和管理，行数据可能有多个格式，比如说 COMPACT、REDUNDANT、DYNAMIC 等。<br>MySQL 8.0 默认的行格式是 DYNAMIC，由COMPACT 演变而来，意味着这些数据如果超过了页内联存储的限制，则会被存储在溢出页中。<br>可以通过 show table status like ‘%article%’ 查看行格式。</p>\n<h4 id=\"了解-MySQL的数据行、行溢出机制吗？\"><a href=\"#了解-MySQL的数据行、行溢出机制吗？\" class=\"headerlink\" title=\"了解 MySQL的数据行、行溢出机制吗？\"></a>了解 MySQL的数据行、行溢出机制吗？</h4><p><strong>InnoDB从磁盘中读取数据的最小单位是数据页。</strong></p>\n<h5 id=\"一-行有哪些格式\"><a href=\"#一-行有哪些格式\" class=\"headerlink\" title=\"一 行有哪些格式\"></a>一 行有哪些格式</h5><p>Mysql的数据行有两种格式:<code>Compact</code>格式和<code>Redundant</code>格式。<br><code>Compact</code>是一种<strong>紧凑的行格式</strong>，设计的初衷就是为了让一个数据页中可以存放更多的数据行。</p>\n<p>你品一品，让一个数据页中可以存放更多的数据行是一个多么激动人心的事，MySQL以数据页为单位从磁盘中读数据，如果能做到让一个数据页中有更多的行，那岂不是使用的空间变少了，且整体的效率直线飙升？</p>\n<p>官网介绍：<code>Compact</code>能比<code>Redundant</code>格式节约20%的存储。</p>\n<p><code>Compact</code>从MySQL5.0引入，MySQL5.1之后，行格式默认设置成 <code>Compact</code> 。所以本文描述的也是Compact格式。</p>\n<h5 id=\"二、紧凑的行格式长啥样？\"><a href=\"#二、紧凑的行格式长啥样？\" class=\"headerlink\" title=\"二、紧凑的行格式长啥样？\"></a>二、紧凑的行格式长啥样？</h5><p>表中有的列允许为<code>null</code>，有的列是变长的<code>varchar</code>类型。<br>那<code>Compact</code>行格式是如何组织描述这些信息的呢？如下图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612152337.png\" alt=\"20250612152337\"></p>\n<pre><code>每部分包含的数据可能要比我上面标注的1、2、3还要多。\n为了给大家更直观的感受和理解我只是挑了一部分展示给大家看。\n</code></pre>\n<h5 id=\"三、MySQL单行能存多大体量的数据？\"><a href=\"#三、MySQL单行能存多大体量的数据？\" class=\"headerlink\" title=\"三、MySQL单行能存多大体量的数据？\"></a>三、MySQL单行能存多大体量的数据？</h5><p>在MySQL的设定中，单行数据最大能存储<code>65535byte</code>的数据（注意是byte，而不是字符）<br>MySQL不允许创建一个长度为65535byte的列，因为数据页中每一行中都有我们上图提到的隐藏列。<br>所以将varchar的长度降低到<code>65532byte</code>即可成功创建该表.</p>\n<p>所以如果你将charset换成utf8这种编码格式，那varchar(N)中的N其实指的N个字符，而不是N个byte。<br>假如encode&#x3D;utf8时三个byte表示一个字符。那么65535 &#x2F; 3 &#x3D; 21845个字符。</p>\n<h5 id=\"四、Compact格式是如何做到紧凑的？\"><a href=\"#四、Compact格式是如何做到紧凑的？\" class=\"headerlink\" title=\"四、Compact格式是如何做到紧凑的？\"></a>四、Compact格式是如何做到紧凑的？</h5><p>MySQL每次进行随机的IO读<br>默认情况下，数据页的大小为16KB。数据页中存储着数行。<br>那就意味着一个数据页中能存储越多的数据行，MySQL整体的进行的IO次数就越少？性能就越快？<br><strong>Compact格式的实现思路是</strong>：当列的类型为<code>VARCHAR</code>、 <code>VARBINARY</code>、 <code>BLOB</code>、<code>TEXT</code>时，该列超过768byte的数据放到其他数据页中去。<br>如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612155421.png\" alt=\"20250612155421\"><br>MySQL这样做，有效的防止了单个varchar列或者Text列太大导致单个数据页中存放的行记录过少而让IO飙升的窘境且占内存的。</p>\n<h5 id=\"五、什么是行溢出？\"><a href=\"#五、什么是行溢出？\" class=\"headerlink\" title=\"五、什么是行溢出？\"></a>五、什么是行溢出？</h5><p>如果数据页默认大小为16KB，换算成byte： 16*1024 &#x3D; 16384 byte<br>那你有没有发现，单页能存储的<code>16384byte</code>和单行最大能存储的 <code>65535byte</code> 差了好几倍呢</p>\n<p>也就是说，假如你要存储的数据行很大超过了65532byte那么你是写入不进去的。假如你要存储的单行数据小于65535byte但是大于16384byte，这时你可以成功insert，但是一个数据页又存储不了你插入的数据。这时肯定会行溢出！</p>\n<p>其实在MySQL的设定中，发生行溢出并不是达到16384byte边缘才会发生。<br>对于varchar、text等类型的行。当这种列存储的长度达到<code>几百byte</code>时就会发生行溢。</p>\n<h5 id=\"六、行-如何溢出？\"><a href=\"#六、行-如何溢出？\" class=\"headerlink\" title=\"六、行 如何溢出？\"></a>六、行 如何溢出？</h5><p>还是看这张图：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612160901.png\" alt=\"20250612160901\"><br>在MySQL设定中，当varchar列长度达到<code>768byte</code>后，会将该列的前<code>768byte</code>当作当作<code>prefix</code>存放在行中，多出来的数据溢出存放到<strong>溢出页</strong>中，然后通过一个<strong>偏移量指针</strong>将两者关联起来，这就是行溢出机制。</p>\n<h5 id=\"七、思考一个问题\"><a href=\"#七、思考一个问题\" class=\"headerlink\" title=\"七、思考一个问题\"></a>七、思考一个问题</h5><p>不知道你有没有想过这样一个问题：<br>首先你肯定知道，MySQL使用的是B+Tree的聚簇索引，在这棵B+Tree中非叶子节点是只存索引不存数据，叶子节点中存储着真实的数据。同时叶子结点指向数据页。<br>那当单行存不下的时候，为啥不存储在两个数据页中呢？就像下图这样～。<br>单个节点存储下，我用多个节点存总行吧！说不定这样我的B+Tee还能变大长高（这其实是错误的想法）<br>这个错误的描述对应的脑图如下：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612162150.png\" alt=\"20250612162150\"></p>\n<p>那MySQL不这样做的原因如下：<br>MySQL想让一个数据页中能存放更多的数据行，至少也得要存放两行数据。否则就失去了B+Tree的意义。B+Tree也退化成一个低效的链表。<br>你可以品一下这句蓝色的话，他说的每个数据页至少要存放两行数据的意思不是说 数据页不能只存一行。你确确实实可以只往里面写一行数据，然后去吃个饭，干点别的。一直让这个数据页中只有一行数据。</p>\n<p>这句话的意思是，当你往这个数据页中写入一行数据时，即使它很大将达到了数据页的极限，但是通过行溢出机制。依然能保证你的下一条数据还能写入到这个数据页中。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612162433.png\" alt=\"20250612162433\"></p>\n<h2 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h2><h3 id=\"24-MySQL-有哪些常见存储引擎？\"><a href=\"#24-MySQL-有哪些常见存储引擎？\" class=\"headerlink\" title=\"24.MySQL 有哪些常见存储引擎？\"></a>24.MySQL 有哪些常见存储引擎？</h3><p>MySQL 支持多种存储引擎，常见的有 <code>MyISAM</code>、<code>InnoDB</code>、<code>MEMORY</code> 等。<br>—这部分是帮助理解 start，面试中可不背—<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612112408.png\" alt=\"20250612112408\"><br>我来做一个表格对比：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250612112435.png\" alt=\"20250612112435\"><br>—这部分是帮助理解 end，面试中可不背—<br>除此之外，我还了解到：<br>①、MySQL 5.5 之前，默认存储引擎是 <code>MyISAM</code>，5.5 之后是 <code>InnoDB</code>。<br>②、<code>InnoDB</code> 支持的哈希索引是自适应的，不能人为干预。<br>③、<code>InnoDB</code> 从 MySQL 5.6 开始，支持全文索引。<br>④、<code>InnoDB</code> 的最小表空间略小于 10M，最大表空间取决于页面大小。<br>如何切换 MySQL 的数据引擎？<br>可以通过 <code>alter table</code> 语句来切换 MySQL 的数据引擎。<br><code>ALTER TABLE your_table_name ENGINE=InnoDB;</code><br>不过不建议，<strong>应该提前设计好到底用哪一种存储引擎</strong>。</p>\n<h3 id=\"25-存储引擎应该怎么选择？\"><a href=\"#25-存储引擎应该怎么选择？\" class=\"headerlink\" title=\"25.存储引擎应该怎么选择？\"></a>25.存储引擎应该怎么选择？</h3><p>大多数情况下，使用默认的 <code>InnoDB</code> 就可以了，<code>InnoDB</code> 可以提供<strong>事务</strong>、<strong>行级锁</strong>、<strong>外键</strong>、<strong>B+ 树索引</strong>等能力。<br><code>MyISAM</code> 适合<strong>读多写少</strong>的场景。<br><code>MEMORY</code> 适合<strong>临时表</strong>，数据量不大的情况。因为数据都存放在内存，所以速度非常快。</p>\n<h3 id=\"26-InnoDB-和-MyISAM-主要有什么区别？\"><a href=\"#26-InnoDB-和-MyISAM-主要有什么区别？\" class=\"headerlink\" title=\"26.InnoDB 和 MyISAM 主要有什么区别？\"></a>26.InnoDB 和 MyISAM 主要有什么区别？</h3><p><code>InnoDB</code> 和 <code>MyISAM</code> 的最大区别在于<strong>事务支持和锁机制</strong>。<code>InnoDB</code> 支持<strong>事务</strong>、<strong>行级锁</strong>，适合大多数业务系统；而 MyISAM <strong>不支持事务</strong>，用的是<strong>表锁</strong>，<strong>查询快但写入性能差</strong>，适合读多写少的场景。</p>\n<p>另外，从存储结构上来说，<code>MyISAM</code> 用三种格式的文件来存储，<code>.frm</code> 文件存储表的定义；<code>.MYD</code> 存储数据；<code>.MYI</code> 存储索引；而 <code>InnoDB</code> 用两种格式的文件来存储，<code>.frm </code>文件存储表的定义；<code>.ibd</code> 存储数据和索引。</p>\n<p>从索引类型上来说，<code>MyISAM</code> 为<strong>非聚簇索引</strong>，索引和数据分开存储，索引保存的是数据文件的指针。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613101120.png\" alt=\"20250613101120\"></p>\n<p><code>InnoDB</code> 为<strong>聚簇索引</strong>，索引和数据不分开。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613101204.png\" alt=\"20250613101204\"></p>\n<p>更细微的层面上来讲，<code>MyISAM</code> 不支持外键，可以没有主键，表的具体行数存储在表的属性中，查询时可以直接返回；<code>InnoDB</code> 支持外键，必须有主键，具体行数需要扫描整个表才能返回，有索引的情况下会扫描索引。</p>\n<h4 id=\"InnoDB的内存结构了解吗？\"><a href=\"#InnoDB的内存结构了解吗？\" class=\"headerlink\" title=\"InnoDB的内存结构了解吗？\"></a>InnoDB的内存结构了解吗？</h4><p>InnoDB 的内存区域主要有两块，<code>buffer pool</code> 和 <code>log buffer</code>。 <code>buffer pool</code> 用于缓存数据页和索引页，提升读写性能；<code>log buffer</code> 用于缓存 <code>redo log</code>，提升写入性能。<br>InnoDB引擎框架图如下:<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613101647.png\" alt=\"20250613101647\"></p>\n<h4 id=\"数据页的结构了解过吗\"><a href=\"#数据页的结构了解过吗\" class=\"headerlink\" title=\"数据页的结构了解过吗\"></a>数据页的结构了解过吗</h4><p><code>InnoDB</code> 的数据页由 7 部分组成，其中<code>文件头</code>、<code>页头</code>和<code>文件尾</code>的大小是固定的，分别为 <code>38</code>、<code>56 </code>和 <code>8</code> 个字节，用来标记该页的一些信息。<code>行记录</code>、<code>空闲空间</code>和<code>页目录</code>的大小是动态的，为实际的行记录存储空间。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613102706.png\" alt=\"20250613102706\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613103225.png\" alt=\"20250613103225\"></p>\n<p>真实的记录会按照指定的行格式存储到 <code>User Records</code> 中。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613103457.png\" alt=\"20250613103457\"></p>\n<p>每个数据页的 <code>File Header</code> 都有一个上一页和下一页的编号，所有的数据页会形成一个双向链表。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613103813.png\" alt=\"20250613103813\"></p>\n<p>在 InnoDB 中，默认的页大小是 16KB。可以通过 <code>show variables like &#39;innodb_page_size&#39;;</code> 查看。</p>\n<h3 id=\"27-InnoDB-的-Buffer-Pool了解吗？\"><a href=\"#27-InnoDB-的-Buffer-Pool了解吗？\" class=\"headerlink\" title=\"27. InnoDB 的 Buffer Pool了解吗？\"></a>27. InnoDB 的 Buffer Pool了解吗？</h3><p><code>Buffer Pool</code> 是 <code>InnoDB</code> 存储引擎中的一个<strong>内存缓冲区</strong>，它会将经常使用的<strong>数据页、索引页</strong>加载进内存，读的时候先查询 <code>Buffer Pool</code>，如果命中就不用访问磁盘了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613104231.png\" alt=\"20250613104231\"></p>\n<p>如果没有命中，就从磁盘读取，并加载到 <code>Buffer Pool</code>，此时可能会触发页淘汰，将不常用的页移出 <code>Buffer Pool</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613104655.png\" alt=\"20250613104655\"></p>\n<p>写操作时不会直接写入磁盘，而是<strong>先修改内存中的页</strong>，此时页被标记为脏页，后台线程会定期将脏页刷新到磁盘。</p>\n<p><code>Buffer Pool</code> 可以显著减少磁盘的读写次数，从而提升 MySQL 的读写性能。</p>\n<h4 id=\"Buffer-Pool-的默认大小是多少？\"><a href=\"#Buffer-Pool-的默认大小是多少？\" class=\"headerlink\" title=\"Buffer Pool 的默认大小是多少？\"></a>Buffer Pool 的默认大小是多少？</h4><p>本机上 InnoDB 的 Buffer Pool 默认大小是 128MB。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> VARIABLES <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>另外，在具有 1GB-4GB RAM 的系统上，默认值为系统 RAM 的 25%；在具有超过 4GB RAM 的系统上，默认值为系统 RAM 的 50%，但不超过 4GB。</p>\n<h4 id=\"InnoDB-对-LRU-算法的优化了解吗？\"><a href=\"#InnoDB-对-LRU-算法的优化了解吗？\" class=\"headerlink\" title=\"InnoDB 对 LRU 算法的优化了解吗？\"></a>InnoDB 对 LRU 算法的优化了解吗？</h4><pre><code>LRU (least resently used)：近期最少使用\nLFU (least freqently used)：频数最少使用\n</code></pre>\n<p>了解，<code>InnoDB</code> 对 <code>LRU</code> 算法进行了改良，最近访问的数据并不直接放到 LRU 链表的头部，而是放在一个叫 midpoiont 的位置。默认情况下，midpoint 位于 LRU 列表的 5&#x2F;8 处。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613105336.png\" alt=\"20250613105336\"></p>\n<p>比如 Buffer Pool 有 100 页，新页插入的位置大概是在第 80 页；当页数据被频繁访问后，再将其移动到 young 区，这样做的好处是热点页能长时间保留在内存中，不容易被挤出去。</p>\n<p>—-这部分是帮助理解 start，面试中可不背—-</p>\n<p>可以通过 <code>innodb_old_blocks_pct</code> 参数来调整 <code>Buffer Pool</code> 中 old 和 young 区的比例；通过 <code>innodb_old_blocks_time</code> 参数来调整页在 <code>young</code> 区的停留时间。</p>\n<p>默认情况下，LRU 链表中 old 区占 37%；同一页再次访问提升的最小时间间隔是 1000 毫秒。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613105519.png\" alt=\"20250613105519\"><br>也就是说，如果某页在 1 秒内被多次访问，只会计算一次，不会立刻升级为热点页，防止短时间批量访问导致缓存污染。</p>\n<p>—-这部分是帮助理解 end，面试中可不背—-</p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><h3 id=\"28-MySQL-日志文件有哪些？\"><a href=\"#28-MySQL-日志文件有哪些？\" class=\"headerlink\" title=\"28.MySQL 日志文件有哪些？\"></a>28.MySQL 日志文件有哪些？</h3><p>有 6 大类，其中<code>错误日志</code>用于<strong>问题诊断</strong>，<code>慢查询日志</code>用于 <strong>SQL 性能分析</strong>，<code>general log</code> 用于<strong>记录所有的 SQL 语句</strong>，<code>binlog</code> 用于<strong>主从复制和数据恢复</strong>，<code>redo log</code> 用于<strong>保证事务持久性</strong>，<code>undo log</code> 用于<strong>事务回滚和 MVCC</strong>。</p>\n<p>—-这部分是帮助理解 start，面试中可不背—-</p>\n<p>①、<code>错误日志（Error Log）</code>：记录 MySQL 服务器<strong>启动、运行或停止</strong>时出现的问题。<br>②、<code>慢查询日志（Slow Query Log）</code>：记录执行时间超过 <code>long_query_time</code> 值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。<br>③、<code>一般查询日志（General Query Log）</code>：记录 MySQL 服务器的启动关闭信息，客户端的连接信息，以及更新、查询的 SQL 语句等。<br>④、<code>二进制日志（Binary Log）</code>：记录所有<strong>修改数据库状态的 SQL 语句</strong>，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作。<br>⑤、<code>重做日志（Redo Log）</code>：记录对于 InnoDB 表的每个写操作，不是 SQL 级别的，而是物理级别的，主要用于崩溃恢复。<br>⑥、<code>回滚日志（Undo Log，或者叫事务日志）</code>：记录数据被修改前的值，用于事务的回滚。</p>\n<p>—-这部分是帮助理解 end，面试中可不背—-</p>\n<h4 id=\"请重点说说-binlog？\"><a href=\"#请重点说说-binlog？\" class=\"headerlink\" title=\"请重点说说 binlog？\"></a>请重点说说 binlog？</h4><p>binlog 是一种物理日志，<strong>会在磁盘上记录数据库的所有修改操作</strong>。<br>如果误删了数据，就可以使用 binlog 进行回退到误删之前的状态。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 步骤<span class=\"number\">1</span>：恢复全量备份</span><br><span class=\"line\">mysql <span class=\"operator\">-</span>u root <span class=\"operator\">-</span>p <span class=\"operator\">&lt;</span> full_backup.sql</span><br><span class=\"line\"># 步骤<span class=\"number\">2</span>：应用Binlog到指定时间点</span><br><span class=\"line\">mysqlbinlog <span class=\"comment\">--start-datetime=&quot;2025-03-13 14:00:00&quot; --stop-datetime=&quot;2025-03-13 15:00:00&quot; binlog.000001 | mysql -u root -p</span></span><br></pre></td></tr></table></figure>\n<p>如果要搭建主从复制，就可以让从库定时读取主库的 binlog。<br>MySQL 提供了三种格式的 binlog：<code>Statement</code>、<code>Row</code> 和 <code>Mixed</code>，分别对应 SQL 语句级别、行级别和混合级别，默认为行级别。<br>从后缀名上来看，binlog 文件分为两类：以 <code>.index</code> 结尾的<strong>索引文件</strong>，以 <code>.00000*</code> 结尾的<strong>二进制日志文件</strong>。<br><strong>binlog 默认是没有启用的。</strong></p>\n<p>生产环境中是一定要启用的，可以通过在 <code>my.cnf</code> 文件中配置 <code>log_bin</code> 参数，以启用 binlog。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_bin <span class=\"operator\">=</span> mysql<span class=\"operator\">-</span>bin #开启binlog</span><br><span class=\"line\">#mysql<span class=\"operator\">-</span>bin.<span class=\"operator\">*</span>日志文件最大字节（单位：字节）</span><br><span class=\"line\">#设置最大<span class=\"number\">100</span>MB</span><br><span class=\"line\">max_binlog_size<span class=\"operator\">=</span><span class=\"number\">104857600</span></span><br><span class=\"line\"></span><br><span class=\"line\">#设置了只保留<span class=\"number\">7</span>天BINLOG（单位：天）</span><br><span class=\"line\">expire_logs_days <span class=\"operator\">=</span> <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">#binlog日志只记录指定库的更新</span><br><span class=\"line\">#binlog<span class=\"operator\">-</span>do<span class=\"operator\">-</span>db<span class=\"operator\">=</span>db_name</span><br><span class=\"line\"></span><br><span class=\"line\">#binlog日志不记录指定库的更新</span><br><span class=\"line\">#binlog<span class=\"operator\">-</span>ignore<span class=\"operator\">-</span>db<span class=\"operator\">=</span>db_name</span><br><span class=\"line\"></span><br><span class=\"line\">#写缓冲多少次，刷一次磁盘，默认<span class=\"number\">0</span></span><br><span class=\"line\">sync_binlog<span class=\"operator\">=</span><span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"binlog-的配置参数都了解哪些？\"><a href=\"#binlog-的配置参数都了解哪些？\" class=\"headerlink\" title=\"binlog 的配置参数都了解哪些？\"></a>binlog 的配置参数都了解哪些？</h4><p><code>log_bin = mysql-bin </code>用于<strong>启用 binlog</strong>，这样就可以在 MySQL 的数据目录中找到 db-bin.000001、db-bin.000002 等日志文件。<br><code>max_binlog_size=104857600</code> 用于设置<strong>每个 binlog 文件的大小</strong>，不建议设置太大，网络传送起来比较麻烦。<br>当 binlog 文件达到 <code>max_binlog_size</code> 时，MySQL 会关闭当前文件并创建一个新的 binlog 文件。<br><code>expire_logs_days = 7</code> 用于设置 binlog 文件的<strong>自动过期时间为 7 天</strong>。过期的 binlog 文件会被自动删除。防止长时间累积的 binlog 文件占用过多存储空间，所以这个配置很重要。<br><code>binlog-do-db=db_name</code>，<strong>指定哪些数据库表的更新应该被记录</strong>。<br><code>binlog-ignore-db=db_name</code>，指定<strong>忽略哪些数据库表的更新</strong>。<br><code>sync_binlog=0</code>，设置<strong>每多少次 binlog 写操作会触发一次磁盘同步操作</strong>。默认值为 0，表示 MySQL 不会主动触发同步操作，而是依赖操作系统的磁盘缓存策略。<br>即当执行写操作时，数据会先写入缓存，当缓存区满了再由操作系统将数据一次性刷入磁盘。<br>如果设置为 1，表示每次 binlog 写操作后都会同步到磁盘，虽然可以保证数据能够及时写入磁盘，但会降低性能。<br>可以通过 <code>show variables like &#39;%log_bin%&#39;;</code> 查看 <code>binlog</code> 是否开启。</p>\n<h4 id=\"有了binlog为什么还要undolog-redolog？\"><a href=\"#有了binlog为什么还要undolog-redolog？\" class=\"headerlink\" title=\"有了binlog为什么还要undolog redolog？\"></a>有了binlog为什么还要undolog redolog？</h4><p><code>binlog</code> 属于 <code>Server</code> 层，与存储引擎无关，<strong>无法直接操作物理数据页</strong>。而 <code>redo log</code> 和 <code>undo log</code> 是 <code>InnoDB</code> 存储引擎实现 ACID的基石。<br>————–ps————-<br><strong>ACID:</strong></p>\n<ul>\n<li>**原子性(Atomicity)**：<br>事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚<br>通过undo log实现，记录事务开始前的状态，用于回滚</li>\n<li>**一致性(Consistency)**：<br>事务执行前后，数据库从一个一致状态转变为另一个一致状态<br>通过其他三个特性(AID)共同保证</li>\n<li>**隔离性(Isolation)**：<br>多个并发事务执行时，一个事务的执行不应影响其他事务<br>通过锁机制和MVCC(多版本并发控制)实现</li>\n<li>**持久性(Durability)**：<br>事务一旦提交，其结果就是永久性的<br>通过redo log实现，即使系统崩溃也能恢复数据</li>\n</ul>\n<p>————–ps————-</p>\n<p><code>binlog</code> 关注的是<strong>逻辑变更的全局记录</strong>；<code>redo log</code> 用于<strong>确保物理变更的持久性</strong>，确保事务最终能够刷盘成功；<code>undo log</code> 是<strong>逻辑逆向操作日志</strong>，记录的是旧值，方便恢复到事务开始前的状态。</p>\n<p><strong>另外一种回答方式。</strong></p>\n<p><code>binlog</code> 会记录<strong>整个 SQL 或行变化</strong>；<code>redo log</code> 是为了恢复<strong>已提交但未刷盘</strong>的数据，<code>undo log</code> 是为了<strong>撤销未提交的事务</strong>。</p>\n<p>以一次事务更新为例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开启事务</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span>;</span><br><span class=\"line\"># 更新数据</span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> users <span class=\"keyword\">SET</span> age <span class=\"operator\">=</span> age <span class=\"operator\">+</span> <span class=\"number\">1</span> <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"># 提交事务</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>事务开始</strong>的时候会生成 <code>undo log</code>，记录更新前的数据，比如原值是 18：</p>\n<pre><code>undo log: id=1, age=18\n</code></pre>\n<p>修改数据的时候，会将数据写入到 <code>redo log</code>。</p>\n<p>比如数据页 <code>page_id=123</code> 上，id&#x3D;1 的用户被更新为 age&#x3D;26：</p>\n<pre><code>redo log (prepare):\npage_id=123, offset=0x40, before=18, after=26\n</code></pre>\n<p>等事务提交的时候，<code>redo log</code> 刷盘，<code>binlog</code> 刷盘。</p>\n<p><code>binlog</code> 写完之后，<code>redo log</code> 的状态会变为 <code>commit</code>：</p>\n<pre><code>redo log (commit):\npage_id=123, offset=0x40, before=18, after=26\n</code></pre>\n<p>binlog 如果是 <code>Statement</code> 格式，会记录一条 SQL 语句：<br>    UPDATE users SET age &#x3D; age + 1 WHERE id &#x3D; 1;<br>binlog 如果是 <code>Row</code> 格式，会记录：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表：users</span><br><span class=\"line\">before: id<span class=\"operator\">=</span><span class=\"number\">1</span>, age<span class=\"operator\">=</span><span class=\"number\">18</span></span><br><span class=\"line\">after:  id<span class=\"operator\">=</span><span class=\"number\">1</span>, age<span class=\"operator\">=</span><span class=\"number\">26</span></span><br></pre></td></tr></table></figure>\n<p>随后，后台线程会将 redo log 中的变更异步刷新到磁盘。</p>\n<h4 id=\"详细探究一下binlog-长文警告⚠️\"><a href=\"#详细探究一下binlog-长文警告⚠️\" class=\"headerlink\" title=\"详细探究一下binlog(长文警告⚠️):\"></a>详细探究一下binlog(长文警告⚠️):</h4><p>MySQL 的 Binlog 日志是一种二进制格式的日志，Binlog 记录所有的 DDL 和 DML 语句(除了数据查询语句SELECT、SHOW等)，以 Event 的形式记录，同时记录语句执行时间。</p>\n<h5 id=\"Binlog-的主要作用有两个：\"><a href=\"#Binlog-的主要作用有两个：\" class=\"headerlink\" title=\"Binlog 的主要作用有两个：\"></a>Binlog 的主要作用有两个：</h5><p><strong>1. 数据恢复:</strong><br>因为 Binlog 详细记录了所有修改数据的 SQL，当某一时刻的数据误操作而导致出问题，或者数据库宕机数据丢失，那么可以根据 Binlog 来回放历史数据。<br><strong>2. 主从复制:</strong><br>想要做多机备份的业务，可以去监听当前写库的 Binlog 日志，同步写库的所有更改。</p>\n<p><strong>Binlog 包括两类文件：</strong><br><code>二进制日志索引文件(.index)</code>：记录所有的二进制文件。<br><code>二进制日志文件(.00000*)</code>：记录所有 <code>DDL</code> 和 <code>DML</code> 语句事件。</p>\n<p>Binlog 日志功能<strong>默认是开启</strong>的，线上情况下 Binlog 日志的增长速度是很快的，在 MySQL 的配置文件 <code>my.cnf</code> 中提供一些参数来对 Binlog 进行设置。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#设置此参数表示启用binlog功能，并制定二进制日志的存储目录</span><br><span class=\"line\">log<span class=\"operator\">-</span>bin<span class=\"operator\">=</span><span class=\"operator\">/</span>home<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>binlog<span class=\"operator\">/</span></span><br><span class=\"line\"></span><br><span class=\"line\">#mysql<span class=\"operator\">-</span>bin.<span class=\"operator\">*</span>日志文件最大字节（单位：字节）</span><br><span class=\"line\">#设置最大<span class=\"number\">100</span>MB</span><br><span class=\"line\">max_binlog_size<span class=\"operator\">=</span><span class=\"number\">104857600</span></span><br><span class=\"line\"></span><br><span class=\"line\">#设置了只保留<span class=\"number\">7</span>天BINLOG（单位：天）</span><br><span class=\"line\">expire_logs_days <span class=\"operator\">=</span> <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">#binlog日志只记录指定库的更新</span><br><span class=\"line\">#binlog<span class=\"operator\">-</span>do<span class=\"operator\">-</span>db<span class=\"operator\">=</span>db_name</span><br><span class=\"line\"></span><br><span class=\"line\">#binlog日志不记录指定库的更新</span><br><span class=\"line\">#binlog<span class=\"operator\">-</span>ignore<span class=\"operator\">-</span>db<span class=\"operator\">=</span>db_name</span><br><span class=\"line\"></span><br><span class=\"line\">#写缓冲多少次，刷一次磁盘，默认<span class=\"number\">0</span></span><br><span class=\"line\">sync_binlog<span class=\"operator\">=</span><span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p><strong>需要注意的是：</strong><br><code>max_binlog_size</code> ：Binlog 最大和默认值是 1G，该设置并不能严格控制 Binlog 的大小，尤其是 Binlog 比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性不可能做切换日志的动作，只能将该事务的所有 SQL 都记录进当前日志直到事务结束。所以真实文件有时候会大于 max_binlog_size 设定值。<br><code>expire_logs_days</code> ：Binlog 过期删除不是服务定时执行，是需要借助事件触发才执行，事件包括：</p>\n<ul>\n<li>服务器重启</li>\n<li>服务器被更新</li>\n<li>日志达到了最大日志长度 max_binlog_size</li>\n<li>日志被刷新</li>\n</ul>\n<p>二进制日志由配置文件的 <code>log-bin</code> 选项负责启用，MySQL 服务器将在数据根目录创建两个新文件mysql-bin.000001 和 mysql-bin.index，若配置选项没有给出文件名，MySQL 将使用主机名称命名这两个文件，其中 <code>.index</code> 文件包含一份全体日志文件的清单。</p>\n<p><code>sync_binlog</code>：这个参数决定了 Binlog 日志的更新频率。默认 0 ，表示该操作由操作系统根据自身负载自行决定多久写一次磁盘。</p>\n<p><code>sync_binlog = 1</code> 表示每一条事务提交都会立刻写盘。<code>sync_binlog=n</code> 表示 n 个事务提交才会写盘。</p>\n<p>根据 MySQL 文档，写 Binlog 的时机是：<code>SQL transaction</code> 执行完，但任何相关的 Locks 还<strong>未释放</strong>或<strong>事务还未最终 commit</strong> 前。这样保证了 Binlog 记录的操作时序与数据库实际的数据变更顺序一致。</p>\n<p><strong>检查 Binlog 文件是否已开启：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%log_bin%&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------------------+------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Variable_name                   <span class=\"operator\">|</span> <span class=\"keyword\">Value</span>                              <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------------------+------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> log_bin                         <span class=\"operator\">|</span> <span class=\"keyword\">ON</span>                                 <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> log_bin_basename                <span class=\"operator\">|</span> <span class=\"operator\">/</span>usr<span class=\"operator\">/</span><span class=\"keyword\">local</span><span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>data<span class=\"operator\">/</span>binlog       <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> log_bin_index                   <span class=\"operator\">|</span> <span class=\"operator\">/</span>usr<span class=\"operator\">/</span><span class=\"keyword\">local</span><span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>data<span class=\"operator\">/</span>binlog.index <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> log_bin_trust_function_creators <span class=\"operator\">|</span> OFF                                <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> log_bin_use_v1_row_events       <span class=\"operator\">|</span> OFF                                <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> sql_log_bin                     <span class=\"operator\">|</span> <span class=\"keyword\">ON</span>                                 <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------------------+------------------------------------+</span></span><br><span class=\"line\"><span class=\"number\">6</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>MySQL 会把用户对所有数据库的内容和结构的修改情况记入 <code>mysql-bin.n</code> 文件，而不会记录 <code>SELECT</code> 和没有实际更新的 <code>UPDATE</code> 语句。</p>\n<p>如果你不知道现在有哪些 Binlog 文件，可以使用如下命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"type\">binary</span> logs; #查看binlog列表</span><br><span class=\"line\"><span class=\"keyword\">show</span> master status; #查看最新的binlog</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> <span class=\"type\">binary</span> logs;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----------+-----------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Log_name         <span class=\"operator\">|</span> File_size <span class=\"operator\">|</span> Encrypted <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----------+-----------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000001</span> <span class=\"operator\">|</span>       <span class=\"number\">179</span> <span class=\"operator\">|</span> <span class=\"keyword\">No</span>        <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span>       <span class=\"number\">156</span> <span class=\"operator\">|</span> <span class=\"keyword\">No</span>        <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----------+-----------+</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>Binlog 文件是二进制文件，强行打开看到的必然是乱码，MySQL 提供了命令行的方式来展示 Binlog 日志：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqlbinlog mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> more</span><br></pre></td></tr></table></figure>\n<p>mysqlbinlog 命令即可查看。<br>虽然看起来凌乱其实也有迹可循。<code>Binlog</code> 通过事件的方式来管理日志信息，可以通过 <code>show binlog events in</code> 的语法来查看当前 <code>Binlog</code> 文件对应的详细事件信息。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> binlog events <span class=\"keyword\">in</span> <span class=\"string\">&#x27;mysql-bin.000001&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Log_name         <span class=\"operator\">|</span> Pos <span class=\"operator\">|</span> Event_type     <span class=\"operator\">|</span> Server_id <span class=\"operator\">|</span> End_log_pos <span class=\"operator\">|</span> Info                              <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000001</span> <span class=\"operator\">|</span>   <span class=\"number\">4</span> <span class=\"operator\">|</span> Format_desc    <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">125</span> <span class=\"operator\">|</span> Server ver: <span class=\"number\">8.0</span><span class=\"number\">.21</span>, Binlog ver: <span class=\"number\">4</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000001</span> <span class=\"operator\">|</span> <span class=\"number\">125</span> <span class=\"operator\">|</span> Previous_gtids <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">156</span> <span class=\"operator\">|</span>                                   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000001</span> <span class=\"operator\">|</span> <span class=\"number\">156</span> <span class=\"operator\">|</span> Stop           <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">179</span> <span class=\"operator\">|</span>                                   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n<p>这是一份没有任何写入数据的 <code>Binlog</code> 日志文件。<br><code>Binlog</code> 的版本是V4，可以看到日志的结束时间为 Stop。出现 Stop event 有两种情况：</p>\n<ol>\n<li>是 master shut down 的时候会在 <code>Binlog</code> 文件结尾出现</li>\n<li>是备机在关闭的时候会写入 <code>relay log</code> 结尾，或者执行 <code>RESET SLAVE</code> 命令执行</li>\n</ol>\n<p>本文出现的原因是我有<strong>手动停止过 MySQL 服务</strong>。<br>一般来说一份正常的 <code>Binlog</code> 日志文件会以 Rotate event 结束。当 <code>Binlog</code> 文件超过指定大小，Rotate event 会写在文件最后，指向下一个 <code>Binlog</code> 文件。<br>我们来看看有过数据操作的 <code>Binlog</code> 日志文件是什么样子的。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> binlog events <span class=\"keyword\">in</span> <span class=\"string\">&#x27;mysql-bin.000002&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Log_name         <span class=\"operator\">|</span> Pos <span class=\"operator\">|</span> Event_type     <span class=\"operator\">|</span> Server_id <span class=\"operator\">|</span> End_log_pos <span class=\"operator\">|</span> Info                              <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span>   <span class=\"number\">4</span> <span class=\"operator\">|</span> Format_desc    <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">125</span> <span class=\"operator\">|</span> Server ver: <span class=\"number\">8.0</span><span class=\"number\">.21</span>, Binlog ver: <span class=\"number\">4</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">125</span> <span class=\"operator\">|</span> Previous_gtids <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">156</span> <span class=\"operator\">|</span>                                   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-----------------------------------+</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>上面是没有任何数据操作且没有被截断的 Binlog。接下来我们插入一条数据，再看看 Binlog 事件。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> binlog events <span class=\"keyword\">in</span> <span class=\"string\">&#x27;mysql-bin.000002&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Log_name         <span class=\"operator\">|</span> Pos <span class=\"operator\">|</span> Event_type     <span class=\"operator\">|</span> Server_id <span class=\"operator\">|</span> End_log_pos <span class=\"operator\">|</span> Info                                                                    <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span>   <span class=\"number\">4</span> <span class=\"operator\">|</span> Format_desc    <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">125</span> <span class=\"operator\">|</span> Server ver: <span class=\"number\">8.0</span><span class=\"number\">.21</span>, Binlog ver: <span class=\"number\">4</span>                                       <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">125</span> <span class=\"operator\">|</span> Previous_gtids <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">156</span> <span class=\"operator\">|</span>                                                                         <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">156</span> <span class=\"operator\">|</span> Anonymous_Gtid <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">235</span> <span class=\"operator\">|</span> <span class=\"keyword\">SET</span> @<span class=\"variable\">@SESSION</span>.GTID_NEXT<span class=\"operator\">=</span> <span class=\"string\">&#x27;ANONYMOUS&#x27;</span>                                    <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">235</span> <span class=\"operator\">|</span> Query          <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">323</span> <span class=\"operator\">|</span> <span class=\"keyword\">BEGIN</span>                                                                   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">323</span> <span class=\"operator\">|</span> Intvar         <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">355</span> <span class=\"operator\">|</span> INSERT_ID<span class=\"operator\">=</span><span class=\"number\">13</span>                                                            <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">355</span> <span class=\"operator\">|</span> Query          <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">494</span> <span class=\"operator\">|</span> use `test_db`; <span class=\"keyword\">INSERT INTO</span> `test_db`.`test_db`(`name`) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;xdfdf&#x27;</span>) <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">494</span> <span class=\"operator\">|</span> Xid            <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">525</span> <span class=\"operator\">|</span> <span class=\"keyword\">COMMIT</span> <span class=\"comment\">/* xid=192 */</span>                                                    <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"number\">7</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>这是加入一条数据之后的 <code>Binlog</code> 事件。</p>\n<p><strong>我们对 event 查询的数据行关键字段来解释一下：</strong></p>\n<ul>\n<li><code>Pos</code>：当前事件的开始位置，每个事件都占用固定的字节大小，结束位置(End_log_position)减去Pos，就是这个事件占用的字节数。<br>上面的日志中我们能看到，第一个事件位置并不是从 0 开始，而是从 4。MySQL 通过文件中的前 4 个字节，来判断这是不是一个 Binlog 文件。这种方式很常见，很多格式的文件，如 pdf、doc、jpg等，都会通常<strong>前几个特定字符判断是否是合法文件</strong>。</li>\n<li><code>Event_type</code>：表示事件的类型</li>\n<li><code>Server_id</code>：表示产生这个事件的 MySQL server_id，通过设置 my.cnf 中的 server-id 选项进行配置</li>\n<li><code>End_log_position</code>：下一个事件的开始位置</li>\n<li><code>Info</code>：包含事件的具体信息</li>\n</ul>\n<h5 id=\"Binlog-日志格式\"><a href=\"#Binlog-日志格式\" class=\"headerlink\" title=\"Binlog 日志格式:\"></a>Binlog 日志格式:</h5><p>针对不同的使用场景，<code>Binlog</code> 也提供了可定制化的服务，提供了<strong>三种模式</strong>来提供不同详细程度的日志内容。</p>\n<ul>\n<li><code>Statement</code> 模式：基于 <code>SQL</code> 语句的复制(statement-based replication-SBR)</li>\n<li><code>Row</code> 模式：基于行的复制(row-based replication-RBR)</li>\n<li><code>Mixed</code> 模式：混合模式复制(mixed-based replication-MBR)</li>\n</ul>\n<ol>\n<li><p><strong>Statement 模式</strong><br><strong>保存每一条修改数据的SQL。</strong><br>该模式只保存一条普通的SQL语句，不涉及到执行的上下文信息。<br>因为每台 MySQL 数据库的本地环境可能不一样，那么对于依赖到本地环境的函数或者上下文处理的逻辑 SQL 去处理的时候可能同样的语句在不同的机器上执行出来的效果不一致。<br>比如像 sleep()函数，last_insert_id()函数，等等，这些都跟特定时间的本地环境有关。</p>\n</li>\n<li><p><strong>Row 模式</strong><br>MySQL V5.1.5 版本开始支持Row模式的 Binlog，它与 Statement 模式的区别在于它<strong>不保存具体的 SQL 语句，而是记录具体被修改的信息</strong>。<br>比如一条 update 语句更新10条数据，如果是 Statement 模式那就保存一条 SQL 就够，但是 Row 模式会保存每一行分别更新了什么，有10条数据。<br>Row 模式的优缺点就很明显了。保存每一个更改的详细信息必然会带来<strong>存储空间的快速膨胀</strong>，换来的是<strong>事件操作的详细记录</strong>。所以要求越高代价越高。</p>\n</li>\n<li><p><strong>Mixed 模式</strong><br>Mixed 模式即以上两种模式的综合体。既然上面两种模式分别走了极简和一丝不苟的极端，那是否可以区分使用场景的情况下将这两种模式综合起来呢？<br>在 Mixed 模式中，<strong>一般的更新语句使用 Statement 模式来保存 Binlog</strong>，但是遇到一些函数操作，<strong>可能会影响数据准确性的操作则使用 Row 模式来保存</strong>。这种方式需要根据每一条具体的 SQL 语句来区分选择哪种模式。<br>MySQL 从 V5.1.8 开始提供 Mixed 模式，V5.7.7 之前的版本默认是Statement 模式，之后默认使用Row模式， <strong>但是在 8.0 以上版本已经默认使用 Mixed 模式了</strong>。</p>\n</li>\n</ol>\n<p>查询当前 Binlog 日志使用格式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> <span class=\"keyword\">global</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%binlog_format%&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------------------+---------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Variable_name                   <span class=\"operator\">|</span> <span class=\"keyword\">Value</span>   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------------------+---------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> binlog_format                   <span class=\"operator\">|</span> MIXED   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> default_week_format             <span class=\"operator\">|</span> <span class=\"number\">0</span>       <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> information_schema_stats_expiry <span class=\"operator\">|</span> <span class=\"number\">86400</span>   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> innodb_default_row_format       <span class=\"operator\">|</span> <span class=\"keyword\">dynamic</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> require_row_format              <span class=\"operator\">|</span> OFF     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------------------+---------+</span></span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"如何通过-mysqlbinlog-命令手动恢复数据\"><a href=\"#如何通过-mysqlbinlog-命令手动恢复数据\" class=\"headerlink\" title=\"如何通过 mysqlbinlog 命令手动恢复数据\"></a>如何通过 mysqlbinlog 命令手动恢复数据</h5><p>上面说过每一条 event 都有位点信息，如果我们当前的 MySQL 库被无操作或者误删除了，那么该如何通过 Binlog 来恢复到删除之前的数据状态呢？<br>首先发现误操作之后，<strong>先停止 MySQL 服务，防止继续更新</strong>。<br>接着通过 <code>mysqlbinlog</code>命令对二进制文件进行分析，查看误操作之前的位点信息在哪里。<br>接下来肯定就是恢复数据，当前数据库的数据已经是错的，那么就从开始位置到误操作之前位点的数据肯定的都是正确的；如果误操作之后也有正常的数据进来，这一段时间的位点数据也要备份。<br>比如说：<br>误操作的位点开始值为 501，误操作结束的位置为705，之后到800的位点都是正确数据。<br>那么从 0 - 500 ，706 - 800 都是有效数据，接着我们就可以进行数据恢复了。<br><strong>先将数据库备份并清空。</strong><br>接着使用 <code>mysqlbinlog</code> 来恢复数据：<br>0 - 500 的数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqlbinlog <span class=\"comment\">--start-position=0  --stop-position=500  bin-log.000003 &gt; /root/back.sql;</span></span><br></pre></td></tr></table></figure>\n<p>上面命令的作用就是将 0 -500 位点的数据恢复到自定义的 SQL 文件中。同理 706 - 800 的数据也是一样操作。之后我们执行这两个 SQL 文件就行了。</p>\n<p><strong>Binlog 事件类型</strong><br>上面我们说到了 <code>Binlog</code> 日志中的事件，不同的操作会对应着不同的事件类型，且不同的 <code>Binlog</code> 日志模式同一个操作的事件类型也不同，下面我们一起看看常见的事件类型。<br>首先我们看看源码中的事件类型定义：<br>源码位置：&#x2F;libbinlogevents&#x2F;include&#x2F;binlog_event.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Log_event_type</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    Every time you update this enum (when you add a type), you have to</span></span><br><span class=\"line\"><span class=\"comment\">    fix Format_description_event::Format_description_event().</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  UNKNOWN_EVENT= <span class=\"number\">0</span>,</span><br><span class=\"line\">  START_EVENT_V3= <span class=\"number\">1</span>,</span><br><span class=\"line\">  QUERY_EVENT= <span class=\"number\">2</span>,</span><br><span class=\"line\">  STOP_EVENT= <span class=\"number\">3</span>,</span><br><span class=\"line\">  ROTATE_EVENT= <span class=\"number\">4</span>,</span><br><span class=\"line\">  INTVAR_EVENT= <span class=\"number\">5</span>,</span><br><span class=\"line\">  LOAD_EVENT= <span class=\"number\">6</span>,</span><br><span class=\"line\">  SLAVE_EVENT= <span class=\"number\">7</span>,</span><br><span class=\"line\">  CREATE_FILE_EVENT= <span class=\"number\">8</span>,</span><br><span class=\"line\">  APPEND_BLOCK_EVENT= <span class=\"number\">9</span>,</span><br><span class=\"line\">  EXEC_LOAD_EVENT= <span class=\"number\">10</span>,</span><br><span class=\"line\">  DELETE_FILE_EVENT= <span class=\"number\">11</span>,</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    NEW_LOAD_EVENT is like LOAD_EVENT except that it has a longer</span></span><br><span class=\"line\"><span class=\"comment\">    sql_ex, allowing multibyte TERMINATED BY etc; both types share the</span></span><br><span class=\"line\"><span class=\"comment\">    same class (Load_event)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  NEW_LOAD_EVENT= <span class=\"number\">12</span>,</span><br><span class=\"line\">  RAND_EVENT= <span class=\"number\">13</span>,</span><br><span class=\"line\">  USER_VAR_EVENT= <span class=\"number\">14</span>,</span><br><span class=\"line\">  FORMAT_DESCRIPTION_EVENT= <span class=\"number\">15</span>,</span><br><span class=\"line\">  XID_EVENT= <span class=\"number\">16</span>,</span><br><span class=\"line\">  BEGIN_LOAD_QUERY_EVENT= <span class=\"number\">17</span>,</span><br><span class=\"line\">  EXECUTE_LOAD_QUERY_EVENT= <span class=\"number\">18</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  TABLE_MAP_EVENT = <span class=\"number\">19</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The PRE_GA event numbers were used for 5.1.0 to 5.1.15 and are</span></span><br><span class=\"line\"><span class=\"comment\">    therefore obsolete.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  PRE_GA_WRITE_ROWS_EVENT = <span class=\"number\">20</span>,</span><br><span class=\"line\">  PRE_GA_UPDATE_ROWS_EVENT = <span class=\"number\">21</span>,</span><br><span class=\"line\">  PRE_GA_DELETE_ROWS_EVENT = <span class=\"number\">22</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The V1 event numbers are used from 5.1.16 until mysql-trunk-xx</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  WRITE_ROWS_EVENT_V1 = <span class=\"number\">23</span>,</span><br><span class=\"line\">  UPDATE_ROWS_EVENT_V1 = <span class=\"number\">24</span>,</span><br><span class=\"line\">  DELETE_ROWS_EVENT_V1 = <span class=\"number\">25</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    Something out of the ordinary happened on the master</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  INCIDENT_EVENT= <span class=\"number\">26</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    Heartbeat event to be send by master at its idle time</span></span><br><span class=\"line\"><span class=\"comment\">    to ensure master&#x27;s online status to slave</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  HEARTBEAT_LOG_EVENT= <span class=\"number\">27</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    In some situations, it is necessary to send over ignorable</span></span><br><span class=\"line\"><span class=\"comment\">    data to the slave: data that a slave can handle in case there</span></span><br><span class=\"line\"><span class=\"comment\">    is code for handling it, but which can be ignored if it is not</span></span><br><span class=\"line\"><span class=\"comment\">    recognized.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  IGNORABLE_LOG_EVENT= <span class=\"number\">28</span>,</span><br><span class=\"line\">  ROWS_QUERY_LOG_EVENT= <span class=\"number\">29</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/** Version 2 of the Row events */</span></span><br><span class=\"line\">  WRITE_ROWS_EVENT = <span class=\"number\">30</span>,</span><br><span class=\"line\">  UPDATE_ROWS_EVENT = <span class=\"number\">31</span>,</span><br><span class=\"line\">  DELETE_ROWS_EVENT = <span class=\"number\">32</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  GTID_LOG_EVENT= <span class=\"number\">33</span>,</span><br><span class=\"line\">  ANONYMOUS_GTID_LOG_EVENT= <span class=\"number\">34</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  PREVIOUS_GTIDS_LOG_EVENT= <span class=\"number\">35</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  TRANSACTION_CONTEXT_EVENT= <span class=\"number\">36</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  VIEW_CHANGE_EVENT= <span class=\"number\">37</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Prepared XA transaction terminal event similar to Xid */</span></span><br><span class=\"line\">  XA_PREPARE_LOG_EVENT= <span class=\"number\">38</span>,</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    Add new events here - right above this comment!</span></span><br><span class=\"line\"><span class=\"comment\">    Existing events (except ENUM_END_EVENT) should never change their numbers</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  ENUM_END_EVENT <span class=\"comment\">/* end marker */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这么多的事件类型我们就不一一介绍，挑出来一些常用的来看看。<br><code>FORMAT_DESCRIPTION_EVENT</code><br><code>FORMAT_DESCRIPTION_EVENT</code> 是 Binlog V4 中为了取代之前版本中的 START_EVENT_V3 事件而引入的。它是 Binlog 文件中的第一个事件，而且，该事件只会在 Binlog 中出现一次。MySQL 根据 <code>FORMAT_DESCRIPTION_EVENT</code> 的定义来解析其它事件。<br>它通常指定了 MySQL 的版本，Binlog 的版本，该 Binlog 文件的创建时间。</p>\n<p><code>QUERY_EVENT</code></p>\n<p><code>QUERY_EVENT</code> 类型的事件通常在以下几种情况下使用：</p>\n<p>事务开始时，执行的 BEGIN 操作<br>STATEMENT 格式中的 DML 操作<br>ROW 格式中的 DDL 操作<br>比如上文我们插入一条数据之后的 Binlog 日志：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> binlog events <span class=\"keyword\">in</span> <span class=\"string\">&#x27;mysql-bin.000002&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Log_name         <span class=\"operator\">|</span> Pos <span class=\"operator\">|</span> Event_type     <span class=\"operator\">|</span> Server_id <span class=\"operator\">|</span> End_log_pos <span class=\"operator\">|</span> Info                                                                    <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span>   <span class=\"number\">4</span> <span class=\"operator\">|</span> Format_desc    <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">125</span> <span class=\"operator\">|</span> Server ver: <span class=\"number\">8.0</span><span class=\"number\">.21</span>, Binlog ver: <span class=\"number\">4</span>                                       <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">125</span> <span class=\"operator\">|</span> Previous_gtids <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">156</span> <span class=\"operator\">|</span>                                                                         <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">156</span> <span class=\"operator\">|</span> Anonymous_Gtid <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">235</span> <span class=\"operator\">|</span> <span class=\"keyword\">SET</span> @<span class=\"variable\">@SESSION</span>.GTID_NEXT<span class=\"operator\">=</span> <span class=\"string\">&#x27;ANONYMOUS&#x27;</span>                                    <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">235</span> <span class=\"operator\">|</span> Query          <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">323</span> <span class=\"operator\">|</span> <span class=\"keyword\">BEGIN</span>                                                                   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">323</span> <span class=\"operator\">|</span> Intvar         <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">355</span> <span class=\"operator\">|</span> INSERT_ID<span class=\"operator\">=</span><span class=\"number\">13</span>                                                            <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">355</span> <span class=\"operator\">|</span> Query          <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">494</span> <span class=\"operator\">|</span> use `test_db`; <span class=\"keyword\">INSERT INTO</span> `test_db`.`test_db`(`name`) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;xdfdf&#x27;</span>) <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000002</span> <span class=\"operator\">|</span> <span class=\"number\">494</span> <span class=\"operator\">|</span> Xid            <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">525</span> <span class=\"operator\">|</span> <span class=\"keyword\">COMMIT</span> <span class=\"comment\">/* xid=192 */</span>                                                    <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"number\">7</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p><code>XID_EVENT</code><br>在事务提交时，不管是 STATEMENT 还 是ROW 格式的 Binlog，都会在末尾添加一个 <code>XID_EVENT</code> 事件代表<strong>事务的结束</strong>。该事件记录了该事务的 ID，在 MySQL 进行崩溃恢复时，根据事务在 Binlog 中的提交情况来决定是否提交存储引擎中状态为 prepared 的事务。<br><code>ROWS_EVENT</code><br>对于 ROW 格式的 Binlog，所有的 DML 语句都是记录在 <code>ROWS_EVENT</code> 中。<br><code>ROWS_EVENT</code>分为三种：<br><code>WRITE_ROWS_EVENT</code><br><code>UPDATE_ROWS_EVENT</code><br><code>DELETE_ROWS_EVENT</code><br>分别对应 <code>insert</code>，<code>update</code> 和 <code>delete</code> 操作。<br>对于 <code>insert</code> 操作，<code>WRITE_ROWS_EVENT</code> 包含了要插入的数据。<br>对于 <code>update</code> 操作，<code>UPDATE_ROWS_EVENT</code> 不仅包含了修改后的数据，还包含了修改前的值。<br>对于 <code>delete</code> 操作，仅仅需要指定删除的主键（在没有主键的情况下，会给定所有列）。</p>\n<p>对比 <code>QUERY_EVENT</code> 事件，是以文本形式记录 DML 操作的。而对于 <code>ROWS_EVENT</code> 事件，<strong>并不是文本形式</strong>，所以在通过 mysqlbinlog 查看基于 ROW 格式的 Binlog 时，需要指定 -vv –base64-output&#x3D;decode-rows。</p>\n<p>我们来测试一下，首先将日志格式改为 Rows：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> binlog_format<span class=\"operator\">=</span><span class=\"type\">row</span>;</span><br><span class=\"line\">Query OK, <span class=\"number\">0</span> <span class=\"keyword\">rows</span> affected (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> flush logs;</span><br><span class=\"line\">Query OK, <span class=\"number\">0</span> <span class=\"keyword\">rows</span> affected (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n<p>然后刷新一下日志文件，重新开始一个 Binlog 日志。我们插入一条数据之后看一下日志：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> binlog events <span class=\"keyword\">in</span> <span class=\"string\">&#x27;binlog.000008&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------+-----+----------------+-----------+-------------+--------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Log_name      <span class=\"operator\">|</span> Pos <span class=\"operator\">|</span> Event_type     <span class=\"operator\">|</span> Server_id <span class=\"operator\">|</span> End_log_pos <span class=\"operator\">|</span> Info                                 <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------+-----+----------------+-----------+-------------+--------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> binlog<span class=\"number\">.000008</span> <span class=\"operator\">|</span>   <span class=\"number\">4</span> <span class=\"operator\">|</span> Format_desc    <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">125</span> <span class=\"operator\">|</span> Server ver: <span class=\"number\">8.0</span><span class=\"number\">.21</span>, Binlog ver: <span class=\"number\">4</span>    <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> binlog<span class=\"number\">.000008</span> <span class=\"operator\">|</span> <span class=\"number\">125</span> <span class=\"operator\">|</span> Previous_gtids <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">156</span> <span class=\"operator\">|</span>                                      <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> binlog<span class=\"number\">.000008</span> <span class=\"operator\">|</span> <span class=\"number\">156</span> <span class=\"operator\">|</span> Anonymous_Gtid <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">235</span> <span class=\"operator\">|</span> <span class=\"keyword\">SET</span> @<span class=\"variable\">@SESSION</span>.GTID_NEXT<span class=\"operator\">=</span> <span class=\"string\">&#x27;ANONYMOUS&#x27;</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> binlog<span class=\"number\">.000008</span> <span class=\"operator\">|</span> <span class=\"number\">235</span> <span class=\"operator\">|</span> Query          <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">313</span> <span class=\"operator\">|</span> <span class=\"keyword\">BEGIN</span>                                <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> binlog<span class=\"number\">.000008</span> <span class=\"operator\">|</span> <span class=\"number\">313</span> <span class=\"operator\">|</span> Table_map      <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">377</span> <span class=\"operator\">|</span> table_id: <span class=\"number\">85</span> (test_db.test_db)       <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> binlog<span class=\"number\">.000008</span> <span class=\"operator\">|</span> <span class=\"number\">377</span> <span class=\"operator\">|</span> Write_rows     <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">423</span> <span class=\"operator\">|</span> table_id: <span class=\"number\">85</span> flags: STMT_END_F       <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> binlog<span class=\"number\">.000008</span> <span class=\"operator\">|</span> <span class=\"number\">423</span> <span class=\"operator\">|</span> Xid            <span class=\"operator\">|</span>         <span class=\"number\">1</span> <span class=\"operator\">|</span>         <span class=\"number\">454</span> <span class=\"operator\">|</span> <span class=\"keyword\">COMMIT</span> <span class=\"comment\">/* xid=44 */</span>                  <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------+-----+----------------+-----------+-------------+--------------------------------------+</span></span><br><span class=\"line\"><span class=\"number\">7</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"说说-redo-log-的工作机制？\"><a href=\"#说说-redo-log-的工作机制？\" class=\"headerlink\" title=\"说说 redo log 的工作机制？\"></a>说说 redo log 的工作机制？</h4><p>当<strong>事务启动</strong>时，MySQL 会为该事务分配一个唯一标识符。<br>在<strong>事务执行过程中，每次对数据进行修改</strong>，MySQL 都会生成一条 <code>Redo Log</code>，记录修改前后的数据状态。<br>这些 <code>Redo Log</code> 首先会被写入内存中的 <code>Redo Log Buffer</code>。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161219.png\" alt=\"20250613161219\"><br>当事务提交时，MySQL 再将 <code>Redo Log Buffer</code> 中的记录刷新到磁盘上的 <code>Redo Log</code> 文件中。<br>只有当<code> Redo Log</code> 成功写入磁盘，事务才算真正提交成功。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161254.png\" alt=\"20250613161254\"><br>当 MySQL 崩溃重启时，会先检查 <code>Redo Log</code>。对于已提交的事务，MySQL 会重放 <code>Redo Log</code> 中的记录。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161338.png\" alt=\"20250613161338\"><br>对于未提交的事务，MySQL 会通过 <code>Undo Log</code> 回滚这些修改，确保数据恢复到崩溃前的一致性状态。<br><code>Redo Log</code> 是循环使用的，当文件写满后会覆盖最早的记录。<br>为避免覆盖未持久化的记录，MySQL 会定期执行 <code>CheckPoint</code> 操作，将内存中的数据页刷新到磁盘，并记录 <code>CheckPoint</code> 点。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613161415.png\" alt=\"20250613161415\"></p>\n<p>重启时，MySQL 只会重放 CheckPoint 之后的 Redo Log，从而提高恢复效率。</p>\n<p><strong>省流版:</strong></p>\n<ol>\n<li>事务开始</li>\n<li>记录undo log（旧数据）</li>\n<li>修改Buffer Pool中的数据</li>\n<li>写入redo log（prepare状态）</li>\n<li>写入binlog</li>\n<li>提交事务（redo log标记为commit）</li>\n<li>后台异步刷脏页到磁盘</li>\n</ol>\n<h4 id=\"redo-log-文件的大小是固定的吗？\"><a href=\"#redo-log-文件的大小是固定的吗？\" class=\"headerlink\" title=\"redo log 文件的大小是固定的吗？\"></a>redo log 文件的大小是固定的吗？</h4><p><code>redo log</code> 文件是固定大小的，通常配置为一组文件，使用<strong>环形方式</strong>写入，旧的日志会在空间需要时被覆盖。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613162534.png\" alt=\"20250613162534\"><br>命名方式为 ib_logfile0、iblogfile1、、、iblogfilen。默认 2 个文件，每个文件大小为 48MB。<br>可以通过 <code>show variables like &#39;innodb_log_file_size&#39;;</code> 查看 redo log 文件的大小；通过 <code>show variables like &#39;innodb_log_files_in_group&#39;;</code> 查看 redo log 文件的数量。</p>\n<h4 id=\"说一说WAL\"><a href=\"#说一说WAL\" class=\"headerlink\" title=\"说一说WAL?\"></a>说一说WAL?</h4><pre><code>WAL——Write-Ahead Logging。\n</code></pre>\n<p>预写日志是 InnoDB <strong>实现事务持久化的核心机制</strong>，它的思想是：<strong>先写日志再刷磁盘</strong>。<br>即在修改数据页之前，先将修改记录写入 <code>Redo Log</code>。<br>这样的话，即使数据页尚未写入磁盘，系统崩溃时也能通过 Redo Log 恢复数据。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250613163109.png\" alt=\"20250613163109\"><br>—-这部分是帮助理解 start，面试中可不背—-<br><strong>解释一下为什么需要 WAL：</strong><br>数据最终是要写入磁盘的，<strong>但磁盘 IO 很慢</strong>；<br>如果每次更新都立刻把数据页刷盘，性能很差；<br>如果还没写入磁盘就宕机，事务会丢失。<br>WAL 的好处是更新时不直接写数据页，而是先写一份变更记录到 redo log，后台再慢慢把真正的数据页刷盘，一举多得。<br>—-这部分是帮助理解 end，面试中可不背—-</p>\n<h3 id=\"29-binlog-和-redo-log-有什么区别？\"><a href=\"#29-binlog-和-redo-log-有什么区别？\" class=\"headerlink\" title=\"29.binlog 和 redo log 有什么区别？\"></a>29.binlog 和 redo log 有什么区别？</h3><p><code>binlog</code> 由 MySQL 的 Server 层实现，与存储引擎无关；<code>redo log</code> 由 InnoDB 存储引擎实现。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616091040.png\" alt=\"20250616091040\"></p>\n<p><code>binlog</code> 记录的是<strong>逻辑日志</strong>，包括原始的 SQL 语句或者行数据变化，例如“将 id&#x3D;2 这行数据的 age 字段+1”。<br><code>redo log</code> 记录<strong>物理日志</strong>，即数据页的具体修改，例如“将 page_id&#x3D;123 上 offset&#x3D;0x40 的数据从 18 修改为 26”。<br><code>binlog</code> 是<strong>追加写入</strong>的，文件写满后会新建文件继续写入，不会覆盖历史日志，保存的是全量操作记录；<code>redo log</code> 是<strong>循环写入</strong>的，空间是固定的，写满后会覆盖旧的日志，仅保存未刷盘的脏页日志，已持久化的数据会被清除。<br>另外，为保证两种日志的一致性，<code>innodb</code> 采用了<strong>两阶段提交策略</strong>，<code>redo log</code> 在事务执行过程中持续写入，并在事务提交前进入 prepare 状态；<code>binlog</code> 在<strong>事务提交的最后阶段写入</strong>，之后 redo log 会被标记为 commit 状态。<br>可以通过回放 <code>binlog</code> <strong>实现数据同步或者恢复到指定时间点</strong>；<code>redo log</code> 用来确保事务提交后即使系统宕机，数据仍然可以通过重放 <code>redo log</code> 恢复。</p>\n<h3 id=\"30-为什么要两阶段提交\"><a href=\"#30-为什么要两阶段提交\" class=\"headerlink\" title=\"30.为什么要两阶段提交?\"></a>30.为什么要两阶段提交?</h3><p>为了保证 redo log 和 binlog 中的数据一致性，防止主从复制和事务状态不一致。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616093841.png\" alt=\"20250616093841\"></p>\n<h4 id=\"为什么-2PC-能保证-redo-log-和-binlog-的强⼀致性？\"><a href=\"#为什么-2PC-能保证-redo-log-和-binlog-的强⼀致性？\" class=\"headerlink\" title=\"为什么 2PC 能保证 redo log 和 binlog 的强⼀致性？\"></a>为什么 2PC 能保证 redo log 和 binlog 的强⼀致性？</h4><p>假如 MySQL 在预写 redo log 之后、写入 binlog 之前崩溃。那么 MySQL 重启后 InnoDB 会回滚该事务，因为 redo log 不是提交状态。并且由于 binlog 中没有写入数据，所以从库也不会有该事务的数据。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616093925.png\" alt=\"20250616093925\"></p>\n<p>假如 MySQL 在写入 binlog 之后、redo log 提交之前崩溃。那么 MySQL 重启后 InnoDB 会提交该事务，因为 redo log 是提交状态。并且由于 binlog 中有写入数据，所以从库也会同步到该事务的数据。<br>伪代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 事务开始</span></span><br><span class=\"line\">begin;</span><br><span class=\"line\"><span class=\"comment\">// try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行 SQL</span></span><br><span class=\"line\">    execute SQL;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 写入 redo log 并标记为 prepare</span></span><br><span class=\"line\">    write redo log prepare xid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 写入 binlog</span></span><br><span class=\"line\">    write binlog xid sql;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 提交 redo log</span></span><br><span class=\"line\">    commit redo log xid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// catch</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 回滚 redo log</span></span><br><span class=\"line\">    innodb rollback redo log xid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 事务结束</span></span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"XID-了解吗？\"><a href=\"#XID-了解吗？\" class=\"headerlink\" title=\"XID 了解吗？\"></a>XID 了解吗？</h4><p>XID 是 binlog 中用来<strong>标识事务提交</strong>的唯一标识符。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616094148.png\" alt=\"20250616094148\"></p>\n<p>在事务提交时，会写入一个 <code>XID_EVENT</code> 到 <code>binlog</code>，表示这个事务真正完成了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  Log_name         | Pos  | Event_type     | Server_id | End_log_pos | Info      </span><br><span class=\"line\">| mysql-bin<span class=\"number\">.000003</span> | <span class=\"number\">2005</span> | Gtid           |   <span class=\"number\">1013307</span> |        <span class=\"number\">2070</span> | SET @<span class=\"meta\">@SESSION</span>.GTID_NEXT= <span class=\"string\">&#x27;f971d5f1-d450-11ec-9e7b-5254000a56df:11&#x27;</span>                 |</span><br><span class=\"line\">| mysql-bin<span class=\"number\">.000003</span> | <span class=\"number\">2070</span> | Query          |   <span class=\"number\">1013307</span> |        <span class=\"number\">2142</span> | BEGIN                                                                              |</span><br><span class=\"line\">| mysql-bin<span class=\"number\">.000003</span> | <span class=\"number\">2142</span> | Table_map      |   <span class=\"number\">1013307</span> |        <span class=\"number\">2187</span> | table_id: <span class=\"number\">109</span> (test.t1)                                                            |</span><br><span class=\"line\">| mysql-bin<span class=\"number\">.000003</span> | <span class=\"number\">2187</span> | Write_rows     |   <span class=\"number\">1013307</span> |        <span class=\"number\">2227</span> | table_id: <span class=\"number\">109</span> flags: STMT_END_F                                                    |</span><br><span class=\"line\">| mysql-bin<span class=\"number\">.000003</span> | <span class=\"number\">2227</span> | Xid            |   <span class=\"number\">1013307</span> |        <span class=\"number\">2258</span> | COMMIT <span class=\"comment\">/* xid=121 */</span></span><br></pre></td></tr></table></figure>\n<p>它不仅用于<strong>主从复制中事务完整性的判断</strong>，也在<strong>崩溃恢复中对 redo log 和 binlog 的一致性校验</strong>起到关键作用。</p>\n<p>XID 可以帮助 MySQL 判断哪些 redo log 是已提交的，哪些是未提交需要回滚的，是两阶段提交机制中非常关键的一环。</p>\n<h3 id=\"31-redo-log-的写入过程了解吗？\"><a href=\"#31-redo-log-的写入过程了解吗？\" class=\"headerlink\" title=\"31.redo log 的写入过程了解吗？\"></a>31.redo log 的写入过程了解吗？</h3><p>InnoDB 会先将 Redo Log 写入内存中的 Redo Log Buffer，之后再以一定的频率刷入到磁盘的 Redo Log File 中。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616101033.png\" alt=\"20250616101033\"></p>\n<h4 id=\"哪些场景会触发-redo-log-的刷盘动作？\"><a href=\"#哪些场景会触发-redo-log-的刷盘动作？\" class=\"headerlink\" title=\"哪些场景会触发 redo log 的刷盘动作？\"></a>哪些场景会触发 redo log 的刷盘动作？</h4><p>比如说 <strong>Redo Log Buffer 的空间不足时</strong>，<strong>事务提交时</strong>，<strong>触发 Checkpoint 时</strong>，后台线程定期刷盘时。<br>不过，Redo Log Buffer 刷盘到 Redo Log File 还会涉及到操作系统的磁盘缓存策略，可能不会立即刷盘，而是等待一定时间后才刷盘。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616110133.png\" alt=\"20250616110133\"></p>\n<h4 id=\"innodb-flush-log-at-trx-commit-参数你了解多少？\"><a href=\"#innodb-flush-log-at-trx-commit-参数你了解多少？\" class=\"headerlink\" title=\"innodb_flush_log_at_trx_commit 参数你了解多少？\"></a>innodb_flush_log_at_trx_commit 参数你了解多少？</h4><p><code>innodb_flush_log_at_trx_commit</code> 参数是用来控制事务提交时，Redo Log 的刷盘策略，一共有三种。</p>\n<p>0 表示<strong>事务提交时不刷盘</strong>，而是<strong>交给后台线程每隔 1 秒执行一次</strong>。这种方式性能最好，但是在 MySQL 宕机时<strong>可能会丢失一秒内的事务</strong>。</p>\n<p>1 表示<strong>事务提交时会立即刷盘</strong>，确保事务提交后数据就持久化到磁盘。这<strong>种方式是最安全的，也是 InnoDB 的默认值</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616112123.png\" alt=\"20250616112123\"></p>\n<p>2 表示事务提交时只把 Redo Log Buffer 写入到 Page Cache，由操作系统决定什么时候刷盘。<strong>操作系统宕机时，可能会丢失一部分数据。</strong></p>\n<h4 id=\"一个没有提交事务的-redo-log，会不会刷盘？\"><a href=\"#一个没有提交事务的-redo-log，会不会刷盘？\" class=\"headerlink\" title=\"一个没有提交事务的 redo log，会不会刷盘？\"></a>一个没有提交事务的 redo log，会不会刷盘？</h4><p>InnoDB 有一个后台线程，每隔 1 秒会把<code>Redo Log Buffer</code>中的日志写入到文件系统的缓存中，然后调用刷盘操作。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113040.png\" alt=\"20250616113040\"></p>\n<p>因此，一个没有提交事务的 Redo Log 也可能会被刷新到磁盘中。<br>另外，如果当 <code>Redo Log Buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 的一半时，也会触发刷盘操作。</p>\n<h4 id=\"Redo-Log-Buffer-是顺序写还是随机写？\"><a href=\"#Redo-Log-Buffer-是顺序写还是随机写？\" class=\"headerlink\" title=\"Redo Log Buffer 是顺序写还是随机写？\"></a>Redo Log Buffer 是顺序写还是随机写？</h4><p>MySQL 在启动后会向操作系统申请一块连续的内存空间作为 Redo Log Buffer，并将其分为若干个连续的 Redo Log Block。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113305.png\" alt=\"20250616113305\"><br>那为了提高写入效率，Redo Log Buffer 采用了顺序写入的方式，会先往前面的 Redo Log Block 中写入，当写满后再往后面的 Block 中写入。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113328.png\" alt=\"20250616113328\"><br>于此同时，InnoDB 还提供了一个全局变量 <code>buf_free</code>，来控制后续的 redo log 记录应该写入到 block 中的哪个位置。</p>\n<h4 id=\"buf-next-to-write-了解吗？\"><a href=\"#buf-next-to-write-了解吗？\" class=\"headerlink\" title=\"buf_next_to_write 了解吗？\"></a>buf_next_to_write 了解吗？</h4><p><code>buf_next_to_write</code> 指向 Redo Log Buffer 中下一次需要写入硬盘的起始位置。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616113533.png\" alt=\"20250616113533\"><br>而 buf_free 指向的是 Redo Log Buffer 中空闲区域的起始位置。</p>\n<h4 id=\"了解-MTR-吗？\"><a href=\"#了解-MTR-吗？\" class=\"headerlink\" title=\"了解 MTR 吗？\"></a>了解 MTR 吗？</h4><p><code>Mini Transaction </code>是 InnoDB 内部用于操作数据页的原子操作单元。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mtr_t mtr;</span><br><span class=\"line\">mtr_start(&amp;mtr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 加锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对待访问的index加锁</span></span><br><span class=\"line\">mtr_s_lock(rw_lock_t, mtr);</span><br><span class=\"line\">mtr_x_lock(rw_lock_t, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对待读写的page加锁</span></span><br><span class=\"line\">mtr_memo_push(mtr, buf_block_t, MTR_MEMO_PAGE_S_FIX);</span><br><span class=\"line\">mtr_memo_push(mtr, buf_block_t, MTR_MEMO_PAGE_X_FIX);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 访问或修改page</span></span><br><span class=\"line\">btr_cur_search_to_nth_level</span><br><span class=\"line\">btr_cur_optimistic_insert</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 为修改操作生成redo</span></span><br><span class=\"line\">mlog_open</span><br><span class=\"line\">mlog_write_initial_log_record_fast</span><br><span class=\"line\">mlog_close</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 持久化redo，解锁</span></span><br><span class=\"line\">mtr_commit(&amp;mtr);</span><br></pre></td></tr></table></figure>\n<p>多个事务的 Redo Log 会以 MTR 为单位交替写入到 Redo Log Buffer 中，假如事务 1 和事务 2 均有两个 MTR，一旦某个 MTR 结束，就会将其生成的若干条 Redo Log 记录顺序写入到 Redo Log Buffer 中。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616151955.png\" alt=\"20250616151955\"></p>\n<p>也就是说，一个 MTR 会包含一组 Redo Log 记录，是 MySQL 崩溃后恢复事务的最小执行单元。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616154016.png\" alt=\"20250616154016\"></p>\n<h4 id=\"Redo-Log-Block-的结构了解吗？\"><a href=\"#Redo-Log-Block-的结构了解吗？\" class=\"headerlink\" title=\"Redo Log Block 的结构了解吗？\"></a>Redo Log Block 的结构了解吗？</h4><p><code>Redo Log Block</code> 由日志头、日志体和日志尾组成，一共占用 512 个字节，其中日志头占用 12 个字节，日志尾占用 4 个字节，剩余的 496 个字节用于存储日志体。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616154915.png\" alt=\"20250616154915\"><br>日志头包含了当前 Block 的序列号、第一条日志的序列号、类型等信息。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616154950.png\" alt=\"20250616154950\"><br>日志尾主要存储的是 LOG_BLOCK_CHECKSUM，也就是 Block 的校验和，主要用于判断 Block 是否完整。</p>\n<h4 id=\"Redo-Log-Block-为什么设计成-512-字节？\"><a href=\"#Redo-Log-Block-为什么设计成-512-字节？\" class=\"headerlink\" title=\"Redo Log Block 为什么设计成 512 字节？\"></a>Redo Log Block 为什么设计成 512 字节？</h4><p>因为机械硬盘的物理扇区大小通常为 512 字节，<code>Redo Log Block</code> 也设计为同样的大小，就可以确保每次写入都是整数个扇区，减少对齐开销。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616155054.png\" alt=\"20250616155054\"></p>\n<p>比如说操作系统的页缓存默认为 4KB，8 个 Redo Log Block 就可以组合成一个页缓存单元，从而提升 Redo Log Buffer 的写入效率。</p>\n<h4 id=\"LSN-了解吗？\"><a href=\"#LSN-了解吗？\" class=\"headerlink\" title=\"LSN 了解吗？\"></a>LSN 了解吗？</h4><p>Log Sequence Number 是一个 8 字节的单调递增整数，用来标识事务写入 redo log 的字节总量，存在于 redo log、数据页头部和 checkpoint 中。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616160916.png\" alt=\"20250616160916\"></p>\n<p>—-这部分是帮助理解 start，面试中可不背—-<br>MySQL 在第一次启动时，LSN 的初始值并不为 0，而是 8704；当 MySQL 再次启动时，会继续使用上一次服务停止时的 LSN。</p>\n<p>在计算 LSN 的增量时，<strong>不仅需要考虑 log block body 的大小，还需要考虑 log block header 和 log block tail 中部分字节数</strong>。</p>\n<p>比如说在上图中，事务 3 的 MTR 总量为 300 字节，那么写入到 Redo Log Buffer 中的 LSN 会增长为 8704 + 300 + 12 &#x3D; 9016。</p>\n<p>假如事务 4 的 MTR 总量为 900 字节，那么再次写入到 Redo Log Buffer 中的 LSN 会增长为 9016 + 900 + 12<em>2 + 4</em>2 &#x3D; 9948。</p>\n<p>2 个 12 字节的 log block header + 2 个 4 字节的 log block tail。</p>\n<p>—-这部分是帮助理解 end，面试中可不背—-</p>\n<p><strong>核心作用有三个：</strong></p>\n<p>第一，<code>redo log</code> 按照 LSN 递增顺序记录所有数据的修改操作。LSN 的递增量等于每次写入日志的字节数。</p>\n<p>第二，InnoDB 的每个数据页头部中，都会记录该页最后一次刷新到磁盘时的 LSN。如果数据页的 LSN 小于 redo log 的 LSN，说明该页需要从日志中恢复；否则说明该页已更新。</p>\n<p>第三，checkpoint 通过 LSN 记录已刷新到磁盘的数据页位置，减少恢复时需要处理的日志。</p>\n<p>—-这部分是帮助理解 start，面试中可不背—-<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616162021.png\" alt=\"20250616162021\"></p>\n<p>可以通过 <code>show engine innodb status;</code> 查看当前的 LSN 信息。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616162445.png\" alt=\"20250616162445\"></p>\n<ul>\n<li>Log sequence number：当前系统最大 LSN（已生成的日志总量）。</li>\n<li>Log flushed up to：已写入磁盘的 redo log LSN。</li>\n<li>Pages flushed up to：已刷新到数据页的 LSN。</li>\n<li>Last checkpoint at：最后一次检查点的 LSN，表示已持久化的数据状态。</li>\n</ul>\n<p>—-这部分是帮助理解 end，面试中可不背—-</p>\n<h4 id=\"Checkpoint-了解多少？\"><a href=\"#Checkpoint-了解多少？\" class=\"headerlink\" title=\"Checkpoint 了解多少？\"></a>Checkpoint 了解多少？</h4><p><code>Checkpoint </code>是 InnoDB 为了保证事务持久性和回收 redo log 空间的一种机制。</p>\n<p>它的作用是在合适的时机将部分脏页刷入磁盘，比如说 buffer pool 的容量不足时。并记录当前 <code>LSN</code> 为 <code>Checkpoint LSN</code>，表示这个位置之前的 redo log file 已经安全，可以被覆盖了。</p>\n<p>MySQL 崩溃恢复时只需要从 Checkpoint 之后开始恢复 redo log 就可以了，这样可以最大程度减少恢复所花费的时间。</p>\n<p>redo log file 的写入是循环的，其中有两个标记位置非常重要，也就是 Checkpoint 和 write pos。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616162937.png\" alt=\"20250616162937\"></p>\n<p>write pos 是 redo log 当前写入的位置，Checkpoint 是可以被覆盖的位置。</p>\n<p>当 write pos 追上 Checkpoint 时，表示 redo log 日志已经写满。这时候就要暂停写入并强制刷盘，释放可覆写的日志空间。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616163140.png\" alt=\"20250616163140\"></p>\n<h4 id=\"关于redo-log-的调优参数了解多少？\"><a href=\"#关于redo-log-的调优参数了解多少？\" class=\"headerlink\" title=\"关于redo log 的调优参数了解多少？\"></a>关于redo log 的调优参数了解多少？</h4><p>如果是<code>高并发写入</code>的电商系统，可以最大化写入吞吐量，容忍秒级数据丢失的风险。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">innodb_flush_log_at_trx_commit = <span class=\"number\">2</span></span><br><span class=\"line\">sync_binlog = <span class=\"number\">1000</span></span><br><span class=\"line\">innodb_redo_log_capacity = 64<span class=\"type\">G</span></span><br><span class=\"line\"><span class=\"variable\">innodb_io_capacity</span> <span class=\"operator\">=</span> <span class=\"number\">5000</span></span><br><span class=\"line\">innodb_lru_scan_depth = <span class=\"number\">512</span></span><br><span class=\"line\">innodb_log_buffer_size = 256M</span><br></pre></td></tr></table></figure>\n<p>如果是金融交易系统，需要<code>保证数据零丢失</code>，接受较低的吞吐量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">innodb_flush_log_at_trx_commit = <span class=\"number\">1</span></span><br><span class=\"line\">sync_binlog = <span class=\"number\">1</span></span><br><span class=\"line\">innodb_redo_log_capacity = 32<span class=\"type\">G</span></span><br><span class=\"line\"><span class=\"variable\">innodb_io_capacity</span> <span class=\"operator\">=</span> <span class=\"number\">2000</span></span><br><span class=\"line\">innodb_lru_scan_depth = <span class=\"number\">1024</span></span><br></pre></td></tr></table></figure>\n<p>核心参数一览表:<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250616163309.png\" alt=\"20250616163309\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>对数据一致性要求高的场景，如金融交易使用innodb_flush_log_at_trx_commit&#x3D;1，对写入吞吐量敏感的场景，如日志采集可以使用 &#x3D;2 或 &#x3D;0，需要结合 sync_binlog 参数</li>\n<li>sync_binlog 参数控制 binlog 的刷盘策略，可以设置为 0、1、N，0 表示依赖系统刷盘，1 表示每次事务提交都刷盘（推荐与 innodb_flush_log_at_trx_commit&#x3D;1 搭配），N&#x3D;1000 表示累计 1000 次事务后刷盘</li>\n<li>innodb_redo_log_capacity 动态调整 Redo Log 总容量，可以根据业务负载情况调整，建议设置为 1 小时写入量的峰值（如每秒 10MB 写入则设为 36GB）</li>\n<li>innodb_io_capacity 定义 InnoDB 后台线程的每秒 I&#x2F;O 操作上限，直接影响脏页刷新速率；机械硬盘建议 200-500，SSD 建议 1000-2000，NVMe SSD 可设为 5000+</li>\n<li>innodb_lru_scan_depth 控制每个缓冲池实例中 LRU 列表的扫描深度，决定每秒可刷新的脏页数量，默认值 1024 适用于多数场景，I&#x2F;O 密集型负载可适当降低（如 512），减少 CPU 开销。</li>\n</ul>\n<h2 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h2><h3 id=\"🌟32-什么是慢-SQL？\"><a href=\"#🌟32-什么是慢-SQL？\" class=\"headerlink\" title=\"🌟32.什么是慢 SQL？\"></a>🌟32.什么是慢 SQL？</h3><p>拓展阅读: <a href=\"https://juejin.cn/post/7048974570228809741\">https://juejin.cn/post/7048974570228809741</a><br>MySQL 中有一个叫<code>long_query_time</code>的参数，原则上执行时间超过该参数值的 SQL 就是慢 SQL，会被记录到<strong>慢查询日志</strong>中。</p>\n<p>—-这部分是帮助理解 start，面试中可不背—-</p>\n<p>可通过 show variables like ‘long_query_time’; 查看当前的 long_query_time 的参数值。<br>—-这部分是帮助理解 end，面试中可不背—-</p>\n<h4 id=\"SQL-的执行过程了解吗？\"><a href=\"#SQL-的执行过程了解吗？\" class=\"headerlink\" title=\"SQL 的执行过程了解吗？\"></a>SQL 的执行过程了解吗？</h4><p>SQL 的执行过程大致可以分为六个阶段：<strong>连接管理</strong>、<strong>语法解析</strong>、<strong>语义分析</strong>、<strong>查询优化</strong>、<strong>执行器调度</strong>、<strong>存储引擎读写</strong>等。Server 层负责理解和规划 SQL 怎么执行，存储引擎层负责数据的真正读写。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250617154612.png\" alt=\"20250617154612\"></p>\n<p>—-这部分是帮助理解 start，面试中可不背—-</p>\n<p>来详细拆解一下：</p>\n<ol>\n<li>客户端发送 SQL 语句给 MySQL 服务器。</li>\n<li>如果查询缓存打开则会优先查询缓存，缓存中有对应的结果就直接返回。不过，MySQL 8.0 已经移除了查询缓存。这部分的功能正在被 Redis 等缓存中间件取代。</li>\n<li>分析器对 SQL 语句进行语法分析，判断是否有语法错误。</li>\n<li>搞清楚 SQL 语句要干嘛后，MySQL 会通过优化器生成执行计划。</li>\n<li>执行器调用存储引擎的接口，执行 SQL 语句。</li>\n</ol>\n<p>SQL 执行过程中，优化器通过成本计算预估出执行效率最高的方式，基本的预估维度为：</p>\n<ul>\n<li>IO 成本：从磁盘读取数据到内存的开销。</li>\n<li>CPU 成本：CPU 处理内存中数据的开销。</li>\n</ul>\n<p>基于这两个维度，可以得出影响 SQL 执行效率的因素有：</p>\n<p>①、<strong>IO 成本，数据量越大，IO 成本越高</strong>。所以要尽量查询必要的字段；尽量分页查询；尽量通过索引加快查询。</p>\n<p>②、<strong>CPU 成本</strong>，尽量避免复杂的查询条件，如有必要，考虑对子查询结果进行过滤。</p>\n<p>—-这部分是帮助理解 end，面试中可不背—-</p>\n<h4 id=\"如何优化慢SQL\"><a href=\"#如何优化慢SQL\" class=\"headerlink\" title=\"如何优化慢SQL?\"></a>如何优化慢SQL?</h4><p>首先，需要找到那些比较慢的 SQL，可以通过启用慢查询日志，记录那些超过指定执行时间的 SQL 查询。</p>\n<p>也可以使用 <code>show processlist;</code> 命令查看当前正在执行的 SQL 语句，找出执行时间较长的 SQL。</p>\n<p>或者在业务基建中加入对慢 SQL 的监控，常见的方案有字节码插桩、连接池扩展、ORM 框架扩展等。</p>\n<p>然后，使用 EXPLAIN 查看慢 SQL 的执行计划，看看有没有用索引，大部分情况下，慢 SQL 的原因都是因为没有用到索引。</p>\n<p><code>EXPLAIN SELECT * FROM your_table WHERE conditions;</code><br>最后，根据分析结果，通过<strong>添加索引</strong>、<strong>优化查询条件</strong>、<strong>减少返回字段</strong>等方式进行优化。</p>\n<h4 id=\"慢sql日志怎么开启？\"><a href=\"#慢sql日志怎么开启？\" class=\"headerlink\" title=\"慢sql日志怎么开启？\"></a>慢sql日志怎么开启？</h4><p>编辑 MySQL 的配置文件 <code>my.cnf</code>，设置 <code>slow_query_log</code> 参数为 1。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slow_query_log <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\">slow_query_log_file <span class=\"operator\">=</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>log<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>slow.log</span><br><span class=\"line\">long_query_time <span class=\"operator\">=</span> <span class=\"number\">2</span>  # 记录执行时间超过<span class=\"number\">2</span>秒的查询</span><br></pre></td></tr></table></figure>\n<p>然后重启 MySQL 就好了。</p>\n<p>也可以通过 set global 命令动态设置。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> slow_query_log <span class=\"operator\">=</span> <span class=\"string\">&#x27;ON&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> slow_query_log_file <span class=\"operator\">=</span> <span class=\"string\">&#x27;/var/log/mysql/slow.log&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> long_query_time <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🌟33-你知道哪些方法来优化-SQL？\"><a href=\"#🌟33-你知道哪些方法来优化-SQL？\" class=\"headerlink\" title=\"🌟33.你知道哪些方法来优化 SQL？\"></a>🌟33.你知道哪些方法来优化 SQL？</h3><p>SQL 优化的方法非常多，但本质上就一句话：<strong>尽可能少地扫描、尽快地返回结果。</strong><br>最常见的做法就是<strong>加索引</strong>、改写 SQL 让它用上索引，比如说使用覆盖索引、让联合索引遵守最左前缀原则等。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618110546.png\" alt=\"20250618110546\"></p>\n<h4 id=\"如何利用覆盖索引？\"><a href=\"#如何利用覆盖索引？\" class=\"headerlink\" title=\"如何利用覆盖索引？\"></a>如何利用覆盖索引？</h4><p>覆盖索引的核心是“<strong>查询所需的字段都在同一个索引里</strong>”，这样 MySQL 就不需要回表，直接从索引中返回结果。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618110821.png\" alt=\"20250618110821\"></p>\n<p>实际使用中，我会优先考虑把 <code>WHERE</code> 和 <code>SELECT</code> 涉及的字段一起建联合索引，并通过 <code>EXPLAIN</code> 观察结果是否有 <code>Using index</code>，确认命中索引。</p>\n<p>—-这部分是帮助理解 start，面试中可不背—-</p>\n<p>举个例子，现在要从 <code>test</code> 表中查询 <code>city</code> 为上海的 name 字段。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> test <span class=\"keyword\">where</span> city<span class=\"operator\">=</span><span class=\"string\">&#x27;上海&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>如果仅在 city 字段上添加索引，那么这条查询语句会先通过索引找到 city 为上海的行，然后再回表查询 name 字段。</p>\n<p>为了避免回表查询，可以在 city 和 name 字段上建立联合索引，这样查询结果就可以直接从索引中获取。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter table</span> test <span class=\"keyword\">add</span> index index1(city,name);</span><br></pre></td></tr></table></figure>\n<p>相当于利用空间换时间,把查询结果都放到了索引里,不需要回表查询。<br>—-这部分是帮助理解 end，面试中可不背—-</p>\n<h4 id=\"如何正确使用联合索引？\"><a href=\"#如何正确使用联合索引？\" class=\"headerlink\" title=\"如何正确使用联合索引？\"></a>如何正确使用联合索引？</h4><p>使用联合索引最重要的一条是<strong>遵守最左前缀原则，也就是查询条件需要从索引的左侧字段开始</strong>。</p>\n<p>—-这部分是帮助理解 start，面试中可不背—-<br>比如说我们创建了一个三列的联合索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_name_age_sex <span class=\"keyword\">ON</span> <span class=\"keyword\">user</span>(name, age, sex);</span><br></pre></td></tr></table></figure>\n<p>我们来看一下什么样的查询条件可以用到这个索引：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618111513.png\" alt=\"20250618111513\"><br>—-这部分是帮助理解 end，面试中可不背—-</p>\n<h4 id=\"如何进行分页优化？\"><a href=\"#如何进行分页优化？\" class=\"headerlink\" title=\"如何进行分页优化？\"></a>如何进行分页优化？</h4><p>分页优化的核心是<strong>避免深度偏移(Deep Offset)带来的全表扫描</strong>，可以通过两种方式来优化：<strong>延迟关联和添加书签</strong>。</p>\n<p><strong>延迟关联</strong>适用于需要<strong>从多个表中获取数据且主表行数较多的情况</strong>。<br>它首先从索引表中检索出需要的行 ID，然后再根据这些 ID 去关联其他的表获取详细信息。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> e.id, e.name, d.details</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees e</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> department d <span class=\"keyword\">ON</span> e.department_id <span class=\"operator\">=</span> d.id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> e.id</span><br><span class=\"line\">LIMIT <span class=\"number\">1000</span>, <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<p>延迟关联后，第一步只查主键，速度快，第二步只处理 20 条数据，效率高。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> e.id, e.name, d.details</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> id</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\">    <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> id</span><br><span class=\"line\">    LIMIT <span class=\"number\">1000</span>, <span class=\"number\">20</span></span><br><span class=\"line\">) <span class=\"keyword\">AS</span> sub</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> sub.id <span class=\"operator\">=</span> e.id</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> department d <span class=\"keyword\">ON</span> e.department_id <span class=\"operator\">=</span> d.id;</span><br></pre></td></tr></table></figure>\n\n<p><strong>添加书签</strong>的方式是通过<strong>记住上一次查询返回的最后一行主键值</strong>，然后在下一次查询的时候从这个值开始，从而跳过偏移量计算，仅扫描目标数据，<strong>适合翻页、资讯流</strong>等场景。</p>\n<p>假设需要对用户表进行分页。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> id, name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> id</span><br><span class=\"line\">LIMIT <span class=\"number\">1000</span>, <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<p>通过添加书签来优化后，查询不再使用OFFSET，而是从上一页最后一个用户的 ID 开始查询。这种方法可以有效避免不必要的数据扫描，提高了分页查询的效率。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> id, name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">&gt;</span> last_max_id  <span class=\"comment\">-- 假设last_max_id是上一页最后一行的ID</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> id</span><br><span class=\"line\">LIMIT <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"为什么分页会变慢？\"><a href=\"#为什么分页会变慢？\" class=\"headerlink\" title=\"为什么分页会变慢？\"></a>为什么分页会变慢？</h4><p>分页查询的效率问题主要是由于 <code>OFFSET</code> 的存在，<code>OFFSET</code> 会导致 MySQL <strong>必须扫描和跳过 offset + limit 条数据</strong>，这个过程是非常耗时的。</p>\n<p>比如说，我们要查询第 100000 条数据，那么 MySQL 就必须扫描 100000 条数据，然后再返回 10 条数据。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> id LIMIT <span class=\"number\">100000</span>, <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>数据越多、偏移越大，就越慢！</p>\n<h4 id=\"JOIN-代替子查询有什么好处？\"><a href=\"#JOIN-代替子查询有什么好处？\" class=\"headerlink\" title=\"JOIN 代替子查询有什么好处？\"></a>JOIN 代替子查询有什么好处？</h4><p>第一，JOIN 的 ON 条件能<strong>更直接地触发索引</strong>，而<strong>子查询可能因嵌套导致索引失效</strong>。<br>第二，JOIN 的<strong>一次连接操作替代了子查询的多次重复执行</strong>，尤其在大数据量的情况下性能差异明显。</p>\n<p>—-这部分是帮助理解 start，面试中可不背—-</p>\n<p>比如说我们有两个表 orders 和 customers。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> orders (</span><br><span class=\"line\">    order_id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    customer_id <span class=\"type\">INT</span>,</span><br><span class=\"line\">    amount <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>),</span><br><span class=\"line\">    INDEX idx_customer_id (customer_id)  <span class=\"comment\">-- customer_id字段有索引</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> customers (</span><br><span class=\"line\">    customer_id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    name <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>子查询的写法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> o.order_id, o.amount, </span><br><span class=\"line\">       (<span class=\"keyword\">SELECT</span> c.name </span><br><span class=\"line\">        <span class=\"keyword\">FROM</span> customers c </span><br><span class=\"line\">        <span class=\"keyword\">WHERE</span> c.customer_id <span class=\"operator\">=</span> o.customer_id) <span class=\"keyword\">AS</span> customer_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> orders o;</span><br></pre></td></tr></table></figure>\n<p>JOIN 的写法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> o.order_id, o.amount, c.name <span class=\"keyword\">AS</span> customer_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> orders o</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> customers c <span class=\"keyword\">ON</span> o.customer_id <span class=\"operator\">=</span> c.customer_id;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618140806.png\" alt=\"20250618140806\"></p>\n<p><strong>对于子查询，执行流程是这样的：</strong></p>\n<ul>\n<li>外层 orders 表的每一行都会触发一次子查询。</li>\n<li>如果 orders 表有 1000 条记录，则子查询会执行 1000 次。</li>\n<li>每次子查询都需要单独查询 customers 表（即使 customer_id 相同）。</li>\n</ul>\n<p><strong>而 JOIN 的执行流程是这样的：</strong></p>\n<ul>\n<li>数据库优化器会将两张表的连接操作合并为一次执行。</li>\n<li>通过索引（如 orders.customer_id 和 customers.customer_id）快速关联数据。</li>\n<li>仅执行一次关联操作，而非多次子查询。<br>来看一下子查询的执行计划：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> o.order_id, </span><br><span class=\"line\">               (<span class=\"keyword\">SELECT</span> c.name <span class=\"keyword\">FROM</span> customers c <span class=\"keyword\">WHERE</span> c.customer_id <span class=\"operator\">=</span> o.customer_id) </span><br><span class=\"line\">        <span class=\"keyword\">FROM</span> orders o;</span><br></pre></td></tr></table></figure>\n<img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618142719.png\" alt=\"20250618142719\"><br>子查询（DEPENDENT SUBQUERY）类型表明其依赖外层查询的每一行，导致重复执行。</li>\n</ul>\n<p>再对比看一下 JOIN 的执行计划：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> o.order_id, </span><br><span class=\"line\">               (<span class=\"keyword\">SELECT</span> c.name <span class=\"keyword\">FROM</span> customers c <span class=\"keyword\">WHERE</span> c.customer_id <span class=\"operator\">=</span> o.customer_id) </span><br><span class=\"line\">        <span class=\"keyword\">FROM</span> orders o;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618142740.png\" alt=\"20250618142740\"><br>JOIN 通过 <code>eq_ref</code> 类型直接利用主键（customers.customer_id）快速关联，减少扫描次数。</p>\n<h4 id=\"JOIN操作为什么要小表驱动大表？\"><a href=\"#JOIN操作为什么要小表驱动大表？\" class=\"headerlink\" title=\"JOIN操作为什么要小表驱动大表？\"></a>JOIN操作为什么要小表驱动大表？</h4><ul>\n<li><p>第一，如果大表的 JOIN 字段有索引，那么小表的每一行都可以通过索引快速匹配大表。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618143231.png\" alt=\"20250618143231\"><br>时间复杂度为**小表行数 N 乘以大表索引查找复杂度 log(大表行数 M)**，总复杂度为 <code>N*log(M)</code>。<br>显然小表做驱动表比大表做驱动表的时间复杂度 <code>M*log(N)</code> 更低。</p>\n</li>\n<li><p>第二，如果大表没有索引，需要将小表的数据加载到内存，再全表扫描大表进行匹配。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618143445.png\" alt=\"20250618143445\"><br>时间复杂度为小表分段数 K 乘以大表行数 M，其中 K &#x3D; 小表行数 N &#x2F; 内存大小 join_buffer_size。<br>显然小表做驱动表的时候 K 的值更小，大表做驱动表的时候需要多次分段。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 小表驱动（高效）</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> small_table s</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> large_table l <span class=\"keyword\">ON</span> s.id <span class=\"operator\">=</span> l.id;  <span class=\"comment\">-- l.id有索引</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 大表驱动（低效）</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> large_table l</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> small_table s <span class=\"keyword\">ON</span> l.id <span class=\"operator\">=</span> s.id;  <span class=\"comment\">-- s.id无索引</span></span><br></pre></td></tr></table></figure></li>\n<li><p>当使用 left join 时，左表是驱动表，右表是被驱动表。</p>\n</li>\n<li><p>当使用 right join 时，刚好相反。</p>\n</li>\n<li><p>当使用 join 时，MySQL 会选择数据量比较小的表作为驱动表，大表作为被驱动表。</p>\n</li>\n</ul>\n<p>这里的小表指实际参与 JOIN 的数据量，而不是表的总行数。大表经过 where 条件过滤后也可能成为逻辑小表。<br>– <strong>实际参与JOIN的数据量决定小表</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> large_table l</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> small_table s <span class=\"keyword\">ON</span> l.id <span class=\"operator\">=</span> s.id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> l.created_at <span class=\"operator\">&gt;</span> <span class=\"string\">&#x27;2025-01-01&#x27;</span>;  <span class=\"comment\">-- l经过过滤后可能成为小表</span></span><br></pre></td></tr></table></figure>\n<p>也可以强制通过 <code>STRAIGHT_JOIN</code> 提示 MySQL 使用指定的驱动表。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explain <span class=\"keyword\">select</span> table_1.col1, table_2.col2, table_3.col2</span><br><span class=\"line\"><span class=\"keyword\">from</span> table_1</span><br><span class=\"line\">straight_join table_2 <span class=\"keyword\">on</span> table_1.col1<span class=\"operator\">=</span>table_2.col1</span><br><span class=\"line\">straight_join table_3 <span class=\"keyword\">on</span> table_1.col1 <span class=\"operator\">=</span> table_3.col1;</span><br><span class=\"line\"></span><br><span class=\"line\">explain <span class=\"keyword\">select</span> straight_join table_1.col1, table_2.col2, table_3.col2</span><br><span class=\"line\"><span class=\"keyword\">from</span> table_1</span><br><span class=\"line\"><span class=\"keyword\">join</span> table_2 <span class=\"keyword\">on</span> table_1.col1<span class=\"operator\">=</span>table_2.col1</span><br><span class=\"line\"><span class=\"keyword\">join</span> table_3 <span class=\"keyword\">on</span> table_1.col1 <span class=\"operator\">=</span> table_3.col1;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么要避免使用-JOIN-关联太多的表？\"><a href=\"#为什么要避免使用-JOIN-关联太多的表？\" class=\"headerlink\" title=\"为什么要避免使用 JOIN 关联太多的表？\"></a>为什么要避免使用 JOIN 关联太多的表？</h4><p>第一，多表 JOIN 的执行路径会随着表的数量<strong>呈现指数级增长</strong>，优化器需要估算所有路径的成本，有可能会导致出现大表驱动小表的情况。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> A</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> B <span class=\"keyword\">ON</span> A.id <span class=\"operator\">=</span> B.a_id</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> C <span class=\"keyword\">ON</span> B.id <span class=\"operator\">=</span> C.b_id</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> D <span class=\"keyword\">ON</span> C.id <span class=\"operator\">=</span> D.c_id</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> E <span class=\"keyword\">ON</span> D.id <span class=\"operator\">=</span> E.d_id;  <span class=\"comment\">-- 5 个表，优化器需评估 5! = 120 种顺序</span></span><br></pre></td></tr></table></figure>\n<p>第二，多表 JOIN 需要缓存中间结果集，可能超出 join_buffer_size，这种情况下内存临时表就会转为磁盘临时表，性能也会急剧下降。<br>《阿里巴巴 Java 开发手册》上就规定，不要使用 join 关联太多的表，<strong>最多不要超过 3 张表</strong>。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618151308.png\" alt=\"20250618151308\"></p>\n<h4 id=\"如何进行排序优化？\"><a href=\"#如何进行排序优化？\" class=\"headerlink\" title=\"如何进行排序优化？\"></a>如何进行排序优化？</h4><p>第⼀，<strong>对 ORDER BY 涉及的字段创建索引</strong>，避免 filesort。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 优化前（可能触发 filesort）</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> age <span class=\"keyword\">DESC</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 优化后（添加索引）</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> users <span class=\"keyword\">ADD</span> INDEX idx_age (age);</span><br></pre></td></tr></table></figure>\n<p>如果是多个字段，联合索引需要保证<strong>ORDER BY 的列是索引的最左前缀</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 联合索引需与 ORDER BY 顺序⼀致（age 在前，name 在后）</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> users <span class=\"keyword\">ADD</span> INDEX idx_age_name (age, name);</span><br><span class=\"line\"><span class=\"comment\">-- 有效利⽤索引的查询</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> age, name;</span><br><span class=\"line\"><span class=\"comment\">-- ⽆效案例（索引失效，因 name 在索引中排在 age 之后）</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> name, age;</span><br></pre></td></tr></table></figure>\n<p>第⼆，可以适当调整排序参数，如增⼤ <code>sort_buffer_size</code>、<code>max_length_for_sort_data </code>等，让排序在内存中完成。<br>—-这部分是帮助理解 start，⾯试中可不背—-</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250618152056.png\" alt=\"20250618152056\"></p>\n<ul>\n<li><code>sort_buffer_size</code>：用于控制排序缓冲区的大小，默认为 256KB。也就是说，如果排序的数据量小于 256KB，MySQL 会在内存中直接排序；否则就要在磁盘上进行 filesort。</li>\n<li><code>max_length_for_sort_data</code>：单行数据的最大长度，会影响排序算法选择。如果单行数据超过该值，MySQL 会使用双路排序，否则使用单路排序。</li>\n<li><code>max_sort_length</code>：限制字符串排序时比较的前缀长度。当 MySQL 不得不对 text、blob 字段进行排序时，会截取前 <code>max_sort_length</code> 个字符进行比较。<br>—-这部分是帮助理解 end，面试中可不背—-<br>第三，可以通过 where 和 limit 限制待排序的数据量，减少排序的开销。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 优化前</span><br><span class=\"line\">SELECT * FROM users ORDER BY age LIMIT <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 优化后（减少数据传输和排序开销）</span><br><span class=\"line\">SELECT id, name, age FROM users ORDER BY age LIMIT <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 深度分页优化（避免 OFFSET 扫描全表）</span><br><span class=\"line\">SELECT * FROM users ORDER BY age LIMIT <span class=\"number\">10000</span>, <span class=\"number\">20</span>;  -- 低效</span><br><span class=\"line\">SELECT * FROM users WHERE age &gt; last_age ORDER BY age LIMIT <span class=\"number\">20</span>;  -- 高效（记录上一页最后一条的 age 值）</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"什么是-filesort？\"><a href=\"#什么是-filesort？\" class=\"headerlink\" title=\"什么是 filesort？\"></a>什么是 filesort？</h4><p><a href=\"https://petrunia.net/2007/08/29/how-mysql-executes-order-by/\">Mysql如何执行ORDER BY</a></p>\n<p>当<strong>不能使用索引</strong>生成排序结果的时候，MySQL 需要自己进行排序，<strong>如果数据量比较小，会在内存中进行</strong>；如果数据量比较大就需要写临时文件到磁盘再排序，我们将这个过程称为<strong>文件排序</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095220.png\" alt=\"20250619095220\"></p>\n<p>—-这部分是帮助理解 start，面试中可不背—-<br>让我们来验证一下 filesort 的情况<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095335.png\" alt=\"20250619095335\"></p>\n<p>能够看得出来，当 order by id 也就是主键的时候，没有触发 filesort；当 order by age 的时候，由于没有索引，就触发了 filesort。<br>—-这部分是帮助理解 end，面试中可不背—-</p>\n<h4 id=\"全字段排序和-rowid-排序了解多少？\"><a href=\"#全字段排序和-rowid-排序了解多少？\" class=\"headerlink\" title=\"全字段排序和 rowid 排序了解多少？\"></a>全字段排序和 rowid 排序了解多少？</h4><p>当排序字段<strong>是索引字段且满足最左前缀原则时</strong>，MySQL 可以<strong>直接利用索引的有序性完成排序</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095617.png\" alt=\"20250619095617\"></p>\n<p>当无法使用索引排序时，MySQL <strong>需要在内存或磁盘中进行排序操作</strong>，分为<strong>全字段排序</strong>和 <strong>rowid 排序</strong>两种算法。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619095723.png\" alt=\"全字段排序\"><br>全字段排序会<strong>一次性取出满足条件行的所有字段</strong>，然后在 sort buffer 中进行排序，排序后直接返回结果，无需回表。</p>\n<p>以 <code>SELECT * FROM user WHERE name = &quot;王二&quot; ORDER BY age</code> 为例：</p>\n<p>从 name 索引中找到第一个满足 name&#x3D;’张三’ 的主键 id；<br>根据主键 id 取出整行所有的字段，存入 sort buffer；<br>重复上述过程直到处理完所有满足条件的行<br>对 sort buffer 中的数据按 age 排序，返回结果。</p>\n<ul>\n<li>优点是<strong>仅需要一次磁盘 IO</strong></li>\n<li>缺点是<strong>内存占用大</strong>，如果数量超过 sort buffer 的话，需要分片读取并借助临时文件合并排序，IO 次数反而会增加。<br>也无法处理包含 text 和 blob 类型的字段。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619100616.png\" alt=\"rowid 排序\"></p>\n<p>rowid 排序分为两个阶段：</p>\n<ul>\n<li>第一阶段：根据查询条件取出<strong>排序字段和主键 ID</strong>，存入<code>sort buffer</code>进行排序；</li>\n<li>第二阶段：根据排序后的主键 ID 回表<strong>取出其他需要的字段</strong>。</li>\n</ul>\n<p>同样以 <code>SELECT * FROM user WHERE name = &quot;王二&quot; ORDER BY age </code>为例：</p>\n<ul>\n<li>从 name 索引中找到第一个满足 name&#x3D;’张三’ 的主键 id；</li>\n<li>根据主键 id 取出排序字段 age，连同主键 id 一起存入 sort buffer；</li>\n<li>重复上述过程直到处理完所有满足条件的行</li>\n<li>对 sort buffer 中的数据按 age 排序；</li>\n<li>遍历排序后的主键 id，回表取出其他所需字段，返回结果。</li>\n</ul>\n<p>优点是<strong>内存占用较少，适合字段多或者数据量大的场景</strong>，缺点是<strong>需要两次磁盘 IO</strong>。</p>\n<p>MySQL 会根据系统变量 <code>max_length_for_sort_data</code> 和<strong>查询字段的总大小</strong>来决定使用全字段排序还是 rowid 排序。</p>\n<p>如果<strong>查询字段总长度 &lt;&#x3D; max_length_for_sort_data</strong>，MySQL 会使用全字段排序；否则会使用 rowid 排序。</p>\n<h4 id=\"你对-Sort-merge-passes-参数了解吗？\"><a href=\"#你对-Sort-merge-passes-参数了解吗？\" class=\"headerlink\" title=\"你对 Sort_merge_passes 参数了解吗？\"></a>你对 Sort_merge_passes 参数了解吗？</h4><p><a href=\"https://mp.weixin.qq.com/s/YBWbEahWp0uVN_n9jAFU0A\">深入了解 MySQL Order By 文件排序</a><br><code>Sort_merge_passes</code> 是一个状态变量，用于<strong>统计 MySQL 在执行排序操作时进行归并排序的次数</strong>。<br>当 MySQL 需要进行排序但排序数据无法完全放入 <code>sort_buffer_size</code> 定义的内存缓冲区时，就会使用临时文件进行外部排序，这时就会产生 Sort_merge_passes。</p>\n<p>如果 <code>Sort_merge_passes</code> 在短时间内快速激增，说明排序操作的数据量较大，<strong>需要调整 sort_buffer_size 或者优化查询语句</strong>。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619101635.png\" alt=\"20250619101635\"></p>\n<p><strong>MySQL 在执行排序操作时，会经历两个过程：</strong></p>\n<ul>\n<li><strong>内存排序阶段</strong>，MySQL 首先尝试在 <code>sort buffer</code> 中进行排序。如果数据量小于 <code>sort_buffer_size</code> 缓冲区大小，会完全在内存中完成快速排序。</li>\n<li><strong>外部排序阶段</strong>，如果数据量超过 <code>sort_buffer_size</code>，MySQL 会将数据分成多个块，每块单独排序后写入临时文件，然后对这些已排序的块进行<strong>归并排序</strong>。每次归并操作都会增加 Sort_merge_passes 的计数。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619101736.png\" alt=\"20250619101736\"></p>\n<h4 id=\"条件下推你了解多少？\"><a href=\"#条件下推你了解多少？\" class=\"headerlink\" title=\"条件下推你了解多少？\"></a>条件下推你了解多少？</h4><p>条件下推的核心思想是<strong>将外层的过滤条件</strong>，比如说 where、join 等，<strong>尽可能地下推到查询计划的更底层</strong>，<strong>比如说子查询、连接操作之前，从而减少中间结果的数据量</strong>。</p>\n<p>比如说原始查询是：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> total <span class=\"operator\">&gt;</span> <span class=\"number\">100</span></span><br><span class=\"line\">) <span class=\"keyword\">AS</span> subquery</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> subquery.status <span class=\"operator\">=</span> <span class=\"string\">&#x27;shipped&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>就可以将条件下推到子查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> total <span class=\"operator\">&gt;</span> <span class=\"number\">100</span> <span class=\"keyword\">AND</span> status <span class=\"operator\">=</span> <span class=\"string\">&#x27;shipped&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AS</span> subquery;</span><br></pre></td></tr></table></figure>\n<p>这样就可以减少查询返回的数据量，避免外层再过滤。</p>\n<p>再比如说 union 中的原始查询是：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t1) </span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span> </span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t2)</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> col LIMIT <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>就可以将条件下推到每个子查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> col LIMIT <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span> </span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t2 <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> col LIMIT <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<p>每个子查询仅返回前 10 条数据，减少临时表的数据量。</p>\n<p>再比如说连接查询 join 中的原始查询是：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> customers <span class=\"keyword\">ON</span> orders.customer_id <span class=\"operator\">=</span> customers.id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> customers.country <span class=\"operator\">=</span> <span class=\"string\">&#x27;china&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>就可以将条件下推到表扫描的时候：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> customers <span class=\"keyword\">WHERE</span> country <span class=\"operator\">=</span> <span class=\"string\">&#x27;china&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AS</span> filtered_customers</span><br><span class=\"line\"><span class=\"keyword\">ON</span> orders.customer_id <span class=\"operator\">=</span> filtered_customers.id;</span><br></pre></td></tr></table></figure>\n<p>先过滤 customers 表，减少 join 时的数据量。</p>\n<h4 id=\"为什么要尽量避免使用-select-？\"><a href=\"#为什么要尽量避免使用-select-？\" class=\"headerlink\" title=\"为什么要尽量避免使用 select *？\"></a>为什么要尽量避免使用 select *？</h4><p><code>SELECT * </code>会强制 MySQL <strong>读取表中所有字段的数据</strong>，包括应用程序可能并不需要的，比如 text、blob 类型的<strong>大字段</strong>。<br><strong>加载冗余数据会占用更多的缓存空间</strong>，从而挤占其他重要数据的缓存资源，<strong>降低整体系统的吞吐量</strong>。<br>也会<strong>增加网络传输的开销</strong>，尤其是在大字段的情况下。<br>最重要的是，<code>SELECT * </code><strong>可能会导致覆盖索引失效</strong>，本来可以走索引的查询最后变成了全表扫描。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 使用覆盖索引（假设索引为 idx_country）</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, country <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> country <span class=\"operator\">=</span> <span class=\"string\">&#x27;china&#x27;</span>;  <span class=\"comment\">-- 可能仅扫描索引</span></span><br><span class=\"line\"><span class=\"comment\">-- 使用 SELECT *</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> country <span class=\"operator\">=</span> <span class=\"string\">&#x27;china&#x27;</span>;            <span class=\"comment\">-- 需回表读取所有列</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"你还知道哪些-SQL-优化方法？\"><a href=\"#你还知道哪些-SQL-优化方法？\" class=\"headerlink\" title=\"你还知道哪些 SQL 优化方法？\"></a>你还知道哪些 SQL 优化方法？</h4><p>①、避免使用 <code>!=</code> 或者 <code>&lt;&gt;</code> 操作符</p>\n<p>!&#x3D; 或者 &lt;&gt; 操作符<strong>会导致 MySQL 无法使用索引</strong>，从而<strong>导致全表扫描</strong>。</p>\n<p>可以把column&lt;&gt;’aaa’，改成column&gt;’aaa’ or column&lt;’aaa’。</p>\n<p>②、使用前缀索引</p>\n<p>比如，邮箱的后缀一般都是固定的@xxx.com，那么类似这种<strong>后面几位为固定值的字段就非常适合定义为前缀索引</strong>：<br><code>alter table test add index index2(email(6));</code><br>需要注意的是，MySQL 无法利用前缀索引做 <code>order by</code> 和 <code>group by </code>操作。</p>\n<p>③、避免在列上使用函数</p>\n<p>在 where 子句中<strong>直接对列使用函数会导致索引失效</strong>，因为 MySQL 需要对每行的列应用函数后再进行比较。<br><code>select name from test where date_format(create_time,&#39;%Y-%m-%d&#39;)=&#39;2021-01-01&#39;;</code><br>可以改成：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> test <span class=\"keyword\">where</span> create_time<span class=\"operator\">&gt;=</span><span class=\"string\">&#x27;2021-01-01 00:00:00&#x27;</span> <span class=\"keyword\">and</span> create_time<span class=\"operator\">&lt;</span><span class=\"string\">&#x27;2021-01-02 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>通过日期的范围查询，而不是在列上使用函数，可以利用 create_time 上的索引。</p>\n<h3 id=\"34-🌟explain平常有用过吗？\"><a href=\"#34-🌟explain平常有用过吗？\" class=\"headerlink\" title=\"34.🌟explain平常有用过吗？\"></a>34.🌟explain平常有用过吗？</h3><p>经常用，explain 是 MySQL 提供的一个用于<strong>查看 SQL 执行计划的工具</strong>，可以帮助我们<strong>分析查询语句的性能问题</strong>。</p>\n<p>一共有 10 来个输出参数。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619105445.png\" alt=\"20250619105445\"></p>\n<p>比如说 type&#x3D;ALL,key&#x3D;NULL 表示 SQL 正在全表扫描，可以考虑为 where 字段添加索引进行优化；<br>Extra&#x3D;Using filesort 表示 SQL 正在文件排序，可以考虑为 order by 字段添加索引。</p>\n<p>使用方式也非常简单，直接在 select 前加上 explain 关键字就可以了。</p>\n<p><code>explain select * from students where name=&#39;王二&#39;;</code><br>更高级的用法可以配合 format&#x3D;json 参数，将 explain 的输出结果以 JSON 格式返回。<br><code>explain format=json select * from students where name=&#39;王二&#39;;</code></p>\n<h4 id=\"explain-输出结果中常见的字段含义理解吗？\"><a href=\"#explain-输出结果中常见的字段含义理解吗？\" class=\"headerlink\" title=\"explain 输出结果中常见的字段含义理解吗？\"></a>explain 输出结果中常见的字段含义理解吗？</h4><p>在 EXPLAIN 输出结果中我最关注的字段是 <code>type</code>、<code>key</code>、<code>rows</code> 和 <code>Extra</code>。</p>\n<p>我会通过它们判断 SQL <strong>有没有走索引</strong>、<strong>是否全表扫描</strong>、<strong>预估扫描行数是否太大</strong>，以及是否触发了 <strong>filesort 或临时表</strong>。<br>一旦发现问题，比如 type&#x3D;ALL 或者 Extra&#x3D;Using filesort，我会考虑建索引、改写 SQL 或控制查询结果集来做优化。</p>\n<p>—-这部分是帮助理解 start，面试中可不背—-<br>以 <code>EXPLAIN SELECT * FROM orders WHERE user_id = 100 </code>的输出为例：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250619105921.png\" alt=\"20250619105921\"></p>\n<p>非表格版本：<br>①、id 列：查询的执行顺序编号。id 相同：同一执行层级，按 table 列从上到下顺序执行（如多表 JOIN）；id 递增：嵌套子查询，数值越大优先级越高，越先执行。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">JOIN</span> (<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t2 <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span>) <span class=\"keyword\">AS</span> sub;</span><br></pre></td></tr></table></figure>\n<p>t2 子查询的 id&#x3D;2，优先执行。</p>\n<p>②、select_type 列：查询的类型。常见的类型有：</p>\n<ul>\n<li>SIMPLE：简单查询，不包含子查询或者 UNION。</li>\n<li>PRIMARY：查询中如果包含子查询，则最外层查询被标记为 PRIMARY。需要关注子查询或派生表性能。</li>\n<li>SUBQUERY：子查询；需要避免多层嵌套，尽量改写为 JOIN。</li>\n<li>DERIVED：派生表（FROM 子句中的子查询）。需要减少派生表数据量，或物化为临时表。</li>\n</ul>\n<p>③、table 列：查的哪个表。</p>\n<ul>\n<li>derivedN：表示派生表（N 对应 id）。</li>\n<li>unionNM,N：表示 UNION 合并的结果（M、N 为参与 UNION 的 id）。</li>\n</ul>\n<p>④、type 列：表示 MySQL 在表中找到所需行的方式。</p>\n<ul>\n<li>system，表仅有一行（系统表或衍生表），无需优化。</li>\n<li>const：通过主键或唯一索引找到一行（如 WHERE id &#x3D; 1）。理想情况。</li>\n<li>eq_ref：对主键&#x2F;唯一索引 JOIN 匹配（如 A JOIN B ON A.id &#x3D; B.id）。确保 JOIN 字段有索引。</li>\n<li>ref：非唯一索引匹配（如 WHERE name &#x3D; ‘王二’，name 有普通索引）。</li>\n<li>range：只检索给定范围的行，使用索引来检索。在where语句中使用 bettween…and、&lt;、&gt;、&lt;&#x3D;、in 等条件查询 type 都是 range。</li>\n<li>index：全索引扫描，如果不需要回表，可接受；否则考虑覆盖索引。</li>\n<li>ALL：全表扫描，效率最低。<br>⑤、possible_keys 列：可能会用到的索引，但并不一定实际被使用。</li>\n</ul>\n<p>⑥、key 列：实际使用的索引。如果为 NULL，则没有使用索引。如果为 PRIMARY，则使用了主键索引。</p>\n<p>⑦、key_len 列：使用的索引字节数，反映索引列的利用率。使用联合索引 (a, b)，key_len 是 a 和 b 的字节总和（仅当查询条件用到 a 或 a+b 时有效）。</p>\n<p>– 表结构：CREATE TABLE t (a INT, b VARCHAR(20), INDEX idx_a_b (a, b));<br>EXPLAIN SELECT * FROM t WHERE a &#x3D; 1 AND b &#x3D; ‘test’;<br>key_len &#x3D; 4（INT） + 20*3（utf8） + 2 &#x3D; 66 字节。</p>\n<p>⑧、ref 列：与索引列比较的值或列。</p>\n<ul>\n<li>const：常量。例如 WHERE column &#x3D; ‘value’。</li>\n<li>func：函数。例如 WHERE column &#x3D; func(column)。</li>\n</ul>\n<p>⑨、rows 列：优化器估算的需要扫描的行数。数值越小越好，若与实际差距大，可能统计信息过期（需 ANALYZE TABLE）。结合 filtered 字段可以计算最终返回行数（rows × filtered）。</p>\n<p>⑩、Extra 列：附加信息。</p>\n<ul>\n<li>Using index：覆盖索引，无需回表。</li>\n<li>Using where：存储引擎返回结果后，Server 层需要再次过滤（条件未完全下推）。</li>\n<li>Using temporary ：使用临时表（常见于 GROUP BY、DISTINCT）。</li>\n<li>Using filesort：文件排序（常见于 ORDER BY）。考虑为 ORDER BY 字段添加索引。</li>\n<li>Select tables optimized away：优化器已优化（如 COUNT(*) 通过索引直接统计）。</li>\n<li>Using join buffer：使用连接缓冲区（Block Nested Loop 或 Hash Join）。考虑增大 join_buffer_size。</li>\n</ul>\n<p>—-这部分是帮助理解 end，面试中可不背—-</p>\n<h4 id=\"type的执行效率等级，达到什么级别比较合适？\"><a href=\"#type的执行效率等级，达到什么级别比较合适？\" class=\"headerlink\" title=\"type的执行效率等级，达到什么级别比较合适？\"></a>type的执行效率等级，达到什么级别比较合适？</h4><p>从高到低的效率排序是 <code>system</code>、<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>range</code>、<code>index</code> 和 <code>ALL</code>。</p>\n<p>一般情况下，建议 type 值达到<code> const</code>、<code>eq_ref</code> 或 <code>ref</code>，因为这些类型表明查询使用了索引，效率较高。<br>如果是范围查询，range 类型也是可以接受的。<br>ALL 类型表示全表扫描，性能最差，往往不可接受，需要优化。</p>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h3 id=\"35-🌟索引为什么能提高MySQL查询效率？\"><a href=\"#35-🌟索引为什么能提高MySQL查询效率？\" class=\"headerlink\" title=\"35.🌟索引为什么能提高MySQL查询效率？\"></a>35.🌟索引为什么能提高MySQL查询效率？</h3><p>索引就像一本书的目录，能让 MySQL 快速定位数据，避免全表扫描。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E7%B4%A2%E5%BC%95%E5%8A%A0%E5%BF%AB%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86.png\" alt=\"索引加快查询原理\"></p>\n<p>它一般是 <code>B+ 树</code>结构，查找效率是 <code>O(log n)</code>，比从头到尾扫一遍数据要快得多。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/MYSQL%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png\" alt=\"MYSQL索引结构\"></p>\n<p>除了查得快，索引还能加速排序、分组、连接等操作。<br>可以通过 create index 创建索引，比如：<br><code>create index idx_name on students(name);</code></p>\n<h3 id=\"36-🌟能简单说一下索引的分类吗？\"><a href=\"#36-🌟能简单说一下索引的分类吗？\" class=\"headerlink\" title=\"36.🌟能简单说一下索引的分类吗？\"></a>36.🌟能简单说一下索引的分类吗？</h3><p>从<strong>功能上分类</strong>的话，有<code>主键索引</code>、<code>唯一索引</code>、<code>全文索引</code>；从<strong>数据结构</strong>上分类的话，有 <code>B+ 树索引</code>、<code>哈希索引</code>；从<strong>存储内容</strong>上分类的话，有<code>聚簇索引</code>、<code>非聚簇索引</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B.png\" alt=\"索引类型\"></p>\n<h4 id=\"你对主键索引了解多少？\"><a href=\"#你对主键索引了解多少？\" class=\"headerlink\" title=\"你对主键索引了解多少？\"></a>你对主键索引了解多少？</h4><p>主键索引用于唯一标识表中的每条记录，其列值<strong>必须唯一且非空</strong>。创建主键时，MySQL 会<strong>自动生成对应的唯一索引</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png\" alt=\"主键索引\"></p>\n<p>每个表只能有一个<strong>主键索引</strong>，一般是表中的自增 id 字段。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> emp6 (emp_id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY KEY</span>, name <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>));  <span class=\"comment\">-- 单列主键</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> CountryLanguage (</span><br><span class=\"line\">    CountryCode <span class=\"type\">CHAR</span>(<span class=\"number\">3</span>),</span><br><span class=\"line\">    <span class=\"keyword\">Language</span> <span class=\"type\">VARCHAR</span>(<span class=\"number\">30</span>),</span><br><span class=\"line\">    <span class=\"keyword\">PRIMARY KEY</span> (CountryCode, <span class=\"keyword\">Language</span>)  <span class=\"comment\">-- 复合主键</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>如果创建表的时候<strong>没有指定主键</strong>，MySQL 的 InnoDB 存储引擎会<strong>优先选择一个非空的唯一索引作为主键</strong>；如果没有符合条件的索引，MySQL 会<strong>自动生成一个隐藏的 _rowid 列</strong>作为主键。</p>\n<p>可以通过 <code>show index from table_name</code> 查看索引信息：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250620110109.png\" alt=\"20250620110109\"></p>\n<ul>\n<li>Table 当前<strong>索引所属的表名</strong>。</li>\n<li>Non_unique <strong>是否唯一索引</strong>，0 表示唯一索引（如主键），1 表示非唯一。</li>\n<li>Key_name <strong>主键索引默认叫 PRIMARY</strong>；普通索引为自定义名。</li>\n<li>Seq_in_index 索引中的<strong>列顺序</strong>，在联合索引中这个字段表示第几列（第 1 个）。</li>\n<li>Column_name 当前索引中<strong>包含的字段名</strong>。</li>\n<li>Collation A 表示升序（Ascend）；D 表示降序。</li>\n<li>Cardinality 索引的基数，即不重复的索引值的数量。越高说明区分度越好（影响优化器是否用此索引）。</li>\n<li>Sub_part 前缀索引的长度。</li>\n<li>Packed 是否压缩存储索引；一般不用，默认为 NULL。</li>\n<li>Null 字段是否允许为 NULL；主键字段不允许为 NULL。</li>\n<li>Index_type 索引底层结构，InnoDB 默认是 B+ 树（BTREE）。</li>\n<li>Comment 索引的注释。</li>\n<li>Visible 是否可见；MySQL 8.0+ 可隐藏索引。<br>—- 这部分是帮助理解 end，面试中可不背 —-</li>\n</ul>\n<h4 id=\"唯一索引和主键索引有什么区别？\"><a href=\"#唯一索引和主键索引有什么区别？\" class=\"headerlink\" title=\"唯一索引和主键索引有什么区别？\"></a>唯一索引和主键索引有什么区别？</h4><p><code>主键索引=唯一索引+非空</code>。每个表只能有一个<code>主键索引</code>，但可以有<code>多个唯一索引</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 在 email 列上添加唯一索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> users (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> AUTO_INCREMENT <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    username <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>) <span class=\"keyword\">NOT NULL</span>,</span><br><span class=\"line\">    email <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT NULL</span>,</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> KEY uk_email (email)  <span class=\"comment\">-- 唯一索引</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 复合唯一索引（保证 user_id 和 role 组合唯一）</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> user_roles (</span><br><span class=\"line\">    user_id <span class=\"type\">INT</span> <span class=\"keyword\">NOT NULL</span>,</span><br><span class=\"line\">    role <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT NULL</span>,</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> KEY uk_user_role (user_id, role)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>主键索引<strong>不允许插入 NULL 值</strong>，尝试插入 NULL 会报错；唯一索引<strong>允许插入多个 NULL 值</strong>。</p>\n<h4 id=\"unique-key-和-unique-index-有什么区别？\"><a href=\"#unique-key-和-unique-index-有什么区别？\" class=\"headerlink\" title=\"unique key 和 unique index 有什么区别？\"></a>unique key 和 unique index 有什么区别？</h4><p>创建<strong>唯一键</strong>时，MySQL 会<strong>自动生成一个同名的唯一索引</strong>；反之，创建唯一索引也会<strong>隐式添加唯一性约束</strong>。</p>\n<p>可通过 <code>UNIQUE KEY uk_name</code> 定义或者 <code>CONSTRAINT uk_name UNIQUE</code> 定义唯一键。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> users (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    email <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>),</span><br><span class=\"line\">    <span class=\"comment\">-- 显式命名唯一键</span></span><br><span class=\"line\">    <span class=\"keyword\">CONSTRAINT</span> uk_email <span class=\"keyword\">UNIQUE</span> (email)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> users3 (</span><br><span class=\"line\">     id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    email <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>),</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> KEY uk_email (email)  <span class=\"comment\">-- 唯一索引</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>可通过 CREATE UNIQUE INDEX 创建唯一索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> users (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    email <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 手动创建唯一索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX uk_email <span class=\"keyword\">ON</span> users(email);</span><br></pre></td></tr></table></figure>\n<p>通过 <code>SHOW CREATE TABLE table_name</code> 查看表结构时，结果都是一样的。</p>\n<h4 id=\"普通索引和唯一索引有什么区别？\"><a href=\"#普通索引和唯一索引有什么区别？\" class=\"headerlink\" title=\"普通索引和唯一索引有什么区别？\"></a>普通索引和唯一索引有什么区别？</h4><p><strong>普通索引仅用于加速查询</strong>，不限制字段值的唯一性；<strong>适用于高频写入的字段、范围查询的字段</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 日志时间戳允许重复，无需唯一性检查</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_log_time <span class=\"keyword\">ON</span> access_logs(access_time);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 订单状态允许重复，但需频繁按状态过滤数据</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_order_status <span class=\"keyword\">ON</span> orders(status);</span><br></pre></td></tr></table></figure>\n<p><strong>唯一索引</strong>强制字段值的唯一性，<strong>插入或更新时会触发唯一性检查</strong>；适<strong>用于业务唯一性约束的字段、防止数据重复插入的字段</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 用户邮箱必须唯一</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX uk_email <span class=\"keyword\">ON</span> users(email);</span><br><span class=\"line\"><span class=\"comment\">-- 确保同一用户对同一商品只能有一条未支付订单</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX uk_user_product <span class=\"keyword\">ON</span> orders(user_id, product_id) <span class=\"keyword\">WHERE</span> status <span class=\"operator\">=</span> <span class=\"string\">&#x27;unpaid&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"你对全文索引了解多少？\"><a href=\"#你对全文索引了解多少？\" class=\"headerlink\" title=\"你对全文索引了解多少？\"></a>你对全文索引了解多少？</h4><p>全文索引是 MySQL 一种<strong>优化文本数据检索的特殊类型索引</strong>，适用于 CHAR、VARCHAR 和 TEXT 等字段。</p>\n<p>MySQL 5.7 及以上版本内置了 ngram 解析器，可处理中文、日文和韩文等分词。</p>\n<p>建表时通过 <code>FULLTEXT (title, body)</code> 来定义。通过 <code>MATCH(col1, col2) AGAINST(&#39;keyword&#39;)</code> 进行检索，默认按照降序返回结果，支持布尔模式查询。</p>\n<ul>\n<li><code>+</code> 表示必须包含；</li>\n<li><code>-</code> 表示排除；</li>\n<li><code>*</code> 表示通配符；<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 建表时创建全文索引（支持中文）</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> articles (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> UNSIGNED AUTO_INCREMENT <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    title <span class=\"type\">VARCHAR</span>(<span class=\"number\">200</span>),</span><br><span class=\"line\">    content TEXT,</span><br><span class=\"line\">    FULLTEXT(title, content) <span class=\"keyword\">WITH</span> PARSER ngram</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 使用布尔模式查询</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> articles </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">MATCH</span>(title, content) AGAINST(<span class=\"string\">&#x27;+MySQL -Oracle&#x27;</span> <span class=\"keyword\">IN</span> <span class=\"type\">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure>\n底层使用倒排索引将字段中的文本内容进行分词，然后建立一个倒排表。性能比 LIKE ‘%keyword%’ 高很多。</li>\n</ul>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p><strong>倒排索引</strong>通过一个辅助表存储单词与单词自身在一个或多个文档中所在位置之间的映射，通常采用关联数组实现。</p>\n<p>有两种表现形式：inverted file index（{单词，单词所在文档的ID}）和full inverted index（{单词，(单词所在文档的ID，在具体文档中的位置)}）</p>\n<p>比如有这样一个文档：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DocumentId  Text  </span><br><span class=\"line\"><span class=\"number\">1</span>          Pease porridge hot, pease porridge cold  </span><br><span class=\"line\"><span class=\"number\">2</span>          Pease porridge <span class=\"keyword\">in</span> the pot  </span><br><span class=\"line\"><span class=\"number\">3</span>          Nine days <span class=\"keyword\">old</span>  </span><br><span class=\"line\"><span class=\"number\">4</span>          <span class=\"keyword\">Some</span> <span class=\"keyword\">like</span> it hot, <span class=\"keyword\">some</span> <span class=\"keyword\">like</span> it cold  </span><br><span class=\"line\"><span class=\"number\">5</span>          <span class=\"keyword\">Some</span> <span class=\"keyword\">like</span> it <span class=\"keyword\">in</span> the pot  </span><br><span class=\"line\"><span class=\"number\">6</span>          Nine days <span class=\"keyword\">old</span></span><br></pre></td></tr></table></figure>\n<p><code>inverted file index</code> 的关联数组存储形式为：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">days → <span class=\"number\">3</span>,<span class=\"number\">6</span>  </span><br><span class=\"line\"><span class=\"keyword\">old</span> → <span class=\"number\">3</span>,<span class=\"number\">6</span>  </span><br><span class=\"line\">pease → <span class=\"number\">1</span>,<span class=\"number\">2</span>  </span><br><span class=\"line\">porridge → <span class=\"number\">1</span>,<span class=\"number\">2</span>  </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p><code>full inverted index</code> 更加详细：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">days → (<span class=\"number\">3</span>:<span class=\"number\">5</span>),(<span class=\"number\">6</span>:<span class=\"number\">5</span>)  </span><br><span class=\"line\"><span class=\"keyword\">old</span> → (<span class=\"number\">3</span>:<span class=\"number\">11</span>),(<span class=\"number\">6</span>:<span class=\"number\">11</span>)  </span><br><span class=\"line\">pease → (<span class=\"number\">1</span>:<span class=\"number\">1</span>),(<span class=\"number\">1</span>:<span class=\"number\">7</span>),(<span class=\"number\">2</span>:<span class=\"number\">1</span>)  </span><br><span class=\"line\">porridge → (<span class=\"number\">1</span>:<span class=\"number\">7</span>),(<span class=\"number\">2</span>:<span class=\"number\">7</span>)  </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p><code>full inverted index</code> 不仅存储了文档 ID，还存储了单词在文档中的具体位置。</p>\n<p>InnoDB 采用的是 <code>full inverted index</code> 的方式实现全文索引。</p>\n<p>如果需要处理中文分词的话，一定要记得加上 <code>WITH PARSER ngram</code>，否则可能查不出来数据。</p>\n<p>不过，对于复杂的中文场景，建议使用 <code>Elasticsearch</code> 等专业搜索引擎替代，技术派项目中就用了这种方案。</p>\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h3 id=\"37-🌟创建索引有哪些注意点？\"><a href=\"#37-🌟创建索引有哪些注意点？\" class=\"headerlink\" title=\"37.🌟创建索引有哪些注意点？\"></a>37.🌟创建索引有哪些注意点？</h3><p><strong>第一，选择合适的字段</strong></p>\n<ul>\n<li>比如说频繁出现在 <code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 中的字段。</li>\n<li>优先选择区分度高的字段，比如用户 ID、手机号等唯一值多的，而不是性别、状态等区分度极低的字段，如果真的需要，可以考虑联合索引。</li>\n</ul>\n<p><strong>第二，要控制索引的数量，避免过度索引</strong>，每个索引都要占用存储空间，单表的索引数量不建议超过 5 个。</p>\n<p>要定期通过 <code>SHOW INDEX FROM table_name</code> 查看索引的使用情况，<strong>删除不必要的索引</strong>。比如说已经有联合索引 (a, b)，单索引（a）就是冗余的。</p>\n<p><strong>第三，联合索引的时候要遵循最左前缀原则</strong>，即在查询条件中使用联合索引的第一个字段，才能充分利用索引。</p>\n<p>比如说联合索引 (A, B, C) 可支持 A、A+B、A+B+C 的查询，但无法支持 B 或 C 的单独查询。</p>\n<p><strong>区分度高的字段放在左侧</strong>，<strong>等值查询的字段优先于范围查询的字段</strong>。例如 WHERE A&#x3D;1 AND B&gt;10 AND C&#x3D;2，优先 (A, C, B)。</p>\n<p>如果<strong>联合索引包含查询的所需字段，还可以避免回表</strong>，提高查询效率。</p>\n<h3 id=\"38-🌟索引哪些情况下会失效呢？\"><a href=\"#38-🌟索引哪些情况下会失效呢？\" class=\"headerlink\" title=\"38.🌟索引哪些情况下会失效呢？\"></a>38.🌟索引哪些情况下会失效呢？</h3><p>简版：<strong>比如索引列使用了函数</strong>、<strong>使用了通配符开头的模糊查询</strong>、<strong>联合索引不满足最左前缀原则</strong>，或者<strong>使用 or 的时候部分字段无索引</strong>等。</p>\n<p><strong>第一，对索引列使用函数或表达式会导致索引失效。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 索引失效</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> <span class=\"keyword\">YEAR</span>(create_time) <span class=\"operator\">=</span> <span class=\"number\">2023</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> products <span class=\"keyword\">WHERE</span> price<span class=\"operator\">*</span><span class=\"number\">2</span> <span class=\"operator\">&gt;</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 优化方案（使用范围查询）</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> create_time <span class=\"keyword\">BETWEEN</span> <span class=\"string\">&#x27;2023-01-01&#x27;</span> <span class=\"keyword\">AND</span> <span class=\"string\">&#x27;2023-12-31&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> products <span class=\"keyword\">WHERE</span> price <span class=\"operator\">&gt;</span> <span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>第二，LIKE 模糊查询以通配符开头会导致索引失效。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 索引失效</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> articles <span class=\"keyword\">WHERE</span> title <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%数据库%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 可以使用索引（但范围有限）</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> articles <span class=\"keyword\">WHERE</span> title <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;数据库%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 解决方案：考虑全文索引或搜索引擎</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> articles <span class=\"keyword\">WHERE</span> <span class=\"keyword\">MATCH</span>(title) AGAINST(<span class=\"string\">&#x27;数据库&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>第三，联合索引违反了最左前缀原则，索引会失效。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 假设有联合索引 (a, b, c)</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">AND</span> c <span class=\"operator\">=</span> <span class=\"number\">3</span>;  <span class=\"comment\">-- 索引失效</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> a <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">AND</span> c <span class=\"operator\">=</span> <span class=\"number\">3</span>;  <span class=\"comment\">-- 只使用a列索引</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 正确使用联合索引</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> a <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">AND</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">AND</span> c <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>联合索引，但 <code>WHERE</code> 不满足最左前缀原则，索引无法起效。例如：<code>SELECT * FROM table WHERE column2 = 2</code>，联合索引为 (column1, column2)。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p><strong>第四，使用 OR 连接非索引列条件，会导致索引失效。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 假设name有索引但age没有</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> name <span class=\"operator\">=</span> <span class=\"string\">&#x27;张三&#x27;</span> <span class=\"keyword\">OR</span> age <span class=\"operator\">=</span> <span class=\"number\">25</span>;  <span class=\"comment\">-- 全表扫描</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 优化方案1：使用UNION ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> name <span class=\"operator\">=</span> <span class=\"string\">&#x27;张三&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> age <span class=\"operator\">=</span> <span class=\"number\">25</span> <span class=\"keyword\">AND</span> name <span class=\"operator\">!=</span> <span class=\"string\">&#x27;张三&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 优化方案2：考虑为age添加索引</span></span><br></pre></td></tr></table></figure>\n<p><strong>第五，使用 !&#x3D; 或 &lt;&gt; 不等值查询会导致索引失效。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> status <span class=\"operator\">!=</span> <span class=\"number\">1</span>;  <span class=\"comment\">-- 若大部分行 `status=1`，可能全表扫描</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 优化方案：使用范围查询</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> status <span class=\"operator\">&lt;</span> <span class=\"number\">1</span> <span class=\"keyword\">OR</span> status <span class=\"operator\">&gt;</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h4 id=\"什么情况下模糊查询不走索引？\"><a href=\"#什么情况下模糊查询不走索引？\" class=\"headerlink\" title=\"什么情况下模糊查询不走索引？\"></a>什么情况下模糊查询不走索引？</h4><p>模糊查询主要使用 LIKE 语句，结合通配符来实现。<br><code>%</code>（代表任意多个字符）和 <code>_</code>（代表单个字符）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">column</span> <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%xxx%&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>这个查询会返回所有 column 列中包含 xxx 的记录。<br>但是，如果模糊查询的通配符** % 出现在搜索字符串的开始位置<strong>，如 LIKE ‘%xxx’，MySQL 将无法使用索引，因为数据库</strong>必须扫描全表以匹配任意位置的字符串**。</p>\n<h3 id=\"39-索引不适合哪些场景呢？\"><a href=\"#39-索引不适合哪些场景呢？\" class=\"headerlink\" title=\"39.索引不适合哪些场景呢？\"></a>39.索引不适合哪些场景呢？</h3><p>第一，<strong>区分度低的列</strong>，<strong>可以和其他高区分度的列组成联合索引</strong>。</p>\n<p>第二，<strong>频繁更新的列</strong>，索引会增加更新的成本。</p>\n<p>第三，TEXT、BLOB 等<strong>大对象类型的字段</strong>，可以<strong>使用前缀索引、全文索引替代</strong>。</p>\n<p>第四，当<strong>表的数据量很小的时候</strong>，不超过 1000 行，<strong>全表扫描可能比使用索引更快</strong>。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>原因时当<strong>数据量很小时</strong>，<strong>全表扫描的成本很低，因为所有的数据可能都加载到内存中了</strong>，使用索引反而需要先查找索引，再通过索引去找到实际的数据行，增加了<strong>额外的 I&#x2F;O 寻址时间</strong>。</p>\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h4 id=\"性别字段要建立索引吗？\"><a href=\"#性别字段要建立索引吗？\" class=\"headerlink\" title=\"性别字段要建立索引吗？\"></a>性别字段要建立索引吗？</h4><p><strong>性别字段不适合建立单独索引</strong>。因为<strong>性别字段的区分度很低</strong>。<br>如果性别字段确实经常用于查询条件，数据规模也比较大，<strong>可以将性别字段作为联合索引的一部分</strong>，与区分度高的字段一起，效果会好很多。</p>\n<h4 id=\"什么是区分度？\"><a href=\"#什么是区分度？\" class=\"headerlink\" title=\"什么是区分度？\"></a>什么是区分度？</h4><p>区分度是<strong>衡量一个字段在 MySQL 表中唯一值的比例</strong>。</p>\n<p><code>区分度 = 字段的唯一值数量 / 字段的总记录数；</code>越接近 1，就越适合作为索引。因为<strong>索引可以更有效地缩小查询范围</strong>。</p>\n<p>例如，一个表中有 1000 条记录，其中性别字段只有两个值（男、女），那么性别字段的区分度只有 0.002，就不适合建立索引。</p>\n<p>可以通过<code>COUNT(DISTINCT column_name)</code>和<code>COUNT(*)</code>的比值来计算字段的区分度。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> </span><br><span class=\"line\">    <span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> gender) <span class=\"operator\">/</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> gender_selectivity</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">    users;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"什么样的字段适合加索引？\"><a href=\"#什么样的字段适合加索引？\" class=\"headerlink\" title=\"什么样的字段适合加索引？\"></a>什么样的字段适合加索引？</h4><p>一句话回答：<br>一般来说，<strong>主键</strong>、<strong>唯一键</strong>、以及<strong>经常作为查询条件的字段</strong>最适合加索引。除此之外，字段的<strong>区分度要高</strong>，这样索引才能起到过滤作用；如果字段经常用于<strong>表连接</strong>、<strong>排序或分组</strong>，也建议加索引。同时如果<strong>多个字段经常一起出现</strong>在查询条件中，也可以<strong>建立联合索引</strong>来提升性能。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>查询条件中的高频字段，比如说WHERE子句中频繁用于等值查询、范围查询或者 IN 列表的字段。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> status <span class=\"operator\">=</span> <span class=\"string\">&#x27;PAID&#x27;</span> <span class=\"keyword\">AND</span> create_time <span class=\"operator\">&gt;</span> <span class=\"string\">&#x27;2023-01-01&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 若`status`和`create_time`常组合查询，建联合索引`(status, create_time)`</span></span><br></pre></td></tr></table></figure>\n<p>多表连接时的关联字段，比如说 user.id 和 order.user_id。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> u <span class=\"keyword\">JOIN</span> <span class=\"keyword\">order</span> o <span class=\"keyword\">ON</span> u.id <span class=\"operator\">=</span> o.user_id;  <span class=\"comment\">-- `user_id`需索引</span></span><br></pre></td></tr></table></figure>\n<p>参与排序或者分组的字段，可以直接利用索引的有序性，避免文件排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> product <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> price <span class=\"keyword\">DESC</span>;       <span class=\"comment\">-- 单字段排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> category, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> product <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> category;  <span class=\"comment\">-- 分组统计</span></span><br></pre></td></tr></table></figure>\n<p>需要利用覆盖索引的字段，可以避免回表操作。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建联合索引`(user_id, create_time)`</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> user_id, create_time <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> user_id <span class=\"operator\">=</span> <span class=\"number\">100</span>;  <span class=\"comment\">-- 覆盖索引生效</span></span><br></pre></td></tr></table></figure>\n\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h3 id=\"40-索引是不是建的越多越好？\"><a href=\"#40-索引是不是建的越多越好？\" class=\"headerlink\" title=\"40.索引是不是建的越多越好？\"></a>40.索引是不是建的越多越好？</h3><p><strong>索引不是越多越好</strong>。<strong>虽然索引可以加快查询</strong>，但也会带来<strong>写入变慢、占用更多存储空间、甚至让优化器选错索引的风险</strong>。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>每次数据写入（INSERT&#x2F;UPDATE&#x2F;DELETE）时，MySQL 都需<strong>同步更新所有相关索引，索引越多，维护成本越高</strong>。</p>\n<p>假如某表有 10 个索引，插入一行数据需更新 10 个 B+树结构，导致写入延迟增加 5~10 倍。</p>\n<p>假如某表数据量 100GB，若建 5 个索引，总存储可能达到 200GB+。</p>\n<p>索引过多时，优化器需评估更多可能的执行路径，可能导致选择困难症，优化器也会选错索引。</p>\n<p>再比如说，已有联合索引 (A, B, C)，再单独建 (A) 或 (A, B) 索引即为冗余。</p>\n<p><strong>单表索引数量建议不超过 5 个</strong>，MySQL 官方建议<code>单表索引总字段数 ≤ 表字段数的 30%</code>。</p>\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h4 id=\"说说索引优化的思路？\"><a href=\"#说说索引优化的思路？\" class=\"headerlink\" title=\"说说索引优化的思路？\"></a>说说索引优化的思路？</h4><p>一句话回答：<br>先通过<strong>慢查询日志找出性能瓶颈</strong>，然后用 <code>EXPLAIN</code> <strong>分析执行计划</strong>，判断是否走了<strong>索引、是否回表、是否排序</strong>。接着根据字段特性<strong>设计合适的索引</strong>，如<strong>选择区分度高的字段</strong>，<strong>使用联合索引和覆盖索引</strong>，<strong>避免索引失效的写法</strong>，最后通过<strong>实测来验证优化效果</strong>。</p>\n<h3 id=\"41-🌟为什么-InnoDB-要使用-B-树作为索引？\"><a href=\"#41-🌟为什么-InnoDB-要使用-B-树作为索引？\" class=\"headerlink\" title=\"41.🌟为什么 InnoDB 要使用 B+树作为索引？\"></a>41.🌟为什么 InnoDB 要使用 B+树作为索引？</h3><p>一句话总结：<br>因为<code> B+ 树</code>是一种<strong>高度平衡的多路查找树</strong>，能<strong>有效降低磁盘的 IO 次数</strong>，并且<strong>支持有序遍历和范围查询</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/B+%E6%A0%91.png\" alt=\"B+树\"></p>\n<p><strong>查询性能非常高</strong>，其结构也适合 MySQL 按照页为单位在磁盘上存储。</p>\n<p>像其他选项，比如说<strong>哈希表不支持范围查询</strong>，<strong>二叉树层级太深</strong>，<strong>B 树又不方便范围扫描</strong>，所以最终选择了 B+ 树。</p>\n<p>再换一种回答：</p>\n<p>相比哈希表：B+ 树<strong>支持范围查询和排序</strong><br>相比二叉树和红黑树：B+ 树更“矮胖”，<strong>层级更少，磁盘 IO 次数更少</strong><br>相比 B 树：B+ 树的<strong>非叶子节点只存储键值</strong>，叶子节点存储数据并通过链表连接，<strong>支持范围查询</strong><br>另外一种回答版本：</p>\n<p>B+树是一种<strong>自平衡的多路查找树</strong>，和<strong>红黑树、二叉平衡树</strong>不同，B+树的每个节点可以有 m 个子节点，而红黑树和二叉平衡树都只有 2 个。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/B+%E6%A0%912.png\" alt=\"B+树2\"><br>另外，和 B 树不同，B+树的<strong>非叶子节点只存储键值</strong>，<strong>不存储数据</strong>，而叶子节点存储了所有的数据，并且构成了一个<strong>有序链表</strong>。</p>\n<p>这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。查询的效率比 B 树更高。</p>\n<p>先说说 B 树。<br>B 树是一种自平衡的多路查找树，和红黑树、二叉平衡树不同，B 树的每个节点可以有 m 个子节点，而红黑树和二叉平衡树都只有 2 个。<br>换句话说，红黑树、二叉平衡树是细高个，而 B 树是矮胖子。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/B%E6%A0%91.png\" alt=\"B树\"></p>\n<p>再来说说内存和磁盘的 IO 读写。</p>\n<p>为了提高读写效率，从磁盘往内存中读数据的时候，一次会读取至少一页的数据，如果不满一页，会再多读点。</p>\n<p>比如说查询只需要读取 2KB 的数据，但 MySQL 实际上会读取 4KB 的数据，以装满整页。页是 MySQL 进行内存和磁盘交互的最小逻辑单元。</p>\n<p>再比如说需要读取 5KB 的数据，实际上 MySQL 会读取 8KB 的数据，刚好两页。</p>\n<p>因为读的次数越多，效率就越低。就好比我们在工地上搬砖，一次搬 10 块砖肯定比一次搬 1 块砖的效率要高，反正我每次都搬 10 块（😁）。</p>\n<p>对于红黑树、二叉平衡树这种细高个来说，每次搬的砖少，因为力气不够嘛，那来回跑的次数就越多。</p>\n<p>通常 B+ 树高度为 3-4 层即可支持 TB 级数据，而每次查询只需 2-4 次磁盘 I&#x2F;O，远低于二叉树或红黑树的 O(log2N) 复杂度</p>\n<p>树越高，意味着查找数据时就需要更多的磁盘 IO，因为每一层都可能需要从磁盘加载新的节点。</p>\n<p>B 树的节点通常与页的大小对齐，这样每次从磁盘加载一个节点时，正好就是一页的大小。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/b%E6%A0%912.png\" alt=\"b树2\"></p>\n<p>B 树的一个节点通常包括三个部分：</p>\n<ul>\n<li>键值：即表中的主键</li>\n<li>指针：存储子节点的信息</li>\n<li>数据：除主键外的行数据<br>正所谓“祸兮福所倚，福兮祸所伏”，因为 B 树的每个节点上都存储了数据，就导致每个节点能存储的键值和指针变少了，因为每一个节点的大小是固定的，对吧？<br>于是 B+树就来了，B+树的非叶子节点只存储键值，不存储数据，而叶子节点会存储所有的行数据，并且构成一个有序链表。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105348.png\" alt=\"20250621105348\"></p>\n<p>这样做的好处是，非叶子节点由于没有存储数据，就可以存储更多的键值对，树就变得更加矮胖了，于是就更有劲了，每次搬的砖也就更多了（😂）。</p>\n<p>相比 B 树，B+ 树的非叶子节点可容纳的键值更多，一个 16KB 的节点可存储约 1200 个键值，大幅降低树的高度。</p>\n<p>由此一来，查找数据进行的磁盘 IO 就更少了，查询的效率也就更高了。</p>\n<p>再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。</p>\n<p>B 树就做不到这一点。</p>\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h4 id=\"B-树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？\"><a href=\"#B-树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？\" class=\"headerlink\" title=\"B+树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？\"></a>B+树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？</h4><p>B+树的叶子节点是通过<strong>双向链表</strong>连接的，这样可以方便范围查询和反向遍历。</p>\n<p>当执行范围查询时，可以从范围的开始点或结束点开始，向前或向后遍历。<br>在需要对数据进行逆序处理时，双向链表非常有用。<br>如果需要在 B+树中从大值向小值进行检索，可以先定位到最右侧节点，找到包含最大值的叶子节点。从根节点开始向右遍历树的方式实现。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105458.png\" alt=\"20250621105458\"></p>\n<p>定位到最右侧的叶子节点后，再利用叶节点间的双向链表向左遍历就好了。</p>\n<h4 id=\"为什么-MongoDB-的索引用-B树，而-MySQL-用-B-树？\"><a href=\"#为什么-MongoDB-的索引用-B树，而-MySQL-用-B-树？\" class=\"headerlink\" title=\"为什么 MongoDB 的索引用 B树，而 MySQL 用 B+ 树？\"></a>为什么 MongoDB 的索引用 B树，而 MySQL 用 B+ 树？</h4><p>MongoDB 通常以 JSON 格式存储文档，查询以单键查询（如 find({_id: 123})）为主。B 树的“节点既存键又存数据”的特性<strong>允许查询在非叶子节点提前终止</strong>，从而减少 I&#x2F;O 次数。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105550.png\" alt=\"20250621105550\"></p>\n<p>MySQL 的查询通常涉及范围（WHERE id &gt; 100）、排序（ORDER BY）、连接（JOIN）等操作。B+ 树的叶子节点是链表结构，天然支持顺序遍历，无需回溯至根节点或中序遍历，效率远高于 B 树。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105601.png\" alt=\"20250621105601\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250621105641.png\" alt=\"20250621105641\"></p>\n<h3 id=\"42-🌟一棵B-树能存储多少条数据呢？\"><a href=\"#42-🌟一棵B-树能存储多少条数据呢？\" class=\"headerlink\" title=\"42.🌟一棵B+树能存储多少条数据呢？\"></a>42.🌟一棵B+树能存储多少条数据呢？</h3><p>一句话回复：<br>一棵 B+ 树能存多少数据，<strong>取决于它的分支因子和高度</strong>。在 InnoDB 中，页的默认大小为 16KB，当主键为 bigint 时，3 层 B+ 树通常可以存储约 2000 万条数据。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623101840.png\" alt=\"20250623101840\"></p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>先来看一下<strong>计算公式</strong>：</p>\n<p><code>最大记录数 = (分支因子)^(树高度-1) × 叶子节点容量</code></p>\n<p>再来看一下关键参数：<br>①、页大小，默认 16KB<br>②、主键大小，假设是 bigint 类型，那么它的大小就是 8 个字节。<br>③、页指针大小，InnoDB 源码中设置为 6 字节，4 字节页号 + 2 字节页内偏移。</p>\n<p>所以非叶子节点可以存储 16384&#x2F;14(键值+指针)&#x3D;1170 个这样的单元。</p>\n<p>当层高为 2 时，根节点可以存储 1170 个指针，指向 1170 个叶子节点，所以总数据量为 1170×16 &#x3D;18720 条。</p>\n<p>当层高为 3 时，根节点指向 1170 个非叶子节点，每个非叶子节点再指向 1170 个叶子节点，所以总数据量为 1170×1170×16≈21,902,400 条（约2,190万条）记录。</p>\n<p>推荐阅读：<a href=\"https://juejin.cn/post/6904293886626103309\">清幽之地：InnoDB 一棵 B+树可以存放多少行数据？</a></p>\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<p>现在有一张表 2kw 数据，我这个 b+树的高度有几层？<br>对于 2KW 条数据来说，B+树的高度为 3 层就够了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/3%E5%B1%82B+%E6%A0%91.png\" alt=\"3层B+树\"></p>\n<h4 id=\"每个叶子节点能存放多少条数据？\"><a href=\"#每个叶子节点能存放多少条数据？\" class=\"headerlink\" title=\"每个叶子节点能存放多少条数据？\"></a>每个叶子节点能存放多少条数据？</h4><p>如果单行数据大小为 1KB，那么每页可存储约 16 行（16KB&#x2F;1KB）数据。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>假设有这样一个表结构：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> `<span class=\"keyword\">user</span>` (</span><br><span class=\"line\">  `id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">PRIMARY KEY</span>,        <span class=\"comment\">-- 8字节</span></span><br><span class=\"line\">  `name` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT NULL</span>,   <span class=\"comment\">-- 实际长度50字节（UTF8MB4，每个字符最多4字节）</span></span><br><span class=\"line\">  `age` TINYINT,                  <span class=\"comment\">-- 1字节</span></span><br><span class=\"line\">  `email` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>)            <span class=\"comment\">-- 实际长度30字节，可为NULL</span></span><br><span class=\"line\">) ROW_FORMAT<span class=\"operator\">=</span>COMPACT;</span><br></pre></td></tr></table></figure>\n<p>那么一行数据的大小为：8 + 50 + 1 + 30 &#x3D; 89 字节。</p>\n<p>行格式的开销为：行头 5 字节+指针 6 字节+可变长度字段开销 2 字节（name 和 email 各占 1 字节）+ NULL 位图 1 字节 &#x3D; 14 字节。</p>\n<p>所以每行数据的实际大小为：89 + 14 &#x3D; 103 字节。</p>\n<p>每页大小默认为 16KB，那么每页最多可以存储 16384 &#x2F; 103 ≈ 158 行数据。</p>\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h3 id=\"43-索引为什么用-B-树不用普通二叉树？\"><a href=\"#43-索引为什么用-B-树不用普通二叉树？\" class=\"headerlink\" title=\"43.索引为什么用 B+树不用普通二叉树？\"></a>43.索引为什么用 B+树不用普通二叉树？</h3><p>普通二叉树的每个节点最多有两个子节点。当数据按顺序递增插入时，二叉树会<strong>退化成链表</strong>，导致树的高度等于数据量。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%80%E5%8C%96.png\" alt=\"二叉树退化\"></p>\n<p>此时查找 id&#x3D;7 就需要 7 次 I&#x2F;O 操作，相当于全表扫描。而 B+ 树作为多叉平衡树，能将数亿级的数据量控制在 3-4 层的树高，能极大减少磁盘的 I&#x2F;O 次数。</p>\n<h4 id=\"为什么不用平衡二叉树呢？\"><a href=\"#为什么不用平衡二叉树呢？\" class=\"headerlink\" title=\"为什么不用平衡二叉树呢？\"></a>为什么不用平衡二叉树呢？</h4><p>平衡二叉树虽然解决了普通二叉树的退化问题，但每个节点最多只有两个子节点的问题依然存在。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623103350.png\" alt=\"20250623103350\"><br>并且平衡二叉树的插入和删除操作也会导致频繁的旋转操作，影响性能。</p>\n<h3 id=\"44-🌟为什么用-B-树而不用-B-树呢？\"><a href=\"#44-🌟为什么用-B-树而不用-B-树呢？\" class=\"headerlink\" title=\"44.🌟为什么用 B+ 树而不用 B 树呢？\"></a>44.🌟为什么用 B+ 树而不用 B 树呢？</h3><p>B+ 树相比 B 树有 3 个显著优势：</p>\n<p>第一，B 树的每个节点既存储键值，又存储数据和指针，导致<strong>单节点存储的键值数量较少</strong>。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623103448.png\" alt=\"20250623103448\"></p>\n<p>一个 16KB 的 InnoDB 页，如果数据较大，B 树的非叶子节点只能容纳几十个键值，而 B+ 树的非叶子节点可以容纳上千个键值。</p>\n<p>第二，<strong>B 树的范围查询需要通过中序遍历逐层回溯</strong>；而 <strong>B+ 树的叶子节点通过双向链表顺序连接</strong>，范围查询只需定位起始点后顺序遍历链表即可，没有回溯开销。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623104021.png\" alt=\"20250623104021\"></p>\n<p>第三，<strong>B 树的数据可能存储在任意节点</strong>，假如目标数据恰好位于根节点或上层节点，查询仅需 1-2 次 I&#x2F;O；但如果数据位于底层节点，则需多次 I&#x2F;O，导致查询时间波动较大。</p>\n<p>而 <strong>B+ 树的所有数据都存储在叶子节点</strong>，查询路径的长度是固定的，**时间稳定为 O(logN)**，对 MySQL <strong>在高并发场景下的稳定性至关重要</strong>。</p>\n<h4 id=\"B-树的时间复杂度是多少？\"><a href=\"#B-树的时间复杂度是多少？\" class=\"headerlink\" title=\"B+树的时间复杂度是多少？\"></a>B+树的时间复杂度是多少？</h4><p><code>O(logN)</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623104724.png\" alt=\"20250623104724\"></p>\n<h4 id=\"为什么用-B-树不用跳表呢？\"><a href=\"#为什么用-B-树不用跳表呢？\" class=\"headerlink\" title=\"为什么用 B+树不用跳表呢？\"></a>为什么用 B+树不用跳表呢？</h4><p>跳表<strong>本质上还是链表结构</strong>，只不过把某些节点抽到上层做了索引。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623104917.png\" alt=\"20250623104917\"></p>\n<p>一条数据一个节点，如果需要存放 2000 万条数据，且每次查询都要能达到二分查找的效果，那么跳表的高度大约为 24 层（2 的 24 次方）。</p>\n<p>在最坏的情况下，这 24 层数据分散在不同的数据页，查找一次数据就需要 24 次磁盘 I&#x2F;O。</p>\n<p>而 2000 万条数据在 B+树中只需要 3 层就可以了。</p>\n<h4 id=\"B-树的范围查找怎么做的？\"><a href=\"#B-树的范围查找怎么做的？\" class=\"headerlink\" title=\"B+树的范围查找怎么做的？\"></a>B+树的范围查找怎么做的？</h4><p>一句话回答：</p>\n<p>先<strong>通过索引路径定位到第一个满足条件的叶子节点</strong>，然后<strong>顺着叶子节点之间的链表向右&#x2F;向左扫描，直到超过范围</strong>。</p>\n<p>详细版：</p>\n<p>B+ 树索引的范围查找主要<strong>依赖叶子节点之间的双向链表来完成</strong>。</p>\n<p>第一步，从 B+ 树的根节点开始，通过索引键值逐层向下，<strong>找到第一个满足条件的叶子节点</strong>。</p>\n<p>第二步，<strong>利用叶子节点之间的双向链表</strong>，从起始节点开始，依次向后遍历每个节点。当索引值超过查询范围，或者遍历到链表末尾时，终止查询。</p>\n<h4 id=\"了解快排吗\"><a href=\"#了解快排吗\" class=\"headerlink\" title=\"了解快排吗\"></a>了解快排吗</h4><p>快速排序使用分治法将一个序列分为较小和较大的 2 个子序列，然后递归排序两个子序列，由东尼·霍尔在 1960 年提出。</p>\n<p><img src=\"https://cdn.tobebetterjavaer.com/stutymore/mysql-Sorting_quicksort_anim.gif\" alt=\"快排\"><br>其核心思想是：</p>\n<ul>\n<li><strong>选择一个基准值。</strong></li>\n<li>将数组分为两部分，<strong>左边小于基准值</strong>，<strong>右边大于或等于基准值</strong>。</li>\n<li>对左右两部分递归排序，最终合并。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quickSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &lt; high) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pivotIndex</span> <span class=\"operator\">=</span> partition(arr, low, high);</span><br><span class=\"line\">        quickSort(arr, low, pivotIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">        quickSort(arr, pivotIndex + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">pivot</span> <span class=\"operator\">=</span> arr[high];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> low - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> low; j &lt; high; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            swap(arr, i, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(arr, i + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">    arr[i] = arr[j];</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"45-B-树索引和-Hash-索引有什么区别？\"><a href=\"#45-B-树索引和-Hash-索引有什么区别？\" class=\"headerlink\" title=\"45.B+树索引和 Hash 索引有什么区别？\"></a>45.B+树索引和 Hash 索引有什么区别？</h3><p><strong>简版回答：</strong><br><code>B+ 树</code>索引支持<strong>范围查询、有序扫描</strong>，是 InnoDB 的默认索引结构。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623110609.png\" alt=\"20250623110609\"></p>\n<p>Hash 索引只支持等值查找，速度快但功能弱，常见于 Memory 引擎。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623110631.png\" alt=\"20250623110631\"></p>\n<p><strong>稍微详细一点的回答：</strong></p>\n<p>B+ 树索引是一种<strong>平衡多路搜索树</strong>，所有数据存储在叶子节点上，非叶子节点仅存储索引键。叶子节点通过指针连接形成有序链表，天然支持排序。<br>并且支持范围查询、模糊查询，是 InnoDB 默认的索引结构。</p>\n<p>Hash 索引基于哈希函数将键值映射到固定长度的哈希值，通过哈希值定位数据存储的位置。<br>完全无序，只支持等值查询，常见于 Memory 引擎。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>因为 B+ 树是 InnoDB 的默认索引类型，所以创建 B+ 树的时候不需要指定索引类型。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> example_btree (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> AUTO_INCREMENT <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    name <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">    INDEX name_index (name)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB;</span><br></pre></td></tr></table></figure>\n<p>可以通过<code>UNIQUE HASH</code>创建哈希索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> example_hash (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> AUTO_INCREMENT <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    name <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> HASH (name)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>MEMORY;</span><br></pre></td></tr></table></figure>\n<p>InnoDB 并不提供直接创建哈希索引的选项，因为 B+ 树索引能够很好地支持范围查询和等值查询，满足了大多数数据库操作的需要。</p>\n<p>不过，InnoDB 内部使用了一种名为“自适应哈希索引”（Adaptive Hash Index, AHI）的技术，当某些索引值频繁访问时，<strong>InnoDB 会在 B+ 树基础上自动创建哈希索引</strong>，兼具两者的优点。</p>\n<p>可通过 <code>SHOW VARIABLES LIKE &#39;innodb_adaptive_hash_index&#39;;</code> 查看自适应哈希索引的状态。</p>\n<p>如果返回的值是 ON，说明自适应哈希索引是开启的。<br>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h3 id=\"46-🌟聚族索引和非聚族索引有什么区别？\"><a href=\"#46-🌟聚族索引和非聚族索引有什么区别？\" class=\"headerlink\" title=\"46.🌟聚族索引和非聚族索引有什么区别？\"></a>46.🌟聚族索引和非聚族索引有什么区别？</h3><p><strong>聚簇索引的叶子节点存储了完整的数据行</strong>，数据和索引是在一起的。<strong>InnoDB 的主键索引就是聚簇索引</strong>，叶子节点不仅存储了主键值，还存储了其他列的值，因此按照主键进行查询的速度会非常快。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623111022.png\" alt=\"20250623111022\"></p>\n<p><strong>每个表只能有一个聚簇索引</strong>，通常由主键定义。如果没有显式指定主键，<strong>InnoDB 会隐式创建一个隐藏的主键索引 row_id</strong>。<br>非聚簇索引的叶子节点只包含了主键值，需要通过回表按照主键去聚簇索引查找其他列的值，<strong>唯一索引、普通索引等非主键索引都是非聚簇索引</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623111225.png\" alt=\"20250623111225\"></p>\n<p>每个表都可以创建<strong>多个非聚簇索引</strong>，如果不想回表的话，可以通过覆盖索引把要查询的字段也放到索引中。</p>\n<p>—- 这部分是帮助大家理解 start，面试中可不背 —-</p>\n<p>一张表只能有一个聚簇索引。</p>\n<p>CREATE TABLE user (<br>  id INT PRIMARY KEY,<br>  name VARCHAR(100),<br>  age INT<br>);<br>主键 id 是聚簇索引，B+ 树的叶子节点直接存储了 (id, name, age)。</p>\n<p>一张表可以有多个非聚簇索引。</p>\n<p>CREATE INDEX idx_name ON user(name);<br>CREATE INDEX idx_age ON user(age);<br>idx_name 是非聚簇索引，叶子节点存的是 name -&gt; id，查整行数据要回表。</p>\n<p>idx_age 也是非聚簇索引，叶子节点存的是 age -&gt; id，查整行数据也要回表。</p>\n<p>想要了解更多聚簇索引和非聚簇索引，推荐阅读：<br><a href=\"https://www.cnblogs.com/vipstone/p/16370305.html\">https://www.cnblogs.com/vipstone/p/16370305.html</a><br><a href=\"https://learnku.com/articles/50096\">https://learnku.com/articles/50096</a><br><a href=\"https://blog.csdn.net/m0_52226803/article/details/135494499\">https://blog.csdn.net/m0_52226803/article/details/135494499</a><br><a href=\"https://mp.weixin.qq.com/s/F0cEzIqecF4sWg7ZRmHKRQ\">https://mp.weixin.qq.com/s/F0cEzIqecF4sWg7ZRmHKRQ</a><br>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h3 id=\"47-🌟回表了解吗？\"><a href=\"#47-🌟回表了解吗？\" class=\"headerlink\" title=\"47.🌟回表了解吗？\"></a>47.🌟回表了解吗？</h3><p>当使用<strong>非聚簇索引进行查询</strong>时，MySQL 需要<strong>先通过非聚簇索引找到主键值</strong>，然后<strong>再根据主键值回到聚簇索引中查找完整数据行</strong>，这个过程称为<strong>回表</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623111452.png\" alt=\"20250623111452\"></p>\n<p>假设现在有一张用户表 users：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> users (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    name <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>),</span><br><span class=\"line\">    age <span class=\"type\">INT</span>,</span><br><span class=\"line\">    email <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>),</span><br><span class=\"line\">    INDEX (name)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>执行查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> name <span class=\"operator\">=</span> <span class=\"string\">&#x27;王二&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>查询过程如下：</strong></p>\n<ul>\n<li>第一步，MySQL 使用 name 列上的非聚簇索引查找所有 name &#x3D; ‘王二’ 的主键 id。</li>\n<li>第二步，使用主键 id 到聚簇索引中查找完整记录。</li>\n</ul>\n<h4 id=\"回表的代价是什么？\"><a href=\"#回表的代价是什么？\" class=\"headerlink\" title=\"回表的代价是什么？\"></a>回表的代价是什么？</h4><p>回表通常<strong>需要访问额外的数据页</strong>，如果数据不在内存中，还需要从磁盘读取，<strong>增加 I&#x2F;O 开销</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623112230.png\" alt=\"20250623112230\"></p>\n<p>可通过覆盖索引或者联合索引来避免回表。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 原表结构</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> users (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    name <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>),</span><br><span class=\"line\">    age <span class=\"type\">INT</span>,</span><br><span class=\"line\">    INDEX idx_name (name)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 需要查询name和age</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> name, age <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> name <span class=\"operator\">=</span> <span class=\"string\">&#x27;张三&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 这会回表，因为age不在idx_name索引中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 优化方案1：创建包含age的联合索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> users <span class=\"keyword\">ADD</span> INDEX idx_name_age (name, age);</span><br><span class=\"line\"><span class=\"comment\">-- 现在同样的查询不需要回表</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>什么情况下会触发回表？</strong></p>\n<p>第一，当查询字段<strong>不在非聚簇索引中时</strong>，必须回表到主键索引获取数据。<br>第二，查询字段包含非索引列（如 SELECT *），必然触发回表。</p>\n<p><strong>回表记录越多好吗？</strong><br><strong>回表记录越多，通常代表性能越差</strong>，因为每条记录都需要通过主键再查询一次完整数据。这个过程涉及内存访问或磁盘 IO，尤其当缓存命中率不高时，<strong>回表会严重影响查询效率</strong>。</p>\n<h4 id=\"了解-MRR-吗？\"><a href=\"#了解-MRR-吗？\" class=\"headerlink\" title=\"了解 MRR 吗？\"></a>了解 MRR 吗？</h4><p>MRR 是 InnoDB 为了解决回表带来的大量随机 IO 问题而引入的一种<strong>优化策略</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/MRR.png\" alt=\"MRR\"></p>\n<p>它会先把非聚簇索引查到的主键值<strong>列表进行排序</strong>，<strong>再按顺序去主键索引中批量回表</strong>，将随机 I&#x2F;O 转换为顺序 I&#x2F;O，以减少磁盘寻道时间。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>可通过 <code>SHOW VARIABLES LIKE &#39;optimizer_switch&#39;;</code> 查看 MRR 是否启用。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113200.png\" alt=\"20250623113200\"></p>\n<p>其中 <code>mrr=on</code> 表示启用 MRR，<code>mrr_cost_based=on</code> 表示基于成本决定使用 MRR。</p>\n<p>另外可以通过 <code>show variables like &#39;read_rnd_buffer_size&#39;;</code> 查看 MRR 的缓冲区大小，默认是 256KB。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113223.png\" alt=\"20250623113223\"><br>我们来创建一个表，插入一些数据，然后执行一个查询来演示 MRR 的效果。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> DATABASE IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> mrr_test; </span><br><span class=\"line\">USE mrr_test; </span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> orders (id <span class=\"type\">INT</span> AUTO_INCREMENT <span class=\"keyword\">PRIMARY KEY</span>, user_id <span class=\"type\">INT</span>, order_date <span class=\"type\">DATE</span>, amount <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>), status <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>), INDEX idx_user_date(user_id, order_date));</span><br><span class=\"line\"></span><br><span class=\"line\">DELIMITER <span class=\"operator\">/</span><span class=\"operator\">/</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> generate_test_data()</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    <span class=\"keyword\">DECLARE</span> i <span class=\"type\">INT</span> <span class=\"keyword\">DEFAULT</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    WHILE i <span class=\"operator\">&lt;=</span> <span class=\"number\">100000</span> DO</span><br><span class=\"line\">        <span class=\"keyword\">INSERT INTO</span> orders (user_id, order_date, amount, status)</span><br><span class=\"line\">        <span class=\"keyword\">VALUES</span> (</span><br><span class=\"line\">            <span class=\"built_in\">FLOOR</span>(<span class=\"number\">1</span> <span class=\"operator\">+</span> RAND() <span class=\"operator\">*</span> <span class=\"number\">1000</span>),  <span class=\"comment\">-- Random user_id between 1 and 1000</span></span><br><span class=\"line\">            DATE_ADD(<span class=\"string\">&#x27;2023-01-01&#x27;</span>, <span class=\"type\">INTERVAL</span> <span class=\"built_in\">FLOOR</span>(RAND() <span class=\"operator\">*</span> <span class=\"number\">365</span>) <span class=\"keyword\">DAY</span>),  <span class=\"comment\">-- Random date in 2023</span></span><br><span class=\"line\">            ROUND(<span class=\"number\">10</span> <span class=\"operator\">+</span> RAND() <span class=\"operator\">*</span> <span class=\"number\">990</span>, <span class=\"number\">2</span>),  <span class=\"comment\">-- Random amount between 10 and 1000</span></span><br><span class=\"line\">            ELT(<span class=\"number\">1</span> <span class=\"operator\">+</span> <span class=\"built_in\">FLOOR</span>(RAND() <span class=\"operator\">*</span> <span class=\"number\">3</span>), <span class=\"string\">&#x27;completed&#x27;</span>, <span class=\"string\">&#x27;pending&#x27;</span>, <span class=\"string\">&#x27;cancelled&#x27;</span>)  <span class=\"comment\">-- Random status</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">SET</span> i <span class=\"operator\">=</span> i <span class=\"operator\">+</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">END</span> WHILE;</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"operator\">/</span><span class=\"operator\">/</span></span><br><span class=\"line\">DELIMITER ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CALL</span> generate_test_data();</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PROCEDURE</span> generate_test_data;&quot;</span><br></pre></td></tr></table></figure>\n<p>查看 MRR 开启和关闭时的性能数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 确保MRR开启并设置足够大的缓冲区</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> SESSION optimizer_switch<span class=\"operator\">=</span><span class=\"string\">&#x27;mrr=on,mrr_cost_based=off&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">SET</span> SESSION read_rnd_buffer_size <span class=\"operator\">=</span> <span class=\"number\">16</span><span class=\"operator\">*</span><span class=\"number\">1024</span><span class=\"operator\">*</span><span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 清理缓存和状态</span></span><br><span class=\"line\">FLUSH STATUS;</span><br><span class=\"line\">FLUSH TABLES;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 强制使用二级索引并回表查询（通过选择未被索引的列）</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"string\">&#x27;Raw data access pattern with MRR ON&#x27;</span> <span class=\"keyword\">as</span> test_case;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"comment\">/*+ MRR(orders_mrr_test) */</span> id, shipping_address, customer_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> orders_mrr_test FORCE INDEX(idx_user_date)</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> user_id <span class=\"keyword\">IN</span> (<span class=\"number\">100</span>,<span class=\"number\">200</span>,<span class=\"number\">300</span>,<span class=\"number\">400</span>,<span class=\"number\">500</span>,<span class=\"number\">600</span>,<span class=\"number\">700</span>,<span class=\"number\">800</span>,<span class=\"number\">900</span>,<span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"keyword\">AND</span> order_date <span class=\"keyword\">BETWEEN</span> <span class=\"string\">&#x27;2023-03-01&#x27;</span> <span class=\"keyword\">AND</span> <span class=\"string\">&#x27;2023-04-01&#x27;</span></span><br><span class=\"line\">LIMIT <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 显示处理器状态</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> STATUS <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;Handler_%&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> STATUS <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%mrr%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 对比：关闭MRR</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> SESSION optimizer_switch<span class=\"operator\">=</span><span class=\"string\">&#x27;mrr=off,mrr_cost_based=off&#x27;</span>;</span><br><span class=\"line\">FLUSH STATUS;</span><br><span class=\"line\">FLUSH TABLES;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"string\">&#x27;Raw data access pattern with MRR OFF&#x27;</span> <span class=\"keyword\">as</span> test_case;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, shipping_address, customer_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> orders_mrr_test FORCE INDEX(idx_user_date)</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> user_id <span class=\"keyword\">IN</span> (<span class=\"number\">100</span>,<span class=\"number\">200</span>,<span class=\"number\">300</span>,<span class=\"number\">400</span>,<span class=\"number\">500</span>,<span class=\"number\">600</span>,<span class=\"number\">700</span>,<span class=\"number\">800</span>,<span class=\"number\">900</span>,<span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"keyword\">AND</span> order_date <span class=\"keyword\">BETWEEN</span> <span class=\"string\">&#x27;2023-03-01&#x27;</span> <span class=\"keyword\">AND</span> <span class=\"string\">&#x27;2023-04-01&#x27;</span></span><br><span class=\"line\">LIMIT <span class=\"number\">15</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 显示处理器状态</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> STATUS <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;Handler_%&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> STATUS <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%mrr%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 显示详细的执行计划</span></span><br><span class=\"line\">EXPLAIN FORMAT<span class=\"operator\">=</span>TREE</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"comment\">/*+ MRR(orders_mrr_test) */</span> id, shipping_address, customer_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> orders_mrr_test FORCE INDEX(idx_user_date)</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> user_id <span class=\"keyword\">IN</span> (<span class=\"number\">100</span>,<span class=\"number\">200</span>,<span class=\"number\">300</span>,<span class=\"number\">400</span>,<span class=\"number\">500</span>,<span class=\"number\">600</span>,<span class=\"number\">700</span>,<span class=\"number\">800</span>,<span class=\"number\">900</span>,<span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"keyword\">AND</span> order_date <span class=\"keyword\">BETWEEN</span> <span class=\"string\">&#x27;2023-03-01&#x27;</span> <span class=\"keyword\">AND</span> <span class=\"string\">&#x27;2023-04-01&#x27;</span>;&quot;</span><br></pre></td></tr></table></figure>\n<p>可以看到 MRR 开启时的结果对比：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113305.png\" alt=\"20250623113305\"></p>\n<p>Wrap 也给出了对应的结果说明：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113322.png\" alt=\"20250623113322\"><br>也可以在 explain 中确认 MRR 的使用情况。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250623113335.png\" alt=\"20250623113335\"><br>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h3 id=\"48-🌟联合索引了解吗？（补充）\"><a href=\"#48-🌟联合索引了解吗？（补充）\" class=\"headerlink\" title=\"48.🌟联合索引了解吗？（补充）\"></a>48.🌟联合索引了解吗？（补充）</h3><p>联合索引就是把<strong>多个字段放在一个索引里</strong>，但必须遵守“<strong>最左前缀</strong>”原则，只有从第一个字段开始连续使用，索引才会生效。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png\" alt=\"联合索引\"></p>\n<p>联合索引会<strong>按字段顺序构建B+树</strong>。例如（age, name）索引会先按照 age 排序，age 相同则按照 name 排序，若两者都相同则按主键排序，确保叶子节点无重复索引项。</p>\n<p>创建(A,B,C)联合索引相当于同时创建了(A)、(A,B)和(A,B,C)三个索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建联合索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_order_user_product <span class=\"keyword\">ON</span> orders(user_id, product_id, create_time)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 高效查询</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> user_id<span class=\"operator\">=</span><span class=\"number\">1001</span> <span class=\"keyword\">AND</span> product_id<span class=\"operator\">=</span><span class=\"number\">2002</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> create_time <span class=\"keyword\">DESC</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"联合索引底层的存储结构是怎样的？\"><a href=\"#联合索引底层的存储结构是怎样的？\" class=\"headerlink\" title=\"联合索引底层的存储结构是怎样的？\"></a>联合索引底层的存储结构是怎样的？</h4><p>联合索引在底层采用 B+ 树结构进行存储，这一点与单列索引相同。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624093822.png\" alt=\"20250624093822\"></p>\n<p>与单列索引不同的是，联合索引的每个节点会存储所有索引列的值，而不仅仅是第一列的值。例如，对于联合索引(a,b,c)，<strong>每个节点都包含 a、b、c 三列的值</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">非叶子节点示例：  </span><br><span class=\"line\">[(a<span class=\"operator\">=</span><span class=\"number\">1</span>, b<span class=\"operator\">=</span><span class=\"number\">2</span>, c<span class=\"operator\">=</span><span class=\"number\">3</span>) → 子节点<span class=\"number\">1</span>, (a<span class=\"operator\">=</span><span class=\"number\">5</span>, b<span class=\"operator\">=</span><span class=\"number\">3</span>, c<span class=\"operator\">=</span><span class=\"number\">1</span>) → 子节点<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">叶子节点示例（InnoDB）：  </span><br><span class=\"line\">(a<span class=\"operator\">=</span><span class=\"number\">1</span>, b<span class=\"operator\">=</span><span class=\"number\">2</span>, c<span class=\"operator\">=</span><span class=\"number\">3</span>) → PK<span class=\"operator\">=</span><span class=\"number\">100</span> <span class=\"operator\">|</span> (a<span class=\"operator\">=</span><span class=\"number\">1</span>, b<span class=\"operator\">=</span><span class=\"number\">2</span>, c<span class=\"operator\">=</span><span class=\"number\">4</span>) → PK<span class=\"operator\">=</span><span class=\"number\">101</span>  </span><br><span class=\"line\">（通过指针连接形成双向链表）</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"联合索引的叶子节点存的什么内容\"><a href=\"#联合索引的叶子节点存的什么内容\" class=\"headerlink\" title=\"联合索引的叶子节点存的什么内容?\"></a>联合索引的叶子节点存的什么内容?</h4><p>联合索引属于<strong>非聚簇索引</strong>，叶子节点存储的是联合索引各列的值和对应行的主键值，而<strong>不是完整的数据行</strong>。查询非索引字段时，需要通过主键值回表到聚簇索引获取完整数据。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094019.png\" alt=\"20250624094019\"></p>\n<p>例如索引<code>(a, b)</code>的叶子节点会完整存储<code>(a, b)</code>的值，并按字段顺序排序（如 a 优先，a 相同则按 b 排序）。如果主键是 id，叶子节点会存储 (a, b, id) 的组合。</p>\n<h4 id=\"49-🌟覆盖索引了解吗？\"><a href=\"#49-🌟覆盖索引了解吗？\" class=\"headerlink\" title=\"49.🌟覆盖索引了解吗？\"></a>49.🌟覆盖索引了解吗？</h4><p>覆盖索引指的是：<strong>查询所需的字段全部都在索引中</strong>，<strong>不需要回表</strong>，从索引页就能直接返回结果。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094156.png\" alt=\"20250624094156\"></p>\n<p><code>empname</code> 和 <code>job</code> 两个字段是一个联合索引，而查询也恰好是这两个字段，这时候单次查询就可以达到目的，不需要回表。</p>\n<p>可以<strong>将高频查询的字段（如 WHERE 条件和 SELECT 列）组合为联合索引，实现覆盖索引</strong>。 例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_empname_job <span class=\"keyword\">ON</span> employee(empname, job);</span><br></pre></td></tr></table></figure>\n<p>这样查询的时候就可以走索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> empname, job <span class=\"keyword\">FROM</span> employee <span class=\"keyword\">WHERE</span> empname <span class=\"operator\">=</span> <span class=\"string\">&#x27;王二&#x27;</span> <span class=\"keyword\">AND</span> job <span class=\"operator\">=</span> <span class=\"string\">&#x27;程序员&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>普通索引只用于加速查询条件的匹配，而覆盖索引还能直接提供查询结果。</p>\n<p>一个表（name, sex,age,id），select age,id,name from tblname where name&#x3D;’paicoding’;怎么建索引<br>由于查询条件有 name 字段，所以最少应该为 name 字段添加一个索引。、</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_name <span class=\"keyword\">ON</span> tblname(name);</span><br></pre></td></tr></table></figure>\n<p>查询结果中还需要 age、id 字段，可以为这三个字段创建一个联合索引，利用覆盖索引，直接从索引中获取数据，减少回表。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_name_age_id <span class=\"keyword\">ON</span> tblname (name, age, id);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"50-🌟什么是最左前缀原则？\"><a href=\"#50-🌟什么是最左前缀原则？\" class=\"headerlink\" title=\"50.🌟什么是最左前缀原则？\"></a>50.🌟什么是最左前缀原则？</h3><p>最左前缀原则指的是：MySQL 使用联合索引时，必须从最左边的字段开始匹配，才能命中索引。</p>\n<p>假设有一个联合索引 (A, B, C)，其生效条件如下：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094631.png\" alt=\"20250624094631\"></p>\n<p>如果排序或分组的列是最左前缀的一部分，索引还可以加速操作。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 索引(a,b)</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> a <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> b; <span class=\"comment\">-- 可以利用索引排序</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"范围查询后的列还能用索引吗？\"><a href=\"#范围查询后的列还能用索引吗？\" class=\"headerlink\" title=\"范围查询后的列还能用索引吗？\"></a>范围查询后的列还能用索引吗？</h4><p>范围查询只能应用于<strong>最左前缀的最后一列</strong>。范围查询之后的列无法使用索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 索引(a,b,c)</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> a <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">AND</span> b <span class=\"operator\">&gt;</span> <span class=\"number\">2</span> <span class=\"keyword\">AND</span> c <span class=\"operator\">=</span> <span class=\"number\">3</span>; </span><br><span class=\"line\"><span class=\"comment\">-- 只能使用a和b，c无法使用索引</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"为什么不从最左开始查，就无法匹配呢？\"><a href=\"#为什么不从最左开始查，就无法匹配呢？\" class=\"headerlink\" title=\"为什么不从最左开始查，就无法匹配呢？\"></a>为什么不从最左开始查，就无法匹配呢？</h4><p>一句话回答：</p>\n<p>因为<strong>联合索引在 B+ 树中是按照最左字段优先排序构建的</strong>，如果跳过最左字段，MySQL 无法判断查找范围从哪里开始，自然也就无法使用索引。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624094835.png\" alt=\"20250624094835\"></p>\n<p>比如有一个 user 表，我们给 name 和 age 建立了一个联合索引 (name, age)。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">add</span> INDEX comidx_name_phone (name,age);</span><br></pre></td></tr></table></figure>\n<p>联合索引在 B+ 树中按照从左到右的顺序依次建立搜索树，name 在左，age 在右。</p>\n<p>当我们使用 where name&#x3D; ‘王二’ and age &#x3D; ‘20’ 去查询的时候， B+ 树会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。</p>\n<p>如果 name 相同的时候再比较 age。</p>\n<p>但如果查询条件没有 name，就不知道应该怎么查了，因为 name 是 B+树中的前置条件，没有 name，索引就派不上用场了。</p>\n<h4 id=\"联合索引-a-b-，where-a-1-和-where-b-1，效果是一样的吗\"><a href=\"#联合索引-a-b-，where-a-1-和-where-b-1，效果是一样的吗\" class=\"headerlink\" title=\"联合索引 (a, b)，where a &#x3D; 1 和 where b &#x3D; 1，效果是一样的吗\"></a>联合索引 (a, b)，where a &#x3D; 1 和 where b &#x3D; 1，效果是一样的吗</h4><p>不一样。</p>\n<p><code>WHERE a = 1</code> 能命中联合索引，因为 a 是联合索引的第一个字段，符合最左前缀匹配原则。而 <code>WHERE b = 1</code> 无法命中联合索引，因为缺少 a 的匹配条件，MySQL 会<strong>全表扫描</strong>。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>我们来验证一下，假设有一个 ab 表，建立了联合索引 <code>(a, b)</code>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> ab (</span><br><span class=\"line\"> a <span class=\"type\">INT</span>,</span><br><span class=\"line\"> b <span class=\"type\">INT</span>,</span><br><span class=\"line\"> INDEX ab_index (a, b)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>插入数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT INTO</span> ab (a, b) <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">1</span>, <span class=\"number\">3</span>), (<span class=\"number\">2</span>, <span class=\"number\">1</span>), (<span class=\"number\">3</span>, <span class=\"number\">3</span>), (<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>执行查询：<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624100243.png\" alt=\"20250624100243\"></p>\n<p>通过 explain 可以看到，WHERE a &#x3D; 1 使用了联合索引，而 WHERE b &#x3D; 1 需要全表扫描，依次检查每一行。</p>\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h4 id=\"假如有联合索引-abc，下面的-sql-怎么走的联合索引？\"><a href=\"#假如有联合索引-abc，下面的-sql-怎么走的联合索引？\" class=\"headerlink\" title=\"假如有联合索引 abc，下面的 sql 怎么走的联合索引？\"></a>假如有联合索引 abc，下面的 sql 怎么走的联合索引？</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> a <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">and</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">and</span> c <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> a <span class=\"operator\">&gt;</span> <span class=\"number\">2</span> <span class=\"keyword\">and</span> b <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>第一条 SQL 语句包含条件 a &#x3D; 2 和 b &#x3D; 2，刚好符合联合索引的前两列。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624100956.png\" alt=\"20250624100956\"></p>\n<p>第二条 SQL 语句由于未使用最左前缀中的 a，会触发全表扫描。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101013.png\" alt=\"20250624101013\"></p>\n<p>第三条 SQL 语句在范围条件 a &gt; 2 之后，索引后会停止匹配，b &#x3D; 2 的条件需要额外过滤。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101041.png\" alt=\"20250624101041\"></p>\n<h4 id=\"A-B-C-联合索引-select-from-tbn-where-a-and-b-in-and-c-会走索引吗？\"><a href=\"#A-B-C-联合索引-select-from-tbn-where-a-and-b-in-and-c-会走索引吗？\" class=\"headerlink\" title=\"(A,B,C) 联合索引 select * from tbn where a&#x3D;? and b in (?,?) and c&gt;? 会走索引吗？\"></a>(A,B,C) 联合索引 select * from tbn where a&#x3D;? and b in (?,?) and c&gt;? 会走索引吗？</h4><p>这个查询<strong>会命中联合索引</strong>，因为 a 是等值匹配，b 是 IN 等值多匹配，c 是 b 之后的范围条件，符合最左前缀原则。</p>\n<p>对于 a&#x3D;?：这是一个精确匹配，并且是联合索引的第一个字段，所以一定会命中索引。</p>\n<p>对于 b IN (?, ?)：等价于 b&#x3D;? OR b&#x3D;?，属于多值匹配，并且是联合索引的第二个字段，所以也会命中索引。</p>\n<p>对于 c&gt;?：这是一个范围条件，属于联合索引的第三个字段，也会命中索引。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>来验证一下。</p>\n<p>第一步，建表。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> tbn (A <span class=\"type\">INT</span>, B <span class=\"type\">INT</span>, C <span class=\"type\">INT</span>, D TEXT);</span><br></pre></td></tr></table></figure>\n<p>第二步，创建索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_abc <span class=\"keyword\">ON</span> tbn (A, B, C);</span><br></pre></td></tr></table></figure>\n<p>第三步，插入数据。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT INTO</span> tbn <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"string\">&#x27;First&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT INTO</span> tbn <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"string\">&#x27;Second&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT INTO</span> tbn <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"string\">&#x27;Third&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT INTO</span> tbn <span class=\"keyword\">VALUES</span> (<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"string\">&#x27;Fourth&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT INTO</span> tbn <span class=\"keyword\">VALUES</span> (<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">&#x27;Fifth&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>第四步，执行查询。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> tbn <span class=\"keyword\">WHERE</span> A<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">AND</span> B <span class=\"keyword\">IN</span> (<span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"keyword\">AND</span> C<span class=\"operator\">&gt;</span><span class=\"number\">3</span>\\G</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101415.png\" alt=\"20250624101415\"><br>从 <code>EXPLAIN</code> 输出结果来看，我们可以得到 MySQL 是如何执行查询的一些关键信息：</p>\n<ul>\n<li>type: 查询类型，这里是 range，表示 MySQL 使用了范围查找，这是因为查询条件包含了 &gt; 操作符。</li>\n<li>possible_keys: 可能被用来执行查询的索引，这里是 idx_abc，表示 MySQL 认为 idx_abc 索引会用于查询优化。</li>\n<li>key: 实际用来执行查询的索引，也是 idx_abc，这确定这条查询命中了联合索引。</li>\n<li>Extra: 提供了关于查询执行的额外信息。Using index condition 表示 MySQL 使用了索引下推（Index Condition Pushdown，ICP），这是 MySQL 的一个优化方式，它允许在索引层面过滤数据。</li>\n</ul>\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h4 id=\"联合索引的一个场景题：-a-b-c-联合索引，-b-c-是否会走索引吗？\"><a href=\"#联合索引的一个场景题：-a-b-c-联合索引，-b-c-是否会走索引吗？\" class=\"headerlink\" title=\"联合索引的一个场景题：(a,b,c)联合索引，(b,c)是否会走索引吗？\"></a>联合索引的一个场景题：(a,b,c)联合索引，(b,c)是否会走索引吗？</h4><p>根据最左前缀原则，(b,c) 查询不会走索引。</p>\n<p>因为联合索引 (a,b,c) 中，a 是最左边的列，联合索引在创建索引树的时候需要先有 a，然后才会有 b 和 c。而查询条件中没有包含 a，所以 MySQL 无法利用这个索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> tbn <span class=\"keyword\">WHERE</span> B<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">AND</span> C<span class=\"operator\">=</span><span class=\"number\">1</span>\\G</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101535.png\" alt=\"20250624101535\"></p>\n<h4 id=\"建立联合索引-a-b-c-，where-c-5-是否会用到索引？为什么？\"><a href=\"#建立联合索引-a-b-c-，where-c-5-是否会用到索引？为什么？\" class=\"headerlink\" title=\"建立联合索引(a,b,c)，where c &#x3D; 5 是否会用到索引？为什么？\"></a>建立联合索引(a,b,c)，where c &#x3D; 5 是否会用到索引？为什么？</h4><p>不会。只有索引的第三列 c 被用作查询条件，而前两列 a 和 b 都没有被使用。这<strong>不符合最左前缀原则</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> tbn <span class=\"keyword\">WHERE</span> C<span class=\"operator\">=</span><span class=\"number\">5</span>\\G</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101624.png\" alt=\"20250624101624\"></p>\n<h4 id=\"sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引？\"><a href=\"#sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引？\" class=\"headerlink\" title=\"sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引？\"></a>sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引？</h4><p>如果查询模式是后缀通配符 <code>LIKE &#39;prefix%&#39;</code>，且该字段有索引，优化器通常会使用索引。否则即便是遵循最左前缀匹配，LIKE 字段也无法命中索引。</p>\n<p>如 age &#x3D; 18 and name LIKE ‘%xxx’，MySQL 会先使用联合索引 age_name 找到 age 符合条件的所有行，然后再全表扫描进行 name 字段的过滤。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101721.png\" alt=\"20250624101721\"></p>\n<p><code>type: ref</code> 表示使用索引查找匹配某个值的所有行。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101751.png\" alt=\"20250624101751\"></p>\n<p>如果是后缀通配符，如 <code>age = 18 and name LIKE &#39;xxx%&#39;</code>，MySQL 会直接使用联合索引 age_name 找到所有符合条件的行。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624101837.png\" alt=\"20250624101837\"></p>\n<p><code>type 为 range</code>，表示 MySQL 使用了<strong>索引范围扫描</strong>，filtered 为 100.00%，表示在扫描的行中，所有的行都满足 WHERE 条件。</p>\n<h3 id=\"51-🌟什么是索引下推？\"><a href=\"#51-🌟什么是索引下推？\" class=\"headerlink\" title=\"51.🌟什么是索引下推？\"></a>51.🌟什么是索引下推？</h3><p>索引下推是指：MySQL 把 WHERE 条件尽可能“下推”到索引扫描阶段，在存储引擎层提前过滤掉不符合条件的记录。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102101.png\" alt=\"20250624102101\"></p>\n<p>当查询条件包含索引列但未完全匹配时，ICP 会在存储引擎层<strong>过滤非索引列条件</strong>，以减少回表次数。</p>\n<p><strong>传统的查询流程</strong>是，存储引擎通过<strong>联合索引</strong>定位到符合最左前缀条件的主键 ID；回表读取完整数据行并返回给 Server 层；Server 层对所有返回的行进行 WHERE 条件过滤。</p>\n<p>有了 ICP 后，存储引擎在索引层<strong>直接过滤可下推的条件</strong>，仅对符合索引条件的记录回表读取数据，再返回给 Server 层进行剩余条件过滤。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>例如有一张 user 表，建了一个联合索引（name, age），查询语句：<code>select * from user where name like &#39;张%&#39; and age=10;</code>，没有索引下推优化的情况下：</p>\n<p>MySQL 会使用索引 name 找到所有 <code>name like &#39;张%&#39;</code> 的主键，根据这些主键，一条条回表查询整行数据，并在 Server 层过滤掉不符合 <code>age=10</code> 的数据行。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102301.png\" alt=\"20250624102301\"></p>\n<p>启用 ICP 后，InnoDB 会通过联合索引直接筛选出符合条件的主键 ID（<code>name like &#39;张%&#39; and age=10</code>），然后再回表查询整行数据。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102354.png\" alt=\"20250624102354\"></p>\n<p>换句话说，假设 name like ‘张%’ 找到 10000 行数据，age&#x3D;10 只有其中 10 行，没有索引下推的情况下，MySQL 会回表 10000 次，读取 10000 行数据，然后在 Server 层过滤掉 9990 行。</p>\n<p>而有了索引下推后，MySQL 只会回表 10 次，读取 10 行数据。</p>\n<p>我们来验证一下。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102426.png\" alt=\"20250624102426\"></p>\n<p>从结果中我们可以清楚地看到 ICP 的效果。ICP 开启时，Extra 列显示”Using index condition”，表明过滤条件被下推到存储引擎层。</p>\n<p>ICP关闭时，Extra 列仅显示”Using where”，表明过滤条件在服务器层执行。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102507.png\" alt=\"20250624102507\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 开启ICP</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> optimizer_switch<span class=\"operator\">=</span><span class=\"string\">&#x27;index_condition_pushdown=on&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 清理状态</span></span><br><span class=\"line\">FLUSH STATUS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"string\">&#x27;Performance test with ICP ON&#x27;</span> <span class=\"keyword\">as</span> test_case;</span><br><span class=\"line\"><span class=\"comment\">-- 执行查询并分析性能</span></span><br><span class=\"line\">EXPLAIN ANALYZE</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"comment\">/*+ ICP_ON */</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> orders_mrr_test</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> user_id <span class=\"keyword\">BETWEEN</span> <span class=\"number\">100</span> <span class=\"keyword\">AND</span> <span class=\"number\">200</span></span><br><span class=\"line\">  <span class=\"keyword\">AND</span> order_date <span class=\"operator\">&gt;=</span> <span class=\"string\">&#x27;2023-01-01&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">AND</span> order_date <span class=\"operator\">&lt;</span> <span class=\"string\">&#x27;2023-02-01&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">AND</span> order_date <span class=\"keyword\">NOT</span> <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;2023-01-15%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 显示处理器状态</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> STATUS <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;Handler_read%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 关闭ICP</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> optimizer_switch<span class=\"operator\">=</span><span class=\"string\">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 清理状态</span></span><br><span class=\"line\">FLUSH STATUS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"string\">&#x27;Performance test with ICP OFF&#x27;</span> <span class=\"keyword\">as</span> test_case;</span><br><span class=\"line\"><span class=\"comment\">-- 执行相同的查询</span></span><br><span class=\"line\">EXPLAIN ANALYZE</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> orders_mrr_test</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> user_id <span class=\"keyword\">BETWEEN</span> <span class=\"number\">100</span> <span class=\"keyword\">AND</span> <span class=\"number\">200</span></span><br><span class=\"line\">  <span class=\"keyword\">AND</span> order_date <span class=\"operator\">&gt;=</span> <span class=\"string\">&#x27;2023-01-01&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">AND</span> order_date <span class=\"operator\">&lt;</span> <span class=\"string\">&#x27;2023-02-01&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">AND</span> order_date <span class=\"keyword\">NOT</span> <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;2023-01-15%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 显示处理器状态</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> STATUS <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;Handler_read%&#x27;</span>;&quot;</span><br></pre></td></tr></table></figure>\n<p>实际的性能差距也很大。ICP 开启时，实际扫描行数：1,649 行，执行时间：约12.3 毫秒。关闭时，实际扫描行数：19,959 行，执行时间：约 32.1 毫秒。<br>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102546.png\" alt=\"20250624102546\"></p>\n<h3 id=\"52-如何查看是否用到了索引？（补充）\"><a href=\"#52-如何查看是否用到了索引？（补充）\" class=\"headerlink\" title=\"52.如何查看是否用到了索引？（补充）\"></a>52.如何查看是否用到了索引？（补充）</h3><p>可以通过 EXPLAIN 关键字来查看是否使用了索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">column</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>如果使用了索引，结果中的 key 值会显示索引的名称。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102631.png\" alt=\"20250624102631\"></p>\n<h4 id=\"联合索引-abc，a-1-c-1-b-1-c-1-a-1-c-1-b-1-走不走索引？\"><a href=\"#联合索引-abc，a-1-c-1-b-1-c-1-a-1-c-1-b-1-走不走索引？\" class=\"headerlink\" title=\"联合索引 abc，a&#x3D;1,c&#x3D;1&#x2F;b&#x3D;1,c&#x3D;1&#x2F;a&#x3D;1,c&#x3D;1,b&#x3D;1 走不走索引？\"></a>联合索引 abc，a&#x3D;1,c&#x3D;1&#x2F;b&#x3D;1,c&#x3D;1&#x2F;a&#x3D;1,c&#x3D;1,b&#x3D;1 走不走索引？</h4><p>ac 能用上索引，条件 a&#x3D;1 符合最左前缀原则，触发索引的第一列 a；由于跳过了中间列 b，c&#x3D;1 无法直接利用索引的有序性优化，<strong>但可通过索引下推在存储引擎层过滤 c 的条件，减少回表次数</strong>。</p>\n<p>bc 无法使用索引，只能全表扫描，因为不符合最左前缀原则；<strong>acb 虽然顺序是乱的，但 MySQL 优化器会自动重排为 abc，所以能命中索引</strong>。</p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>我们通过实际的 SQL 来验证一下。</p>\n<p>示例 1（a&#x3D;1,c&#x3D;1）：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> tbn <span class=\"keyword\">WHERE</span> A<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">AND</span> C<span class=\"operator\">=</span><span class=\"number\">1</span>\\G</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102842.png\" alt=\"20250624102842\"></p>\n<p>key 是 idx_abc，表明 a&#x3D;1,c&#x3D;1 会使用联合索引。<code>Extra: Using index condition</code> 表示 ICP 生效。</p>\n<p>示例 2（b&#x3D;1,c&#x3D;1）：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> tbn <span class=\"keyword\">WHERE</span> B<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">AND</span> C<span class=\"operator\">=</span><span class=\"number\">1</span>\\G</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102921.png\" alt=\"20250624102921\"></p>\n<p>key 是 NULL，表明 b&#x3D;1,c&#x3D;1 不会使用联合索引。这是因为查询条件没有遵循最左前缀原则。</p>\n<p>示例 3（a&#x3D;1,c&#x3D;1,b&#x3D;1）：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> tbn <span class=\"keyword\">WHERE</span> A<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">AND</span> C<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">AND</span> B<span class=\"operator\">=</span><span class=\"number\">1</span>\\G</span><br></pre></td></tr></table></figure>\n<p><strong>优化器会自动调整条件顺序为 a&#x3D;1 AND b&#x3D;1 AND c&#x3D;1</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250624102956.png\" alt=\"20250624102956\"></p>\n<p>key 是 idx_abc，表明 a&#x3D;1,c&#x3D;1,b&#x3D;1 会使用联合索引。</p>\n<p>并且 rows&#x3D;1，因为 MySQL 优化器会自动重排查询条件，以满足最左前缀原则，直接使用联合索引找出 a&#x3D;1 AND b&#x3D;1 AND c&#x3D;1 的行。</p>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"53-🌟MySQL-中有哪几种锁？\"><a href=\"#53-🌟MySQL-中有哪几种锁？\" class=\"headerlink\" title=\"53.🌟MySQL 中有哪几种锁？\"></a>53.🌟MySQL 中有哪几种锁？</h3><p>MySQL 中有多种类型的锁，可以从不同维度来分类，按<strong>锁粒度</strong>划分的话，有表锁、行锁。</p>\n<p>按照<strong>加锁机制</strong>划分的话，有乐观锁和悲观锁。按照<strong>兼容性</strong>划分的话，有共享锁和排他锁。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625092449.png\" alt=\"20250625092449\"></p>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>表锁：<strong>锁定整个表</strong>，资源开销小，加锁快，但并发度低，不会出现死锁；<strong>适合查询为主、少量更新</strong>的场景（如 MyISAM 引擎）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625093141.png\" alt=\"20250625093141\"></p>\n<p>再细分的话，有<strong>表共享读锁</strong>（S锁）：允许多个事务同时读，但阻塞写操作；<strong>表独占写锁</strong>（X锁）：独占表，阻塞其他事务的读写。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625095630.png\" alt=\"20250625095630\"></p>\n<p>行锁：锁定单行或多行，开销大、加锁慢，可能出现死锁，但并发度高（InnoDB 默认支持）。</p>\n<p>再细分的话，有<strong>记录锁</strong>（Record Lock）：锁定索引中的具体记录；<strong>间隙锁</strong>（Gap Lock）：锁定索引记录之间的间隙，防止幻读；<strong>临键锁</strong>（Next-Key Lock）：结合记录锁和间隙锁，锁定一个左开右闭的区间（如 <code>(5, 10]</code>）。</p>\n<p><strong>共享锁</strong>（S锁&#x2F;读锁），允许多个事务同时读取数据，但阻塞写操作。语法：<code>SELECT ... LOCK IN SHARE MODE</code></p>\n<p><strong>排他锁</strong>（X锁&#x2F;写锁），独占数据，阻塞其他事务的读写。语法：<code>SELECT ... FOR UPDATE</code>。</p>\n<p><strong>乐观锁</strong>假设冲突少，通过版本号或 CAS 机制检测冲突（如 <code>UPDATE SET version=version+1 WHERE version=old_version</code>）。</p>\n<p><strong>悲观锁</strong>假设并发冲突频繁，先加锁再操作<code>SELECT FOR UPDATE</code>。<br>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h3 id=\"54-全局锁了解吗？（补充）\"><a href=\"#54-全局锁了解吗？（补充）\" class=\"headerlink\" title=\"54.全局锁了解吗？（补充）\"></a>54.全局锁了解吗？（补充）</h3><p><strong>全局锁就是对整个数据库实例进行加锁</strong>，当执行全局锁定操作时，整个数据库将会处于<strong>只读状态</strong>，<strong>所有写操作都会被阻塞</strong>，直到全局锁被释放。</p>\n<p>在进行全库备份，或者数据迁移时，可以使用全局锁来保证数据的一致性。</p>\n<p>在 MySQL 中，可以使用 <code>FLUSH TABLES WITH READ LOCK</code> 命令来获取全局锁。</p>\n<p>执行该命令后，所有表将被锁定为只读状态。记得在完成备份或迁移后，使用 <code>UNLOCK TABLES</code> 命令释放全局锁。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 锁定整个数据库</span></span><br><span class=\"line\">FLUSH TABLES <span class=\"keyword\">WITH</span> READ LOCK;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 执行备份操作</span></span><br><span class=\"line\"><span class=\"comment\">-- 例如使用 mysqldump 进行备份</span></span><br><span class=\"line\"><span class=\"operator\">!</span> mysqldump <span class=\"operator\">-</span>u username <span class=\"operator\">-</span>p database_name <span class=\"operator\">&gt;</span> backup.sql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 释放全局锁定</span></span><br><span class=\"line\">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>\n<h4 id=\"表锁了解吗？\"><a href=\"#表锁了解吗？\" class=\"headerlink\" title=\"表锁了解吗？\"></a>表锁了解吗？</h4><p>了解。<br>表锁常见于 <code>MyISAM</code> 引擎，<code>InnoDB</code> 也可以手动通过 LOCK TABLES 加锁。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625103530.png\" alt=\"20250625103530\"></p>\n<p>适合<strong>读多写少、全表扫描或者表结构变更</strong>的场景用。</p>\n<p>表锁又可以细分为<strong>共享锁</strong>和<strong>排他锁</strong>。<strong>共享锁允许多个事务同时读表，但不允许写操作</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOCK TABLES table_name READ;  <span class=\"comment\">-- 显式加读锁</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> table_name;     <span class=\"comment\">-- 其他会话可读，不可写</span></span><br><span class=\"line\">UNLOCK TABLES;                <span class=\"comment\">-- 释放锁</span></span><br></pre></td></tr></table></figure>\n<p><strong>排他锁只允许一个事务进行写操作</strong>，其他事务不能读也不能写。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOCK TABLES table_name WRITE; <span class=\"comment\">-- 显式加写锁</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span><span class=\"operator\">/</span><span class=\"keyword\">UPDATE</span><span class=\"operator\">/</span><span class=\"keyword\">DELETE</span> table_name; <span class=\"comment\">-- 其他会话读写均阻塞</span></span><br><span class=\"line\">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>\n<p><code>MyISAM</code> 在执行 SELECT 时<strong>会自动加读锁</strong>，执行 INSERT&#x2F;UPDATE&#x2F;DELETE 时<strong>会加写锁</strong>。</p>\n<p>对于 <code>InnoDB</code> 引擎，无索引的 <code>UPDATE/DELETE</code> 可能会<strong>导致锁升级为表锁</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> innodb_table <span class=\"keyword\">SET</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;new&#x27;</span> <span class=\"keyword\">WHERE</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;old&#x27;</span>; <span class=\"comment\">-- 全表扫描，退化为表锁</span></span><br></pre></td></tr></table></figure>\n<p>执行 <code>ALTER TABLE</code> 时会自动加表锁，阻塞所有读写操作。</p>\n<h3 id=\"55-🌟说说-MySQL-的行锁？\"><a href=\"#55-🌟说说-MySQL-的行锁？\" class=\"headerlink\" title=\"55.🌟说说 MySQL 的行锁？\"></a>55.🌟说说 MySQL 的行锁？</h3><p>行锁是 <code>InnoDB</code> 存储引擎中<strong>最细粒度的锁</strong>，它<strong>锁定表中的一行记录</strong>，允许其他事务访问表中的其他行。</p>\n<p>底层是通过<strong>给索引加锁</strong>实现的，这就意味着<strong>只有通过索引条件检索数据时</strong>，InnoDB <strong>才能使用行级锁</strong>，否则会退化为表锁。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625103938.png\" alt=\"20250625103938\"></p>\n<p>行锁又可以细分为<strong>记录锁</strong>、<strong>间隙锁</strong>和<strong>临键锁</strong>三种形式。通过 <code>SELECT ... FOR UPDATE</code> 可以加排他锁。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 加排他锁，锁定某一行</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> your_table <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 对该行进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> your_table <span class=\"keyword\">SET</span> column1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;new_value&#x27;</span> <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>通过 <code>SELECT ...LOCK IN SHARE MODE</code> 可以加共享锁。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 加共享锁，锁定某一行</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> your_table <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> LOCK <span class=\"keyword\">IN</span> SHARE MODE;</span><br><span class=\"line\"><span class=\"comment\">-- 只能读取该行，不能修改</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"select-for-update-有什么需要注意的？\"><a href=\"#select-for-update-有什么需要注意的？\" class=\"headerlink\" title=\"select for update 有什么需要注意的？\"></a>select for update 有什么需要注意的？</h4><p>第一，必须<strong>在事务中使用</strong>，否则锁会立即释放。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> your_table <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 对该行进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n<p>第二，<strong>使用时必须注意是否命中索引</strong>，否则可能锁全表。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name 没有索引，会退化为表锁</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> name <span class=\"operator\">=</span> <span class=\"string\">&#x27;王二&#x27;</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;</span><br></pre></td></tr></table></figure>\n<p>—- 这部分是帮助理解 start，面试中可不背 —-</p>\n<p>假设有一张名为 orders 的表，包含以下数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> orders (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    order_no <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">    amount <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>),</span><br><span class=\"line\">    status <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>),</span><br><span class=\"line\">    INDEX (order_no)  <span class=\"comment\">-- order_no 上有索引</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>表中的数据是这样的：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625104220.png\" alt=\"20250625104220\"><br>如果我们通过主键索引执行 <code>SELECT FOR UPDATE</code>，确实只会锁定特定的行：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 对 id=1 的行进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n<p>由于 id 是主键，所以只会锁定 id&#x3D;1 这行，不会影响其他行的操作。其他事务依然可以对 id &#x3D; 2, 3, 4, 5 等行执行更新操作，因为它们没有被锁定。<br>如果使用 order_no 这个普通索引执行 SELECT FOR UPDATE，也只会锁定特定的行：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> order_no <span class=\"operator\">=</span> <span class=\"string\">&#x27;10001&#x27;</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 对 order_no=10001 的行进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n<p>因为 order_no 是唯一索引，所以只会锁定 order_no&#x3D;10001 这行，不会影响其他行的操作。</p>\n<p>但如果 WHERE 条件是 status&#x3D;’pending’，而 status 上没有索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> status <span class=\"operator\">=</span> <span class=\"string\">&#x27;pending&#x27;</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 对 status=pending 的行进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n<p>就会退化为表锁，因为在这种情况下，MySQL 需要全表扫描检查每一行的 status。</p>\n<p>—- 这部分是帮助理解 end，面试中可不背 —-</p>\n<h4 id=\"说说记录锁吧？\"><a href=\"#说说记录锁吧？\" class=\"headerlink\" title=\"说说记录锁吧？\"></a>说说记录锁吧？</h4><p><strong>记录锁</strong>是行锁最基本的表现形式，当我们<strong>使用唯一索引或者主键索引进行等值查询时</strong>，MySQL 会为该记录<strong>自动添加排他锁</strong>，<strong>禁止其他事务读取或者修改锁定记录</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625105204.png\" alt=\"20250625105204\"></p>\n<p>例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;  <span class=\"comment\">-- 加X锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">table</span> <span class=\"keyword\">SET</span> name <span class=\"operator\">=</span> <span class=\"string\">&#x27;王二&#x27;</span> <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">-- 隐式加X锁</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"间隙锁了解吗？\"><a href=\"#间隙锁了解吗？\" class=\"headerlink\" title=\"间隙锁了解吗？\"></a>间隙锁了解吗？</h4><p>间隙锁用于在<strong>范围查询时锁定记录之间的“间隙”</strong>，<strong>防止其他事务在该范围内插入新记录</strong>。仅在可重复读及以上的隔离级别下生效，主要用于防止幻读。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625105253.png\" alt=\"20250625105253\"></p>\n<p>—- 这部分是帮助大家理解 start，面试中可不背 —-</p>\n<p>例如事务 A 锁定了 <code>(1000,2000)</code> 区间，会阻止事务 B 在此区间插入新记录：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 事务A</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> amount <span class=\"keyword\">BETWEEN</span> <span class=\"number\">1000</span> <span class=\"keyword\">AND</span> <span class=\"number\">2000</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务B尝试插入会被阻塞</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT INTO</span> orders <span class=\"keyword\">VALUES</span>(<span class=\"keyword\">null</span>,<span class=\"number\">1500</span>,<span class=\"string\">&#x27;pending&#x27;</span>);  <span class=\"comment\">-- 阻塞&lt;/code&gt;</span></span><br></pre></td></tr></table></figure>\n<p>假设表 test_gaplock 有 id、age、name 三个字段，其中 id 是主键，age 上有索引，并插入了 4 条数据。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> `test_gaplock` (</span><br><span class=\"line\"> `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT NULL</span>,</span><br><span class=\"line\"> `age` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\"> `name` <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\"> <span class=\"keyword\">PRIMARY KEY</span> (`id`),</span><br><span class=\"line\"> KEY `age` (`age`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert into</span> test_gaplock <span class=\"keyword\">values</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">&#x27;张三&#x27;</span>),(<span class=\"number\">6</span>,<span class=\"number\">6</span>,<span class=\"string\">&#x27;吴老二&#x27;</span>),(<span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"string\">&#x27;赵四&#x27;</span>),(<span class=\"number\">12</span>,<span class=\"number\">12</span>,<span class=\"string\">&#x27;熊大&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>间隙锁会锁住：</p>\n<ul>\n<li><code>(−∞, 1)</code>：最小记录之前的间隙。</li>\n<li><code>(1, 6)、(6, 8)、(8, 12)</code>：记录之间的间隙。</li>\n<li><code>(12, +∞)</code>：最大记录之后的间隙。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625110538.png\" alt=\"20250625110538\"></p>\n<p>假设有两个事务，T1 执行以下语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> test_gaplock <span class=\"keyword\">WHERE</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">5</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;</span><br></pre></td></tr></table></figure>\n\n<p>T2 执行以下语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">INSERT INTO</span> test_gaplock <span class=\"keyword\">VALUES</span> (<span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"string\">&#x27;王五&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>T1 会锁住 <code>(6, 8)</code> 的间隙，防止其他事务在这个范围内插入新记录。</p>\n<p>T2 在插入 <code>(7, 7, &#39;王五&#39;)</code> 时，会被阻塞，可以在另外一个会话中执行 <code>SHOW ENGINE INNODB STATUS</code> 查看到间隙锁的信息。<br><img src=\"https://cdn.jsdelivr.net/gh/JakicDong/blog-assets@main/images/20250625112428.png\" alt=\"20250625112428\"></p>\n<h4 id=\"执行什么命令会加上间隙锁？\"><a href=\"#执行什么命令会加上间隙锁？\" class=\"headerlink\" title=\"执行什么命令会加上间隙锁？\"></a>执行什么命令会加上间隙锁？</h4><p>在可重复读隔离级别下，执行<code>FOR UPDATE / LOCK IN SHARE MODE</code>等加锁语句，且<strong>查询条件是范围查询</strong>时，就会自动加上间隙锁。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- SELECT ... FOR UPDATE + 范围查询</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> score <span class=\"operator\">&gt;</span> <span class=\"number\">100</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;</span><br><span class=\"line\"><span class=\"comment\">-- SELECT ... LOCK IN SHARE MODE + 范围查询</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> id <span class=\"keyword\">BETWEEN</span> <span class=\"number\">10</span> <span class=\"keyword\">AND</span> <span class=\"number\">20</span> LOCK <span class=\"keyword\">IN</span> SHARE MODE;</span><br><span class=\"line\"><span class=\"comment\">-- UPDATE/DELETE + 范围查询</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> score <span class=\"operator\">&lt;</span> <span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure>"}]}