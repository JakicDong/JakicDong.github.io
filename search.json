[{"title":"2025.6.12学习日记","path":"/2025/06/12/学习日记/2025.6.12学习笔记/","content":"今日学习内容3DGS:今日工作总结明日工作计划力扣每日一题:循环数组简单题. 上午看mysql看到24题. 下午看项目看了一篇Servlet的文章. Spring学习生活记录","tags":["3DGS","spring","日记","leetcode","mysql"]},{"title":"3DGS学习笔记","path":"/2025/06/11/3DGS学习笔记/","content":"环境配置https://www.youtube.com/watch?v=UXtuigy_wYc youtube复现视频https://github.com/graphdeco-inria/gaussian-splatting 3DGS的github源码地址https://dl.acm.org/doi/10.1145/3592433 论文地址https://arxiv.org/abs/2308.04079 下载依赖和环境视频老哥的github地址https://github.com/jonstephens85/gaussian-splatting-Windows 下载git(跳过)测试是否下载git –version 下载anaconda(跳过)下载CUDA :nvcc –version测试版本nvidia-smi确定电脑最高支持的CUDA版本 ,我的最高支持12.8 准备下载CUDA 11.8版本安装vs2019官方下载地址：https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/ 下载colmap准备编译打开anaconda prompt D: 切换D盘D:\\user\\desktop\\workplace\\3DGS\\userdesktopworkplace3DGS 要将 Anaconda 创建的虚拟环境设置在 D 盘，可以按照以下步骤操作： 修改 Anaconda 配置首先，需要修改 Anaconda 的配置，使其将环境创建在指定路径。在 Anaconda Prompt 中执行以下命令：conda config –add envs_dirs D:\\Anaconda\\envs（如果需要，将 D:\\Anaconda\\envs 替换为你想要的路径） 确保路径存在确保你指定的路径已经存在。如果不存在，请手动创建该文件夹。 创建虚拟环境现在你就可以创建虚拟环境，新的环境将被创建在 D 盘的指定路径下：conda create –name env_name python3.x 检查环境位置可以使用以下命令查看虚拟环境的位置：conda info –envs经过以上步骤后，你的虚拟环境将会在 D 盘创建。conda create -n gaussian_splatting python3.7conda activate gaussian_splattingconda install -c conda-forge vs2019_win-64pip install torch1.13.1+cu117 torchvision0.14.1+cu117 torchaudio0.13.1 –extra-index-url https://download.pytorch.org/whl/cu117pip install submodulesdiff-gaussian-rasterizationpip install submodulessimple-knnpip install submodulesfused-ssim 训练3dgs的运行训练下述所有命令都是在终端里运行的，运行时保持是从gaussian-splatting目录下开始输入的。省流版本:conda activate gaussian_splattingd:cd D:\\sys\\Desktop\\Workplace\\3DGS新的路径训练:python train.py -s data_train -m data_train/output (参数为输出地址)python render.py -m data_train/output把train文件夹的method复制到test文件夹python metrics.py -m data_train/output 1.视频截取帧这里可以用自己手机拍摄的一段视频，一两分钟即可，可以参考一下作者的训练时间，作者用自己的笔记本（4060 8G），大概训练了两个小时左右，跑完了所有的迭代。 在gaussian-splatting目录下新建一个data文件夹，将你拍摄的视频移动到该data文件夹下，并将你的视频改名为input，后缀.mp4不用改。然后在data文件夹里再建一个与视频同名的文件夹，名字也是input。然后就可以输入命令啦（终端里从gaussian-splattingdata目录下开始输入） cd data ffmpeg -i input.mp4 -vf setpts=0.2*PTS input\\input_%04d.jpg #推荐运行这个指令 ffmpeg -i input.mp4 -vf setpts=0.2*PTS,fps=1 input\\input_%04d.jpg #如果需要调整抽帧频率可以参考这个指令。选择一个运行即可 这里简单的说一下各个参数的含义。setpts0.2*PTS 将视频播放速度加快到原来的 5 倍。这意味着原视频的每秒帧数增加到 5 倍。如果原始视频是 30 FPS，加速后的视频将以 150 FPS 播放。尽管视频播放速度加快了，ffmpeg fps1 会以每秒一帧的频率提取图片。 这样就可以把你的视频截取为帧并保存在input文件夹里，在input文件夹里应该可以看到许多张照片。 2.产生点云在终端gaussian-splatting目录下输入cd ..python convert.py -s data 这个就是利用安装的colmap产生点云，会花费一些时间，等待完成即可。 3.查看点云终端里输入 colmap 调出来colmap后，选择file-import model然后选择gaussian-splattingdatasparse0文件夹，选择确定，即可打开生成的点云，遇到弹窗×掉即可。可以看到生成的点云还有相机路径。 4.开始训练同样，在终端里gaussian-splatting目录下，输入 python train.py -s data -m dataoutput (参数为输出地址)python train.py -s data -m dataimages 成功开始会出现如下图所示然后耐心等待训练完成以后即可。 5.查看结果同样，在终端里gaussian-splatting目录下，输入 .\\viewers\\bin\\SIBR_gaussianViewer_app -m dataoutput 即可打开viewer窗口，可以把你的场景拖大，下面是一些快捷按键 w uio asd jkl 就是可以控制视角的变化，大家自己按一下就知道是干啥的了，这里就不一一列举对应的功能了（作者已经累了），注意切换输入法为英文输入。 至此，就全部结束啦，完结撒花！ 1 . convert.py将input数据集转换成为点云通过sfm算法将输入的图片集转换成点云,这种方式的具体流程如下: 特征提取：从输入的图像集中，对每一张图像提取特征点及其描述子，常用的特征提取算法有 SIFT、SURF、ORB 等。 全局特征匹配：在所有图像的特征点之间进行匹配，找出不同图像中表示同一物理点的特征点对。由于是全局匹配，可能会处理大量的特征点对，计算量较大。 相机位姿估计：根据匹配的特征点对，使用诸如对极几何、PnP 等算法来估计相机的相对位姿。 三角测量：利用已知的相机位姿和匹配的特征点，通过三角测量计算出三维点的坐标，从而生成点云。 全局优化：使用束调整（Bundle Adjustment）等方法对相机位姿和三维点的坐标进行全局优化，提高点云的精度。SfM 侧重于对静态图像集进行全局处理，通过全局优化来生成高精度的点云,SfM相比ORB方法 更侧重于离线的高精度三维重建. 渲染辐射场的几种方法建立了最近的数据集。革命性地合成了用多张照片或视频捕获的场景。然而，实现高视觉质量仍然需要训练和渲染成本高昂的神经网络，而最近更快的方法不可避免地要牺牲速度来换取质量。对于无界和完整的场景(而不是孤立的对象)和1080p分辨率的渲染，目前没有一种方法可以实现实时显示速率。我们介绍了三个关键要素，使我们能够在保持有竞争力的训练时间的同时实现最先进的视觉质量，并且重要的是允许在1080p分辨率下实现高质量的实时(≥30 fps)新视图合成。首先，从相机校准过程中产生的稀疏点开始，我们用3D高斯分布表示场景，该分布保留了用于场景优化的连续体辐射场的理想属性，同时避免了在空白空间中不必要的计算;其次，我们对3D高斯分布进行交错优化密度控制，特别是优化各向异性协方差以实现场景的准确表示;第三，我们开发了一种支持各向异性喷溅的快速可视性感知渲染算法，既加速了训练，又允许实时渲染。我们展示了最先进的视觉质量和实时性 3dgs流程3DGS流程：（1）通过colmap等工具从多视角图像获取SfM点云（SfM是一种三维重建算法，通过两个或多个场景图片恢复相机位姿，并重建三维坐标点），对 SfM 点云进行了初始化。 （2）点云中的每一个点代表着一个三维的高斯分布，除了点的位置（均值）外，还有协方差、不透明度、颜色（球谐函数）–3D 高斯球云。 （3）将这些椭球体沿着特定角度投影到对应位姿所在平面（Splatting）。一个椭球体投影到平面会得到一个椭圆；然后通过计算待求解像素和椭圆中心的距离，我们得到不透明度（离的近，说明越不透明）；每个椭球又代表各自的颜色，进行alpha composting来合成颜色，然后快速的对所有像素做“可微光栅化”，渲染得到图像。 （4）得到渲染图像Image后，再与gt图像比较，得到损失loss，并沿蓝色箭头反向传播，随机梯度下降；向下送入自适应密度控制中（增密或修剪），更新点云优化。 代码运行流程1.Runningpython train.py -s 示例： python train.py -s data360_extra_scenestreehill 运行完在output下得到相应的文件夹outputtreehill， 将得到的结果路径添加至SIBR_viewer.py（model_path r’D:\\gaussian-splatting\\output\\treehill’），运行即可获得可视化。 densify_and_prune操作会改变高斯数量。结合在一起，允许模型根据当前两个的训练状态动态地调整高斯的数量，从而实现更好的表示能力和计算效率。因此，在这个过程中，高斯的数量会变化，所以需要在执行后打印出当前的高斯数量。在训练的时候添加高斯数量打印： print(f”Iteration {iteration}: Number of Gaussians after densification and pruning: {gaussians.get_xyz.shape[0]}”) 2. Evaluationpython train.py -s –eval # Train with traintest splitpython render.py -m # Generate renderingspython metrics.py -m # Compute error metrics on renderings 训练模型-渲染图像-计算指标 示例：Evaluation运行，输入命令行(python train.py -s + 数据集的路径) python train.py -s data360_extra_scenestreehill –evalpython render.py -m outputtreehillpython metrics.py -m outputtreehill 2. Processing your own Scenes按照README.me进行，选择的mill19building-pixsfm进行简单测试 图像目录结构： location|---input |---image 0 |---image 1 |---...python convert.py -s location [--resize] #If not resizing, ImageMagick is not needed示例：data/mill19/building-pixsfm|---input |---image 0 |---image 1 |---... 然后运行： python convert.py -s datamill19building-pixsfm","tags":["3DGS"]},{"title":"2025.6.11学习日记","path":"/2025/06/11/学习日记/2025.6.11学习笔记/","content":"今日学习内容3DGS:今日工作总结:​一. 代码运行与结构梳理​​:学习了原版3DGS的项目结构和训练流程: train.py : 训练脚本,主要负责对高斯球参数进行训练. render.py : 渲染脚本,用于将训练得到的高斯球参数渲染成图像. metrics.py : 评估脚本,对比真值图像和渲染图像,用于评估渲染结果的质量. 二.训练结果:火车数据集301张图像. train.py :ITER 7000:L1损失 : 0.06603520661592484PSNR :20.096060180664065训练时间 : 13分30秒ITER 30000:L1损失 : 0.038734884932637215PSNR : 24.450721740722656s训练时间:77分25秒 render.py : metrics.py :SSIM: 0.87444342PSNR: 25.8431702LPIPS: 0.1703709 ​​明日工作计划:​​今天对火车的数据集进行了实验,明天准备开始对其他数据集进行实验,得出一组原版3DGS的训练结果作为参考,方便对后续3DGS改进算法进行实验对比. 下午回学校开会来着晚上继续做力扣二叉树篇明日计划3dgs明天尽量让时间一直在跑代码,然后我可以学java. mysql学习力扣项目文档生活记录1. 早上足球训练早上7点,颠球短传训练.","tags":["3DGS","日记"]},{"title":"nvm更改node版本","path":"/2025/06/11/杂项笔记/nvm更改node版本/","content":"安装brew首先安装 Brew。这个就不详细说了 没有的话自己去搜一下 第一步：进行nvm 安装操作brew install nvm 执行后：== Pouring nvm-0.39.1_1.all.bottle.tar.gz== CaveatsPlease note that upstream has asked us to make explicit managingnvm via Homebrew is unsupported by them and you should check anyproblems against the standard nvm install method prior to reporting.You should create NVMs working directory if it doesnt exist: // 这里就是提示你创建一个 nvm文件 mkdir ~/.nvmAdd the following to ~/.zshrc or your desired shellconfiguration file: // 这里就是想让你进行一些配置 export NVM_DIR=$HOME/.nvm [ -s /opt/homebrew/opt/nvm/nvm.sh ] \\. /opt/homebrew/opt/nvm/nvm.sh # This loads nvm [ -s /opt/homebrew/opt/nvm/etc/bash_completion.d/nvm ] \\. /opt/homebrew/opt/nvm/etc/bash_completion.d/nvm # This loads nvm bash_completionYou can set $NVM_DIR to any location, but leaving it unchanged from/opt/homebrew/opt/nvm will destroy any nvm-installed Node installationsupon upgrade/reinstall.Type `nvm help` for further information.== Summary🍺 /opt/homebrew/Cellar/nvm/0.39.1_1: 9 files, 184KB 执行 nvm –versionnvm --version //出现问题。去进行配置 zsh: command not found: nvm 第二步：nvm配置1.vim ~/.bash_profile点击 i 进行插入操作 插入下面配置 export NVM_DIR=~/.nvmsource $(brew --prefix nvm)/nvm.sh 插入完成后 点击Esc 然后 使用 :wq. 保存并退出 执行：source ~/.bash_profile 如果出问题先不管接着往下走 2.vim ~/.zshrc点击 i 进行插入操作 插入下面配置 export NVM_DIR=~/.nvmsource $(brew --prefix nvm)/nvm.sh 插入完成后 点击Esc 然后 使用 :wq. 保存并退出 执行：source ~/.zshrc 3.vim ~/.profile点击 i 进行插入操作 插入下面配置 export NVM_DIR=~/.nvmsource $(brew --prefix nvm)/nvm.sh 插入完成后 点击Esc 然后 使用 :wq. 保存并退出 执行：source ~/.profile 最后开始进行测试执行：nvm --version 显示版本号就说明配置成功：0.39.1 通过nvm 进行node 版本控制 版本号根据自己的需求定义 nvm install 12.6.0 查看版本：node -v nvm 常用命令：以下用8.9.2版本为例nvm ls ：打印出所有的版本 install stable：安装最稳定的版本nvm install v8.9.2 ： 安装node的8.9.2的版本（删除用uninstall）nvm current ：当前使用的node版本nvm use v8.9.2 ：将node改为8.9.2版本nvm alias default 0.12.7：设置默认 node 版本为 0.12.7nvm alias default ：设置系统默认的node版本nvm alias ：给不同的版本号添加别名nvm unalias ： 删除已定义的别名nvm reinstall-packages ：在当前版本node环境下，重新全局安装指定版本号的npm包npm install -g mz-fis：安装 mz-fis 模块至全局目录，安装的路径：/Users/你的用户名/.nvm/versions/node/v0.12.7/lib/mz-fisnvm use 4：切换至 4.2.2 版本（支持模糊查询）npm install -g react-native-cli：安装 react-native-cli 模块至全局目录，安装的路径：/Users/你的用户名/.nvm/versions/node/v4.2.2/lib/react-native-cli node npm 版本对照链接: 版本对照 末尾 npm 降级执行：sudo npm install npm@6.9.0 -g 问题是不可控的 如果未能解决你的问题 就祝你顺利","tags":["nvm","node"]},{"title":"Java集合框架笔记","path":"/2025/06/10/Java集合框架笔记/","content":"框架图先贴一个Java集合框架图 可以看出,集合主要分成两大部分: Collection:主要由 List、Set、Queue 组成，List 代表有序、可复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；Set 代表⽆序、不可复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列ArrayDeque，以及优先级队列 PriorityQueue。 Map:代表键值对的集合，典型代表就是 HashMap。 CollectionListList 的特点是存取有序，可以存放复的元素，可以⽤下标对元素进⾏操作。 ArrayListArrayList的增删改查: // 创建⼀个集合ArrayListString list = new ArrayListString();// 添加元素list.add(王⼆);list.add(沉默);list.add(陈清扬);// 遍历集合 for 循环for (int i = 0; i list.size(); i++) String s = list.get(i); System.out.println(s);// 遍历集合 for eachfor (String s : list) stem.out.println(s);// 删除元素list.remove(1);// 遍历集合for (String s : list) System.out.println(s);// 修改元素list.set(1,王⼆狗);// 遍历集合for (String s : list) System.out.println(s);","tags":["基础","Java","集合"]},{"title":"Mysql学习笔记","path":"/2025/06/10/Mysql学习笔记/","content":"Mysql基础0.什么是MYSQLMySQL 是⼀个开源的关系型数据库，现在⾪属于 Oracle 公司。 删除创建一张表DROP TABLE 删除表CREATE TABLE 创建表创建表的时候，可以通过 PRIMARY KEY 设定主键。 CREATE TABLE users ( id INT AUTO_INCREMENT, name VARCHAR(100) NOT NULL, email VARCHAR(100), PRIMARY KEY (id)); 写一个升序降序的SQL语句可以使用ORDER BY字句对查询结果进行排序.默认情况下是升序排序.如需要降序,使用关键字DESC例子: SELECT id, name, salaryFROM employeesORDER BY salary DESC; 如若对多个字段进行排序: SELECT id, name, salaryFROM employeesORDER BY salary DESC, name ASC; 优先级从左到右,相当于先按工资降序,工资相同再按照姓名升序. MYSQL出现性能差的原因可能是 SQL 查询使⽤了全表扫描，也可能是查询语句过于复杂，如多表JOIN或嵌套⼦查询。也有可能是单表数据量过⼤。 通常情况下,增加索引就可以解决大部分的性能问题.对于热点数据,增加redis缓存,减轻对数据库的压力. 1.两张表怎么进行连接可以通过内连接inner join、外连接 outer join 、交叉连接 cross join 等方式来进行连接. 什么是内连接内连接⽤于返回两个表中有匹配关系的⾏。假设有两张表，⽤户表和订单表，想查询有订单的⽤户，就可以使⽤内连接 users INNER JOIN orders，按照⽤户 ID 关联就⾏了。 SELECT users.name, orders.order_idFROM usersINNER JOIN orders ON users.id = orders.user_id; 两表匹配的行才会输出. 什么是外连接和内连接不同，外连接不仅返回两个表中匹配的⾏，还返回没有匹配的⾏，⽤ null 来填充。外连接⼜分为左外连接 left join 和右外连接 right join。 left join 会保留左表中符合条件的所有记录，如果右表中有匹配的记录，就返回匹配的记录，否则就⽤null 填充，常⽤于某表中有，但另外⼀张表中可能没有的数据的查询场景。假设要查询所有⽤户及他们的订单，即使⽤户没有下单，就可以使⽤左连接： SELECT users.id, users.name, orders.order_idFROM usersLEFT JOIN orders ON users.id = orders.user_id; (这里面左表就是users,users所有行都会输出) 右连接就是左连接的镜像，right join 会保留右表中符合条件的所有记录，如果左表中有匹配的记录，就返回匹配的记录，否则就⽤ null 填充。 什么是交叉连接交叉连接会返回两张表的笛卡尔积，也就是将左表的每⼀⾏与右表的每⼀⾏进⾏组合，返回的⾏数是两张表⾏数的乘积。假设有 A 表和 B 表，A 表有 2 ⾏数据，B 表有 3 ⾏数据，那么交叉连接的结果就是 2 * 3 6 ⾏。笛卡尔积是数学中的⼀个概念，例如集合 A{a,b}，集合 B{0,1,2} ，那么 A x B {a,0,a,1,a,2,b,0,b,1,b,2,}。 SELECT A.id, B.idFROM ACROSS JOIN B; 2.内连接 左连接 右连接有什么区别左连接 FROM 表a join 表b 相当于 a在左 b在右MySQL 的连接主要分为内连接和外连接，外连接⼜可以分为左连接和右连接。 内连接相当于找两表的交集.左连接和右连接可以⽤来找出两个表中不同的记录，相当于两个数据集的并集。两者的区别是，左连接会保留左表中符合条件的所有记录，右连接则刚好相反。 例子:有三张表，⼀张⽂章表 article，主要存⽂章标题 title.⼀张⽂章详情表 article_detail，主要存⽂章的内容 content.⼀张⽂章评论表 comment，主要存评论 content.三个表通过⽂章 id关联。内连接:返回至少有评论的文章标题和评论内容 SELECT LEFT(a.title, 20) AS ArticleTitle, LEFT(c.content, 20) AS CommentContent //返回LEFT左数前20字符 AS为列或表起临时别名FROM article a //article起别名 aINNER JOIN comment c ON a.id = c.article_id //内连接 id相同 起别名cLIMIT 2; //只返回两条 左连接:返回所有⽂章的标题和⽂章评论，即使某些⽂章没有评论（填充为 NULL）。 SELECT LEFT(a.title, 20) AS ArticleTitle, LEFT(c.content, 20) ASCommentContentFROM article aLEFT JOIN comment c ON a.id = c.article_idLIMIT 2; 右连接:调换了位置 SELECT LEFT(a.title, 20) AS ArticleTitle, LEFT(c.content, 20) ASCommentContentFROM comment cRIGHT JOIN article a ON a.id = c.article_idLIMIT 2; 3.数据库的三大范式 - 第⼀范式:确保表的每⼀列都是不可分割的基本数据单元.⽐如说⽤户地址，应该拆分成省、市、区、详细地址等 4 个字段。相当于保持列的原子性. - 第⼆范式:要求表中的每⼀列都和主键直接相关。⽐如在订单表中，商品名称、单位、商品价格等字段应该拆分到商品表中。然后再创建一个订单商品关联表.不能出现部分依赖的情况.相当于让解决复合主键的部分依赖问题.订单明细(订单ID, 产品ID, 产品名称, 数量)↑ 复合主键是(订单ID, 产品ID)，但”产品名称”只依赖”产品ID”（部分依赖）修改为:订单明细(订单ID, 产品ID, 数量)产品(产品ID, 产品名称) - 第三范式:⾮主键列应该只依赖于主键列。⽐如说在设计订单信息表的时候，可以把客户名称、所属公司、联系⽅式等信息拆分到客户信息表中，然后在订单信息表中⽤客户编号进⾏关联。**相当于消除传递依赖.**将​​传递依赖​​的字段（A→B→C，其中A是主键）拆分到新表中。学生(学号, 姓名, 宿舍号, 宿舍费用)↑ “宿舍费用”依赖”宿舍号”，而”宿舍号”依赖”学号”（传递依赖）修改为:学生(学号, 姓名, 宿舍号)宿舍(宿舍号, 宿舍费用) 建表时需要考虑哪些问题⾸先需要考虑表是否符合数据库的三⼤范式，确保字段不可再分，消除⾮主键依赖，确保字段仅依赖于主键等。然后在选择字段类型时，应该尽量选择合适的数据类型。在字符集上，尽量选择 utf8mb4，这样不仅可以⽀持中⽂和英⽂，还可以⽀持表情符号等。当数据量较⼤时，⽐如上千万⾏数据，需要考虑分表。⽐如订单表，可以采⽤⽔平分表的⽅式来分散单表存储压⼒。 水平分表(按行拆分):水平分表是将​​同一张表中的数据按行拆分到多个结构相同的表中 按照id范围分表 按照时间范围分表 按照hash分表 按照地域分表 垂直分表(按列拆分):不同分表包含不同字段,表字段过多或冷热数据分离时使用. 4.varchar 与 char 的区别latin1 字符集，且列属性定义为 NOT NULL。 varchar 是可变⻓度的字符类型，原则上最多可以容纳 65535 个字符，但考虑字符集，以及MySQL 需要 1 到 2 个字节来表示字符串⻓度，所以实际上最⼤可以设置到 65533。char 是固定⻓度的字符类型，当定义⼀个 CHAR(10) 字段时，不管实际存储的字符⻓度是多少，都只会占⽤ 10 个字符的空间。如果插⼊的数据⼩于 10 个字符，剩余的部分会⽤空格填充。 varchar在输入过长时也会截断. 5.blob 和 text 有什么区别blob ⽤于存储⼆进制数据，⽐如图⽚、⾳频、视频、⽂件等；但实际开发中，我们都会把这些⽂件存储到 OSS 或者⽂件服务器上，然后在数据库中存储⽂件的 URL。 text ⽤于存储⽂本数据，⽐如⽂章、评论、⽇志等。 6.DATETIME 和 TIMESTAMP 有什么区别DATETIME 直接存储⽇期和时间的完整值，与时区⽆关。TIMESTAMP 存储的是 Unix 时间戳，1970-01-01 00:00:01 UTC 以来的秒数，受时区影响。 另外，DATETIME 的默认值为 null，占⽤ 8 个字节；TIMESTAMP 的默认值为当前时间——CURRENT_TIMESTAMP，占 4 个字节，实际开发中更常⽤，因为可以⾃动更新。 7. in 和 exists 的区别当使⽤ IN 时，MySQL 会⾸先执⾏⼦查询，然后将⼦查询的结果集⽤于外部查询的条件。这意味着⼦查询的结果集需要全部加载到内存中。 ⽽ EXISTS 会对外部查询的每⼀⾏，执⾏⼀次⼦查询。如果⼦查询返回任何⾏，则EXISTS条件为真。EXISTS 关注的是⼦查询是否返回⾏，⽽不是返回的具体值。 -- IN 的临时表可能成为性能瓶颈SELECT * FROM usersWHERE id IN (SELECT user_id FROM orders WHERE amount 100);//查询所有下过单笔订单金额超过100的用户（完整信息）-- EXISTS 可以利⽤关联索引SELECT * FROM users uWHERE EXISTS (SELECT 1 FROM orders oWHERE o.user_id = u.id AND o.amount 100); IN 适⽤于⼦查询结果集较⼩的情况。如果⼦查询返回⼤量数据,IN的查询效率会下降,因为他会把整个结果存到内存当中. ⽽ EXISTS 适⽤于⼦查询结果集可能很⼤的情况。由于 EXISTS 只需要判断⼦查询是否返回⾏，⽽不需要加载整个结果集，因此在某些情况下性能更好，特别是当⼦查询可以使⽤索引时。 NULL值IN的返回结果中如果有NULL值,可能会出现意料外的情况:比如WHERE column IN ((subquery))，如果subquery为NULL,这个条件永远不会为真,除非column也为NULL. EXISTS如果有NULL值的话,因为EXISTS只关心是否有⾏,所以不会出现NULL值的影响. 8.记录货币⽤什么类型⽐较好?如果是电商、交易、账单等涉及货币的场景，建议使⽤ DECIMAL 类型，因为 DECIMAL 类型是精确数值类型，不会出现浮点数计算误差。 如果是银⾏,涉及到⽀付的场景，建议使⽤ BIGINT 类型。可以将货币⾦额乘以⼀个固定因⼦，⽐如 100，表示以“分”为单位，然后存储为 BIGINT 。这种⽅式既避免了浮点数问题，同时也提供了不错的性能。但在展示的时候需要除以相应的因⼦。 为什么不推荐使⽤ FLOAT 或 DOUBLE？因为 FLOAT 和 DOUBLE 都是浮点数类型，会存在精度问题。在许多编程语⾔中， 0.1 + 0.2 的结果会是类似 0.30000000000000004 的值，⽽不是预期的 0.3 。 9.如何存储emoji?因为 emoji是 4 个字节的 UTF-8 字符，⽽ MySQL 的 utf8 字符集只⽀持最多 3 个字节的 UTF-8 字符，所以在 MySQL 中存储 emoji 时，需要使⽤ utf8mb4 字符集。 MySQL 8.0 已经默认⽀持 utf8mb4 字符集，可以通过 SHOW VARIABLES WHERE Variable_name LIKE character\\_set\\_% OR Variable_name LIKE collation%; 查看。 10.drop、delete 与 truncate 的区别？ DROP 是物理删除，⽤来删除整张表，包括表结构，且不能回滚。 DELETE ⽀持⾏级删除，可以带 WHERE 条件，可以回滚。 TRUNCATE ⽤于清空表中的所有数据，但会保留表结构，不能回滚。 11.UNION 与 UNION ALL 的区别？UNION 会⾃动去除合并后结果集中的重复⾏。UNION ALL 不会去重，会将所有结果集合并起来。 12.count(1)、count(*) 与 count(列名) 的区别？在InnoDB引擎里面,count(1)和count(*)没有任何区别,都用来统计所有行,包括NULL.如果有索引,那么count(1)和count(*)都会走索引,而count(列名)会走主键索引. COUNT(列名) 只统计列名不为 NULL 的⾏数。 13.SQL 查询语句的执⾏顺序了解吗？了解,先执行FROM确定主表,，再执⾏JOIN连接，然后 WHERE 进⾏过滤，接着 GROUP BY 进⾏分组，HAVING 过滤聚合结果，SELECT 选择最终列，ORDER BY 排序，最后 LIMIT 限制返回⾏数。 WHERE 先执⾏是为了减少数据量，HAVING 只能过滤聚合数据，ORDER BY 必须在SELECT 之后排序最终结果，LIMIT 最后执⾏以减少数据传输。 这个执⾏顺序与编写 SQL 语句的顺序不同，这也是为什么有时候在 SELECT ⼦句中定义的别名不能在 WHERE ⼦句中使⽤得原因，因为 WHERE 是在 SELECT 之前执⾏的。 LIMIT 为什么在最后执⾏？因为 LIMIT 是在最终结果集上执⾏的，如果在 WHERE 之前执⾏ LIMIT，那么就会先返回所有⾏，然后再进⾏ LIMIT 限制，这样会增加数据传输的开销。 ORDER BY 为什么在 SELECT 之后执⾏？因为排序需要基于最终返回的列，如果 ORDER BY 早于 SELECT 执⾏，计算 类的聚合函数就会出问题。比如说如果要按照所选的平均值排序,order by先执行,还没有计算平均值. 14.介绍⼀下 MySQL 的常⽤命令MySQL 的常⽤命令主要包括数据库操作命令、表操作命令、⾏数据 CRUD 命令、索引和约束的创建修改命令、⽤户和权限管理的命令、事务控制的命令等。 -- 数据库操作CREATE DATABASE db_name; -- 创建数据库DROP DATABASE db_name; -- 删除数据库SHOW DATABASES; -- 查看所有数据库USE db_name; -- 切换数据库-- 表操作CREATE TABLE table_name ( -- 创建表 id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50) NOT NULL);DROP TABLE table_name; -- 删除表ALTER TABLE table_name ADD COLUMN col_name INT; -- 添加列ALTER TABLE table_name DROP COLUMN col_name; -- 删除列SHOW TABLES; -- 查看所有表DESC table_name; -- 查看表结构-- 数据CRUDINSERT INTO table_name VALUES (1, test); -- 插入数据SELECT * FROM table_name; -- 查询数据UPDATE table_name SET name=new WHERE id=1;-- 更新数据DELETE FROM table_name WHERE id=1; -- 删除数据-- 索引和约束CREATE INDEX idx_name ON table_name(col); -- 创建索引ALTER TABLE table_name ADD PRIMARY KEY(id); -- 添加主键ALTER TABLE table_name ADD UNIQUE(col_name); -- 添加唯一约束ALTER TABLE table_name ADD FOREIGN KEY(col) REFERENCES other_table(col); -- 外键-- 用户权限CREATE USER user@host IDENTIFIED BY pwd; -- 创建用户GRANT ALL ON db_name.* TO user@host; -- 授权REVOKE ALL ON db_name.* FROM user@host; -- 撤销权限DROP USER user@host; -- 删除用户-- 事务控制START TRANSACTION; -- 开始事务COMMIT; -- 提交事务ROLLBACK; -- 回滚事务SET autocommit=0; -- 关闭自动提交 说说数据库操作命令?CREATE DATABASE database_name; ⽤于创建数据库;USE database_name;⽤于显示所有数据库;DROP DATABASE database_name;⽤于删除数据库;SHOW DATABASES; 换数据库。 说说表操作命令？CREATE TABLE table_name (列名1 数据类型1, 列名2 数据类型2,...); 用于创建表；DROP TABLE table_name; 用于删除表；SHOW TABLES; 用于显示所有表；DESCRIBE table_name; 用于查看表结构；ALTER TABLE table_name ADD column_name datatype; 用于修改表。 说说行数据的 CRUD 命令？INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...); 用于插入数据；SELECT column_names FROM table_name WHERE condition; 用于查询数据；UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition; 用于更新数据；DELETE FROM table_name WHERE condition; 用于删除数据。 说说索引和约束的创建修改命令？CREATE INDEX index_name ON table_name (column_name); 用于创建索引；ALTER TABLE table_name ADD PRIMARY KEY (column_name); 用于添加主键；ALTER TABLE table_name ADD CONSTRAINT fk_name FOREIGN KEY (column_name) REFERENCES parent_table (parent_column_name); 用于添加外键。 说说用户和权限管理的命令？CREATE USER username@host IDENTIFIED BY password; 用于创建用户；GRANT ALL PRIVILEGES ON database_name.table_name TO username@host; 用于授予权限；REVOKE ALL PRIVILEGES ON database_name.table_name FROM username@host; 用于撤销权限；DROP USER username@host; 用于删除用户。 说说事务控制的命令？START TRANSACTION; 用于开始事务；COMMIT; 用于提交事务；ROLLBACK; 用于回滚事务。 15.MySQL bin 目录下的可执行文件了解吗MySQL 的 bin 目录下有很多可执行文件，主要用于管理 MySQL 服务器、数据库、表、数据等。比如说：mysql：用于连接 MySQL 服务器mysqldump：用于数据库备份，对数据备份、迁移或恢复时非常有用mysqladmin：用来执行一些管理操作，比如说创建数据库、删除数据库、查看 MySQL 服务器的状态等。mysqlcheck：用于检查、修复、分析和优化数据库表，对数据库的维护和性能优化非常有用。mysqlimport：用于从文本文件中导入数据到数据库表中，适合批量数据导入。mysqlshow：用于显示 MySQL 数据库服务器中的数据库、表、列等信息。mysqlbinlog：用于查看 MySQL 二进制日志文件的内容，可以用于恢复数据、查看数据变更等。 16.MySQL 第 3-10 条记录怎么查？可以使用 limit 语句，结合偏移量和行数来实现。 SELECT * FROM table_name LIMIT 2, 8; limit 语句用于限制查询结果的数量，偏移量表示从哪条记录开始，行数表示返回的记录数量。2：偏移量，表示跳过前两条记录，从第三条记录开始。8：行数，表示从偏移量开始，返回 8 条记录。偏移量是从 0 开始的，即第一条记录的偏移量是 0；如果想从第 3 条记录开始，偏移量就应该是 2。 17.用过哪些 MySQL 函数？用过挺多的，比如说处理字符串的函数：CONCAT(): 用于连接两个或多个字符串。LENGTH(): 用于返回字符串的长度。SUBSTRING(): 从字符串中提取子字符串。REPLACE(): 替换字符串中的某部分。TRIM(): 去除字符串两侧的空格或其他指定字符。 处理数字的函数：ABS(): 返回一个数的绝对值。ROUND(): 四舍五入到指定的小数位数。MOD(): 返回除法操作的余数。 日期和时间处理函数：NOW(): 返回当前的日期和时间。CURDATE(): 返回当前的日期。 汇总函数：SUM(): 计算数值列的总和。AVG(): 计算数值列的平均值。COUNT(): 计算某列的行数。 逻辑函数：IF(): 如果条件为真，则返回一个值；否则返回另一个值。CASE: 根据一系列条件返回值。 18.说说 SQL 的隐式数据类型转换？当一个整数和一个浮点数相加时，整数会被转换为浮点数。SELECT 1 + 1.0; – 结果为 2.0当一个字符串和一个整数相加时，字符串会被转换为整数。SELECT 1 + 1; – 结果为 2隐式转换会导致意想不到的结果，最好通过显式转换来规避。SELECT CAST(1 AS SIGNED INTEGER) + 1; – 结果为 2 19. 说说 SQL 的语法树解析？SQL 语法树解析是将 SQL 查询语句转换成抽象语法树 —— AST 的过程，是数据库引擎处理查询的第一步，也是防止 SQL 注入的重要手段。通常分为 3 个阶段。 第一个阶段，词法分析：拆解 SQL 语句，识别关键字、表名、列名等。 —start—比如说：SELECT id, name FROM users WHERE age 18;将会被拆解为：[SELECT] [id] [,] [name] [FROM] [users] [WHERE] [age] [] [18] [;]—end— 第二个阶段，语法分析：检查 SQL 是否符合语法规则，并构建抽象语法树。 —start—比如说上面的语句会被构建成如下的语法树： SELECT / \\ Columns FROM / \\ | id name users | WHERE | age 18或者这样表示：SELECT ├── COLUMNS: id, name ├── FROM: users ├── WHERE │ ├── CONDITION: age 18—end— 第三个阶段，语义分析：检查表、列是否存在，进行权限验证等。 —start—比如说执行：SELECT id, name FROM users WHERE age ‘eighteen’;会报错：ERROR: Column ‘age’ is INT, but ‘eighteen’ is STRING.—end— 数据库架构20.说说 MySQL 的基础架构？MySQL 采用分层架构，主要包括连接层、服务层、和存储引擎层。①、连接层主要负责客户端连接的管理，包括验证用户身份、权限校验、连接管理等。可以通过数据库连接池来提升连接的处理效率。②、服务层是 MySQL 的核心，主要负责查询解析、优化、执行等操作。在这一层，SQL 语句会经过解析、优化器优化，然后转发到存储引擎执行，并返回结果。这一层包含查询解析器、优化器、执行计划生成器、日志模块等。③、存储引擎层负责数据的实际存储和提取。MySQL 支持多种存储引擎，如 InnoDB、MyISAM、Memory 等。binlog写入在哪一层？binlog 在服务层，负责记录 SQL 语句的变化。它记录了所有对数据库进行更改的操作，用于数据恢复、主从复制等。 21.一条查询语句SELECT是如何执行的？当我们执行一条 SELECT 语句时，MySQL 并不会直接去磁盘读取数据，而是经过 6 个步骤来解析、优化、执行，然后再返回结果。第一步，客户端发送 SQL 查询语句到 MySQL 服务器。 第二步，MySQL 服务器的连接器开始处理这个请求，跟客户端建立连接、获取权限、管理连接。 第三步，解析器对 SQL 语句进行解析，检查语句是否符合 SQL 语法规则，确保数据库、表和列都是存在的，并处理 SQL 语句中的名称解析和权限验证。 第四步，优化器负责确定 SQL 语句的执行计划，这包括选择使用哪些索引，以及决定表之间的连接顺序等。 第五步，执行器会调用存储引擎的 API来进行数据的读写。 第六步，存储引擎负责查询数据，并将执行结果返回给客户端。客户端接收到查询结果，完成这次查询请求。 22.一条更新语句UPDATE是如何执行的？undo log 回滚日志: 用于事务的回滚操作.redo log 重做日志: 用于实现事务的持久性,保持数据一致性.总的来说，一条 UPDATE 语句的执行过程包括读取数据页、加锁解锁、事务提交、日志记录等多个步骤。拿 update test set a=1 where id=2 举例来说：在事务开始前，MySQL 需要记录undo log，用于事务回滚。 操作 id 旧值 新值 update 2 N 1 除了记录 undo log，存储引擎还会将更新操作写入 redo log，状态标记为 prepare，并确保 redo log 持久化到磁盘。这一步可以保证即使系统崩溃，数据也能通过 redo log 恢复到一致状态。 写完redo log 后，MySQL 会获取行锁，将 a 的值修改为 1，标记为脏页，此时数据仍然在内存的 buffer pool 中，不会立即写入磁盘。后台线程会在适当的时候将脏页刷盘，以提高性能。 最后提交事务，redo log 中的记录被标记为 committed，行锁释放。 如果 MySQL 开启了 binlog，还会将更新操作记录到 binlog 中，主要用于主从复制。 以及数据恢复，可以结合 redo log 进行点对点的恢复。binlog 的写入通常发生在事务提交时，与 redo log 共同构成“两阶段提交”，确保两者的一致性。 注意，redo log 的写入有两个阶段的提交，一是 binlog 写入之前prepare 状态的写入，二是binlog写入之后 commit 状态的写入。 23.说说 MySQL 的段区页行MySQL 是以表的形式存储数据的，而表空间的结构则由段、区、页、行组成。 ①、段：表空间由多个段组成，常见的段有数据段、索引段、回滚段等。创建索引时会创建两个段，数据段和索引段，数据段用来存储叶子节点中的数据；索引段用来存储非叶子节点的数据。回滚段包含了事务执行过程中用于数据回滚的旧数据。 ②、区：段由一个或多个区组成，区是一组连续的页，通常包含 64 个连续的页，也就是 1M 的数据。使用区而非单独的页进行数据分配可以优化磁盘操作，减少磁盘寻道时间，特别是在大量数据进行读写时。 ③、页：页是 InnoDB 存储数据的基本单元，标准大小为 16 KB，索引树上的一个节点就是一个页。也就意味着数据库每次读写都是以 16 KB 为单位的，一次最少从磁盘中读取 16KB 的数据到内存，一次最少写入 16KB 的数据到磁盘。 ④、行：InnoDB 采用行存储方式，意味着数据按照行进行组织和管理，行数据可能有多个格式，比如说 COMPACT、REDUNDANT、DYNAMIC 等。MySQL 8.0 默认的行格式是 DYNAMIC，由COMPACT 演变而来，意味着这些数据如果超过了页内联存储的限制，则会被存储在溢出页中。可以通过 show table status like ‘%article%’ 查看行格式。 存储引擎24.MySQL 有哪些常见存储引擎？MySQL 支持多种存储引擎，常见的有 MyISAM、InnoDB、MEMORY 等。—这部分是帮助理解 start，面试中可不背—我来做一个表格对比：—这部分是帮助理解 end，面试中可不背—除此之外，我还了解到：①、MySQL 5.5 之前，默认存储引擎是 MyISAM，5.5 之后是 InnoDB。②、InnoDB 支持的哈希索引是自适应的，不能人为干预。③、InnoDB 从 MySQL 5.6 开始，支持全文索引。④、InnoDB 的最小表空间略小于 10M，最大表空间取决于页面大小。如何切换 MySQL 的数据引擎？可以通过 alter table 语句来切换 MySQL 的数据引擎。ALTER TABLE your_table_name ENGINE=InnoDB;不过不建议，应该提前设计好到底用哪一种存储引擎。","tags":["基础","Mysql"]},{"title":"2025.6.10学习日记","path":"/2025/06/10/学习日记/2025.6.10学习笔记/","content":"学习内容最近学习重心想转到算法相关,把随想录和题单刷一遍之后做力扣周赛,太长时间没做需要复健一下. 1. 打卡力扣每日简单的字符串计数找最大最小. 2. 看Mysql基础笔记同步在了Mysql学习笔记中. 3. 代码随想录二叉树的三种遍历和迭代遍历.今天踩了一个小坑:在实现迭代调用的统一写法时,需要在Deque中插入一个null元素作为是否遍历过的标志,但是实现Deque时用的ArrayDeque,这个实现方式不能插入null元素,需要使用LinkedList实现才可以.感觉这几个集合框架还是有必要学的深入一些的,不管是算法还是写项目都有很大帮助. 明天开始跑项目ply生活记录1. 健身今天健身房练上肢 肩 胸 核心","tags":["基础","项目","日记","leetcode"]},{"title":"JVM学习笔记","path":"/2025/06/09/JVM学习笔记/","content":"运行时数据区域 程序计数器记录正在执行的虚拟机字节码指令的地址,如果是本地方法则为空. Java虚拟机栈每个 Java ⽅法在执⾏的同时会创建⼀个栈帧⽤于存储局部变量表、操作数栈、常量池引⽤等信息。从⽅法调⽤直⾄执⾏完成的过程，对应着⼀个栈帧在 Java 虚拟机栈中⼊栈和出栈的过程。 该区域可能抛出的异常: 当线程请求的栈深度超过最⼤值，会抛出 StackOverflowError 异常； 栈进⾏动态扩展时如果⽆法申请到⾜够内存，会抛出 OutOfMemoryError 异常。 本地方法栈本地方法栈和Java虚拟机栈类似,区别在于本地方法栈为虚拟机使用到的 Native ⽅法服务. 堆所有对象都在这⾥分配内存，是垃圾收集的主要区域（”GC 堆”）。现代垃圾收集器基本都是采⽤分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块： 新⽣代（Young Generation） ⽼年代（Old Generation）堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 ⽅法区⽤于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。和堆⼀样不需要连续的内存，并且可以动态扩展，动态扩展失败⼀样会抛出 OutOfMemoryError 异常。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放⼊堆中。 运行时常量池是⽅法区的⼀部分。Class ⽂件中的常量池（编译器⽣成的字⾯量和符号引⽤）会在类加载后被放⼊这个区域。除了在编译期⽣成的常量，还允许动态⽣成，例如 String 类的 intern()。 直接内存JDK 1.4 新引⼊了 NIO 类，它可以使⽤ Native 函数库直接分配堆外内存，然后通过 Java 堆⾥的 DirectByteBuffer对象作为这块内存的引⽤进⾏操作。这样能在⼀些场景中显著提⾼性能，因为避免了在堆内存和堆外内存来回拷⻉数据。 理解运行时的数据区 垃圾收集垃圾收集主要是针对堆和⽅法区进⾏。程序计数器、虚拟机栈和本地⽅法栈这三个区域属于线程私有的，只存在于线程的⽣命周期内，线程结束之后就会消失，因此不需要对这三个区域进⾏垃圾回收。 判断一个对象是否可被回收1. 引⽤计数算法为对象添加⼀个引⽤计数器，当对象增加⼀个引⽤时计数器加 1，引⽤失效时计数器减 1。引⽤计数为 0 的对象可被回收。 但由于对象之间循环引用的存在，引⽤计数器也会失效。 2. 可达性分析算法以 GC Roots 为起始点进⾏搜索，可达的对象都是存活的，不可达的对象可被回收。Java 虚拟机使⽤该算法来判断对象是否可被回收，GC Roots ⼀般包含以下内容： 虚拟机栈中局部变量表中引⽤的对象 本地⽅法栈中 JNI 中引⽤的对象 ⽅法区中类静态属性引⽤的对象 ⽅法区中的常量引⽤的对象 3. 方法区的回收因为⽅法区主要存放永久代对象，⽽永久代对象的回收率⽐新⽣代低很多，所以在⽅法区上进⾏回收性价⽐不⾼。主要是对常量池的回收和对类的卸载。为了避免内存溢出，在⼤量使⽤反射和动态代理的场景都需要虚拟机具备类卸载功能。类的卸载条件很多，需要满⾜以下三个条件，并且满⾜了条件也不⼀定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地⽅被引⽤，也就⽆法在任何地⽅通过反射访问该类⽅法。 4. finalize()类似 C++ 的析构函数，⽤于关闭外部资源。但是⽤ try-finally 可以做得更好，并且 finalize ⽅法运⾏代价很⾼，不确定性⼤，⽆法保证各个对象的调⽤顺序，因此最好不要使⽤。 引用类型⽆论是通过引⽤计数算法判断对象的引⽤数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引⽤有关。Java 提供了四种强度不同的引⽤类型。 1. 强引⽤被强引⽤关联的对象不会被回收。使⽤ new ⼀个新对象的⽅式来创建强引⽤。Object obj = new Object(); 2. 软引⽤被软引⽤关联的对象只有在内存不够的情况下才会被回收。使⽤ SoftReference 类来创建软引⽤。 Object obj = new Object();SoftReferenceObject sf = new SoftReferenceObject(obj);obj = null; // 使对象只被软引⽤关联 3. 弱引⽤被弱引⽤关联的对象⼀定会被回收，也就是说它只能存活到下⼀次垃圾回收发⽣之前。使⽤ WeakReference 类来创建弱引⽤。 Object obj = new Object();WeakReferenceObject wf = new WeakReferenceObject(obj);obj = null; 4. 虚引⽤⼜称为幽灵引⽤或者幻影引⽤，⼀个对象是否有虚引⽤的存在，不会对其⽣存时间造成影响，也⽆法通过虚引⽤得到⼀个对象。为⼀个对象设置虚引⽤的唯⼀⽬的是能在这个对象被回收时收到⼀个系统通知。使⽤ PhantomReference 来创建虚引⽤。 Object obj = new Object();PhantomReferenceObject pf = new PhantomReferenceObject(obj, null);obj = null; 垃圾收集算法1. 标记-清除算法最基础的收集算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。不足: 效率问题，标记和清除两个过程的效率都不⾼； 空间问题，会产⽣⼤量不连续的内存碎⽚，导致⽆法给⼤对象分配内存。 2. 标记-整理算法让所有存活的对象都向⼀端移动，然后直接清理掉端边界以外的内存。 优点: 不会产⽣内存碎⽚ 不⾜: 需要移动⼤量对象，处理效率⽐较低。 3. 复制算法将内存划分为⼤⼩相等的两块，每次只使⽤其中⼀块，当这⼀块内存⽤完了就将还存活的对象复制到另⼀块上⾯，然后再把使⽤过的内存空间进⾏⼀次清理。不⾜是只使⽤了内存的⼀半。 4. 分代收集算法现在的商业虚拟机采⽤分代收集算法，它根据对象存活周期将内存划分为⼏块，不同块采⽤适当的收集算法。⼀般将堆分为新⽣代和⽼年代。 新⽣代使⽤：复制算法 ⽼年代使⽤：标记 - 清除 或者 标记 - 整理 算法 垃圾收集器以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使⽤。 单线程与多线程：单线程指的是垃圾收集器只使⽤⼀个线程，⽽多线程使⽤多个线程； 串⾏与并⾏：串⾏指的是垃圾收集器与⽤户程序交替执⾏，这意味着在执⾏垃圾收集的时候需要停顿⽤户程序；并⾏指的是垃圾收集器和⽤户程序同时执⾏。除了 CMS 和 G1 之外，其它垃圾收集器都是以串⾏的⽅式执⾏。 1. Serial 收集器串行的垃圾收集器，是最基本、历史最悠久的垃圾收集器。单CPU环境下，Serial 收集器由于没有线程交互的开销，可以获得最高的单线程收集效率。 优点: 简单、容易实现 缺点: 单线程、停顿时间⻓ 2. ParNew 收集器ParNew 收集器是 Serial 收集器的多线程版本，它是 Server 场景下默认的新⽣代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使⽤。 3. Parallel Scavenge 收集器与 ParNew ⼀样是多线程收集器。其它收集器⽬标是尽可能缩短垃圾收集时⽤户线程的停顿时间，⽽它的⽬标是达到⼀个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这⾥的吞吐量指 CPU ⽤于运⾏⽤户程序的时间占总时间的⽐值。 4. Serial Old 收集器是 Serial 收集器的⽼年代版本，也是给 Client 场景下的虚拟机使⽤。如果⽤在 Server 场景下，它有两⼤⽤途： 在 JDK 1.5 以及之前版本（Parallel Old 诞⽣以前）中与 Parallel Scavenge 收集器搭配使⽤。 作为 CMS 收集器的后备预案，在并发收集发⽣ Concurrent Mode Failure 时使⽤。 5. Parallel Old 收集器是 Parallel Scavenge 收集器的⽼年代版本。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 6. CMS 收集器CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。分为以下四个流程： 初始标记：仅仅只是标记⼀下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进⾏ GC Roots Tracing 的过程，它在整个回收过程中耗时最⻓，不需要停顿。 重新标记：为了修正并发标记期间因⽤户程序继续运作⽽导致标记产⽣变动的那⼀部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最⻓的并发标记和并发清除过程中，收集器线程都可以与⽤户线程⼀起⼯作，不需要进⾏停顿。具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利⽤率不够⾼。 ⽆法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于⽤户线程继续运⾏⽽产⽣的垃圾，这部分垃圾只能到下⼀次 GC 时才能进⾏回收。由于浮动垃圾的存在，因此需要预留出⼀部分内存，意味着 CMS 收集不能像其它收集器那样等待⽼年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启⽤ Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎⽚，往往出现⽼年代空间剩余，但⽆法找到⾜够⼤连续空间来分配当前对象，不得不提前触发⼀次 Full GC。 7. G1 收集器G1（Garbage-First），它是⼀款⾯向服务端应⽤的垃圾收集器，在多 CPU 和⼤内存的场景下有很好的性能。堆被分为新⽣代和⽼年代，其它收集器进⾏收集的范围都是整个新⽣代或者⽼年代，⽽ G1 可以直接对新⽣代和⽼年代⼀起回收。G1 把堆划分成多个⼤⼩相等的独⽴区域（Region），新⽣代和⽼年代不再物理隔离。通过引⼊ Region 的概念，从⽽将原来的⼀整块内存空间划分成多个的⼩空间，使得每个⼩空间可以单独进⾏垃圾回收。这种划分⽅法带来了很⼤的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护⼀个优先列表，每次根据允许的收集时间，优先回收价值最⼤的 Region。每个 Region 都有⼀个 Remembered Set，⽤来记录该 Region 对象的引⽤对象所在的 Region。通过使⽤Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作⼤致可划分为以下⼏个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因⽤户程序继续运作⽽导致标记产⽣变动的那⼀部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs ⾥⾯，最终标记阶段需要把 Remembered Set Logs的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并⾏执⾏。 筛选回收：⾸先对各个 Region 中的回收价值和成本进⾏排序，根据⽤户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与⽤户程序⼀起并发执⾏，但是因为只回收⼀部分 Region，时间是⽤户可控制的，⽽且停顿⽤户线程将⼤幅度提⾼收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运⾏期间不会产⽣内存空间碎⽚。 可预测的停顿：能让使⽤者明确指定在⼀个⻓度为 M 毫秒的时间⽚段内，消耗在 GC 上的时间不得超过 N 毫秒。 内存分配与回收策略’Minor GC 和 Full GC Minor GC：回收新⽣代，因为新⽣代对象存活时间很短，因此 Minor GC 会频繁执⾏，执⾏的速度⼀般也会⽐较快。 Full GC：回收⽼年代和新⽣代，⽼年代对象存活时间⻓，因此 Full GC 很少执⾏，执⾏速度会⽐ Minor GC 慢很多。 内存分配策略 对象优先在 Eden 分配⼤多数情况下，对象在新⽣代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。 ⼤对象直接进⼊⽼年代⼤对象是指需要连续内存空间的对象，最典型的⼤对象是那种很⻓的字符串以及数组。经常出现⼤对象会提前触发垃圾收集以获取⾜够的连续空间分配给⼤对象。-XX:PretenureSizeThreshold，⼤于此值的对象直接在⽼年代分配，避免在 Eden 和 Survivor之间的⼤量内存复制。 ⻓期存活的对象进⼊⽼年代为对象定义年龄计数器，对象在 Eden 出⽣并经过 Minor GC 依然存活，将移动到 Survivor中，年龄就增加 1 岁，增加到⼀定年龄则移动到⽼年代中。-XX:MaxTenuringThreshold ⽤来定义年龄的阈值。 动态对象年龄判定虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升⽼年代，如果在Survivor 中相同年龄所有对象⼤⼩的总和⼤于 Survivor 空间的⼀半，则年龄⼤于或等于该年龄的对象可以直接进⼊⽼年代，⽆需等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保在发⽣ Minor GC 之前，虚拟机先检查⽼年代最⼤可⽤的连续空间是否⼤于新⽣代所有对象总空间，如果条件成⽴的话，那么 Minor GC 可以确认是安全的。如果不成⽴的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查⽼年代最⼤可⽤的连续空间是否⼤于历次晋升到⽼年代对象的平均⼤⼩，如果⼤于，将尝试着进⾏⼀次 Minor GC；如果⼩于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进⾏⼀次 Full GC。 Full GC 的触发条件对于 Minor GC，其触发条件⾮常简单，当 Eden 空间满时，就将触发⼀次 Minor GC。⽽ FullGC 则相对复杂，有以下条件： 调⽤ System.gc()只是建议虚拟机执⾏ Full GC，但是虚拟机不⼀定真正去执⾏。不建议使⽤这种⽅式，⽽是让虚拟机管理内存。 ⽼年代空间不⾜⽼年代空间不⾜的常⻅场景为前⽂所讲的⼤对象直接进⼊⽼年代、⻓期存活的对象进⼊⽼年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过⼤的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调⼤新⽣代的⼤⼩，让对象尽量在新⽣代被回收掉，不进⼊⽼年代。还可以通过 -XX:MaxTenuringThreshold 调⼤对象进⼊⽼年代的年龄，让对象在新⽣代多存活⼀段时间。 空间分配担保失败使⽤复制算法的 Minor GC 需要⽼年代的内存空间作担保，如果担保失败会执⾏⼀次 FullGC。具体内容请参考上⾯的第 5 ⼩节。 JDK 1.7 及以前的永久代空间不⾜在 JDK 1.7 及以前，HotSpot 虚拟机中的⽅法区是⽤永久代实现的，永久代中存放的为⼀些Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调⽤的⽅法较多时，永久代可能会被占满，在未配置为采⽤CMS GC 的情况下也会执⾏ Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，可采⽤的⽅法为增⼤永久代空间或转为使⽤ CMS GC。 Concurrent Mode Failure执⾏ CMS GC 的过程中同时有对象要放⼊⽼年代，⽽此时⽼年代空间不⾜（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不⾜），便会报 Concurrent Mode Failure 错误，并触发Full GC。 类加载机制类是在运⾏期间第⼀次使⽤时动态加载的，⽽不是⼀次性加载所有类。因为如果⼀次性加载，会占⽤很多的内存。 类的生命周期 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使⽤（Using） 卸载（Unloading） 类的加载过程包含了加载、验证、准备、解析和初始化这 5 个阶段。 1. 加载加载是类加载的⼀个阶段，注意不要混淆。加载过程完成以下三件事： 通过类的完全限定名称获取定义该类的⼆进制字节流。 将该字节流表示的静态存储结构转换为⽅法区的运⾏时存储结构。 在内存中⽣成⼀个代表该类的 Class 对象，作为⽅法区中该类各种数据的访问⼊⼝。 其中⼆进制字节流可以从以下⽅式中获取： 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。 从⽹络中获取，最典型的应⽤是 Applet。 运⾏时计算⽣成，例如动态代理技术，在 java.lang.reflect.Proxy 使⽤ProxyGenerator.generateProxyClass 的代理类的⼆进制字节流。由其他⽂件⽣成，例如由 JSP ⽂件⽣成对应的 Class 类。 2. 验证确保 Class ⽂件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机⾃身的安全。 3. 准备类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使⽤的是⽅法区的内存。应该注意到，实例化不是类加载的⼀个过程，类加载发⽣在所有实例化操作之前，并且类加载只进⾏⼀次，实例化可以进⾏多次。初始值⼀般为 0 值，例如下⾯的类变量 value 被初始化为 0 ⽽不是 123。public static int value = 123;如果类变量是常量，那么它将初始化为表达式所定义的值⽽不是 0。例如下⾯的常量 value 被初始化为 123 ⽽不是 0。public static final int value = 123; 4. 解析将常量池的符号引⽤替换为直接引⽤的过程。其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了⽀持 Java 的动态绑定。 5. 初始化初始化阶段才真正开始执⾏类中定义的 Java 程序代码。 初始化阶段是虚拟机执⾏类构造器clinit() ⽅法的过程。在准备阶段，类变量已经赋过⼀次系统要求的初始值，⽽在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 clinit() 是由编译器⾃动收集类中所有类变量的赋值动作和静态语句块中的语句合并产⽣的，编译器收集的顺序由语句在源⽂件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： public class Test static i = 0; // 给变量赋值可以正常编译通过System.out.print(i); // 这句编译器会提示“⾮法向前引⽤”static int i = 1; 由于⽗类的 () ⽅法先执⾏，也就意味着⽗类中定义的静态语句块的执⾏要优先于⼦类。例如以下代码： static class Parent public static int A = 1;static A = 2;static class Sub extends Parent public static int B = A;public static void main(String[] args) System.out.println(Sub.B); // 2 静态代码块和赋值动作是按照代码的顺序执行的。接⼝中不可以使⽤静态语句块，但仍然有类变量初始化的赋值操作，因此接⼝与类⼀样都会⽣成 clinit() ⽅法。 但接⼝与类不同的是，执⾏接⼝的 clinit() ⽅法不需要先执⾏⽗接⼝的 clinit() ⽅法。只有当⽗接⼝中定义的变量使⽤时，⽗接⼝才会初始化。另外，接⼝的实现类在初始化时也⼀样不会执⾏接⼝的 clinit() ⽅法。虚拟机会保证⼀个类的 clinit() ⽅法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化⼀个类，只会有⼀个线程执⾏这个类的 clinit() ⽅法，其它线程都会阻塞等待，直到活动线程执⾏ clinit() ⽅法完毕。 如果在⼀个类的clinit()⽅法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 类的初始化时机1.主动引用虚拟机规范中并没有强制约束何时进⾏加载，但是规范严格规定了有且只有下列五种情况必须对类进⾏初始化（加载、验证、准备都会随之发⽣）: 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进⾏过初始化，则需要先触发其初始化。 使⽤ java.lang.reflect 包的方法对类进⾏反射调⽤的时候，如果类没有进⾏过初始化，则需要先触发其初始化。 当初始化⼀个类时，如果发现其父类还没有进⾏过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，⽤于执⾏主类（包含 main() ⽅法的那个类）的初始化。 使⽤ JDK 7 新加入的动态语言⽀持时，如果⼀个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的⽅法句柄，并且这个⽅法句柄所对应的类没有进⾏过初始化，则需要先出触发其初始化。 2.被动引用以上 5 种场景中的⾏为称为对⼀个类进⾏主动引⽤。除此之外，所有引⽤类的⽅式都不会触发初始化，称为被动引⽤。被动引⽤的常⻅例⼦包括：通过⼦类引⽤⽗类的静态字段，不会导致⼦类初始化。 System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引⽤类，不会触发此类的初始化。该过程会对数组类进⾏初始化，数组类是⼀个由虚拟机⾃动⽣成的、直接继承⾃ Object 的⼦类，其中包含了数组的属性和⽅法。 SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存⼊调⽤类的常量池中，本质上并没有直接引⽤到定义常量的类，因此不会触发定义常量的类的初始化。 System.out.println(ConstClass.HELLOWORLD); 类加载器分类从 Java 虚拟机的⻆度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），使⽤ C++ 实现，是虚拟机⾃身的⼀部分； 所有其它类的加载器，使⽤ Java 实现，独⽴于虚拟机，继承⾃抽象类java.lang.ClassLoader。 从 Java 开发⼯程的⻆度来看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在 JAVA_HOME\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引⽤，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器去处理，那么直接⽤ null 代替即可。 扩展类加载器（Extension ClassLoader）：这个类加载器是在类 java.lang.ClassLoader 的构造函数中被调⽤的。它负责将 libext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使⽤扩展类加载器。 应用程序类加载器（Application ClassLoader）：这个类加载器是在类 java.lang.ClassLoader 的构造函数中被调⽤的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以也被称为系统类加载器。它负责将⽤户类路径（ClassPath）上所指定的类库加载到内存中。开发者可以直接使⽤这个类加载器，如果应⽤程序中没有定义过⾃定义的类加载器，一般情况下这个就是程序中默认的类加载器。 ⼯作过程⼀个类加载器⾸先将类加载请求转发到⽗类加载器，只有当⽗类加载器⽆法完成时才尝试⾃⼰加载。 好处使得 Java 类随着它的类加载器⼀起具有⼀种带有优先级的层次关系，从⽽使得基础类得到统⼀。例如 java.lang.Object 存放在 rt.jar 中，如果编写另外⼀个 java.lang.Object 并放到 ClassPath中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object ⽐在 ClassPath 中的 Object 优先级更⾼，这是因为 rt.jar 中的 Object 使⽤的是启动类加载器，⽽ ClassPath 中的 Object 使⽤的是应⽤程序类加载器。rt.jar 中的 Object 优先级更⾼，那么程序中所有的 Object 都是这个Object。","tags":["JVM","基础"]},{"title":"2025.6.9学习日记","path":"/2025/06/09/学习日记/2025.6.9学习笔记/","content":"学习内容1. 力扣每日一题 ＋ 昨天的每日一题昨天又忘打卡力扣了,还欠了13天的,得五个月之后才能全续上了.今天的每日是字典序第K数字.昨天的也是字典序相关.做了两道字典序感觉理解了. 2. 学习JVM相关基础学习了JVM相关,并且记了一篇笔记. 3. 把KMP算法实践一下手画梳理了一下流程,然后构造了两遍之后感觉理解很多了.个人理解KMP的核心思想就是让主串索引不后退,匹配串索引通过next数组快速找到前缀相同的下标位置继续匹配.核心就是next数组的构造.这个算法理解后实现也比较复杂,有一堆的边界条件,一个比较好的思路是在主串和匹配串前面加一个空格作为哨兵,然后边界问题会少很多,只需要比较j+1和主串i位置即可. 4. 学习项目文档生活记录1. 足球训练今天七点起床,下楼练球,练颠球和逆足.10","tags":["基础","项目","日记","leetcode"]},{"title":"Java并发篇","path":"/2025/06/07/Java并发篇/","content":"使用线程三种方法 继承Thread类需要重写run方法，然后调用start方法启动线程。 实现Runnable接口需要重写run方法，然后调用start方法启动线程。 实现Callable接口需要重写call方法，然后调用start方法启动线程。有返回值，通过 FutureTask 进⾏封装。 实现接口还是继承类？实现接口更好一些，java不支持多继承，但可以实现多个接口。 基础线程机制ExecutorExecutor用来管理多个异步操作（多个任务互不干扰，不需要同步操作）。 主要有三种Executor：CachedThreadPool：⼀个任务创建⼀个线程；FixedThreadPool：所有任务只能使⽤固定⼤⼩的线程；SingleThreadExecutor：相当于⼤⼩为 1 的 FixedThreadPool。 DaemonDaemon守护线程是⼀个服务线程，⽤于为其他线程提供服务。所有非守护线程都执⾏完毕后，无论有没有守护线程，程序都会退出。线程启动前可以通过setDaemon() 方法来设置该线程是否为守护线程。 sleep()Thread.sleep() 使当前线程暂停执⾏指定的时间，暂停期间，其他线程可以继续运⾏，不会受到阻塞。sleep()可能会抛出InterruptedException异常，异常不会传回main()，所以必须在Thread类中捕获并处理。 yield()代表线程已经走完了重要的部分，可以让其他线程有机会执行。 中断线程完成会自动关闭，但是如果线程异常也会提前关闭。 InterruptedException 异常线程在 sleep() 或 wait() 时被中断，会抛出 InterruptedException 异常。 interrupted()如果一个线程处于无限循环中，并且没有执行 sleep() 或 wait()，那么可以通过 interrupted() 来判断线程是否被中断。如果线程被中断，interrupted() 会返回 true。如果线程没有被中断，interrupted() 会返回 false。 Executor的中断操作调用shutdown()方法会等待所有任务执行完毕后关闭Executor。调用shutdownNow()方法会中断所有任务，相当于调用每个任务的interrupt()方法，然后关闭Executor。 如果只想中断某一个线程，可以通过submit() 方法提交一个Callable任务，然后调用Future的cancel()方法来中断任务。 互斥同步Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第⼀个是 JVM 实现的synchronized，另⼀个是 JDK 实现的 ReentrantLock。 synchronizedsynchronized 是 Java 中的关键字，它可以修饰方法和代码块。修饰方法时，锁的是当前对象。修饰代码块时，锁的是括号中的对象。 ReentrantLockReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。 比较synchronized和ReentrantLock 锁的实现synchronized 是 JVM 实现的，⽽ ReentrantLock 是 JDK 实现的。 性能新版本 Java 对 synchronized 进⾏了很多优化，例如⾃旋锁，synchronized 与ReentrantLock 的性能⼤致相同。 等待可中断当持有锁的线程⻓期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，⽽ synchronized 不⾏。 公平锁公平锁是指多个线程在等待同⼀个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是⾮公平的，ReentrantLock 默认情况下也是⾮公平的，但是也可以是公平的。 锁绑定多个条件⼀个 ReentrantLock 可以同时绑定多个 Condition 对象。 使用选择除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。因为synchronized 是 JVM 实现的，可以保证⾃⼰的线程安全，⽽ ReentrantLock 需要程序员手动释放锁， 线程之间的协作join()在一个线程中调用另一个线程的 join() 方法，会将当前线程挂起，直到被调用的线程执行完毕。 wait() notify() notifyAll()wait() 使当前线程等待，直到其他线程调⽤ notify() 或 notifyAll() 方法。notify() 随机唤醒⼀个等待线程，notifyAll() 唤醒所有等待线程。wait()必须在 synchronized 块中调⽤,否则会抛出IllegalMonitorStateException异常。 wait()和sleep()的区别 wait() 是 Object 的⽅法，sleep() 是 Thread 的⽅法。 wait() 会释放锁，sleep() 不会释放锁。 wait() 可以被 notify() 或 notifyAll() 唤醒，sleep() 只能被中断。 wait() 必须在 synchronized 块中调⽤，sleep() 可以在任何位置调⽤。 await() signal() signalAll()java.util.concurrent 提供的 Condition 类，可以再Condition 上调⽤ await() 使线程等待. 相比wait()，await() 可以指定时间，超过时间会⾃动唤醒。 线程状态一个线程通常只有一种状态,并且这里特指jvm线程状态,而不是操作系统线程状态.线程状态有6种: 新建(New)创建后尚未启用. 可运行(Runnable)正在Java虚拟机中执行,但是它可能正在等待操作系统分配处理器资源. 阻塞(Blocked)线程被阻塞,等待其他线程完成操作. 等待(Waiting)线程等待其他线程执行特定操作. 计时等待(Timed Waiting)线程等待指定的时间. 终止(Terminated)线程已经完成执行. 状态转换 J.U.C - AQSjava.util.concurrent （J.U.C）⼤⼤提⾼了并发性能，AQS 被认为是 J.U.C 的核⼼。AQS是AbstractQueuedSynchronizer的缩写,是Java并发包中用来实现锁的基础框架. CountDownLatchCountDownLatch用来控制一个或多个线程等待其他线程完成操作. CyclicBarrier用来控制多个线程互相等待，直到到达某个公共屏障点（common barrier point）。和CountDownLatch不同的是，CyclicBarrier的计数器可以被重置后使用，所以它被称为循环屏障。 SemaphoreSemaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。 J.U.C - 其它组件FutureTask实现了Future接口和Runnable接口,可以作为Runnable被线程执行,也可以用来获取异步执行的结果.适用于需要异步执行任务,并且需要获取结果的场景. BlockingQueue阻塞队列,可以用来实现生产者-消费者模式. java.util.concurrent.BlockingQueue 接⼝有以下阻塞队列的实现：FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定⻓度）优先级队列 ：PriorityBlockingQueue ForkJoin和MapReduce类似,可以将⼤量的数据拆分成⼩量的数据，然后分⽴计算，最后将结果合并。 Java 内存模型Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到⼀致的内存访问效果。 主内存和工作内存主内存是所有线程共享的内存区域，工作内存是每个线程独有的内存区域。 所有的变量都存储在主内存中，每个线程还有⾃⼰的⼯作内存，⼯作内存存储在⾼速缓存或者寄存器中，保存了该线程使⽤的变量的主内存副本拷⻉。线程只能直接读写⾃⼰的⼯作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。 内存间的交互操作 java内存模型规定了8种操作来完成主内存和工作内存之间的交互操作：read：把⼀个变量的值从主内存传输到⼯作内存中load：在 read 之后执⾏，把 read 得到的值放⼊⼯作内存的变量副本中use：把⼯作内存中⼀个变量的值传递给执⾏引擎assign：把⼀个从执⾏引擎接收到的值赋给⼯作内存的变量store：把⼯作内存的⼀个变量的值传送到主内存中write：在 store 之后执⾏，把 store 得到的值放⼊主内存的变量中lock：作⽤于主内存的变量unlock:作⽤于主内存的变量 内存模型的三大特性原子性java内存模型保证了read、load、use、assign、store、write这6个操作是具有原子性的。但是不保证这6个操作的组合是具有原子性的。AtomicInteger 是⼀个提供原子操作的 Integer 类。除了使用原子类外，还可以通过 synchronized 关键字来保证操作的原子性。 可见性可⻅性指当⼀个线程修改了共享变量的值，其它线程能够⽴即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可⻅性的。主要有三种可见性的实现方式: volatile synchronized，对⼀个变量执⾏ unlock 操作之前，必须把变量值同步回主内存。 final，被 final 关键字修饰的字段在构造⽅法中⼀旦初始化完成，并且没有发⽣ this 逃逸（其它线程通过 this 引⽤访问到初始化了⼀半的对象），那么其它线程就能看⻅ final 字段的值。 有序性有序性指的是在本线程内观察，所有操作都是有序的；如果在⼀个线程观察另⼀个线程，所有操作都是无序的。Java 内存模型是通过禁止指令重排序来保证有序性的。主要有两种有序性的实现方式: volatile synchronized，对⼀个变量执⾏ unlock 操作之前，必须把变量值同步回主内存。 先⾏发⽣原则先⾏发⽣原则是指如果在程序中两个操作的先后顺序与代码中的顺序相同，那么这两个操作就会先⾏发⽣。 1. 单⼀线程原则在单⼀线程中，在程序前⾯的操作先⾏发⽣于后⾯的操作。 2. 管程锁定规则⼀个 unlock 操作先⾏发⽣于后⾯对同⼀个锁的 lock 操作。 3. volatile 变量规则对⼀个 volatile 变量的写操作先⾏发⽣于后⾯对这个变量的读操作。 4. 线程启动规则Thread 对象的 start() ⽅法调⽤先⾏发⽣于此线程的每⼀个动作。 5. 线程加⼊规则Thread 对象的结束先⾏发⽣于 join() ⽅法返回。 6. 线程中断规则对线程interrupt()⽅法的调⽤先⾏发⽣于被中断线程的代码检测到中断事件的发⽣，可以通过 interrupted() ⽅法检测到是否有中断发⽣。 7. 对象终结规则⼀个对象的初始化完成（构造⽅法执⾏结束）先⾏发⽣于它的 finalize() ⽅法的开始。 8. 传递性如果操作 A 先⾏发⽣于操作 B，操作 B 先⾏发⽣于操作 C，那么操作 A 先⾏发⽣于操作 C。 线程安全多个线程不管以何种⽅式访问某个类，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的⾏为，那么就称这个类是线程安全的。 线程安全有以下几种实现方法:不可变不可变（Immutable）的对象⼀定是线程安全的，不需要再采取任何的线程安全保障措施。只要⼀个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不⼀致的状态。多线程环境下，应当尽量使对象成为不可变，来满⾜线程安全。 不可变的类型：final 关键字修饰的基本数据类型String枚举类型Number 部分⼦类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等⼤数据类型。但同为 Number 的原⼦类 AtomicInteger 和 AtomicLong 则是可变的。对于集合类型，我们可以使⽤ Collections.unmodifiableXXX() 方法来获取⼀个不可变的集合。 互斥同步synchronized 和 ReentrantLock。 ⾮阻塞同步阻塞同步是一种悲观的并发策略，即认为只要不去做正确的同步措施，那就肯定会出现问题。而非阻塞是一种基于冲突检测的乐观并发策略，即不加锁，但是如果存在冲突，就重试当前操作直到成功。 CAS硬件⽀持的原⼦性操作最典型的是：⽐较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执⾏操作时，只有当 V的值等于 A，才将 V 的值更新为 B。 乐观锁需要操作、冲突检测这两个步骤具备原⼦性，这⾥就不能再使⽤互斥同步来保证了，只能靠硬件来完成。 AtomicIntegerJ.U.C 包⾥⾯的整数原⼦类 AtomicInteger 的⽅法调⽤了 Unsafe 类的 CAS 操作。 ABA如果⼀个变量初次读取的时候是 A 值，它的值被改成了 B，后来⼜被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。J.U.C 包提供了⼀个带有标记的原⼦引⽤类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。⼤部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改⽤传统的互斥同步可能会⽐原⼦类更⾼效。 无同步方案要保证线程安全，并不是⼀定就要进⾏同步。如果⼀个⽅法本来就不涉及共享数据，那它⾃然就⽆须任何同步措施去保证正确性。 栈封闭多个线程访问同⼀个⽅法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。 线程本地存储（Thread Local Storage）如果⼀个变量在线程的⼀个⽅法中被TLS变量存储，并被其他⽅法读取和修改，那么即使两个线程执⾏的是同⼀个代码，它们也会访问到不同的数据。 锁优化主要是针对synchronized关键字的优化。 ⾃旋锁⾃旋锁虽然能避免进⼊阻塞状态从⽽减少开销，但是它需要进⾏忙循环操作占⽤ CPU 时间，它只适⽤于共享数据的锁定状态很短的场景。 锁消除锁消除是指虚拟机即时编译器在运⾏时，对代码进⾏扫描，去除不可能存在共享数据竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。 锁粗化锁粗化是指虚拟机即时编译器在运⾏时，对代码进⾏扫描，将多个相邻的加锁操作合并为⼀个加锁操作，通过锁粗化，可以节省加锁和释放锁的时间。 轻量级锁JDK 1.6 引⼊了偏向锁和轻量级锁，从⽽让锁拥有了四个状态：⽆锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。 轻量级锁相比传统的重量级锁，它使用CAS操作来避免线程阻塞和唤醒的开销，同时也避免了操作系统层面的线程调度。如果轻量级锁自旋或检测到有线程冲突，会升级为重量级锁。 偏向锁偏向锁是指在没有线程竞争的情况下，锁对象会偏向于使⽤它的线程，这样就不需要进⾏额外的加锁和解锁操作。 多线程开发良好的实践 给线程起个有意义的名字，这样可以⽅便找 Bug。 缩⼩同步范围，从⽽减少锁争⽤。例如对于 synchronized，应该尽量使⽤同步块⽽不是同步⽅法。 多⽤同步⼯具少⽤ wait()和 notify() 。⾸先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，⽽⽤ wait()和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。 使⽤ BlockingQueue 实现⽣产者消费者问题。 多⽤并发集合少⽤同步集合，例如应该使⽤ ConcurrentHashMap ⽽不是 Hashtable。 使⽤本地变量和不可变类来保证线程安全。 使⽤线程池⽽不是直接创建线程，这是因为创建线程代价很⾼，线程池可以有效地利⽤有限的线程来启动任务。","tags":["基础","Java","并发"]},{"title":"2025.6.7学习日记","path":"/2025/06/07/学习日记/2025.6.7学习笔记/","content":"学习内容1. 力扣每日一题https://leetcode.cn/problems/lexicographically-minimum-string-after-removing-stars?envType=daily-questionenvId=2025-06-07 先是尝试优先队列，最小堆找前面的最小元素，然后遇到*就删除，但时间复杂度为On2，特殊用例超时了。然后发现可以用栈模拟二十六个字母，栈中存储下标，遇到*出栈最小的字符。优化点：可以使用二进制掩码来表示最小的非空栈在哪里。 2. 学习完java并发篇笔记记录在java并发篇. 3. 把昨天的题用堆来完善一下维护小顶堆求前k大的元素。 4. 学习KMP算法.KMP算法是一种字符串匹配算法，它的时间复杂度为O(n+m)，其中n是文本串的长度，m是模式串的长度。贴一个模板,原理已经理解了，但是代码还需要再写一遍： class Solution // KMP 算法 // ss: 原串(string) pp: 匹配串(pattern) public int strStr(String ss, String pp) if (pp.isEmpty()) return 0; // 分别读取原串和匹配串的长度 int n = ss.length(), m = pp.length(); // 原串和匹配串前面都加空格，使其下标从 1 开始 ss = + ss; pp = + pp; char[] s = ss.toCharArray(); char[] p = pp.toCharArray(); // 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的） int[] next = new int[m + 1]; // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】 for (int i = 2, j = 0; i = m; i++) // 匹配不成功的话，j = next(j) while (j 0 p[i] != p[j + 1]) j = next[j]; // 匹配成功的话，先让 j++ if (p[i] == p[j + 1]) j++; // 更新 next[i]，结束本次循环，i++ next[i] = j; // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】 for (int i = 1, j = 0; i = n; i++) // 匹配不成功 j = next(j) while (j 0 s[i] != p[j + 1]) j = next[j]; // 匹配成功的话，先让 j++，结束本次循环后 i++ if (s[i] == p[j + 1]) j++; // 整一段匹配成功，直接返回下标 if (j == m) return i - m; return -1;","tags":["基础","项目","日记","leetcode"]},{"title":"java30天学习笔记","path":"/2025/06/06/java30天笔记/","content":"杂项最好不使用 clone()来进行复制,可以使用拷贝构造函数或拷贝工厂来复制对象. 抽象类提供了⼀种 IS-A 的关系接⼝更像是⼀种 LIKE-A 关系 Fail-Fast 机制Fail-Fast 机制是 Java 集合(Collection)中的⼀种错误机制。当多个线程对同一个集合的内容进⾏操作时，就可能产⽣线程安全问题。Fail-Fast 机制会⾃动检测到线程安全问题,在操作前后比较集合的结构变化次数是否相同，并抛出 ConcurrentModificationException 异常。 tips:禁⽌在foreach⾥执⾏元素的删除操作 容器的一些解析vector和arraylist的比较vector是同步的，所以开销更大vector每次扩容请求2倍，而arraylist是1.5倍 如果对线程安全有要求的话，可以选择Collections.synchronizedList() 或者使用CopyOnWriteArrayList保证线程安全。 CopyOnWriteArrayList写操作在拷贝的数组上进行，而读操作在原数组上进行。写操作需要加锁，防止并发写操作。适用于读多写少的场景。问题:内存占用约占原数组的两倍。数据一致性问题。 所以CopyOnWriteArrayList更加适合对内存不敏感以及实时性要求很高的场景。 LinkedListArrayList是基于数组实现的，而LinkedList是基于链表实现的。数组支持随机访问，而链表不支持随机访问。数组的插入和删除操作需要移动元素，而链表的插入和删除操作只需要修改指针。数组的空间利用率高，而链表的空间利用率低。LinkedList适用于需要频繁插入和删除元素的场景。 HashMap相当于分成了很多个桶，每个桶里面是一个链表，链表的每个节点是一个键值对，使用头插法插入节点。 ConcurrentHashMapConcurrentHashMap是线程安全的HashMap，它的实现方式是使用分段锁。ConcurrentHashMap将整个HashMap分成了多个段，每个段都是一个HashMap。每个段都有一个锁，当一个线程访问一个段时，其他线程也可以访问其他段。 LinkedHashMapLinkedHashMap是HashMap的子类，它的实现方式是使用双向链表。LinkedHashMap的迭代顺序是插入顺序或者访问顺序。可以通过LinkedHashMap实现LRU缓存。 WeakHashMap主要是用来实现缓存的。WeakHashMap的键是弱引用，当键不再被引用时，键值对会被自动移除。WeakHashMap的迭代器是弱引用的，所以在迭代时可能会出现空指针异常。 ConcurrentCacheConcurrentCache是一个线程安全的缓存，它的实现方式是使用ConcurrentHashMap。","tags":["java"]},{"title":"好用的快捷键和操作","path":"/2025/06/06/好用的快捷键或操作/","content":"MAC系统操作截图到剪切板mac:shift+control+command+4 最小化窗口mac:command+m 关闭窗口mac:command+w 全屏mac:command+control+f VSCODE单行上下移动mac:shift+option+up/down 多行上下移动mac:shift+option+command+up/down 删除本行mac:command+shift+k 开关左侧项目树mac:command+1 重命名文件mac:fn+shift+f6 VSCODE picgo插件上传到图床mac:option+command+u 关闭终端窗口mac:command+j 终端Warp到hexo根目录cd /Users/mac/Blog/JakicDong.github.io hexo清理并且重新上传hexo clean hexo g hexo d 本地部署hexo s Edge浏览器标签页左右移动mac:command+option+left/right 关闭标签页mac:command+w 开发者工具mac:command+option+i fn+f12","tags":["快捷键"]},{"title":"2025.6.6学习日记","path":"/2025/06/06/学习日记/2025.6.6学习笔记/","content":"学习内容1. 优化了一下个人博客的图片上传工作流由于大部分笔记在语雀中,导致图片上传后外链无法访问,所以今天通过picgo➕github搭建了一个图床.具体流程如下: 首先需要在github中创建一个仓库,用来存放图片 然后在picgo中配置github的仓库,将图片上传到github中操作如下:mac:shift+control+command+4 截图 然后在vscode中option+command+u上传到图床后会自动生成markdown的链接. 2. 优化了一下自己记笔记发博客的工作流语雀写笔记还是太麻烦了。所以准备以后还是用vscode写笔记,然后直接运行一行命令同步到仓库,而且还有补全工具。 3. 力扣两道每日一题：这题思路很清晰，贪心加一个栈的模拟题，实现有一些小细节需要注意。前K个高频元素：map记录频率，然后小顶堆维护前K个元素。（第一遍做用了单调栈，忘记用小顶堆维护了）做了关于最大最小堆的笔记。 4. 看了java容器相关的八股文记在java30天笔记里面了。 5. 项目部分看了session登录拦截器相关的部分6. 杂谈感觉需要增加基础的学习，项目可以先读一遍文档。","tags":["基础","博客","项目","日记","leetcode","picgo"]},{"title":"Hello World","path":"/2025/06/05/hello-world/","content":"hexo的基本使用和模板常用模版 ---title: 个人博客搭建tags: [博客, hexo]date: 2025-06-01--- 快捷部署: hexo clean hexo g hexo d Quick Start创建一篇文章$ hexo new My New Post 更多信息: Writing 运行服务$ hexo server 更多信息: Server 生成静态文件$ hexo generate 更多信息: Generating 部署到远程站点$ hexo deploy 更多信息: Deployment 文章模版---# 基本信息title: title date: date tags: []categories: []description: # excerpt 也可 # 封面cover: banner: poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选# 插件sticky: # 数字越大越靠前mermaid:katex: mathjax: # 可选topic: # 专栏 idauthor: references:comments: # 设置 false 禁止评论indexing: # 设置 false 避免被搜索breadcrumb: # 设置 false 隐藏面包屑导航leftbar: rightbar:h1: # 设置为 隐藏标题type: # tech/story---","tags":["欢迎页"]},{"title":"2025.6.5学习日记","path":"/2025/06/05/学习日记/2025.6.5学习日记/","content":"学习内容1. hexo轻量化框架搭建个人博客搭建了个人博客网站.简化了一下笔记的流程:直接本地写markdown笔记然后直接运行一行命令同步太仓库,比较方便.todo:后期可以考虑加一个打卡墙. 2. leetcode每日一题并查集的题,太久没做图论有点忘了 class Solution public String smallestEquivalentString(String s1, String s2, String baseStr) int[] fa = new int[26]; for (int i = 0; i 26; i++) fa[i] = i; for (int i = 0; i s1.length(); i++) merge(fa, s1.charAt(i) - a, s2.charAt(i) - a); char[] s = baseStr.toCharArray(); for (int i = 0; i s.length; i++) s[i] = (char) (find(fa, s[i] - a) + a); return new String(s); private int find(int[] fa, int x) if (fa[x] != x) fa[x] = find(fa, fa[x]); return fa[x]; private void merge(int[] fa, int x, int y) int fx = find(fa, x); int fy = find(fa, y); // 把大的代表元指向小的代表元 if (fx fy) fa[fy] = fx; else fa[fx] = fy; 3. 健身练胸日","tags":["日记","leetcode"]},{"title":"技术派项目笔记","path":"/2025/06/04/技术派项目笔记/","content":"开启新项目要考虑的事情业务模块拆解首先对业务模块进行拆解，除了业务属性纬度以外，还有一个很重要的属性就是参与者角色。 首先对功能、模块划分、概要设计，详细设计有初步的了解。 主要就是功能模块设计 + DB 的设计。 启动项目mysql 启动 redis 启动： 路径 ： D:\\workTools\\Redis-x64-3.2.100 redis-server.exe redis.windows.conf 启动成功，点击进入首页: http://127.0.0.1:8080 跑环境 font style=color:#000000;D:\\sys\\Desktop\\Workplace\\IDEA_Projects\\paicoding/font下载位置 font style=color:#000000;git clone git@github.com:itwanger/paicoding.git D:\\sys\\Desktop\\Workplace\\IDEA_Projects\\paicoding/fontgit 下载 git clone 出现报错 ， 原因：github ssh 秘钥没有配置 1 打开运行，输入services.msc，确定 找到 OpenSSH Authentication Agent 服务，需开启它. ssh-keygen -t rsa -C “你的邮箱地址” 我用的是Administrator用户，执行完后，可以在 C:\\Users\\Administrator.ssh 目录下生成 id_rsa 和 id_rsa.pub 这两个文件。如果你没有用Administrator用户，也是在类似的目录下 项目结构该项目主要有五个模块，各模块功能如下： paicoding-api： 用于定义一些通用的枚举、实体类，包含 DO（数据对象）、DTO（数据传输对象）、VO（视图对象）等，为不同层之间的数据交互提供统一的格式和规范。 paicoding-core： 核心工具和组件相关的模块，像工具包 util 以及通用的组件都放在这里。按照包路径对模块功能进行拆分，例如搜索、缓存、推荐等功能组件。 paicoding-service： 服务模块，负责业务相关的主要逻辑，数据库（DB）的操作都在这个模块中进行。 paicoding-ui： 存放 HTML 前端资源，包括 JavaScript、CSS、Thymeleaf 等，主要用于构建用户界面。 paicoding-web： Web 模块，是 HTTP 请求的入口，也是项目启动的入口，同时包含权限身份校验、全局异常处理等功能。 web 模块：admin：admin 目录存放和管理后台相关的代码，主要处理管理员对系统的管理操作。 common：common 一般用来存放项目通用的代码，提高代码的复用性和可维护性。 comoinent：TemplateEngineHelper Thymeleaf模版渲染引擎，通过末班引擎进行服务端渲染（SSR），在初次渲染速度方面有显著优势。 configForumDataSourceInitializer 用来进行数据库表的初始化，首次启动时候执行： DbChangeSetLoader 杂项笔记请求参数解析如果一个请求不会引起服务器上任何资源的状态变化，那就可以使用 GET 请求 AOP技术派中的 AOP 记录接口访问日志是放在 paicoding-core 模块下的 mdc 包下。 三层架构 为什么要使用微服务而不是单体项目呢？用不用微服务取决于业务量，能用单体的绝对不用微服务，毕竟单体的好处显而易见，当业务简单的时候，部署非常简单，技术架构也简单，不用考虑微服务间的调用什么的，但是随着业务的复杂，单体的缺点也就暴露出来了，例如修改一个模块上线，就要整个服务下线，这在某些业务中是不被允许的，其次单体复杂度高了，部署就缓慢了，出现问题排查也很困难，这些的前提就是业务复杂度提高了。 所以微服务的出现在我看来最初就是为了解决业务复杂单体所出现的问题的，将业务拆分到不同的模块，不同的模块单独部署开发，提高了开发效率，节省了维护时间成本，问题排查也方便了很多，微服务也并不是没有缺点，只不过是维护一个平衡，例如需要引入注册中心，为了方便配置的修改，还需要引入配置中心，不可能修改一个配置重新打包发布，服务间的调用组件，很多都是为了使用微服务而引入的。 所以没有哪种技术更好，只有哪种技术更符合当下的业务，抛开业务谈技术，在我看来并不是那么可靠。 工厂模式创建型设计模式，定义一个创建对象的接口，但让实现这个接口的类决定实例化哪个类。 工厂方法把类的实例化延迟到子类中进行。 @Bean 就是一个工厂方法 各种注解@Slf4j@Slf4j：借助 Lombok 自动添加 SLF4J 日志记录器，简化日志记录代码。 @Value@Configuration@Configuration：把类标记为 Spring 配置类，允许在类里使用 @Bean 注解定义 Spring Bean。 在 Spring 应用启动时，Spring 会扫描带有 @Configuration 注解的类，将其作为配置类来处理，把类里使用 @Bean 注解定义的方法返回的对象注册到 Spring 容器中。 @Component@Component：通用的组件注解，用于标记一个类为 Spring 组件，Spring 会自动扫描并将其注册到容器中。 @Service@Service：@Component 的特殊化注解，通常用于标记服务层类。 @Repository@Repository：@Component 的特殊化注解，通常用于标记数据访问层类。 @Controller@Controller：@Component 的特殊化注解，通常用于标记 Web 控制器类。 @Bean@Bean注册一个实体类 @册一个实体类 实体对象 用 GET 还是 POSTGET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据。 GET 请求是 HTTP 协议中的一种请求方法，通常用于请求访问指定的资源。如果一个请求不会导致服务器上任何资源的状态变化，那你就可以使用 GET 请求。 Filter过滤器 首先进入 filter，执行相关业务逻辑 若判定通行，则进入 Servlet 逻辑，Servlet 执行完毕之后，又返回 Filter，最后在返回给请求方 判定失败，直接返回，不需要将请求发给 Servlet 过滤器的使用如果要使用过滤器，实现 Filter 接口，需要重写 doFilter 方法，在方法中编写过滤逻辑。init: 初始化时执行destory: 销毁时执行doFilter: 重点关注这个，filter 规则命中的请求，都会走进来三个参数，注意第三个 FilterChain，这里是经典的责任链设计模式执行 filterChain.doFilter(servletRequest, servletResponse) 表示会继续将请求执行下去；若不执行这一句，表示这一次的 http 请求到此为止了，后面的走不下去了 过滤器在项目中的应用 身份识别,并保存身份到ReqInfoContext上下文中 记录请求记录 添加跨域支持 跨域问题:跨域问题（CORS）的本质是浏览器的安全限制，而代理服务器是解决该问题的关键方案之一。以下通过​​场景化解析​​帮你彻底理解代理机制. 假如说:前端​​：运行在 http://localhost:5700​​后端​​：运行在 http://localhost:8080​​问题​​：前端直接请求后端接口时，浏览器会拦截并报错： 代理与服务器间的通信属于服务器之间的通信,不受浏览器同源规则的约束. ServletServlet的使用姿势，以及注册自定义的Servelt的四种姿势 ● @WebServlet 注解:在自定义的servlet上添加Servlet3+的注解@WebServlet，来声明这个类是一个Servlet和Fitler的注册方式一样，使用这个注解，需要配合Spring Boot的@ServletComponentScan，否则单纯的添加上面的注解并不会生效 /** * 使用注解的方式来定义并注册一个自定义Servlet */@WebServlet(urlPatterns = /annotation)public class AnnotationServlet extends HttpServlet @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException String name = req.getParameter(name); PrintWriter writer = resp.getWriter(); writer.write([AnnotationServlet] welcome + name); writer.flush(); writer.close(); 还需要配置启动类 @ServletComponentScan@SpringBootApplicationpublic class Application public static void main(String[] args) SpringApplication.run(Application.class); ● ServletRegistrationBean bean定义在Filter的注册中，我们知道有一种方式是定义一个Spring的BeanFilterRegistrationBean来包装我们的自定义Filter，从而让Spring容器来管理我们的过滤器；同样的在Servlet中，也有类似的包装bean: ServletRegistrationBean自定义的bean如下，注意类上没有任何注解: public class RegisterBeanServlet extends HttpServlet @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException String name = req.getParameter(name); PrintWriter writer = resp.getWriter(); writer.write([RegisterBeanServlet] welcome + name); writer.flush(); writer.close(); 接下来我们需要定义一个ServletRegistrationBean，让它持有RegisterBeanServlet的实例 @Beanpublic ServletRegistrationBean servletBean() ServletRegistrationBean registrationBean = new ServletRegistrationBean(); registrationBean.addUrlMappings(/register); registrationBean.setServlet(new RegisterBeanServlet()); return registrationBean; ● ServletContext 动态添加这种姿势，在实际的Servlet注册中，其实用得并不太多，主要思路是在ServletContext初始化后，借助javax.servlet.ServletContext#addServlet(java.lang.String, java.lang.Class? extends javax.servlet.Servlet)方法来主动添加一个Servlet 所以我们需要找一个合适的时机，获取ServletContext实例，并注册Servlet，在SpringBoot生态下，可以借助ServletContextInitializer public class ContextServlet extends HttpServlet @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException String name = req.getParameter(name); PrintWriter writer = resp.getWriter(); writer.write([ContextServlet] welcome + name); writer.flush(); writer.close(); @Componentpublic class SelfServletConfig implements ServletContextInitializer @Override public void onStartup(ServletContext servletContext) throws ServletException ServletRegistration initServlet = servletContext.addServlet(contextServlet, ContextServlet.class); initServlet.addMapping(/context); ● 普通的spring bean模式","tags":["项目","技术派"]},{"title":"个人博客搭建","path":"/2025/06/02/个人博客搭建/","content":"环境配置: node -v #查看node版本npm -v #查看npm版本 可以使用nvm来管理node版本 安装 hexo: npm install hexo-cli -g 出现权限问题 ,修改: sudo chown -R $(whoami) $(npm config get prefix)/lib/node_modules,bin,share #修改权限范围 初始化个人博客文件夹: hexo init /Users/mac/Blog/JakicDong.github.io # 博客初始化，这里是创建的本地博客文件夹，执行后会自动创建，我这里图简洁，直接用了我网站的地址 hihulu.github.io 为文件名cd /Users/mac/Blog/JakicDong.github.io # 进入本地的博客文件夹hexo server # 打开本地服务器预览 UsersmacJakicDong.github.io 4.Github部署为了部署到Github上，需要安装hexo-deployer-git插件，命令如下： sudo npm install hexo-deployer-git --save 然后找到自己的本地博客文件夹，修改博客根目录下的_config.yml文件中的deploy，修改成： deploy: type: git repo: git@github.com:JakicDong/JakicDong.github.io.git #这个地址是从github仓库复制过来的ssh branch: main （⚠️注意，这里有一个很容易犯错的点，我们在创建“hihulu.github.io”这个仓库的时候，一定要创建和你github用户名相同的仓库，后面加.http://github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。所以上图我的仓库显示的是“hihuluhihulu.github.io”，如果仓库名和用户名不一致，后面是根本打不开这个网站的～） 然后就可以通过以下命令行上传github了 hexo g #hexo generate的简写，即把刚刚做的改动生成更新一下hexo d #hexo deploy，上传到github网站 还有一些常用的命令行： hexo clean #清空一下缓存，有时候博客页面显示不正常也可以试试这个命令行hexo server # 在本地服务器运行，网址默认https://localhost:4000 5.更改主题很多前端大牛博主设计了很多好看的主题，网址https://hexo.io/themes/ ，可以预览并选择你喜爱的主题进行应用。 这里浅以一个蛮火的主题butterfly主题来走一个安装主题的步骤～ 执行以下代码： git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 运行成功之后，在项目文件夹根目录中可以查看到新的主题themes文件夹：butterfly 在博客的项目文件夹下，修改_config.yml配置文件如下: # theme: landscape 默认主题theme: butterfly 此时主题还不能正常配置使用，需要安装pug 以及stylus 的渲染器： npm install hexo-renderer-pug hexo-renderer-stylus --save 最后推送到github # 清除缓存b.json 和已生成的静态文件 publichexo clean# 生成静态页面到默认设置的 public 文件夹hexo g# 部署到设定的仓库或上传部署至服务端hexo d 至此主题安装end，可访问https://hihulu.github.io/ 查看～ https://JakicDong.github.io/ # 7.4 常用命令hexo new name # 新建文章hexo new page name # 新建页面hexo g # 生成页面hexo d # 部署hexo g -d # 生成页面并部署hexo s # 本地预览hexo clean # 清除缓存和已生成的静态文件hexo help # 帮助","tags":["博客","hexo"]},{"title":"算法学习笔记","path":"/2025/06/01/算法笔记/算法题刷题笔记/","content":"常用操作ACM 格式import java.util.*;import java.io.*;public class Main public static void main(String[] args) throws IOException BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) // 逐行读取 int n = Integer.parseInt(line.trim()); int[] nums = new int[n]; String[] parts = br.readLine().split( ); for (int i = 0; i n; i++) nums[i] = Integer.parseInt(parts[i]); // 处理逻辑 // 输出结果 System.out.println(result); public static void main(String[] args) Scanner scanner = new Scanner(System.in); String s = scanner.next(); System.out.println(replaceNumber(s)); scanner.close(); 第二种: import java.util.*;import java.io.*;public static void main(String[] args) Scanner scanner = new Scanner(System.in); String s = scanner.next(); System.out.println(replaceNumber(s)); scanner.close(); 杂项操作绝对值:Math.abs();Int最大值:Integer.MAX_VALUE取随机值： import java.util.Random;import java.util.concurrent.ThreadLocalRandom;public class RandomDemo public static void main(String[] args) int n = 10; //0~9 // 方法1: Math.random() int random1 = (int) (Math.random() * n); System.out.println(Math.random(): + random1); // 方法2: Random类 Random rand = new Random(); int random2 = rand.nextInt(n); System.out.println(Random: + random2); // 方法3: ThreadLocalRandom（多线程安全） int random3 = ThreadLocalRandom.current().nextInt(n); System.out.println(ThreadLocalRandom: + random3); Array 常用操作// ========== 数组声明与初始化 ==========int[] arr = new int[5]; // 创建空数组 [0,0,0,0,0]int[] nums = 3,1,4,5,2; // 直接初始化String[] strArr = A, B, C; // 字符串数组int[][] matrix = 1,2, 3,4,5; // 二维数组// ========== 基本操作 ==========// 访问元素int first = nums[0]; // 获取第一个元素 → 3nums[2] = 9; // 修改元素 → [3,1,9,5,2]// 获取长度int len = nums.length; // 一维数组长度 → 5int cols = matrix[1].length; // 二维数组第二维长度 → 3// ========== 遍历操作 ==========// 普通for循环for(int i=0; inums.length; i++) System.out.print(nums[i] + ); // 3 1 9 5 2// 增强for循环for(int num : nums) System.out.print(num + );// 二维数组遍历for(int[] row : matrix) for(int n : row) System.out.print(n + ); // 1 2 / 3 4 5 // ========== 数组工具操作 ==========// 排序Arrays.sort(nums); // 排序后 → [1,2,3,5,9]// 复制int[] copy1 = Arrays.copyOf(nums, 3); // 复制前3元素 → [1,2,3]int[] copy2 = Arrays.copyOfRange(nums, 1, 4); // 复制1-3索引 → [2,3,5]// 比较boolean isEqual = Arrays.equals(nums, copy1); // false// 填充Arrays.fill(nums, 0); // 全部填充0 → [0,0,0,0,0]Arrays.fill(nums, 1, 3, 5); // 索引1-2填充5 → [0,5,5,0,0]// ========== 类型转换 ==========// 数组转List（固定大小）ListInteger list = Arrays.asList(1,2,3); // 数组转StreamIntStream stream = Arrays.stream(nums);// ========== 其他操作 ==========// 二分查找（需先排序）int index = Arrays.binarySearch(nums, 5); // 返回元素索引// 多维数组操作int[][] matrixCopy = Arrays.copyOf(matrix, matrix.length); // 浅拷贝String deepStr = Arrays.deepToString(matrix); // [[1, 2], [3, 4, 5]]// 反转数组for(int i=0; inums.length/2; i++) int temp = nums[i]; nums[i] = nums[nums.length-1-i]; nums[nums.length-1-i] = temp; Array 排序： 升序排序：Arrays.sort(array); 降序排序：Arrays.sort(Collections.reverseOrder()); 和 int 数组相互转换： Integer[] arr = 1,2,3;ArrayListInteger list = new ArrayList(Arrays.asList(arr));ArrayListInteger list = new ArrayList();Integer[] arr = list.toArray(new Integer[0]);//但是如何转成int[]数组呢//方法1 arr = list.stream().mapToInt(Integer::valueOf).toArray(); List 常用操作// ====================== 1. 初始化 List ======================ListString arrayList = new ArrayList(); // 可修改列表ListInteger linkedList = new LinkedList(); ListString immutableList = List.of(A, B, C); // Java9+ 不可变列表// ====================== 2. 添加元素 ======================arrayList.add(Apple); // 末尾添加arrayList.add(0, Banana); // 索引0插入arrayList.addAll(List.of(Orange, Grape)); // 批量添加// ====================== 3. 访问元素 ======================String firstElement = arrayList.get(0); // Bananaboolean containsApple = arrayList.contains(Apple); // trueint indexOfOrange = arrayList.indexOf(Orange); // 2// ====================== 4. 删除元素 ======================arrayList.remove(Banana); // 按值删除arrayList.remove(0); // 按索引删除arrayList.clear(); // 清空列表// ====================== 5. 修改元素 ======================arrayList.add(Mango);arrayList.set(0, Pineapple); // 修改索引0的元素// ====================== 6. 遍历 List ======================// 方式1: 普通for循环for (int i = 0; i arrayList.size(); i++) System.out.println(arrayList.get(i));// 方式2: 增强for循环for (String fruit : arrayList) System.out.println(fruit);// 方式3: 迭代器IteratorString it = arrayList.iterator();while (it.hasNext()) System.out.println(it.next());// 方式4: forEach + LambdaarrayList.forEach(System.out::println);// ====================== 7. 其他操作 ======================int size = arrayList.size(); // 列表长度boolean isEmpty = arrayList.isEmpty(); // 是否为空ListString subList = arrayList.subList(0, 2); // 截取子列表Object[] array = arrayList.toArray(); // 转为数组// ====================== 8. 注意事项 ======================/*1. ArrayList初始容量10，扩容1.5倍 2. LinkedList用节点链接实现3. 线程不安全，多线程环境使用：ListString syncList = Collections.synchronizedList(new ArrayList());4. 快速失败机制(fast-fail)：遍历时修改会抛出ConcurrentModificationException*/ 二维List例子:import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class TwoDListExample public static void main(String[] args) // ====================== // 1. 创建二维List // ====================== ListInteger[] ls = new ArrayList[26]; Arrays.setAll(ls,i-new ArrayList()); // 方法1: 使用Arrays.asList()初始化 ListListInteger matrix1 = new ArrayList(); matrix1.add(Arrays.asList(1, 2, 3)); matrix1.add(Arrays.asList(4, 5, 6)); matrix1.add(Arrays.asList(7, 8, 9)); // 方法2: 动态创建空二维List ListListString matrix2 = new ArrayList(); // 方法3: 使用嵌套循环初始化 ListListCharacter matrix3 = new ArrayList(); for (int i = 0; i 3; i++) ListCharacter row = new ArrayList(); for (int j = 0; j 4; j++) row.add((char) (A + i + j)); matrix3.add(row); // ====================== // 2. 添加元素 // ====================== // 添加新行 matrix2.add(new ArrayList(Arrays.asList(Java, Python))); matrix2.add(new ArrayList(Arrays.asList(C++, JavaScript))); // 在指定行添加元素 matrix2.get(0).add(Ruby); // 第一行添加元素 matrix2.get(1).add(0, Go); // 第二行开头插入元素 // 添加新行（空行） matrix2.add(new ArrayList()); matrix2.get(2).add(Swift); // 给新行添加元素 // ====================== // 3. 访问元素 // ====================== // 访问单个元素 int element = matrix1.get(1).get(2); // 获取第二行第三列元素 → 6 String lang = matrix2.get(0).get(1); // 获取第一行第二列元素 → Python // 获取行数 int rows = matrix1.size(); // 获取列数（特定行） int colsRow0 = matrix1.get(0).size(); int colsRow2 = matrix2.get(2).size(); // ====================== // 4. 修改元素 // ====================== matrix1.get(0).set(0, 100); // 修改第一行第一列: 1 → 100 matrix2.get(1).set(2, TypeScript); // 修改第二行第三列 // ====================== // 5. 删除元素 // ====================== // 删除指定位置的元素 matrix1.get(2).remove(1); // 删除第三行第二列元素(8) // 删除整行 matrix2.remove(2); // 删除第三行 // ====================== // 6. 遍历二维List // ====================== System.out.println( 遍历matrix1:); // 方法1: 索引遍历 for (int i = 0; i matrix1.size(); i++) for (int j = 0; j matrix1.get(i).size(); j++) System.out.print(matrix1.get(i).get(j) + ); System.out.println(); System.out.println( 遍历matrix2:); // 方法2: 增强for循环 for (ListString row : matrix2) for (String item : row) System.out.print(item + ); System.out.println(); System.out.println( 遍历matrix3:); // 方法3: 使用forEach + lambda matrix3.forEach(row - row.forEach(item - System.out.print(item + )); System.out.println(); ); // ====================== // 7. 其他常用操作 // ====================== // 检查是否为空 boolean isEmpty = matrix2.isEmpty(); // 检查是否包含元素 boolean containsPython = matrix2.get(0).contains(Python); // 查找元素位置 int rowIndex = -1, colIndex = -1; for (int i = 0; i matrix1.size(); i++) int index = matrix1.get(i).indexOf(5); if (index != -1) rowIndex = i; colIndex = index; break; // 转换为二维数组 String[][] array2D = new String[matrix2.size()][]; for (int i = 0; i matrix2.size(); i++) ListString row = matrix2.get(i); array2D[i] = row.toArray(new String[0]); ////翻转行 //方法1 使用工具类 ListListInteger matrix = new ArrayList(); // 假设 matrix 已经填充数据 // 翻转行（首行变末行，次行变次末行，依此类推） Collections.reverse(matrix); //方法2 ListListInteger matrix = new ArrayList(); // 假设 matrix 已经填充数据 int left = 0; int right = matrix.size() - 1; while (left right) // 使用临时行 temp 交换左右两行 ListInteger temp = matrix.get(left); matrix.set(left, matrix.get(right)); matrix.set(right, temp); left++; right--; //方法3 Stream ListListInteger matrix = new ArrayList(); // 假设 matrix 已经填充数据 // 翻转行顺序 ListListInteger reversed = IntStream.range(0, matrix.size()) .mapToObj(i - matrix.get(matrix.size() - 1 - i)) .collect(Collectors.toList()); matrix = reversed; // 如果需要原地翻转，需重新赋值 // 打印结果 System.out.println( matrix1: + matrix1); System.out.println(matrix2: + matrix2); System.out.println(matrix3: + matrix3); System.out.println(找到数字5的位置: [ + rowIndex + ][ + colIndex + ]); HashSet 常用操作// =================== HashSet 基础操作 ===================import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.Set;// 创建对象SetString set = new HashSet(); // 空集合（默认初始容量16，负载因子0.75）SetInteger initSet = new HashSet(32); // 指定初始容量SetString prefilled = new HashSet(Arrays.asList(A, B, C)); // 通过集合初始化// 元素操作boolean added = set.add(Apple); // 添加元素 → true（首次添加）boolean dupAdd = set.add(Apple); // 添加重复元素 → falseboolean hasBanana = set.contains(Apple); // 检查存在 → trueboolean removed = set.remove(Apple); // 删除元素 → true（存在时）set.clear(); // 清空集合// 批量操作SetString fruits = new HashSet(Arrays.asList(Orange, Mango));boolean addedAll = set.addAll(fruits); // 合并集合 → true（集合改变时）boolean retainAll = set.retainAll(Arrays.asList(Mango)); // 保留交集 → true（集合改变时）boolean removeAll = set.removeAll(fruits); // 删除所有匹配元素 → true（集合改变时）// 遍历操作set.add(Apple);set.add(Banana);for (String item : set) // 增强for循环（无序） System.out.print(item + ); // 输出顺序不确定（如 Banana Apple）IteratorString it = set.iterator(); // 迭代器遍历while (it.hasNext()) System.out.print(it.next() + );set.forEach(item - System.out.print(item)); // Java8+ Lambda遍历// 集合信息int size = set.size(); // 元素数量（如 2）boolean isEmpty = set.isEmpty(); // 是否空集合 → falseObject[] array = set.toArray(); // 转Object数组String[] strArray = set.toArray(new String[0]); // 转指定类型数组// 特殊操作SetString cloneSet = (HashSetString) ((HashSetString) set).clone(); // 浅拷贝SetString syncSet = Collections.synchronizedSet(set); // 线程安全包装// 集合运算示例SetString set1 = new HashSet(Arrays.asList(A, B));SetString set2 = new HashSet(Arrays.asList(B, C));SetString union = new HashSet(set1); // 并集 → [A, B, C]union.addAll(set2);SetString intersection = new HashSet(set1); // 交集 → [B]intersection.retainAll(set2);SetString difference = new HashSet(set1); // 差集 → [A]difference.removeAll(set2);/* 核心特性：1. 唯一性：基于 hashCode() 和 equals() 判断重复2. 无序性：遍历顺序不保证与插入顺序一致3. 允许 null 元素（但只能有一个 null）4. 基础操作时间复杂度：add/remove/contains → 平均 O(1)5. 非线程安全：需通过 Collections.synchronizedSet 包装实现线程安全*/ HashMap 常用操作// =================== HashMap 基础操作 ===================import java.util.Collections;import java.util.HashMap;import java.util.Map;import java.util.Set;// 创建对象MapString, Integer map = new HashMap(); // 默认容量16，负载因子0.75MapString, String initMap = new HashMap(32); // 指定初始容量MapString, Integer prefilled = new HashMap(Map.of(A, 1, B, 2)); // Java9+快速初始化// 增删改操作map.put(Apple, 10); // 添加键值对 → Apple=10map.put(Banana, 20); // → Apple=10, Banana=20map.putIfAbsent(Apple, 50); // 仅当键不存在时添加 → 原值10保持不变map.replace(Apple, 15); // 替换已有键的值 → Apple=15, Banana=20map.remove(Banana); // 删除键 → Apple=15map.replace(Apple, 15, 20); // 键值匹配时替换 → Apple=20map.clear(); // 清空映射// 查询操作int count = map.get(Apple); // 获取值（需确保键存在）Integer countSafe = map.get(Orange); // 键不存在时返回nullboolean existsKey = map.containsKey(Apple); // 检查键是否存在 → trueboolean existsValue = map.containsValue(20); // 检查值是否存在 → trueint size = map.size(); // 键值对数量boolean isEmpty = map.isEmpty(); // 是否为空映射// 遍历操作（4种方式）// 1. Entry遍历（推荐）for (Map.EntryString, Integer entry : map.entrySet()) System.out.println(entry.getKey() + : + entry.getValue());// 2. Key遍历for (String key : map.keySet()) System.out.println(key + - + map.get(key));// 3. Value遍历for (Integer value : map.values()) System.out.println(Value: + value);// 4. Java8+ Lambda遍历map.forEach((k, v) - System.out.println(k + = + v));// 批量操作MapString, Integer newItems = Map.of(Cherry, 5, Durian, 8);map.putAll(newItems); // 合并映射 → Apple=20, Cherry=5, Durian=8// 特殊值处理map.put(null, 0); // 允许null键 → null=0map.put(Mango, null); // 允许null值 → null=0, Mango=null// 高级操作（Java8+）map.computeIfAbsent(Orange, k - 3); // 不存在时计算 → 添加 Orange=3map.computeIfPresent(Apple, (k, v) - v + 5); // 存在时更新 → Apple=25map.merge(Apple, 10, (oldVal, newVal) - oldVal + newVal); // 合并值 → Apple=35// 线程安全包装MapString, Integer syncMap = Collections.synchronizedMap(map);// 不可变映射（Java9+）MapString, Integer immutableMap = Map.ofEntries( Map.entry(A, 1), Map.entry(B, 2));/* 核心特性：1. 键唯一性：基于 hashCode() 和 equals() 判断重复2. 无序存储：迭代顺序不保证与插入顺序一致3. 允许一个null键和多个null值4. 基础操作时间复杂度：get/put → 平均 O(1)5. 扩容机制：当元素数量超过（容量*负载因子）时自动翻倍扩容6. 树化优化：当链表长度超过8时转红黑树（Java8+）*/ HashMapCharacter, Integer hm_s = new HashMap();//遍历字符串的所有字符（更清晰的逻辑）for (char c : s.toCharArray()) hm_s.merge(c, 1, Integer::sum);// 使用getOrDefault避免NullPointerExceptionint countS = hm_s.getOrDefault(c, 0); 一个 Key 只能对应一个值，所以如果要实现类似 Multimap 的结构需要如下方式： //初始化HashMapString, ListInteger multiValueMap = new HashMap();/////添加元素if (!multiValueMap.containsKey(scores)) multiValueMap.put(scores, new ArrayList());multiValueMap.get(scores).add(90);// 若键不存在，自动创建空列表multiValueMap.computeIfAbsent(scores, k - new ArrayList()).add(90);multiValueMap.computeIfAbsent(scores, k - new ArrayList()).add(85);////访问元素//获取某个键的所有值ListInteger scores = multiValueMap.get(scores);if (scores != null) for (int num : scores) System.out.println(num); //输出 90, 85 //避免 NullPointerException的情况ListInteger scores = multiValueMap.getOrDefault(scores, new ArrayList());for (int num : scores) System.out.println(num);////删除元素//删除整个键值对multiValueMap.remove(scores);// 删除某个键的特定值ListInteger scores = multiValueMap.get(scores);if (scores != null) scores.remove(Integer.valueOf(90)); // 删除值为 90 的元素 // 如果列表为空，可选删除键 if (scores.isEmpty()) multiValueMap.remove(scores); ////遍历哈希表// 遍历所有键值对for (Map.EntryString, ListInteger entry : multiValueMap.entrySet()) String key = entry.getKey(); ListInteger values = entry.getValue(); System.out.println(key + : + values);//遍历所有键for (String key : multiValueMap.keySet()) System.out.println(Key: + key);//遍历所有值for (ListInteger values : multiValueMap.values()) System.out.println(Values: + values); String的常用操作// =================== String 常用操作 ===================// 创建对象String str1 = Hello; // 直接量创建（字符串常量池）String str2 = new String(World); // 堆内存新对象char[] chars = J,a,v,a;String str3 = new String(chars); // 通过字符数组创建 → Java// 基本操作int len = str1.length(); // 获取长度 → 5char c = str1.charAt(1); // 获取索引1字符 → eString substr1 = str1.substring(2); // 从索引2截取 → lloString substr2 = str1.substring(1,4); // 截取1-3索引 → ellString concatStr = str1.concat( World);// 拼接 → Hello WorldString upper = str1.toUpperCase(); // 转大写 → HELLOString lower = HELLO.toLowerCase(); // 转小写 → helloString trimStr = text .trim(); // 去首尾空格 → textString replaced = str1.replace(l, L);// 替换字符 → HeLLoString replacedAll = a1b2c3.replaceAll(\\\\d, #); // 正则替换 → a#b#c#// 转换与比较char[] arr = str1.toCharArray(); // 转字符数组 → [H,e,l,l,o]byte[] bytes = str1.getBytes(); // 按默认编码转字节数组boolean eq1 = str1.equals(Hello); // 值比较 → trueboolean eq2 = str1.equalsIgnoreCase(hElLo); // 忽略大小写 → trueint cmp = str1.compareTo(Hella); // 字典序比较 → 正数（o a）// 正则处理boolean matches = 123.matches(\\\\d+); // 正则匹配 → trueString[] parts = a,b,c.split(,); // 分割字符串 → [a,b,c]String[] regexParts = a1b2c3.split(\\\\d); // 按数字分割 → [a,b,c]// 格式化处理String format1 = String.format(%s-%d, ID, 100); // → ID-100String format2 = String.join(|, A, B, C); // → A|B|C// 特殊判断boolean isEmpty = .isEmpty(); // 空字符串 → trueboolean isBlank = .isBlank(); // 全空白字符（Java 11+） → trueboolean starts = str1.startsWith(He); // 开头判断 → trueboolean ends = str1.endsWith(lo); // 结尾判断 → true/* 核心特性：1. 不可变性：所有操作返回新字符串，原对象不变2. 字符串常量池复用机制：直接量赋值优先使用常量池3. 支持正则表达式操作（split/matches/replaceAll等）4. 包含丰富的格式化方法（format/join等）*/ int转StringString s = String.valueOf(i);String s = Integer.toString(i);String 转 intString str = 123;int num = Integer.parseInt(str); StringBuffer 和 StringBuilderStringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。 // =================== StringBuilder ===================// 创建对象StringBuilder sb = new StringBuilder(); // 默认容量16StringBuilder sb2 = new StringBuilder(Hello); // 指定初始内容// 基本操作sb.append( World); // 追加内容 → Hello Worldsb.insert(5, Java); // 指定位置插入 → Hello Java Worldsb.delete(5, 10); // 删除5-9位置 → Hello Worldsb.replace(6, 11, Earth); // 替换指定区间 → Hello Earthsb.reverse(); // 反转 → htraE olleH sb.setLength(5); // 截断保留前5字符 → htraEchar c = sb.charAt(2); // 获取索引2的字符 → rsb.setCharAt(0, H); // 修改索引0字符 → HtraEint len = sb.length(); // 获取当前长度 → 5String s = sb.toString(); // 转换为String// 正向遍历for (int i = 0; i sb.length(); i++) char c = sb.charAt(i); System.out.println(c);// 链式调用StringBuilder sb3 = new StringBuilder() .append(123) // 支持多类型 .append(3.14) .append(true);// =================== StringBuffer ===================// 创建对象（操作方法与StringBuilder完全一致）StringBuffer sbf = new StringBuffer(); sbf.append(100); // 追加数值sbf.insert(3, new char[]A,B); // 插入字符数组sbf.deleteCharAt(4); // 删除单个字符sbf.setLength(0); // 清空缓冲区（复用对象）// 线程安全示例sbf.append(ThreadSafe); // 所有方法都有synchronized修饰符/* 共性特征：1. 初始容量16，自动扩容（每次扩容2n+2）2. append() 支持所有基础类型/Object类型3. 修改后对象地址不变（与String的不可变性对比）4. 主要方法：append/insert/delete/replace/reverse*/String s1 = buffer.toString(); // StringBuffer → StringString s2 = builder.toString(); // StringBuilder → String PriorityQueue的常用操作最大堆（降序优先队列） PriorityQueue pq new PriorityQueue((a, b) - b - a); 自定义比较器： (a, b) - b - a 是一个 Lambda 表达式，用作自定义比较器。它通过计算 b - a 来确定元素的优先级： 当结果为正数时，说明 a 应排在 b 之后，即 b 的优先级更高。 当结果为负数或零时，a 的优先级不低于 b。 与默认行为的对比： 默认情况下，优先队列使用自然顺序（最小堆），即 a - b，队首元素是最小值。 此处通过 b - a 反转顺序，使队首元素变为最大值，形成最大堆。 java优先队列,(a,b)-a-b 意思相当于 a代表父节点,b代表子节点,a-b小于0代表a优先级更高,a-b小于0相当于a小于b,所以这个是小顶堆. 小顶堆（默认，前 K 大，升序）// 创建小顶堆（默认）PriorityQueueInteger minHeap = new PriorityQueue();// 添加元素minHeap.offer(5);minHeap.add(3); // offer和add功能相同// 查看堆顶元素（不删除）int min = minHeap.peek();// 取出堆顶元素（删除）int removedMin = minHeap.poll();// 获取堆大小int size = minHeap.size();// 检查是否为空boolean isEmpty = minHeap.isEmpty();// 删除指定元素（非堆顶）minHeap.remove(2);// 清空堆minHeap.clear(); 大顶堆（前 K 小，降序）// 创建大顶堆（使用自定义比较器）PriorityQueueInteger maxHeap = new PriorityQueue((a, b) - b - a);// 或 PriorityQueue(Comparator.reverseOrder());// 添加元素maxHeap.offer(8);maxHeap.add(4);// 查看堆顶元素（不删除）int max = maxHeap.peek();// 取出堆顶元素（删除）int removedMax = maxHeap.poll();// 检查元素是否存在boolean contains = maxHeap.contains(5);// 遍历并输出元素for (Integer num : minHeap) System.out.println(num);// 构造按照字典序排列的优先队列PriorityQueueInteger pq = new PriorityQueue((a, b) - // 将 int 转换为 String 后比较字典序 String strA = String.valueOf(a); String strB = String.valueOf(b); return strA.compareTo(strB);); 自定义对象堆// 自定义类class Student String name; int score; // 构造方法等...// 按分数的小顶堆PriorityQueueStudent studentMinHeap = new PriorityQueue( (s1, s2) - s1.score - s2.score);// 按分数的大顶堆 PriorityQueueStudent studentMaxHeap = new PriorityQueue( (s1, s2) - s2.score - s1.score);// 添加自定义对象studentMinHeap.offer(new Student(Alice, 85)); 堆序性质堆类型\t比较条件\t数学表达\tJava比较器实现小顶堆\t父 ≤ 子\ta ≤ b\ta - b 或 a.compareTo(b)大顶堆\t父 ≥ 子\ta ≥ b\tb - a 或 b.compareTo(a) 比较器的本质a在堆里代表父节点 b是子节点 a-b 要小于0 a优先级才高 ab 所以是最小堆 比较器定义的是”优先级”关系： 返回负数：第一个参数（a）应该排在前面（更高优先级） 返回正数：第二个参数（b）应该排在前面 返回零：两者优先级相同 使用场景:前 K 大的元素：使用最小堆，因为堆顶是存储的最小的元素，如果新增元素比堆顶大，那只需要替换掉堆顶即可。 前 K 小的元素：使用最大堆，因为堆顶是存储的最大的元素，如果新增元素比堆顶小，那只需要替换掉堆顶即可。 默认小顶堆：升序排序。 默认大顶堆：降序排序。 Deque 的常用操作import java.util.Deque;import java.util.ArrayDeque;import java.util.Iterator;// 初始化 Deque（以 ArrayDeque 为例）DequeString deque = new ArrayDeque(); //不能插入null元素DequeString deque = new LinkedList();// ================== 插入操作 ==================// 队头插入deque.addFirst(A); // 插入元素到队头（容量满时抛出 IllegalStateException）deque.offerFirst(B); // 插入元素到队头（容量满时返回 false）// 队尾插入deque.addLast(C); // 插入元素到队尾（容量满时抛出 IllegalStateException）deque.offerLast(D); // 插入元素到队尾（容量满时返回 false）// 批量插入（从 Collection 继承）deque.addAll(List.of(E, F)); // 依次插入队尾// ================== 删除操作 ==================// 队头删除String first1 = deque.removeFirst(); // 删除并返回队头元素（空队列抛 NoSuchElementException）String first2 = deque.pollFirst(); // 删除并返回队头元素（空队列返回 null）// 队尾删除String last1 = deque.removeLast(); // 删除并返回队尾元素（空队列抛异常）String last2 = deque.pollLast(); // 删除并返回队尾元素（空队列返回 null）// 删除指定元素（从队头开始搜索）boolean removed1 = deque.remove(E); // 删除第一个出现的 Eboolean removed2 = deque.removeFirstOccurrence(F); // 删除队头方向第一个 Fboolean removed3 = deque.removeLastOccurrence(G); // 删除队尾方向第一个 G// ================== 查看元素 ==================// 查看队头String head1 = deque.getFirst(); // 返回队头元素（空队列抛异常）String head2 = deque.peekFirst(); // 返回队头元素（空队列返回 null）// 查看队尾String tail1 = deque.getLast(); // 返回队尾元素（空队列抛异常）String tail2 = deque.peekLast(); // 返回队尾元素（空队列返回 null）// ================== 队列状态 ==================boolean isEmpty = deque.isEmpty(); // 判断队列是否为空int size = deque.size(); // 返回元素数量boolean exists = deque.contains(A); // 判断是否包含元素 A// ================== 其他操作 ==================// 清空队列deque.clear();// 转换为数组Object[] array1 = deque.toArray(); // 返回 Object[]String[] array2 = deque.toArray(new String[0]); // 指定类型数组// 迭代器（正向：队头 → 队尾）IteratorString iterator = deque.iterator();while (iterator.hasNext()) String element = iterator.next();// 反向迭代器（队尾 → 队头）IteratorString descendingIterator = deque.descendingIterator();while (descendingIterator.hasNext()) String element = descendingIterator.next();// ================== 栈操作（Deque 兼容的额外方法）==================deque.push(X); // 等效于 addFirst()String popped = deque.pop(); // 等效于 removeFirst()// ================== 容量限制队列（如 LinkedBlockingDeque）==================// 阻塞操作示例（需使用线程安全 Deque，此处仅展示方法）/*deque.offerFirst(W, 1, TimeUnit.SECONDS); // 等待1秒尝试插入队头deque.offerLast(Z, 1, TimeUnit.SECONDS); // 等待1秒尝试插入队尾String item = deque.pollFirst(1, TimeUnit.SECONDS); // 等待1秒尝试取出队头*/ 数组 二分查找https://leetcode.cn/problems/binary-search/通用模板： class Solution public int search(int[] nums, int target) int i = lowerBound(nums, target); // 选择其中一种写法即可 return i nums.length nums[i] == target ? i : -1; // 【下面列了三种写法，选一种自己喜欢的就行】 // lowerBound 返回最小的满足 nums[i] = target 的 i // 如果数组为空，或者所有数都 target，则返回 nums.length // 要求 nums 是非递减的，即 nums[i] = nums[i + 1] // 闭区间写法 private int lowerBound(int[] nums, int target) int left = 0, right = nums.length - 1; // 闭区间 [left, right] while (left = right) // 区间不为空 // 循环不变量： // nums[left-1] target // nums[right+1] = target int mid = left + (right - left) / 2; if (nums[mid] target) left = mid + 1; // 范围缩小到 [mid+1, right] else right = mid - 1; // 范围缩小到 [left, mid-1] return left; // 或者 right+1 // 左闭右开区间写法 private int lowerBound2(int[] nums, int target) int left = 0, right = nums.length; // 左闭右开区间 [left, right) while (left right) // 区间不为空 // 循环不变量： // nums[left-1] target // nums[right] = target int mid = left + (right - left) / 2; if (nums[mid] target) left = mid + 1; // 范围缩小到 [mid+1, right) else right = mid; // 范围缩小到 [left, mid) return left; // 或者 right // 开区间写法 private int lowerBound3(int[] nums, int target) int left = -1, right = nums.length; // 开区间 (left, right) while (left + 1 right) // 区间不为空 // 循环不变量： // nums[left] target // nums[right] = target int mid = left + (right - left) / 2; if (nums[mid] target) left = mid; // 范围缩小到 (mid, right) else right = mid; // 范围缩小到 (left, mid) return right; // 或者 left+1 题目移除元素https://leetcode.cn/problems/remove-element/ 双指针 有序数组的平方https://leetcode.cn/problems/squares-of-a-sorted-array/ 双指针 长度最小的子数组https://leetcode.cn/problems/minimum-size-subarray-sum/ 螺旋矩阵IIhttps://leetcode.cn/problems/spiral-matrix-ii/ 模拟 区间和https://kamacoder.com/problempage.php?pid=1070 ACM输入输出模式（笔试面试必备） import java.util.Scanner;public class Main public static void main(String[] args) Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int [] pre = new int [n]; int [] nums = new int [n]; for(int i = 0;in;++i) nums[i] = scanner.nextInt(); int sum = 0; for(int i = 0;in;++i) sum += nums[i]; pre[i] = sum; while(scanner.hasNextInt()) int a = scanner.nextInt(); int b = scanner.nextInt(); if(a == 0) System.out.println(pre[b]); else System.out.println(pre[b]-pre[a-1]); scanner.close(); 开发商购买土地题目链接 总结数组理论基础数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力 也就是说，想法很简单，但实现起来 可能就不是那么回事了。 首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题 数组是存放在连续内存空间上的相同类型数据的集合。 数组可以方便的通过下标索引的方式获取到下标对应的数据。 需要两点注意的是 数组下标都是从0开始的。 数组内存空间的地址是连续的 正是因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。 例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作 数组的元素是不能删的，只能覆盖。 那么二维数组在内存的空间地址是连续的么？ 我们来举一个Java的例子，例如： int[][] rating = new int[3][4]; ， 这个二维数组在内存空间可不是一个 3*4 的连续地址空间 所以Java的二维数组在内存中不是 3*4 的连续地址空间，而是四条连续的地址空间组成！ 数组的经典题目在面试中，数组是必考的基础数据结构。 其实数组的题目在思想上一般比较简单的，但是如果想高效，并不容易。 我们之前一共讲解了四道经典数组题目，每一道题目都代表一个类型，一种思想。 二分法数组：每次遇到二分法，都是一看就会，一写就废 这道题目呢，考察数组的基本操作，思路很简单，但是通过率在简单题里并不高，不要轻敌。 可以使用暴力解法，通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目 暴力解法时间复杂度：O(n) 二分法时间复杂度：O(logn) 在这道题目中我们讲到了循环不变量原则，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。 二分法是算法面试中的常考题，建议通过这道题目，锻炼自己手撕二分的能力。 双指针法 数组：就移除个元素很难么？(opens new window) 双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 暴力解法时间复杂度：O(n^2) 双指针时间复杂度：O(n) 这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为以下两点： 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。 C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。 双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。 滑动窗口 数组：滑动窗口拯救了你(opens new window) 本题介绍了数组操作中的另一个重要思想：滑动窗口。 暴力解法时间复杂度：O(n^2) 滑动窗口时间复杂度：O(n) 本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。 滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。 如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。 模拟行为 数组：这个循环可以转懵很多人！(opens new window) 模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。 在这道题目中，我们再一次介绍到了循环不变量原则，其实这也是写程序中的重要原则。 相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实真正解决题目的代码都是简洁的，或者有原则性的，大家可以在这道题目中体会到这一点. 前缀和 数组：求取区间和(opens new window) 前缀和的思路其实很简单，但非常实用，如果没接触过的录友，也很难想到这个解法维度，所以 这是开阔思路 而难度又不高的好题。 总结数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力。数组的题目，在解题之前一定要明确数组的含义，不要凭感觉来写代码。 链表 链表理论基础什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链表的入口节点称为链表的头结点也就是head。 链表的类型接下来说一下链表的几种类型: 单链表刚刚说的就是单链表。 双链表单链表中的指针域只能指向节点的下一个节点。 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。 双链表 既可以向前查询也可以向后查询。 循环链表循环链表，顾名思义，就是链表首尾相连。 循环链表可以用来解决约瑟夫环问题。 链表的存储方式了解完链表的类型，再来说一说链表在内存中的存储方式。 数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表是通过指针域的指针链接在内存中各个节点。 所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。 这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。 链表的定义接下来说一说链表的定义。 链表节点的定义，很多同学在面试的时候都写不好。 这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。 而在面试的时候，一旦要自己手写链表，就写的错漏百出。 这里我给出CC++的定义链表节点方式，如下所示： // 单链表struct ListNode int val; // 节点上存储的元素 ListNode *next; // 指向下一个节点的指针 ListNode(int x) : val(x), next(NULL) // 节点的构造函数;/** JAVA * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode() * ListNode(int val) this.val = val; * ListNode(int val, ListNode next) this.val = val; this.next = next; * */ 有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。 但是这个构造函数不会初始化任何成员变量，下面我来举两个例子： 通过自己定义构造函数初始化节点： ListNode* head = new ListNode(5); 使用默认构造函数初始化节点： ListNode* head = new ListNode();head-val = 5; 所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！ 链表的操作删除节点只要将C节点的next指针 指向E节点就可以了。 那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。 是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。 其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。 添加节点可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。 但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。 性能分析再把链表的特性和数组的特性进行一个对比:链表更加灵活，但是查找的时间复杂度是O(n)，而数组查找的时间复杂度是O(1)。数组的静态分配内存和动态分配内存，都在栈上进行，而链表的动态分配内存在堆上进行。 数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。 链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。 相信大家已经对链表足够的了解，后面我会讲解关于链表的高频面试题目，我们下期见！ JAVA版本public class ListNode // 结点的值 int val; // 下一个结点 ListNode next; // 节点的构造函数(无参) public ListNode() // 节点的构造函数(有一个参数) public ListNode(int val) this.val = val; // 节点的构造函数(有两个参数) public ListNode(int val, ListNode next) this.val = val; this.next = next; 题目移除链表元素力扣题目链接设计链表力扣题目链接反转链表力扣题目链接原地反转，只需要把每个节点间的指向反转就可以尝试递归调用两两交换链表中的节点力扣题目链接删除链表的倒数第N个节点力扣题目链接面试题 02.07. 链表相交力扣题目链接142.环形链表II力扣题目链接 哈希表题目242.有效的字母异位词力扣题目链接349.两个数组的交集力扣题目链接第202题. 快乐数力扣题目链接两数之和力扣题目链接第454题.四数相加II力扣题目链接赎金信力扣题目链接第15题. 三数之和力扣题目链接第18题. 四数之和力扣题目链接 字符串KMP算法介绍:KMP 算法是一个快速查找匹配串的算法，它的作用其实就是本题问题：如何快速在「原字符串」中找到「匹配字符串」。 上述的朴素解法，不考虑剪枝的话复杂度是 O(m∗n) 的，而 KMP 算法的复杂度为 O(m+n)。 KMP 之所以能够在 O(m+n) 复杂度内完成查找，是因为其能在「非完全匹配」的过程中提取到有效信息进行复用，以减少「重复匹配」的消耗。个人理解:通过构造一个next数组,使的前缀一样的部分能够快速跳转,前缀一样,但是后面的一个不一样,那就可以直接通过next数组跳转到上一个前缀一样的位置的下标,然后继续匹配.所以这个算法的关键就是构造next数组.看到的一个比较好的实现方式就是在主串和匹配串前面都加上一个空格,这样就可以保证next数组的下标从1开始,这样就可以避免很多边界问题. 先贴一个实现: class Solution // KMP 算法 // ss: 原串(string) pp: 匹配串(pattern) public int strStr(String ss, String pp) if (pp.isEmpty()) return 0; // 分别读取原串和匹配串的长度 int n = ss.length(), m = pp.length(); // 原串和匹配串前面都加空格，使其下标从 1 开始 ss = + ss; pp = + pp; char[] s = ss.toCharArray(); char[] p = pp.toCharArray(); // 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的） int[] next = new int[m + 1]; // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】 for (int i = 2, j = 0; i = m; i++) // 匹配不成功的话，j = next(j) while (j 0 p[i] != p[j + 1]) j = next[j]; // 匹配成功的话，先让 j++ if (p[i] == p[j + 1]) j++; // 更新 next[i]，结束本次循环，i++ next[i] = j; // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】 for (int i = 1, j = 0; i = n; i++) // 匹配不成功 j = next(j) while (j 0 s[i] != p[j + 1]) j = next[j]; // 匹配成功的话，先让 j++，结束本次循环后 i++ if (s[i] == p[j + 1]) j++; // 整一段匹配成功，直接返回下标 if (j == m) return i - m; return -1; next数组构造: 匹配过程: 题目344.反转字符串力扣题目链接 aa^b: 先把a和b中，不相同的位保存到a，现在a中置1的位，代表原始的a和b不相同的位，而0，就是a和b相同的位。 ba^b: 不相同的位是1和原始b异或，就得到原始a的那个位的值；相同的位是0和原始b异或就是原始a或者原始b的值（本来就相同）。现在得到的就是原始a的值，现在存在b中。 aa^b：和上面相同。 a，b已经交换。 1.反转字符串II力扣题目链接 二叉树二叉树的种类 满二叉树:如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 完全二叉树:在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。也就是只有最后一层右侧不满,前面都是满的. 二叉搜索树:二叉搜索树是一个有序树 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 平衡二叉搜索树:平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 二叉树的存储方式二叉树可以链式存储，也可以顺序存储。 二叉树遍历顺序前序遍历：中左右中序遍历：左中右后序遍历：左右中 public class TreeNode int val; TreeNode left; TreeNode right; TreeNode() TreeNode(int val) this.val = val; TreeNode(int val, TreeNode left, TreeNode right) this.val = val; this.left = left; this.right = right; 二叉树递归遍历递归的三要素:1.确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 2.确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 3.确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 // 前序遍历·递归·LC144_二叉树的前序遍历class Solution public ListInteger preorderTraversal(TreeNode root) ListInteger result = new ArrayListInteger(); preorder(root, result); return result; public void preorder(TreeNode root, ListInteger result) if (root == null) return; result.add(root.val); preorder(root.left, result); preorder(root.right, result); // 中序遍历·递归·LC94_二叉树的中序遍历class Solution public ListInteger inorderTraversal(TreeNode root) ListInteger res = new ArrayList(); inorder(root, res); return res; void inorder(TreeNode root, ListInteger list) if (root == null) return; inorder(root.left, list); list.add(root.val); // 注意这一句 inorder(root.right, list); // 后序遍历·递归·LC145_二叉树的后序遍历class Solution public ListInteger postorderTraversal(TreeNode root) ListInteger res = new ArrayList(); postorder(root, res); return res; void postorder(TreeNode root, ListInteger list) if (root == null) return; postorder(root.left, list); postorder(root.right, list); list.add(root.val); // 注意这一句 二叉树迭代遍历144.二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/94.二叉树的中序遍历https://leetcode.cn/problems/binary-tree-inorder-traversal/145.二叉树的后序遍历https://leetcode.cn/problems/binary-tree-postorder-traversal/ 统一写法!!!!!!!!思路:将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。实现方式: 方法一：就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法可以叫做空指针标记法。 方法二：加一个 boolean 值跟随每个节点，false (默认值) 表示需要为该节点和它的左右儿子安排在栈中的位次，true 表示该节点的位次之前已经安排过了，可以收割节点了。 这种方法可以叫做boolean 标记法。 这种方法更容易理解，在面试中更容易写出来。前序遍历代码:public ListInteger preorderTraversal(TreeNode root) ListInteger result = new LinkedList(); DequeTreeNode st = new LinkedList(); if (root != null) st.push(root); while (!st.isEmpty()) TreeNode node = st.peek(); if (node != null) st.pop(); // 将该节点弹出，避免重复操作，下面再将右左中节点添加到栈中（前序遍历-中左右，入栈顺序右左中） if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 else // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 return result; 中序遍历代码:public ListInteger inorderTraversal(TreeNode root) ListInteger result = new LinkedList(); DequeTreeNode st = new LinkedList(); if (root != null) st.push(root); while (!st.isEmpty()) TreeNode node = st.peek(); if (node != null) st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中（中序遍历-左中右，入栈顺序右中左） if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） else // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 return result; 后序遍历代码:public ListInteger postorderTraversal(TreeNode root) ListInteger result = new LinkedList(); DequeTreeNode st = new LinkedList(); if (root != null) st.push(root); while (!st.isEmpty()) TreeNode node = st.peek(); if (node != null) st.pop(); // 将该节点弹出，避免重复操作，下面再将中右左节点添加到栈中（后序遍历-左右中，入栈顺序中右左） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） else // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 return result; 直接用栈模拟的写法:前序 中序 后序的写法不一样. // 前序遍历顺序：中-左-右，入栈顺序：中-右-左class Solution public ListInteger preorderTraversal(TreeNode root) ListInteger result = new ArrayList(); if (root == null) return result; StackTreeNode stack = new Stack(); stack.push(root); while (!stack.isEmpty()) TreeNode node = stack.pop(); result.add(node.val); if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); return result; // 中序遍历顺序: 左-中-右 入栈顺序： 左-右class Solution public ListInteger inorderTraversal(TreeNode root) ListInteger result = new ArrayList(); if (root == null) return result; StackTreeNode stack = new Stack(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) if (cur != null) stack.push(cur); cur = cur.left; else cur = stack.pop(); result.add(cur.val); cur = cur.right; return result; // 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果class Solution public ListInteger postorderTraversal(TreeNode root) ListInteger result = new ArrayList(); if (root == null) return result; StackTreeNode stack = new Stack(); stack.push(root); while (!stack.isEmpty()) TreeNode node = stack.pop(); result.add(node.val); if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); Collections.reverse(result); return result; 二叉树的层序遍历(BFS)// 102.二叉树的层序遍历class Solution public ListListInteger resList = new ArrayListListInteger(); public ListListInteger levelOrder(TreeNode root) //checkFun01(root,0); checkFun02(root); return resList; //BFS--递归方式 public void checkFun01(TreeNode node, Integer deep) if (node == null) return; deep++; if (resList.size() deep) //当层级增加时，list的Item也增加，利用list的索引值进行层级界定 ListInteger item = new ArrayListInteger(); resList.add(item); resList.get(deep - 1).add(node.val); checkFun01(node.left, deep); checkFun01(node.right, deep); //BFS--迭代方式--借助队列 public void checkFun02(TreeNode node) if (node == null) return; QueueTreeNode que = new LinkedListTreeNode(); que.offer(node); while (!que.isEmpty()) ListInteger itemList = new ArrayListInteger(); int len = que.size(); while (len 0) TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; resList.add(itemList); 动态规划数位DP字典序字典序字典树:我觉得比较关键的点是: 字典树左子树字典序一定比右子树小. 字典树想要到右侧兄弟节点,直接num++就可以. 关键就是要找到以当前数字为根的十叉树的元素总个数.看着这个图就比较好理解了: 这张图也很好: class Solution /** * 以当前数字为根的十叉树的元素总个数 (包括当前数字) * * @param num 当前数字 (需要先 cast 成 long, 因为 num*10 可能导致 int 溢出) * @param n 数字的最大值 * @return */ private int count(long num, int n) int cnt = 0; // 元素总个数 int width = 1; // 当前层数的宽度, 第一层只有 num 一个元素, 所以第一层宽度为 1 while (true) if (num + width - 1 = n) // n 的值大于等于当前层的最大值, 说明当前层数的个数可以全部添加 cnt += width; num *= 10; width *= 10; else // n 的值小于当前层的最大值则只能添加部分个数或者不添加, 并跳出循环 if (n - num = 0) cnt += n - num + 1; break; return cnt; public int findKthNumber(int n, int k) int cnt = 0; // 已经经过的元素个数, 开始一个元素都没有经过, 所以个数为 0 int num = 1; // 第一个元素 (经过 i 个元素, 当前 num 是第 i + 1 元素) // 要找到第 k 个元素, 需要经过 k - 1 个元素 while (true) if (cnt == k - 1) // 经过了 k - 1 个元素找到了第 k 个元素 break; int temp = count((long) num, n); // 以 num 为根, 以 n 为最大值的十叉树的元素总个数 if (cnt + temp = k) // 以 num 为根的十叉树内有第 k 个元素 num *= 10; cnt++; else if (cnt + temp k) // 以 num 为根的十叉树内没有第 k 个元素 num++; cnt += temp; return num;","tags":["基础","leetcode","算法"]}]